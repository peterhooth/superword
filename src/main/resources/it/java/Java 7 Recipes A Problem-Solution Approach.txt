For your convenience Apress has placed some of the front matter material after the index.
The Java programming language was first introduced in 1995 by Sun Microsystems.
Derived from languages such as C and C++, Java was designed to be moreintuitive and easier to use than older languages, specifically due to its simplistic object model and automated facilities such as memory management.
At the time, Java drew the interest of developers because of its object-oriented, concurrent architecture; excellent security and scalability; and because applications developed in the Java language could be run on any operating system that contained a Java Virtual Machine (JVM)
Since its inception, Java has been described as a language that allows developers to “write once, run everywhere” as code is compiled into class files that contain bytecode, and the resulting class files can run on any compliant JVM.
This concept made Java an immediate success for desktop development, which later branched off into different technological solutions over the years, including development of web-based applications and rich Internet applications (RIAs)
Today, Java is deployed on a broad range of devices including mobile phones, printers, medical devices, blue ray players, and so on.
The Java platform consists of a hierarchy of components, starting with the Java Development Kit (JDK), which is composed of the Java Runtime Environment (JRE), the Java programming language, and platform tools that are necessary to develop and run Java applications.
The JRE contains the Java Virtual Machine (JVM), plus the Java application programming interfaces (APIs) and libraries that assist in the development of Java applications.
The JVMis the base upon which compiled Java class files run and is responsible for interpreting compiled Java classes and executing the code.
Every operating system that is capable of running Java code has its own version of the JVM.
To that end, the JRE must be installed on any system that will be running local Java desktop or stand-alone Java applications.
Oracle provides JRE implementations for most of the major operating systems, most recently adding Mac OS X to the list.
Each operating system can have its own flavor of the JRE.
For instance, mobile devices can run a scaled down version of the full JRE that is optimized to run Java Mobile Edition (ME) applications.
The JVM and the Java platform APIs and libraries play key roles in the lifecycle of every Java application.
Entire books have been written to explore the platform and JVM.
This book will focus on the Java language itself, which is used to develop Java applications, although the JVM and Java platform APIs and libraries will be referenced as needed.
The Java language is a robust, secure, and modern objectoriented language that can be used to develop applications to run on the JVM.
The Java programming language has been refined over several iterations and it becomes more powerful, secure, and modern with each new release.
Oracle Corporation released Java 7, which was a milestone release for the Java ecosystem.
Not only is Java 7 the most modern, statically typed, object-oriented language available for development, it also enhances the ability to integrate different languages that run on the JVM, such as Jython, Groovy, JRuby, and Scala to name a handful.
JavaFX 2.0 can be used for developing rich desktop and Internet applications using the Java language, or any other language that runs on the JVM.
It provides a rich set of graphical and media user interfaces to develop extraordinary visual applications.
This release is a major update to the JavaFX platform, allowing applications to be written entirely in the Java language.
Previous releases of JavaFX mandated the use of JavaFX Script for development of user interfaces for JavaFX.
JavaFX 2.0 does away with the mandate for using JavaFX Script and allows developers to use the language of their choice for working with the JavaFX application programming interfaces.
This book covers fundamentals of Java development such as installation of the JDK, writing classes, and running applications.It delves into essential topics such as the development of object-oriented constructs, exception handling, unit testing, and localization.
The book also provides solutions for desktop application development using the Swing API, and web-based solutions including servlets and applets.
It covers JavaFX 2.0 in depth and is an essential guide for developers beginning to use JavaFX.This book can be used as a guide for solving problems that ordinary Java developers may encounter at some point.
A broad range of topics is discussed, and the solutions to the problems that are covered in this book are concise and tothe point.
If you are a novice Java developer, we hope that this book will help you get started on your journey to working with one of the most advanced and widely used programming languages available today.
We ensure that advanced Java application developers will also learn a thing or two regarding the new features of the language and perhaps even stumble upon some techniques that were not used in the past.
Whatever your skill level, this book will be good to have close at hand as a reference for solutions to those problems that you will encounter in your daily programming.
Those who have not yet programmed in the Java language can read this book, and it will allow them to start from scratch to get up and running quickly.
Java desktop programmers will find this book useful for its content on developing desktop applications using the Java Swing toolkit and JavaFX 2.0
Developers of Java web applications will find useful content regarding servlets, applets, and more.
There is, of course, a myriad of other essential topics that will be useful to Java developers of any type.
How This Book Is Structured This book is structured so that it does not have to be read from cover to cover.
In fact, it is structured so that developers can chose which topic(s) they’d like to read about and jump right to them.
Each recipe contains a problem to solve, one or more solutions to solve that problem, and a detailed explanation of how the solution works.
Although some recipes may build upon concepts that have been discussed in other recipes, they will contain the appropriate references so that the developer can find other related recipes that are beneficial to the solution.
The book is designed to allow developers to get up and running quickly with a solution so that they can be home in time for dinner.
The Java language has been around for quite some time now.
It has been labeled a “legacy language,” and some say that Java will become outdated and a language of the past.
Those who advocate languages that do not run on the Java Virtual Machine (JVM) make these statements, and they are untrue.
With each release, the Java language gains new features, adding new capabilities to help developers of the JVM become more productive.
The first major release of Java was distributed in 1996, and since then the language has undergone many changes.
Over the years, the language has added features such as inner classes, JavaBeans, regular expressions, generics, enumerations, and so on.
With each release, the Java language changes the way in which applications are built and used.
That release featured updates that offered new features to the Java language, as well as other languages on the JVM.
Scripting language support with JSR223 paved the road for integration between Java and other languages to integrate with one another.
The Java 7 release marks one of the most monumental updates to the language in years.
Not only does Java 7 offer more features but it also enhances the ability to write other languages for the JVM.
Constructs such as the try-with-resources and the diamond operator add productivity to the language.
Invoke Dynamic increases the language’s ability to offer support for dynamic languages.
The new I/O library enhances platform independence and makes I/O easier to use.
New graphics features have been added along with new Swing components to make graphical user interfaces (GUIs) better.
All these features and more offer one of the largest updates to the Java language in years.
The language is better than ever, and it has a user community that rivals any other.
It will help those who are unfamiliar with the language to get started.
You will learn how to install Java and configure it for your environment.
You will learn basics of Java such as how to create a class and how to accept keyboard input.
Documentation is often overlooked, but in this chapter you will quickly learn how to create great documentation for your Java code.
Download the requisite Java 7 distribution for your platform, or download and build OpenJDK.
To download the binary distribution of the JDK, please visit the Oracle downloads page and choose the correct binary Java SE release for your platform of choice.
Note If you are working on Mac OS X, you have a couple of options for working with OpenJDK.
To download sources for OpenJDK, please visit http://openjdk.java.net and build the sources on your workstation or laptop, or go to the Google Source project openjdk-osx-build and download an installer.
The JDK is distributed in a binary format via the Oracle Corporation.
If interested in obtaining the most recent build of the latest JDK, go to the OpenJDK site, download, and build the sources.
Since the binary installer contains an installation wizard, I will not cover the wizard installation in detail.
However, there are a few key things to note regarding the installation process.
Be sure that you download the JDK and not the Java Runtime Environment (JRE) because you will want to develop with Java.
The JRE does not include the tools that are required to develop and compile Java code.
Instead, the JRE merely provides the runtime required to load and execute Java applications on the JVM.
When you initiate the installation wizard, you will be presented with a number of different features that can be installed.
I recommend installing everything because you will benefit from looking at the demos and samples, and you may also benefit from looking at the JDK sources.
You can specify a default installation location for the JDK.
By default, the wizard will want to install to the Program Files area on a Windows machine.
I recommend changing this location to another directory that contains no spaces in its name and is made at the root of your OS drive.
If you have multiple drives, you can install to any of them, although it is not recommended to install the JDK on an external drive.
On all platforms, you can have more than one JDK installed.
This allows you to run older Java programs that rely on deprecated or removed Java tools, and at the same time provides the ability to work with the most recent Java platform.
Hence, it is a smart choice to install the JDK into a directory containing the JDK release number.
In our case, we are installing into the directory jdk1.7.0
If you are working on a Solaris or Linux platform, you will have the same type of wizard that is provided for use with Microsoft Windows.
However, if you are working on a Mac OS X platform, you may not be provided with such a wizard.
The JDK 7 Developer Preview from Oracle is bundled as a disk image, and the installation involves opening the disk image and dragging the JDK bundle to the designated location within the OS.
You also have the option of going to the OpenJDK site and downloading the sources so that they can be built and installed on your operating system.
There is also a dmg (disk image) available for the latest builds of OpenJDK for OS X hosted on the Google Code repository.
Since this is the easier route to take, we choose to install from the disk image.
Go to the openjdk-osx-build project on Google Code (http://code.google.com/p/openjdk-osxbuild/) and download the most recent OpenJDK disk image.
You will want to install the universal disk image if it is available.
Once downloaded, you can open the disk image, and run the Installation.pkg.
Once you run the installer, a standard OS X installation wizard will begin.
Unlike the Microsoft Windows installation wizard, you cannot select the installation path.
Once the installation completes, you can go to the Java Preferences utility and see the OpenJDK 7 listed as one of the options.
Drag it to the top of the list to ensure that Java 7 will be the default runtime.
Note If you are running Java applications that are not compatible with Java 7 on OS X, you can use the Java Preferences utility to drag the JDK of your choice to the top of the list of available JDK installations to set as default.
You want to execute a Java program or include an external Java library in the application you are executing.
Note Would you like to run a “Hello, World” program now that you’ve installed the JDK as described in the previous recipe? Not to worry.
Set the CLASSPATH equal to the directory location of the user-defined Java classes or Java Archive (JAR) files that you need to have access to for executing your application.
Note It is a good idea to organize your code; it is also good to organize where you place your code on the computer.
A good practice is to place all your Java projects within the same directory; it can become your workspace.
Place all the Java libraries that are contained in JAR files into the same directory for easier management.
Let’s say that you have a directory named JAVA_DEV located at the root of your OS drive, and all the files that you need to have access to are located in this directory.
If this is the case then you would do the following at the command line or terminal:
Alternately, the javac tool provides an option for specifying resources that need to be loaded for an application.
On all platforms, setting the CLASSPATH using this technique can be done as follows:
Of course, on Microsoft Windows machines the file path will use the backslash (\) instead.
In order for the JVM to find the resources that are needed to execute Java applications, there needs to be a specified search path that can be used to find associated files.
That being said, the CLASSPATH can be used by the JVM in order to find and load any Java sources or JAR files that may be required.
The CLASSPATH is a parameter that tells the JVM where to look for classes and packages, and it can be set using an environment variable or command-line argument.
When executing Java programs, the JVM finds and loads classes as needed using the following search order:
The classes that are fundamental to the Java Platform and are contained in the Java installation directory.
Any packages or JAR files that are located within the extension directory of the JDK.
Packages, classes, JAR files, and libraries that are loaded somewhere on the specified CLASSPATH.
Note JAR files are a used to package applications and Java libraries into a distributable format.
You may need to load more than one directory or JAR file into the CLASSPATH for an application.
This could be the case if your dependencies are located in more than one location.
To do so, simply use the delimiter for your operating system (either ; or :) as a separator between the locations specified for the CLASSPATH as such (on UNIX):
When loading the resources for a Java application, the JVM loads all the classes and packages that.
This is important because the order of loading may make a difference in some instances.
In order to add all the JAR files within a specified directory, use the wildcard character (*) after the directory containing the files.
You can do so as follows when using the –classpath option of the javac tool:
Specifying a wildcard will tell the JVM that it should be loading JAR files only.
It will not load class files that are located in the directory specified with the wildcard character.
In order to include Java class files that are located in a directory, do not specify the wildcard.
For example, if you want to load all JAR files and class files within the /JAVA_DEV directory, you would specify the following:
However, Java packages that are equivalent to the subdirectory structure will be loaded.
Therefore, any Java classes that reside within a Java package that is equivalent to the subdirectory structure will be loaded.
You want to develop an executable Java program that can be run from the command line or terminal.
A class containing a main() method is executable because this method will be loaded when the application is executed.
In the following Java class, a “Hello World” message will be printed at the command line when executed.
To make a Java class executable, simply add a main() method somewhere within the class that will be executed when the class is run.
The main() method should take care of any application setup or instantiations in order to run the program.
The main() method is comparable to the “driver” for the application.
It should always be specified using the same definition, including the static modifier so that it can be invoked without creating an instance of the class first.
The return type of the method should always be void, meaning that nothing will be returned from the method.
Lastly, the signature of the main() method should include a String array as an argument.
This String array allows arguments to be passed to the program at runtime.
Zero or more arguments can be passed to the program using a space to separate them.
In the following example class, the main() method is printing each of the arguments that are passed to the program at runtime:
First, the length of the args String array is tested to see whether it is greater than zero.
If it is, the method will loop through each of the arguments in the String array using a for loop, printing each out along the way.
If there are no arguments passed to the program, the length of the args String array will be zero, and a message indicating as such will be printed.
To learn how to execute this program and pass arguments via the command line or terminal, please see Recipe 1-4
You have written a Java class and you want to compile and execute it.
First, if you are planning to make use of the CLASSPATH environment variable, set up your CLASSPATH to include all the required resources to run your Java class.
For more information on doing this, please see Recipe 1-2
Next, compile your Java class using the javac tool that ships with the JDK.
Note In order to compile Java sources, you must be located in the same directory containing the sources, or specify the full path to the sources when issuing the javac command.
So using the command line enables you to change directories until you are within the same directory that contains the code you want to compile.
In order to execute this class, use the java tool that also ships with the JDK:
Note that you do not include the .java suffix after the class name when executing the class.
Similarly, you do not include a .class suffix after the class name.
However, you do append the Java package directory structure to the front of the class name, and use the –cp flag to set the CLASSPATH.
The preceding command will execute the MainTestArguments class, and you should receive the following output when executing this application:
In order to compile a Java class, all required classes and libraries must be in the CLASSPATH.
This can be accomplished either by setting the CLASSPATH environment variable or by using the -classpath option of the javac tool, as demonstrated in Recipe 1-2
CLASSPATH, use the javac tool to compile the sources into class files.
To use the javac tool, you must either be working from within the command line or terminal unless you are working within an integrated development environment (IDE)
The command can be issued from within the directory in which the Java source file resides; otherwise, the entire path to where the source is located must be specified along with the file name.
Once the javac tool compiles the code, another file with the same name and a .class suffix will be generated.
This resulting file can be run on the JVM by use of the java command.
To run any executable Java class file that has already been compiled, issue the java command, followed by the name of the class as you see here:
To maintain consistency throughout the examples, the command shown here runs the compiled Java class file from a directory different from the one in which it resides.
The same rules apply for the java command as with the javac utility, in that you can use the java command from within the same directory of a Java class file if the Java class is not contained within any Java packages or from another directory, and use the –cp flag to include the entire path to the file along with the file name (or the path to the file from the directory in which you are currently located)
The –cp flag will set the CLASSPATH for the java command.
As demonstrated in the preceding example, using the java command can become a bit trickier when Java packages are introduced.
A Java package is basically a directory that can contain a Java source file.
Most Java applications use packages for organization of code, and packages are often nested within each other to form an organized file system of code.
Because packages are directories, you may think that it is possible to traverse within them in order to get to the same package containing your Java source to issue the java command, but that is not correct.
In order to run a Java class that is contained within a Java package, you must traverse to the root of the application source structure (outside of the outermost package) and specify the package path along with the file name.
Another option is to include the parent directory of the outermost package within the CLASSPATH, as demonstrated by the example using the cp flag.
You want to print output from a Java program to the command line or terminal.
For example, suppose that you would like to display the message “I love Java 7” for those running your program.
The System class acts as a utility for Java application developers.
It cannot be instantiated, and it contains a myriad of fields and methods to assist developers in performing commonly used tasks.
As such, printing to the command line is a very common way of displaying messages to application users, or printing error codes and messages for debugging purposes.
System.out is the standard output stream for the Java language.
It is already open by default, so it can be used right away without any setup.
Using the System.out stream to print messages to the command line is essential for any command line–based application.
However, often Java applications are not used from within the command line.
In such cases, the System.out stream is not visible to the user unless the application has been coded so that the stream is presented to the application display.
In any case, System.out can still be useful for displaying messages because any message sent to it will be printed in the server log for web applications.
As for Swing, JavaFX, or other GUI–based applications, System.out can still be handy for a myriad of tasks including debugging.
You want to pass arguments to a Java application via the command line or terminal.
Run the application using the java command-line tool and specify the arguments that you want to pass into it after the application name.
For example, suppose you want to pass the arguments "one" and "two" to the MainTestArguments class that we created in Recipe 1-3
To do so, you should first traverse into the directory containing the outermost package org and then issue the command as follows:
As you know by now, all Java classes that are executable from the command line or terminal contain a main() method.
If you look at the signature for the main() method, you can see that it accepts the String[] argument.
In other words, you can pass an array of String values into the main() method.
Therefore, since the main() method is the first piece of code that is executed when running a Java class, any arguments that you pass to the class will go into this String array so that they can be used from within the application.
Commonly a series of Strings or numbers is passed into an executable Java class, and then the method iterates through the elements of the String array and performs some processing.
In the case of the class that was used in the Solution to this recipe, two String values were passed into the main() method and printed out.
Much more complex work can be performed with the arguments that are passed in as well.
What happens if you try to pass a number into the main() method? It will convert the number to a String automatically and it will be treated as a string of numeric characters rather than as a numeric value.
Anything that is passed into the main() method is treated as a String.
If you need to work with number values for calculation purposes, String-to-Integer conversions can be performed.
You can read more about converting Strings to number values in Recipe 2-6
The application you are developing needs to make use of some OS environment variables.
You are also interested in setting the values of environment variables from within the Java application.
Make use of the Java System class to retrieve any OS environment variable values.
The System class has a method getenv(), which accepts a String argument corresponding to the name of a system environment variable.
It will then return the value of the given variable.
If no matching environment variable exists, a NULL value will be returned.
In the following example, the Java class EnvVars accepts an environment variable name and prints out its value.
As noted previously, if there is not a matching variable name, a NULL value will be returned and an error message will be displayed:
If you are interested in retrieving the entire list of environment variables that is defined on a system, do not pass any arguments to the System.getenv() method.
Once you have obtained the Map of variables, you can iterate through them.
Once the Map of variables is obtained, the program iterates through each of the variables and prints the corresponding value:
The System class contains many different utilities that can aid in application development.
One of those is the getenv() method, which will return a value for a given system environment variable.
Environment variables are stored in a Map, a collection of name/value pairs; the getenv() method is used to pass the name of an environment variable, and it will return that variable’s value.
If there is no environment variable name that matches the one passed to getenv(),a NULL value is returned.
If you want to obtain an entire list of all environment variables, do not pass any String value to System.getenv()
When no value is passed to System.getenv(), a Map of all system environment variables is returned.
Such a Map can be traversed so that the name/value pairs can be read, displayed, and used as necessary.
You want to document some of your Java classes to assist in future maintenance.
Use Javadoc to place comments before any of the classes, method, and fields that you want to document.
Lastly, to end the Javadoc comment, close it with the characters */ at the end.
Such comments can be added to the beginning of classes and fields the same way.
The JDK provides another useful tool named Javadoc that parses the named Java source file and formulates HTML documentation based upon the defined class elements and Javadoc comments.
If no Javadoc comments exist within the source, some default documentation will be produced automatically.
Keep in mind that the same rules apply when using the Javadoc tool as with using javac.
You must reside within the same directory as the source file or prepend the name of the file with the path to where it is located.
The JDK comes packaged with an extensive system for documentation known as Javadoc.
Placing some special comments throughout the code source and running a simple command-line tool makes it easy to generate useful documentation and keep it current.
Moreover, even if some of the classes, methods, or fields in an application are not commented specifically for the Javadoc utility, default documentation will be recorded for such elements.
To create Javadoc comments, begin the comment line with the characters (/**)
Although optional since Java 1.4, a common practice is to include an asterisk as the first character of every line within the comment.
Another good practice is to indent the comment so that it aligns with the code that is being documented.
Javadoc comments should begin with a short description of the class or method.
The comment can be several lines in length and can even contain more than one paragraph.
If you want to break comments into paragraphs, then separate them using the <p>tag.
Comments can include several tags that indicate various details regarding the method or class that is being commented.
Javadoc tags begin with an asterisk (@), and some of the common tags are as follows:
As mentioned in the solution to this recipe, the Javadoc utility is used to create the actual documentation set for a given class.
This utility ships along with the JDK and resides within the bin directory of your JDK install.
Running the Javadoc utility is much like running javac in that you must either reside within the same directory as the sources you want to run the utility against or prepend the name with the full path to the sources.
Once initiated, Javadoc will produce several HTML files that will document all features of the given class.
The utility is smart enough to provide some default documentation for each class, method, and field without any Javadoc comments being manually provided.
However, it is highly recommended to include Javadoc comments before each class and method to indicate a description of functionality.
The Javadoc tool can also be run against entire packages or source.
To do this, simply pass the entire package name to the Javadoc tool rather than individual source file names.
To generate Javadoc for more than one package at a time, separate the package names with spaces as follows:
Another option is to specify the path to the source files using the –sourcepath flag as follows:
One thing to note is that by default, the Javadoc tool will generate the HTML and place it into the.
This can become a cluttered nightmare if you like to have source files separate from documentation like I do.
You can set up a destination for the generated documentation by passing the –d flag to the Javadoc tool.
There are also a number of other flags that can be passed to the tool in order to customize your documentation.
Some of the most commonly used flags are listed in Table 1-1
For a complete listing of the flags, you can issue the Javadoc –help command.
The Javadoc tool contains many options, but it is a great way to document application sources.
The best part is that if a change is made to the sources, the Javadoc tool can simply be run again to update the documentation.
This recipe only touches upon the many options available for use with Javadoc.
If you are interested in learning more, please look at the documentation available on Oracle’s web site.
You want to mark a method in your Java class as deprecated because a newer version of the method has been created, and the older version will be going away in a future release.
Use the @Deprecated annotation to signify that the method has been deprecated and may be taken out of future versions of your class.
Also make sure that you use the @Deprecated Javadoc tag to mark the method as deprecated within the documentation.
In the following class, the addNumbers() methods is deprecated in lieu of a newer, more robust application programming interface (API) that has been put into place.
The code marks the method as deprecated, and its Javadoc makes use of the @Deprecated tag to inform users that the new API should now be used:
It can mean that a specified class, method, or field is no longer important and should not be used.
It can also mean that the specified item contains a poor programming practice, is insecure, contains bugs, or is highly inefficient.
Any feature that has been designated as deprecated may or may not be available in a future release.
There are a couple of different ways to designate a class, method, or field as deprecated.
This annotation can be placed before the signature of a class, method, or field.
When the compiler uses a program element marked with the @Deprecated annotation, a warning will be issued.
This warning will indicate to the developer that said program element should no longer be used.
In the solution to this recipe, you saw that the @Deprecated annotation was used as follows:
When the addNumbers(int x, int y) method is called, the compiler will issue a warning.
Many IDEs (integrated development environments) will place a line through the element if a developer tries to use it.
Another way to indicate that a class, method, or field is deprecated would be to mark it with the @deprecatedJavadoc tag.
By doing so, the Javadoc will add special HTML to any tagged elements so that they can be easily identified.
When marking Javadoc with the @Deprecated tag, a space or newline should follow the tag, and a paragraph should be used to explain why the element has been deprecated and what new functionality has been added to replace it.
Again, the example in the solution to this recipe showed how this was done:
Using the @Deprecated annotation will cause a compiler warning if you are compiling a class that calls a deprecated method, and it also automatically marks Javadoc for the element as deprecated.
Therefore, it is the preferred method of marking an element as deprecated.
The ability to deprecate adds functionality to code in that it allows for a smooth transition to newly developed code in order to phase out older code.
It also warns all developers using deprecated code to begin learning the updated API, rather than simply removing functionality and leaving the developer stranded to learn on their own.
You want to encapsulate some functionality that is contained within a Java class so that it can be reused in other places.
Abstract the functionality that you want to encapsulate and place it into a method so that it can be reused.
Methods reside within Java classes and they encompass a body of code that is used to perform a task.
They can accept zero or more parameters, and they may or may not return a value.
In the following Java class, the functionality for adding two numbers and displaying the result has been placed inside a method named addNumbers()
Similarly, the functionality for multiplying the same two numbers has been placed inside of a method named multiplyNumbers()
As you can see, both methods encapsulate some mathematical functionality, produce a result, and print a value.
Java methods are another one of the fundamental building blocks of a Java application.
In fact, a Java desktop application cannot execute without the main() method.
Methods can be made public, protected, or private depending on the level of access that is required.
If a method has a private modifier, it can be invoked only from within the same class in which it is contained.
If a method has a protected modifier, any class within the same package can invoke it.
Any methods designated with a public modifier are accessible to all classes in the application.
Methods can return a value if needed, but they do not have to do so.
Methods can accept zero or more arguments, and the data type of each argument that is passed must be denoted within the method signature.
The method signature consists of the access modifier, return value, method name, and argument list.
The first example demonstrates a method that has a public modifier.
The method with this signature can be invoked without instantiating its containing class because it is marked as static.
This method is called multiplyNumbers and it accepts no arguments.
The method with a signature like the one in the second example is named divideBy, it returns an int value, and it accepts two arguments with int types.
In the solution to this recipe, two class fields with the int data type are declared.
When the class is executed, two numbers will be accepted and stored into the class fields.
The main() method then calls each method implemented in the class separately to perform calculations on the numbers that are stored within the class fields.
As you can see, to invoke a method simply call it by name and pass any arguments that it requires within the parentheses at the end of the name.
If no arguments are required, place an empty set of parentheses at the end of the name, as demonstrated by the Solution to this recipe.
Methods can accept arguments, such as the divideBy() method that was discussed previously in this section.
To learn more about passing arguments to a method, please see Recipe 1-11
Please see Recipe 1-11 for more information on returning values from methods.
You want to create a method that accepts arguments and returns a result.
Declare any method(s) that will accept arguments by naming the specific number of arguments and the data types of the arguments within the method signature.
Once declared, only those specified argument types will be acceptable as input for that method.
If the method will return a value, list the returning value data type within the method signature prior to the method name.
The following class contains the same functionality as the one listed in the solution for Recipe 1-10
However, instead of the program declaring class fields that will hold the value of the integers, two fields are declared within the main() method and then passed to each method when they are called:
Running this class will yield the same result as the class in Recipe 1-10, but instead of each method using global variables, they will use the int arguments that are passed instead.
Methods can be very useful for encapsulating logic that performs tasks.
This encapsulation can help to make code more readable and reusable.
For instance, if you were to code a calculation operation such as one that is demonstrated in the Solution to this Recipe, it makes sense to place it into a separate method.
Otherwise, you would have to rewrite that calculation logic each time you wanted to use it.
This Recipe discusses two of the major strengths that methods provide: the ability to accept arguments and to return a value.
The ability to accept arguments allows methods to become reusable.
If you had to rely on using global variables for work within methods, they would be useful only for the purpose of working with the same data each time they were called.
Using the logic of passing arguments allows methods to be coded in a generic manner, so that they can work on the data that has been passed into them instead.
Consider the multiplyNumbers() method demonstrated in the Solution to this recipe.
If it were not able to accept parameters then it would only be able to calculate variables that were globally defined within its containing class, such as demonstrated in Recipe 1-10
However, by affording this method the opportunity to accept arguments, it has become a method that can be reused anytime and in any location in order to perform the task of multiplying two values.
The ability to return a value allows for reusability as well.
Often methods will need to return a value to the caller so the value can be used by the application in some way.
The type of any value being returned must match the return type in the method’s signature.
The following piece of code demonstrates the ability to assign a value of a variable based upon the result that is returned from a method:
Any nontrivial Java application will contain methods that can be reused.
They are an important part of the language, and they help to promote object-oriented capability in an application codebase.
Your application consists of a set of Java classes, interfaces, and other types.
You want to organize these source files to make them easier to maintain and avoid potential class-naming conflicts.
Create Java packages and place source files within them much like a filing system.
Java packages can be used to organize logical groups of source files within an application.
Packages can help to organize code, reduce naming conflicts among different classes and other Java type files, and provide access control.
To create a package, simply create a directory within the root of your application source folder and name it.
Packages are usually nested within each other and conform to a standard naming convention.
For the purposes of this recipe, assume that my organization is named Juneau and that my organization makes widgets.
To organize all the code for the widget application, create a group of nested packages conforming to the following directory structure:
Any source files that are placed within a package must contain the package statement as the first line.
The package statement lists the name of the package in which the source file is contained.
To place this class into a package named org.juneau, physically move the source file into a directory named juneau, which resides within the org directory, which in turn resides within the root of the source folder for the application.
Note that the first line in the source contains the package statement, which lists the name of the package that the source file is located within.
The entire package path is listed in the statement, and each package name is separated by a dot.
Note A package statement must be the first statement listed within the Java source.
However, there may be a comment or Javadoc listed before the package statement.
The application may have interfaces that can be used to interact with the widget objects.
Java packages are useful for organizing source files, controlling access to different classes, and ensuring that there are no naming conflicts.
Note When a class resides within a Java package, it is no longer referenced by only the class name, but instead the package name is prepended to the class name, which is known as the fully qualified name.
Packages are represented by a series of physical directories on a file system, and they can contain any number of Java source files.
Each source file must contain a package statement before any other.
This package statement lists the name of the package in which the source file resides.
In the solution to this recipe, the source included the following package statement:
This package statement indicates that the source file resides within a directory named juneau, and that directory resides within another directory named org.
However, it is important that Java keywords are in lowercase so they do not conflict with any Java class or other type file names.
Many companies will use the reverse of their domain name for package naming.
However, if a domain name includes hyphens, underscores should be used instead.
Packages are very useful for establishing levels of security as well as organization.
By default, different classes that reside within the same package have access to each other.
If a source file resides within a different package than another file that it needs to use, an import statement must be declared at the top of the source file (underneath the package statement) to import that other file for use; otherwise, the fully qualified package.class name must be used within the code.
Classes may be imported separately, as demonstrated in the following import statement:
However, it is often likely that all classes and type files that reside within a package need to be used.
A single import statement utilizing a wildcard character (*) can import all files within a named package as follows:
Although it is possible to import all files, it is not recommended unless absolutely necessary.
As a matter of fact, it is considered a poor programming practice to include many import statements that use the wildcard.
Type file organization by package can prove to be very helpful.
Suppose that the widget application that was described in the Solution to this Recipe includes different Java classes for each different widget object.
Similarly, each of the widgets could extend some Java type or interface.
Any Java library or API that you use includes packages.
When you import classes or types from those libraries, you are listing packages that are contained in the library.
You are interested in writing a command line or terminal application that will accept user input from the keyboard.
In the following example, the user is prompted to enter a username when they run the program.
With the help of the aforementioned classes, when users type their usernames into the keyboard, they are saved into a local variable and then printed out:
After the user is finished typing the username into the command line or terminal, it is read into the program and saved into a BufferedReader type variable.
Quite often, our applications need to accept user input of some kind.
Granted, most applications are not used from the command line or terminal nowadays, but having the ability to create an application that reads input from the command line or terminal helps to lay a good foundation.
It can also be useful for developing administrative applications that you or a system administrator may use.
As you can see from the example, System.in is passed into a new instance of the InputStreamReader, which is then passed into a new instance of the BufferedReader.
This stacking of statements is very common in Java development.
Strings are one of the most commonly used data types in any programming language.
They can be used for obtaining text from a keyboard, printing messages to a command line, and much more.
Given the fact that Strings are used so often, there have been many features added to the String object over time in order to make them easier to work with.
After all, a String is an object in Java, so it contains methods that can be used to manipulate the contents of the String.
Strings are also immutable in Java, which means that their state cannot be changed or altered.
This makes them a bit different to work with than some of the mutable, or changeable, data types.
It is important to understand how to properly make use of immutable objects, especially when attempting to change or assign different values to them.
This chapter will focus on some of the most commonly used String methods and techniques for working with String objects.
We will also cover some useful techniques that are not inherent of String objects.
You would like to retrieve a portion of a String.
Use the substring() method to obtain a portion of the String between two different positions.
In the solution that follows, a String is created and then various portions of the String are printed out using the substring() method.
This is the original String is the original original String.
One such method is substring(), which can be used to obtain portions of the String.
One of them accepts a single argument, that being the starting index; and the other accepts two arguments: startingindex and endingindex.
Having two variations of the substring() method makes it seem as though the second argument is optional; if it is not specified, the length of the calling String is used in its place.
It should be noted that indices begin with zero, so the first position in a String has the index of 0, and so on.
As you can see from the solution to this recipe, the first use of substring() prints out the entire contents of the String.
This is because the first argument passed to the substring() method is 0, and the second argument passed is the length of the original String.
The third example specifies only one argument; therefore, the result will be the original String beginning with the position specified by that argument.
If you attempt to pass a negative value, an exception will be thrown.
An application that you are writing needs to have the ability to compare two or more String values.
The following is a series of tests using different String comparison operations.
As you can see, various if statements are used to print out messages if the comparisons are equal:
One of the trickier parts of using a programming language can come when attempting to compare two or more values.
In the Java language, comparing Strings can be fairly straightforward, keeping in mind that one should not use the == for String comparison.
This is because the comparison operator (==) is used to compare references, not values of Strings.
One of the most tempting things to do when programming with Strings in Java is to use the comparison operator, but you must not because the results can vary.
Note Java uses interning of Strings to speed up performance.
This means that the JVM contains a table of interned Strings, and each time the intern() method is called on a String, a lookup is performed on that table to find a match.
If no matching String resides within the table, the String is added to the table and a reference is returned.
If the String already resides within the table, the reference is returned.
Java will automatically intern String literals, and this can cause variation when using the == comparison operator.
In the solution to this recipe, you can see various different techniques for comparing String values.
The equals() method is a part of every Java object.
The Java String equals() method has been overridden so that it will compare the values contained within the String rather than the object itself.
As you can see from the following examples that have been extracted from the solution to this recipe, the equals() method is a safe way to compare Strings.
The equals() method will first check to see whether the Strings reference the same object using the == operator; it will return true if they do.
If they do not reference the same object, equals() will compare each String character by character to determine whether the Strings being compared to each other contain exactly the same values.
What if one of the Strings has a different case setting than another? Do they still compare equal to each other using equals()? The answer is no, and that is why the equalsIgnoreCase() method was created.
Comparing two values using equalsIgnoreCase() will cause each of the characters to be compared without paying attention to the case.
The following examples have been extracted from the solution to this recipe:
This comparison is based upon the Unicode value of each character contained within the Strings.
The result will be a negative integer if the String lexicographically precedes the argument String.
The result will be a positive integer if the String lexicographically follows the argument String.
The result will be zero if both Strings are lexicographically equal to each other.
The following excerpt from the solution to this recipe demonstrates the compareTo() method:
Inevitably, many applications contain code that must compare Strings at some level.
The next time you have an application that requires String comparison, consider the information discussed in this recipe before you write the code.
One of the Strings you are working with contains some whitespace on either end.
In the following example, a sentence is printed including whitespace on either side.
The same sentence is then printed again using the trim() method to remove the whitespace so that the changes can be seen.
Regardless of how careful we are, whitespace is always an issue when working with Strings of text.
This is especially the case when comparing Strings against matching values.
If a String contains an unexpected whitespace character then that could be disastrous for a pattern-searching program.
Luckily, the Java String object contains the trim() method that can be used to automatically remove whitespace from each end of any given String.
In fact, as you can see from the solution to this recipe, all that is required to use the trim() method is a call against any given String.
Because Strings are objects, they contain many helper methods, which can make them very easy to work with.
After all, Strings are one of the most commonly used data types in any programming language…so they’d better be easy to use! The trim() method returns a copy of the original String with all leading and trailing whitespace removed.
If, however, there is no whitespace to be removed, the trim() method returns the original String instance.
You would like to change all the Strings to uppercase before they are processed in order to avoid any case sensitivity issues down the road.
The String object provides these two helper methods to assist in performing a case change for all of the characters in a given String.
For example, given the String in the following code, each of the two methods will be called:
To ensure that the case of every character within a given String is either upper- or lowercase, use the toUpperCase() and toLowerCase() methods, respectively.
There are a couple of items to note when using these methods.
First, if a given String contains an uppercase letter, and the toUpperCase() method is called against it, the uppercase letter is ignored.
The same concept holds true for calling the toLowerCase() method.
Any punctuation or numbers contained within the given String are also ignored.
One of the variations does not accept any arguments, while the other accepts an argument pertaining to the locale you want to use.
Calling these methods without any arguments will result in a case conversion using the default locale.
If you want to use a different locale, you can pass the desired locale as an argument, using the variation of the method that accepts an argument.
For instance, if you want to use an Italian locale, you would use the following code:
Converting Strings to upper- or lowercase using these methods can make life easy.
They are also very useful for comparing Strings that are taken as input from an application.
Consider the case in which a user is prompted to enter a username, and the result is saved into a String.
Now consider that later in the program that String is compared against all the usernames stored within a database to ensure that the username is valid.
What happens if the person who entered the username types it with an uppercase first character? What happens if the username is stored within the database in all uppercase? The comparison will never be equal.
In such a case, a developer can use the toUpperCase() method to alleviate the problem.
Calling this method against both the Strings that are being compared will result in a comparison in which the case is the same in both Strings.
There are various Strings that you want to combine into one.
If you want to concatenate Strings onto the end of each other, use the concat() method.
The following example demonstrates the use of the concat() method:
Use the concatenation operator to combine the Strings in a shorthand manner.
In the following example, a space character has been placed in between the two Strings:
String one = "Hello"; String two = "Java7"; String result = one + " " + two;
The following example demonstrates the use of StringBuffer to concatenate two Strings:
The Java language provides a couple of different options for concatenating Strings of text.
Although neither is better, you may find one or the other to work better in different situations.
It has the ability to append one String onto the end of another, as demonstrated by solution #1 to this recipe.
The concat() method will accept any String value; therefore, you can explicitly type a String value to pass as an argument if you want.
As demonstrated in solution #1, simply passing one String as an argument to this method will append it to the end of the String, which the method is called upon.
However, if you wanted to add a space character in between the two Strings, you could do so by passing a space character as well as the String you want to append as follows:
As you can see, having the ability to pass any String or combination of Strings to the concat() method makes it very useful.
Because all of the String helper methods actually return copies of the original String with the helper method functionality applied, you can pass Strings calling other helper methods to concat() (or any other String helper method) as well.
Consider that you want to display the text “Hello Java” rather than “Hello Java7”
The following combination of String helper methods would allow you to do just that:
The concatenation operator (+) can be used to combine any two Strings.
It is almost thought of as a shorthand form of the concat() method.
The last technique that is demonstrated in solution #3 to this example is the use of StringBuffer, which is a mutable sequence of characters, much like a String, except that it can be modified.
The StringBuffer class contains a number of helper methods for building and manipulating character sequences.
In the solution, the append() method is used to append two String values.
The append() method places the String that is passed as an argument at the end of the StringBuffer.
For more information regarding the use of StringBuffer, please refer to the online documentation: http://download.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html.
You would like to have the ability to convert any numeric values that are stored as Strings into Integers.
As you can see, both of the String variables are converted into Integer values.
After that, they are used to perform an addition calculation and then stored into an int.
Note A technique known as autoboxing is used in this example.
Autoboxing is a feature of the Java language that automates the process of converting primitive values to their appropriate wrapper classes.
For instance, this occurs when you assign an int value to an Integer.
Similarly, unboxing automatically occurs when you try to convert in the opposite direction, from a wrapper class to a primitive.
For more information on autoboxing, please refer to the online documentation at http://download.oracle.com/javase/1.5.0/docs/guide/language/autoboxing.html.
The Integer class contains the valueOf()and parseInt() methods, which are used to convert Strings or int types into Integers.
There are two different forms of the Integer class’s valueOf() type that can be used to convert Strings into Integer values.
Each of them differs by the number of arguments that they accept.
This String is then converted into an Integer value if possible.
The second version of Integer’s valueOf() method accepts two arguments: a String argument that will be converted into an Integer and an int that represents the radix that is to be used for the conversion.
Note Many of the Java type classes contain valueOf() methods that can be used for converting different types into that class’s type.
Such is the case with the String class because it contains many different valueOf() methods that can be used for conversion.
For more information on the different valueOf() methods that the String class or any other type class contains, please see the online Java documentation (http://download.oracle.com/javase/7/docs/)
There are also two different forms of the Integer class’s parseInt() method.
One of them accepts one argument: the String you want to convert into an Integer.
The other form accepts two arguments: the String that you want to convert to an Integer and the radix.
The first format is the most widely used, and it parses the String argument as a signed decimal integer.
The second format, which is less widely used, returns an Integer object holding the value that is represented by the String argument in the given radix.
You want to iterate over the characters within a String of text so that you can manipulate it at the character level.
Use a combination of String helper methods to gain access to the String at a character level.
If you use a String helper method within the context of a loop, you can easily traverse a String by character.
In the following example, the String str is broken down using the toCharArray() method.
The same strategy could be used with the older version of the for loop.
An index could be created that would allow access to each character of the String using the charAt() method.
Note The first example using toCharArray() generates a new character array.
Therefore, the second example, using the traditional for loop, might perform faster.
String objects contain methods that can be used for performing various tasks.
The solution to this recipe demonstrates a number of different String methods.
The toCharArray() method can be called against a String in order to break the String into characters and then store those characters in an array.
This method is very powerful and it can save a bit of time when performing this task is required.
The result of calling the toCharArray() method is a char[], which can then be traversed using an index.
Such is the case in the solution to this recipe.
An enhanced for loop is used to iterate through the contents of the char[] and print out each of its elements.
The String length() method is used to find the number of characters contained within a String.
The result is an int value that can be very useful in the context of a for loop, as demonstrated within the solution to this recipe.
In the second example, the length() method is used to find the number of characters in the String so that they can be iterated over using the charAt() method.
The charAt() method accepts an int index value as an argument and returns the character that resides at the given index in the String.
Often the combination of two or more String methods can be used to obtain different results.
In this case, using the length() and charAt() methods within the same code block provided the ability to break down a String into characters.
You would like to search a body of text for a particular sequence of characters.
Make use of regular expressions and the String matches() helper method to determine how many matches exist.
To do this, simply pass a String representing a regular expression to the matches() method against any String you are trying to match.
In doing so, the String will be compared with the String that matches() is being called upon.
Once evaluated, matches() will yield a Boolean result, indicating whether it is a match or not.
The following code excerpt contains a series of examples using this technique.
The comments contained within the code explain each of the matching tests.
Each of the results printed out in the example will be TRUE, with the exception of the second example because it does not match.
Use the regular expression Pattern and Matcher classes for a better performing and more versatile matching solution than the String matches() method.
Although the matches() method will get the job done most of the time, there are some occasions in which you will require a more flexible way of matching.
Construct a Matcher object using the matcher() method on the Pattern.
In the following example code, the Pattern and Matcher technique is demonstrated:
String str = "I love Java 7!"; boolean result = false;
The previous example will yield a TRUE value just like its variant that was demonstrated in solution #1
Regular expressions are a great way to find matches because they allow patterns to be defined so that an application does not have to explicitly find an exact String match.
They can be very useful when you want to find matches against some text that a user may be typing into your program.
However, they could be overkill if you are trying to match Strings against a String constant you have defined in your program because the String class provide many methods that could be used for such tasks.
Nevertheless, there will certainly come a time in almost every developer’s life when regular expressions can come in handy.
They can be found in just about every programming language used today.
Java makes them easy to use and easy to understand.
Note Although regular expressions are used in many different languages today, the expression syntax for each language varies.
For complete information regarding regular expression syntax, please see the documentation online at http://download.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html.
The easiest way to make use of regular expressions is to call the matches() method on the String object.
Passing a regular expression to the matches() method will yield a Boolean result that indicates whether the String matches the given regular expression pattern or not.
At this point, it is useful to know what a regular expression is and how it works.
A regular expression is a String pattern that is used to match against other Strings in order to determine its contents.
Regular expressions can contain a number of different patterns that enable them to be dynamic in that they can have the ability to match many different Strings that contain the same format.
For instance, in the solution to this recipe, the following code can match several different strings:
To see a listing of all the different patterns that can be used in a regular expression, please see the online documentation available at http://download.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html.
A combination of Pattern and Matcher objects can also be used to achieve similar results as the String matcher() method.
The Pattern object can be used to compile a String into a regular expression pattern.
A compiled pattern can provide performance gains to an application if the pattern is used multiple times.
The result is a compiled Pattern object that can be matched against a String for comparison.
A Matcher object can be obtained by calling the Pattern object’s matcher() method against a given String.
Once a Matcher object is obtained, it can be used to match a given String against a Pattern using any of the following three methods, which each return a.
The Matcher matches() method attempts to match the entire input String with the pattern.
The Matcher lookingAt() method attempts to match the input String to the pattern starting at the beginning.
The Matcher find() method scans the input sequence looking for the next matching sequence in the String.
In the solution to this recipe, the matches() method is called against the Matcher object in order to attempt and match the entire String.
In any event, regular expressions can be very useful for matching Strings against patterns.
The technique used for working with the regular expressions can vary in different situations, using whichever method works best for the situation.
You have searched a body of text for a particular sequence of characters, and you are interested in replacing all matches with another String value.
Use a regular expression pattern to obtain a Matcher object; then use the Matcher object’s replaceAll() method to replace all matches with another String value.
Original: I love Java 7! It is my favorite language.
Replacement: I love Java 6! It is my favorite language.
The replaceAll() method of the Matcher object makes it easy to find and replace a String or portion of String that is contained within a body of text.
Use the resulting Pattern object to obtain a Matcher object by calling its matcher() method.
The following lines of code show how this is done:
Once you have obtained a Matcher object, call its replaceAll() method by passing a String that you want to use to replace all the text that is matched by the compiled pattern.
You are reading a file from the server and you need to determine what type of file it is in order to read it properly.
Determine the suffix of the file by using the endsWith() method on a given file name.
In the following example, assume that the variable filename contains the name of a given file, and the code is using the endsWith() method to determine whether filename ends with a particular string.:
Given that a file name and its suffix are included in the filename variable, this block of code will read it and determine what type of file the given variable represents by reading its suffix.
As mentioned previously, the String object contains many helper methods that can be used to perform tasks.
The String object’s endsWith() method accepts a character sequence and then returns a Boolean value representing whether the original String ends with the given sequence.
In the case of the solution to this recipe, the endsWith() method is used in an if block.
A series of file suffixes are passed to the endsWith() method to determine what type of file is represented by the filename variable.
If any of the file name suffixes matches, a line is printed, stating what type of file it is.
As such, it is helpful to know how to use them correctly within the context of the work that you are trying to perform.
This chapter will help you to understand how to perform some of the most basic operations with numbers, and it will also provide insight on performing advanced tasks such as working with currency.
Dates can also become important as they can be used for many different reasons within an application.
In this chapter, you will learn how to work with dates and how to perform calculations with them.
This chapter will also cover some new additions to the Java language with the Java 7 release.
There have been some minor but important updates to binary literals and numeric literals that will be demonstrated in this chapter.
In the end, you will learn how to perform essential tasks with both numbers and dates in order to make your application development easier.
You need to have the ability to round floating-point numbers or doubles within your application to an Integer value.
Use one of the java.lang.Math round() methods to round the number into the format you require.
The Math class has two different methods that can be used for rounding floating-point numbers or Double values.
The following code demonstrates how to use each of these methods:
The first method, roundFloatToInt(), accepts a floating-point number and uses the java.lang.Math class to round that number to an Integer.
The java.lang.Math class contains plenty of helper methods to make our lives easier when working with numbers.
The round() methods are no exception as they can be used to easily round floating-point or double values.
One version of the java.lang.Math round() method accepts a float as an argument.
It will round the float to the closest int value, with ties rounding up.
If the argument is NaN, then a zero will be returned.
The second version of the java.lang.Math round() method accepts a double value.
The double value is rounded to the closest long value, with ties rounding up.
Just like the other round(), if the argument is Not a Number (NaN), a zero will be returned.
NaN (Not a Number) is an undefined or unrepresentable value.
You need to have the ability to format double and long numbers within your application.
Use the DecimalFormat class to format and round the value to the precision your application requires.
In the following method, a double value is accepted and a formatted String value is printed:
For instance, if the double value passed into the formatDouble() method is 345.9372, the following will be the result:
Similarly, if the value .7697 is passed to the method, the following will be the result:
Each of the results is formatted using the specified pattern and rounded accordingly.
The DecimalFormat class can be used along with the NumberFormat class to round and/or format double or long values.
NumberFormat is an abstract class that provides the interface for formatting and parsing numbers.
This class provides the ability to format and parse numbers for each locale, and obtain formats for currency, percentage, integers, and numbers.
By itself, the NumberFormat class can be very useful as it contains factory methods that can be used to obtain formatted numbers.
In fact, little work needs to be done in order to obtain a formatted String.
For example, the following code demonstrates the calling of some factory methods on NumberFormat class:
To format using a pattern, the DecimalFormat class can be used along with NumberFormat.
In the solution to this recipe, you saw that creating a new DecimalFormat instance by passing a pattern to its.
Because the NumberFormat class is abstract, DecimalFormat contains all the functionality that NumberFormat contains, plus added functionality for working with patterns.
Therefore, it can be used to work with different formats from the locales just as you have seen in the previous demonstration.
This provides the ultimate flexibility when working with double or long formatting.
As mentioned previously, the DecimalFormat class can take a String-based pattern in its constructor.
You can also use the applyPattern() method to apply a pattern after the fact.
Each pattern contains a prefix, numeric part, and suffix, which allows you to format a particular decimal value to the required precision, and include leading digits and commas as needed.
The symbols that can be used to build patterns are displayed in Table 3-1
Each of the patterns also contains a positive and negative subpattern.
These two subpatterns are separated by a semicolon (;), and the negative subpattern is optional.
If there is no negative subpattern present, the localized minus sign is used.
The DecimalFormat class provides enough flexibility to format double and long values for just about every situation.
Use the comparison operators to compare Integer values against one another.
In the following example, three int values are compared against each other, demonstrating various comparison operators:
As you can see, comparison operators will generate a Boolean result.
The following lines could compare the same int values that were declared in the first solution:
Perhaps the most commonly used numeric comparisons are against two or more int values.
The Java language makes it very easy to compare an int using the comparison operators (see Table 3-2)
Just like in your math lessons at school, these comparison operators will determine whether the first Integer is equal to, greater than, or less than the second Integer.
Straightforward and easy to use, these comparison operators are most often seen within the context of an if statement.
You need to compare two or more floating-point values in an application.
Use the Float object’s compareTo() method to perform a comparison of one Float against another.
The result of calling the compareTo() method is an Integer value.
A negative result indicates that the first float is less than the float that it is being compared against.
A zero indicates that the two float values are equal.
Lastly, a positive result indicates that the first float is greater than the float that it is being compared against.
Use the Float class compare() method to perform the comparison.
The most useful way to compare two Float objects is to make use of the compareTo() method.
This method will perform a numeric comparison against the given float objects.
The result will be an integer value indicating whether the first Float is numerically greater than, equal to, or less than the Float that it is compared against.
If a float value is NaN, it is considered to be equal to other NaN values or greater than all other float values.
An alternative to using compareTo() is the compare() method, which is also native to the Float class.
The compare() method was introduced in Java 1.4, and it is a static method that compares two float values in the same manner as compareTo()
The compare() method shown will actually make the following call using compareTo():
In the end, the same results will be returned using either compareTo() or compare()
You have a requirement to perform calculations with complex numbers in your Java application.
Download the Apache Commons Math library and make use of the Complex class.
The Commons Math library makes it easy to work with complex numbers.
In the following example code, a Java class including import statements for the Apache Commons Math library demonstrates how to create complex numbers and perform arithmetic operations:
This example provides you with a solid foundation on how to use the Apache Commons Math library to work with complex numbers.
To learn more about printing out the results of an imaginary number and formatting properly, please see recipe 3-6
For the most part, they are used in scientific and engineering fields, and they make it possible to extend the real value of a number so that problems can be solved.
The issue with using complex numbers in Java is that there are no classes built into the language for working with them properly.
Therefore, many people have worked around this by building their own complex number classes to work with them.
As a result, there are hundreds of different Complex.java classes (or some named similarly) that can be found on the Web.
In this book, we will use one of the most widely accepted libraries, the Apache Commons Math library, to tackle tasks such as these when possible.
This library contains its own set of classes for working with complex numbers.
To get started, the first thing you need to do is download the latest JAR files for the Apache Commons Math library from its location on the web (http://commons.apache.org/math/), and place the JAR files in your CLASSPATH.
As of this writing, release 2.2 was the most current version.
Therefore, the examples in the solution to this recipe might differ if you are using a different version of the library.
Version 2.2 contains three JAR files, and these files include the library, sources, and Javadoc.
Make sure you place the JAR file that contains the compiled library into your CLASSPATH.
If you are using an IDE, you might want to also include the Javadoc JAR file into your CLASSPATH as this will allow the IDE to display the associated Javadoc with a method when you are using auto-completion.
Once the JARs are downloaded and in your CLASSPATH, you need to import the appropriate classes into the class from which you wish to make use of the library.
Once imported, you can create complex numbers using the Complex class, perform calculations, and manipulate them as needed.
To create a complex number object using the library, pass two double arguments to the constructor.
The first double represents the real number part, and the second represents the imaginary part.
After you’ve created a complex number object, you can work with it by calling the various methods contained within it.
Most of the methods contained within the Complex class are used to perform mathematical calculations, while a handful of helper methods are used to gain access to different parts of the number, see if the number is NaN, and other miscellaneous tasks.
The mathematical methods include those that are useful for performing everyday mathematics, as well as those that are useful for working with the numbers in a trigonometric methodology.
A summary of the standard mathematical methods can be seen in Table 3-3
To make use of these methods, you call them against any given complex number object.
A demonstration of these methods can be seen in the solution to this recipe.
Trigonometric methods can also be called against a Complex object, and they do not accept any arguments.
A summary of the trigonometric Complex class methods can be seen in Table 3-4
You can see some of these trigonometric methods demonstrated in the solution to this recipe.
You might have noticed that earlier in this section the NaN symbol was used.
This is comparable to a NULL value for a Complex object.
The isNaN() method can be called against a Complex object to return a Boolean value stating whether the object is NaN.
To test the equality of two Complex objects, simply call the equals() method, as the following code demonstrates: it returns a Boolean value indicating whether the two Complex objects are equal to each other:
There are a few more methods that can be used on a Complex object, and you can see the documentation for more information on them.
As you might have noticed, the solution to this recipe does not print out the values for any of the manipulations that were performed.
To learn more about formatting and printing complex number values, see recipe 3-6
You have a requirement to format complex numbers with your Java application.
Download the Apache Commons Math library (refer to recipe 3-5 for more details) and make use of the ComplexFormat class.
This class will allow you to properly format the complex number and convert it to a String that represents both the real and imaginary number parts.
The following code demonstrates the use of the ComplexFormat class:
The ComplexFormat class also allows for the parsing of Strings into Complex objects.
The code that follows demonstrates parsing a String into a Complex object:
In the previous code, the String is parsed using the ComplexFormat class, and a Complex object, complexNum, is generated.
By default, ComplexFormat will generate a String in the standard complex number format, including the real and imaginary number parts separated by a plus (+) symbol.
The ComplexFormat class can also be used to take a complex number in String format and parse it into a Complex object.
Doing such conversions can often come in quite handy, especially if you are accepting input from a user.
You are developing an application that requires the use of monetary values and you are not sure which data type to use for storing and calculating currency values.
Use the BigDecimal data type to perform calculation on all monetary values.
In the following code, three monetary values are calculated using a handful of the methods that are part of the BigDecimal class.
The resulting calculations are then converted into double values and formatted using the NumberFormat class.
First, take a look at how these values are calculated:
Next, let’s take a look at the formatDollars() method that is used in the code.
This method accepts a double value and performs formatting on it using the NumberFormat class based upon the U.S.
As you can see, the NumberFormat class allows for currency to be formatted per the specified locale.
This can be very handy if you are working with an application that deals with currency and has an international scope.
Many people attempt to use different number formats for working with currency.
While it might be possible to use any type of numeric object to work with currency, the BigDecimal class was added to the language to help satisfy the requirements of working with currency values, among other things.
Perhaps the most useful feature of the BigDecimal class is that it provides complete control over rounding.
This is essentially why such a class is so useful for working with currency values.
The BigDecimal class provides an easy API for rounding values, and also makes it easy to convert to double values such as the solution to this recipe demonstrates.
Note The use of BigDecimal for working with monetary values is a good practice.
Depending upon the application and performance requirements, it might be worth using Math.round() to achieve basic rounding if performance becomes an issue.
To provide specific rounding with the BigDecimal class, you should use a MathContext object or the RoundingMode enumeration values.
In either case, such precision can be omitted by using a currency formatting solution such as the one demonstrated in the solution example.
BigDecimal objects have mathematical implementations built into them, so performing such operations is an easy task.
The arithmetic operations that can be used are described in Table 3-5
After performing the calculations you require, call the doubleValue() method on the BigInteger object to convert and obtain a double.
You can then format the double using the NumberFormat class for currency results.
An application that you are developing requires the use of randomly generated numbers.
The Random class was developed for the purpose of generating random numbers for a handful of the Java numeric data types.
This code demonstrates the use of Random to generate such numbers:
As you can see from the example in the solution to this recipe, the Random class can generate many different types of random number values based upon the given seed.
By default, the seed is generated based upon a calculation derived from the number of milliseconds that the machine has been active.
However, the seed can be set manually using the Random setSeed() method.
It should be noted that if two Random objects have the same seed, they will produce the same results.
It should be noted that there are cases in which the Random class might not be the best choice for generating random values.
In such a case, you might consider using the ThreadLocalRandom class instead.
To see more information regarding ThreadLocalRandom, see the documentation at http://download.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadLocalRandom.html.
Similarly, if you require the use of a cryptographically secure Random object, consider the use of SecureRandom.
Not only is it easy to use but it also provides a wide range of options for return-type.
Both techniques provide a good means of generating random values.
You are developing an application for which you would like to obtain the current date to display on a form.
If you only need to obtain the current date without going into calendar details, use the java.util.Date class to generate a new Date object.
Doing so will cause the new Date object to be equal to the current system date.
In the following code, you can see how easy it is to create a new Date object and obtain the current date:
The result will be a Date object that contains the current date and time taken from the system that the code is run on, as shown following.
Although working with the Calendar class will make your code longer, you can be much more precise.
The following code demonstrates just a handful of the capabilities of using this class to obtain the current date:
As demonstrated by this code, it is possible to obtain more detailed information regarding the current date when using the Calendar class.
The results of running the code would look like the following:
Many applications require the use of the current calendar date.
It is often also necessary to obtain the current time.
There are a couple of different ways to do that, and the solution to this recipe demonstrates two of them.
By default, the java.util.Date class can be instantiated with no arguments to return the current date and time.
The Date class can also be used to return the current time of day via the getTime() method.
There are several other methods that can be called against a Date object with regards to breaking down the current date and time into more granular intervals.
When some method or class is deprecated, that means it should no longer be used because it might be removed in some future release of the Java language.
However, a few of the methods contained within the Date class have not been tagged as deprecated, so the Date class will most likely be included in future releases of Java.
The methods that were left intact include the comparison methods after(), before(), compareTo(), setTime(), and equals()
Solution #1 to this recipe demonstrates how to instantiate a Date object and print out the current date and time.
As mentioned previously, the Date class has many methods that have become deprecated and should no longer be used.
The Calendar class was introduced in JDK 1.1, at which time many of the Date methods were deprecated.
As you can see from solution #2, the Calendar class contains all the same functionality that is included in the Date class, except the Calendar class is much more flexible.
The Calendar class is actually an abstract class that contains methods that are used for converting between a specific time and date, and manipulating the calendar in various ways.
The Calendar, as demonstrated in solution #2, is one such class that extends the Calendar class and therefore provides this functionality.
Once you have created a new Calendar object, you can extract the different date and time intervals using the get() method and passing one of the Calendar object’s static int values.
As seen in solution #2 to this recipe, the current date can be extracted and printed using the following lines of code:
For instance, the Date class can be useful when working with timestamps.
However, if the application requires detailed manipulation of dates and times then it is advisable to make use of a Calendar class, which includes all the functionality of the Date class and also adds more features.
Both solutions to this recipe are technically sound; choose the one that best suits the need of your application.
You would like to perform date calculations within your application.
This class allows you to obtain the Integer representation for a given month, day, or year of a specified date.
These Integer values can be used to perform calculations to obtain the desired result.
The results of running this code will resemble the following:
The Calendar class contains methods that make it easy to perform basic mathematics using date and time values.
Performing date calculations can be difficult if they require conversion between dates into time or into other measurements.
Such is the case if you use the java.util.Date class to perform calculations.
In the early days of Java, a Date object was often converted into hours, minutes, and seconds; and time was used to perform mathematics on a given date.
This is no longer the case with the use of the Calendar class.
The two basic requirements for date calculations are addition and subtraction.
Most often, days, weeks, months, or years need to be added or subtracted from a given date.
Via the use of the Calendar add() method, each of these two functionalities can be easily performed.
In the preceding signature, the first argument is an int value that represents the field type that will be added to the given date.
The second argument is another int value that represents the number of the.
The static int field values that can be passed as the first argument are listed in Table 3-6
When using the add() method, pass a negative value for the argument to perform a subtraction.
Working with the Calendar class might take a few minutes of use to become familiar with the syntax, but it is flexible and easy to use.
You need to determine how many hours, days, weeks, months, or years have elapsed between two dates.
Using this enum, you can obtain the Integer values for days, hours, microseconds, milliseconds, minutes, nanoseconds, and seconds.
Doing so will allow you to perform the necessary calculations.
The output of this code will be formatted to display Strings of text indicating the differences between the current date and the Date object that is created.
As with most programmatic techniques, there is more than one way to perform date calculations with Java.
However, one of the most useful techniques is to perform calculations based upon the given date’s time in milliseconds.
This provides the most accurate calculation because it works on the time at a very small interval: milliseconds.
The current time in milliseconds can be obtained from a Calendar object by calling the getTimeInMillis() method against it.
Likewise, a Date object will return its value represented in milliseconds by calling the getTime() method.
As you can see from the solution to this recipe, the first math that is performed is the difference between the given dates in milliseconds.
Obtaining that value and then taking its absolute value will provide the base that is needed in order to perform the date calculations.
In order to obtain the absolute value of a number, use the abs() method that is contained in the java.lang.Math class, shown in the following line of code:
The TimeUnit enum can be used in order to obtain different conversions of the date.
It contains a number of static enum constant values that represent different time intervals, similar to those of a Calendar object.
Note An enum type is a type whose fields consist of a fixed set of constant values.
Enum types were welcomed to the Java language in release 1.5
The values speak for themselves with regard to the conversion interval they represent.
By calling conversion methods against these enums, long values representing the duration between two dates can be converted.
As you can see in the solution to this recipe, first the time unit is established using the enum and then a conversion call is made against that time unit.
Second, the toHours() method is called against it, and a long value that is represented by the mill field is passed as an argument:
This code can be translated in English as follows: “The contents of the field mill are represented in milliseconds; convert those contents into hours.” The result of this call will be the conversion of the value within the mill field into hours.
By stacking the calls to TimeUnit, more-precise conversions can be made.
For instance, the following code converts the contents of the mill field into hours and then into days:
Combining the precision of the TimeUnit conversions along with mathematics will allow you to convert the difference of two dates into just about any time interval.
Dates need to be displayed by your application using a specific format.
You would like to define that format once and apply it to all dates that need to be displayed.
The following example demonstrates the use of the SimpleDateFormat class:
As you can see from the results, the SimpleDateFormat class makes it easy to convert a date into just about any format.
Date formatting is a common concern when it comes to any program.
People like to see their dates in a certain format for different situations.
The SimpleDateFormat class was created so we don’t have to perform manual translations for a given date.
Note Different date formats are used within different locales, and the SimpleDateFormat class facilitates locale-specific formatting.
To use the class, an instance must be instantiated either by passing a String-based pattern as an argument to the constructor or passing no argument to the constructor at all.
There are actually four constructors for instantiating an instance of SimpleDateFormat:
In the solution to this recipe, the second constructor in the preceding list is used.
The String-based pattern provides a template that should be applied to the given date and then a String representing the date in the given pattern style is returned.
A pattern consists of a number of different characters strung together.
Table 3-7 shows the different characters that can be used within a pattern.
Any of the pattern characters can be placed together in a String and then passed to the.
If the class is instantiated without passing a pattern, the pattern can be applied later using the class’s applyPattern() method.
The applyPattern() method also comes in handy when you want to change the pattern of an instantiated SimpleDateFormat object, as seen in the solution to this recipe.
The following excerpts of code demonstrate the application of a pattern:
Once a pattern has been applied to a SimpleDateFormat object, a long value representing time can be passed to the SimpleDateFormat object’s format() method.
The format() method will return the given date\time formatted using the pattern that was applied.
The String-based result can then be used however your application requires.
You need to determine whether one date is equal to or greater than another date.
In the following example, two Calendar objects are instantiated, and then they are compared with each other:
The result of this code demonstration would be a String that displays a Boolean value indicating whether the first date is prior to the second.
The comparison methods after() and before() that are contained within the Calendar class accept another Calendar object as an argument and return a Boolean indicating whether the Date passed as an argument comes after or before the Calendar object on which the method is invoked.
The Calendar object also has another method named compareTo() that accepts another Calendar object and returns an int indicating if the Calendar argument is before or after the Calendar object on which the method is invoked.
The results of the compareTo() method are shown in Table 3-8
Date argument is less than the object invoking the call.
Date argument is greater than the object invoking the call.
Some of the numeric literals in your application are rather long and you would like to make it easier to tell how large a number is at a glance.
Use underscores in place of commas or decimals in larger numbers in order to make them more readable.
The following code shows some examples of making your numeric literals more readable by using underscores in place of commas:
Sometimes working with large numbers can become cumbersome and difficult to read.
Because of the release of Java SE7, underscores can now be used within numeric literals in order to make code a bit easier to read.
The underscores can appear anywhere between digits within a numeric literal.
This allows for the use of underscores in place of commas or spaces to separate the digits and make them easier to read.
Note Underscores cannot be placed at the beginning or end of a number, adjacent to a decimal point or floating-point literal, prior to an F or L suffix, or in positions where a string of digits is expected.
You are working on an application that requires the declaration of binary numbers.
Make use of binary literals to make your code readable.
The following code segment demonstrates the use of binary literals.
The types byte, short, int, and long can be expressed using the binary number system.
This feature can help to make binary numbers easier to recognize within code.
Java is one of the most capable programming languages in use today.
Java powers the desktop, the enterprise, the Web, mobile devices, and much more.
As a Java developer, regardless of which space you are working in, there are some parts of the language that you use occasionally as needed, other parts of the language that you use rarely, and those parts of the language that you likely use on a regular basis.
In this chapter, we present a variety of recipes covering topics that fall into the latter category.
All Java applications require the use of data structures, iteration, and conditional control flow.
You will find recipes covering the use of classes from the Java Collections Framework as well as Java arrays.
If you are a new Java developer, there is a recipe to get you up to speed quickly on the use of generic types with the Collection classes.
Regardless of your level of Java experience, be sure to check out this recipe to read about a new Java 7 feature, the diamond syntax, which will make your life easier if you are doing a lot of generics programming.
In the iteration category, you may find the recipes on the use of the Iterable interface, the enhanced for loop, and Map iteration useful.
There is a recipe that demonstrates a longawaited addition to the language, finally appearing in Java 7: the ability to use Strings in the switch statement.
We start off the chapter with a couple of recipes covering what is quite likely one of the most underappreciated and underutilized features of Java: the enum type.
You need a type that can represent a fixed set of related constants.
The following example defines an enum type, called FieldType, to represent various form fields you might find on the GUI of an application:
This is the simplest form of an enum type, which will often suffice when all that is needed is a related set of named constants.
The next recipe will demonstrate how to use Java enum types in a much more powerful way.
First, let’s take a look at the capabilities that all enum types possess.
Next, the code prints out the results of calling various methods that are defined for all enum types:
A common pattern for representing a fixed set of related constants is to define each constant as an int type or some other type like a String.
Often, these constants are defined in a class or interface whose sole purpose is to encapsulate constants.
In any case, constants are typically defined with the static and final modifiers:
There are multiple problems with this pattern, the primary one being the lack of type safety.
By defining these constants as ints, it is possible to assign an invalid value to a variable that is supposed to only be allowed to hold one of the constant values:
As you can see, there will be no compiler error or warning produced to inform you of this invalid value assignment.
Chances are, you will discover this at runtime, when your application tries to use inputField.
That is, attempts to assign a value of the wrong type to an enum variable will result in a compiler error.
Attempting to assign a value that isn’t of type FieldType naturally results in a compiler error:
Under the covers, Java implements an enum type as a subclass of the abstract and final java.lang.Enum class.
Thus, an enum type cannot be instantiated directly (outside of the enum type) or extended.
The constants defined by an enum type are actually instances of the enum type.
The java.lang.Enum class defines a number of final methods that all enum types inherit.
In addition, all enum types have two implicitly declared static methods: values() and valueOf(String)
The solution code demonstrates these static methods and some of the more often used instance methods.
Most of these methods are pretty self-explantory, but the following details should be kept in mind:
Each enum constant has an ordinal value representing its relative position in the enum declaration.
The first constant in the declaration is assigned an ordinal value of zero.
The ordinal() method can be used to retrieve an enum constant’s ordinal value; however, it is not recommended that applications be written to depend on this value for maintainability reasons.
The name() method and the default implementation of the toString() method both return a string representation of the enum constant (toString() actually calls name())
It is common for toString() to be overridden to provide a more userfriendly string representation of the enum constant.
For this reason, and for maintainability reasons, it is recommended that toString() be used in preference to name()
When testing for equality, note that both the equals() method and == perform reference comparison.
However, it is recommended that == be used to take advantage of compile-time type safety.
Performing equals() comparison with a String parameter, for example, may allow the error to go unnoticed; it will compile, but it will always return false.
Conversely, attempting to compare an enum with a String using the == comparison would result in an error at compile time.
When you have the choice of catching errors sooner (at compile time) rather than later (at runtime), choose the former.
The implicitly declared static methods values() and valueOf(String) do not appear in the Java documentation or the source code for the java.lang.Enum class.
However, the Java Language Specification does detail their required implementations.
In summary, values() returns an array containing the constants of the enum, in the order they are declared.
Please refer to the online Java documentation for further details on java.lang.Enum and each its methods (http://download.oracle.com/javase/7/docs/api/java/lang/Enum.html)
You are also encouraged to check out the Enums section of the Java Language Specification for a lot of good information on enum types (http://download.oracle.com/javase/cmn/spec_index.html)
You need a type that can represent a fixed set of related constants, and you would like to build in some state and behavior (logic) around your constants in an object-oriented fashion.
Use an enum type and take advantage of the fact that enum types are full-fledged Java classes.
An enum type can have state and behavior just like any other class, and the enum constants, themselves being instances of the enum type, inherit this state and behavior.
Imagine that you need to process and validate all the form fields from an HTML form that has been submitted.
Each form field has unique rules for validating its contents, based on the field type.
For each form field, you have the field’s “name” and the value that was entered into that form field.
The FieldType enum can be expanded to handle this very easily:
Notice that our enhanced FieldType enum now defines a fieldName instance variable and a constructor with a fieldName String argument for initializing the instance variable.
Each enum constant (again, each constant being an instance of FieldType) must be instantiated with a fieldName.
FieldType also defines an abstract validate(String) method that each enum constant must implement to perform the field validation.
Here, each FieldType’s validate() method applies a regular expression match against the field value and returns the boolean result of the match.
Imagine the following form input fields corresponding to our FieldType instances:
The value of the input field’s “name” attribute is what will be used to identify the FieldType; we used this same name when we instantiated each FieldType enum constant.
When a form is submitted, we have access to each input field’s “name” and the value that was entered into thefield.
We need to be able to map the field’s “name” to a FieldType and call the validate() method with the input value.
For each FieldType enum constant, nameToFieldTypeMap stores an entry with the field name as the key, and the FieldType as the value.
The lookup(String) class method uses this map to look up the FieldType from the field name.
The code to validate an “email” input field with an input value of “john@doe.com” is quite concise:
The main() method shows an example validation for each of the FieldTypes.
The printValid() method prints the field name, field value, and the field’s validation result.
This recipe has demonstrated that there is a lot more potential in the enum type than just the ability to define a set of named constants.
Enum types have all the power of a normal class, plus additional features that allow you to create well-encapsulated and intelligent constants.
You want to execute different blocks of code based on the value of a singular expression.
Consider using a switch statement if your variable or expression result is one of the allowed switch types and you want to test for equality against a type-compatible constant.
These examples show various ways to use the switch statement, including a new feature of Java 7: the ability to switch on Strings.
The SwitchTypeChecker class demonstrates the use of a String as the switch expression type.
So, SwitchTypeChecker is using a switch statement to simultaneously demonstrate switching on Strings and to show the valid types for use in a switch expression:
The switch statement is a control flow statement that allows you to execute different blocks of code based on the value of a switch expression.
It is similar to the if-then-else statement, except that the switch statement can only have a single test expression, and the expression type is restricted to one of several different types.
When a switch statement executes, it evaluates the expression against constants contained in the switch statement’s case labels.
If the value of the expression equals the value of a case label constant, control is transferred to the section of code that corresponds to the matching case label.
All code statements from that point on are then executed until either the end of the switch statement is reached or a break statement is reached.
The break statement causes the switch statement to terminate, with control being transferred to the.
Optionally, the switch statement can contain a default label, which provides a branch point for the case when there is no case label constant that equates to the switch expression value.
The method also demonstrates how case labels can be grouped to implement a logical OR conditional test.
If a case label does not have any associated code to execute, and no break statement, the flow of execution falls through to the next closest case label containing executable statements, thus allowing common code to be executed if the result of the switch expression matches any one of the grouped case constants.
There are two methods in this class that demonstrate the switch statement.
The getHand() method shows the use of an enum variable in the switch expression.
The playHands() method simply intends to show that the switch expression, although often just a variable, can be any expression whose result is of one of the allowed switch types.
In this case, the expression is using a ternary operator that returns an int value.
You need a simple data structure that can store a fixed (and possibly large) amount of same-typed data and provide for fast sequential access.
While Java provides more sophisticated and flexible Collection types, the array type can be useful data structure for some types of applications.The following example demonstrates the simplicity of working with arrays.
The GradeAnalyzer class provides a means for calculating various grade-related statistics, such as the mean (average) grade, minimum grade, and maximum grade.
The Java array type is often dismissed for its insuperiority to Java’s more sophisticated ArrayList (part of the Java Collections Framework)
Often this criticism comes from the inflexibility of the array type.
That is, when an array is created, you must tell it how much data it can hold.
Once an array has been created, you cannot insert or remove array items, or otherwise change the size of the array.
However, if you have a fixed amount (and especially a very large amount) of data that you just need to work on while iterating over it sequentially, an array may be a good choice.
The first thing you need to know about the Java array type is that it is an Object type.
All arrays, regardless of the type of data they hold, have Object as their superclass.
Regardless of the array type, the memory for an array is always allocated out of the heap space for the application.
The heap is the area of memory used by the JVM for dynamic memory allocation.
Note It is possible to create an array of Objects (Object[]) that can hold references to objects of different types, however, this is not recommended as it requires you to check the type of elements and perform explicit type casting when retrieving elements from the array.
There are two steps to completely defining an array object in Java: array variable declaration, which specifies the array element type, and array creation, which allocates the memory for the array.
There are multiple ways to initialize an array, which are shown in the solution code.
If you know in advance what data you need to store in the array, you can combine array declaration, creation, and initialization in one step using a shortcut syntax you will see demonstrated in the solution code.
Let’s walk through the GradeAnalyzer class and examine the various ways to declare, create, initialize, and access arrays.
First, notice that our class has one instance variable to hold the grades to be analyzed:
Like all other uninitialized Object reference instance variables, the _grades array instance variable is automatically initialized to null.
Before we can start analyzing grades, we have to set the _grades instance variable to reference the grades data we want to analyze.
Once GradeAnalyzer has a collection of grades to analyze, the meanGrade(), minGrade(), and maxGrade() methods can be called to compute their respective statistics.
Together, these three methods demonstrate how to iterate over the elements of an array, how to access elements of an array, and how to determine the number of elements an array can hold.
To determine the number of elements an array can hold, simply access the implicitly defined, final instance variable, length, which is defined for all arrays:
To iterate over the elements of an array, simply use a for loop whose index variable goes through all possible indices of the array.
While iterating over the array, we can access the array element at the current index by using the name of the array variable followed by the current index enclosed in brackets (often called an array subscript):
Alternatively, the enhanced for loop, also known as the foreach loop, could be used to iterate over the array (see recipe 4-7 for more discussion of the foreach loop):
The initGrades1() method declares and creates an array (using new) that can hold five grades, then manually sets the value at each element index to an integer grade value.
The initGrades2() method combines array creation and initialization in one line using the special array initializer syntax:
Note, this syntax can be used only in an array declaration, so the following is not allowed:
Here we are creating and returning an anonymous (unnamed) array:
With this syntax, you use the new keyword with the array element type, but the size of the array is not explicitly specified.
Similar to the array initializer syntax shown in the initGrades2() method, the array size is implied by the number of elements given within the initializer brackets.
After computing the grade statistics for the three sets of grades data, the remainder of the GradeAnalyzer main() method demonstrates various methods that can be used to determine array type information and to convert an array to a printable string.
You see that we first assign the array returned from a call to the getGrades() instance method to an Object variable, testArray:
We can make this assignment because, as stated previously, an array is an Object.
The left bracket says “I am an array type”, and the “I” says “with a component type of integer”
As you have seen, arrays are simple and easy to work with.
There will be times when this simplicity works to your advantage.
In recipe 4-6 we’ll show an alternative to the array type that provides for easy insertion and removal of elements: the ArrayList collection class.
You are a new Java developer and you need to come up to speed quickly on on generics, or you are an experienced Java developer and you want to learn about a new Java 7 feature that will make your generics programming easier.
You’ll likely first encounter generic types when using the interfaces and classes that are part of the Java Collections Framework (http://download.oracle.com/javase/tutorial/collections/)
All collection types are parameterized to allow you to specify, at the time of instantiation, the type of elements the collection can hold.
The example code in this recipe will be less of a “recipe” and more of a demonstration of the need-to-know topics of generics that will get you up to speed quickly.
The examples will demonstrate the use of generics with Java collections versus showing you how to create generic types.
Unless you are developing a library API, you probably won’t be creating your own generic types.
However, if you understand how generics are used with the Collection interfaces and classes, you will have the knowledge you need to create your own generic types.
Note When we talk generally about a collection or a collection type, you can read this as those types that make up the Java Collections Framework.
This includes all the classes and interfaces that descend from the Collection and Map interfaces.
Collection types generally refer to types that descend from the Collection interface.
The first thing to understand and remember about Java generics is that they are strictly a compile-time feature that aids the developer in creating more type-safe code.
All the type information that you specify when you parameterize a generic type gets “erased” by the compiler when the code is compiled down to byte code.
Let’s look at an example of a generic Collection type: the List.
To specify the element type for a List (or any Collection type), simply include the type name in angle brackets when declaring and instantiating objects.
When you do this, you are specifying a “parameterized type”
Now that we’ve parameterized these types to restrict the element type to Integers, the List add(E e) method becomes:
If we try to add anything other than an Integer to aList, the compiler will generate an error:
It’s important to note that it’s the reference type that is checked at compile time, so the following will also result in a compiler error:
This is a compile error because aNum could reference any Number object.
If the compiler were to allow this, we could end up with a set that contains Doubles, Floats, and so on, which would violate the Integer parameter constraint we specified when we created aList.
Of course, a simple type cast could get you around the compiler error, but this would surely cause unintended consequences when casting between incompatible Number objects.
Generics were designed to reduce the amount of explicit type casting you have to do in your code, so if you find yourself using explicit type casting when using methods of parameterized types, this is a clue of potentially dangerous code.
Another thing to watch out for when using generic types is compiler warnings.
They may indicate that you’re doing something that is not recommended and it usually indicates that your code has a potential runtime error looming.
The following code will compile but produce two compiler warnings:
First, we’re creating rawList, which is a raw type, a generic type that isn’t parameterized.
When generics were introduced into the language, the language designers decided that in order to maintain compatibility with pregenerics code, they would need to allow the use of raw types.
However, the use of raw types is strongly discouraged for new (post–Java 5) code, so compilers will generate a raw type warning if you use them.
Next, rawList is assigned to aList, which was created using parameterized types.
Again, this is allowed by the compiler (due to generics type erasure and backward compatibility), but an unchecked conversion warning is generated for the assignment to flag potential runtime type incompatibility.
Later, if you later tried to retrieve Integer elements from aList, you would get a runtime error.
Regarding type compatibility, it doesn’t apply to generic type parameters.
Fortunately, this won’t slip by you if you accidentally write code like this; the compiler will generate an “incompatible types” warning.
So you may be wondering whether there is a way to achieve a variant subtyping relationship similar to what we tried to do in the previous line of code.
The answer is yes, by using a feature of generics called the wildcard.
A wildcard is denoted by use of a question mark (?) within the type parameter angle brackets.
Wildcards are used to declare parameterized types that are either bounded or unbounded.
The following is an example declaration of a bounded parameterized type:
When a wildcard is used with the extends keyword, an upper bound is established for the type parameter.
In this example, ? extends Number means any type that is either a Number or a subtype of a Number.
Therefore, the following would be valid assignments because both Integer and Double are subtypes of Number:
So, cList can hold a reference to any List instance that has an element type that is compatible with Number.
Obviously, this makes it a challenge for the compiler to enforce type safety if it were to allow elements to be added to cList.
Therefore, the compiler does not allow elements (other than a null) to be added to a collection type that is parameterized with ? extends.
However, you are allowed to get an element from the list without any problem:
The only restriction here is that the reference we get from the list has to be treated like a Number.
Remember, cList could be pointing to a list of Integers, a list of Doubles, or list of any other subtype of Number.
A wildcard can also be used with the super keyword.
In this case, a lower bound is established for the type parameter:
In this example, ? super Integer means any type that is either an Integer or any supertype of Integer.
Therefore, the following would be valid assignments because Number and Object are the only supertypes of Integer:
This lower bound now places a restriction on retrieving elements from the list.
Because dListcan hold a reference to any one of the above parameterized types, the compiler would not be able to enforce type safety if an assumption were made about the type of the element being retrieved.
Therefore, the compiler must not allow calls to get()on a collection type that is parameterized with ? super, and the following would result in a compiler error:
However, now we can add elements to the list, but the lower bound, Integer, still applies.
Only Integers can be added because Integer is compatible with Number and Object:
You will see the use of the wildcard with both extends and super throughout the collection types.
Most often, you will see them used in method parameter types, such as the addAll() method, which is defined for all Collections.
Sometimes you will see the collection types using the wildcard (?) alone as a type parameter, which is called an unbounded wildcard.
You probably won’t be (probably shouldn’t be) defining your own parameterized types using an unbounded wildcard.
If you try to do this, you will soon learn there isn’t much you can do with it.
If you understand concrete parameterized types, wildcard parameterized types, and the concept of bounded and unbouned types, as described in this recipe, you have most of what you need to work with the generic collection types, and create your own generic types if you so chose.
Now that we’ve talked a lot about parameterizing types, we’re going to tell you to forget about some of it.
With the Java 7 release, there is a nice little new feature called the diamond (sometimes seen referred to as the diamond operator, although it is not considered to be an operator in Java)
The diamond allows the compiler to infer the type argument(s) from the context of the parameterized type usage.
Notice there is no type argument specified between the angle brackets when instantiating the ArrayList.
The compiler can easily infer the type to be Integer, based on the context of the assignment or initializer.
Integer is the only type that would work in this context.
The diamond can similarly be used in return statements, as well as in method arguments:
Note that using the diamond as shown here is not the same as using a raw type.
The following is not equivalent to the declaration of aMap that uses the diamond; it will result in an “unchecked conversion” warning, and possibly a raw type warning, from the compiler:
The discussion around why this is different than the diamond example is beyond the scope of this recipe.
If you remember to avoid the use of raw types, you shouldn’t need to worry about this.
Use the diamond whenever possible to save yourself some typing, as well as to make your code more robust, readable, and concise.
You need a flexible data structure that can store a variable amount of data and that allows for easy insertion and deletion of data.
The example code for this recipe is the StockScreener class that allows you to screen a list of stocks or a single stock based on a specific screen parameter (P/E, Yield, and Beta) and screen value.
An example screen might be “Tell me which of the stocks in this list has a P/E (price-toearnings ratio) of 15 or less.” Don’t worry if you’re not familiar with these stock market terms.
Whatever you do, don’t use this class to make your stock investment decisions!
The output from running this code will vary because it is randomly assigning a stock’s screen result value.
Here is one sample of output from running the class:
The ArrayList is one of the most often used classes in the Java Collections Framework.
The ArrayList class implements the List interface, which, in turn, implements the Collection interface.
The Collection interface defines the set of common operations for all Collection types, and the List.
If you are new to generics, it is recommended that you read recipe 4-5, which gives a brief summary of generics and their use with collections.
The StockScreener main() method starts by declaring a List of stocks, and specifying with the generic type parameter, that the stocks list elements will be of type String.
The stocks list will hold a variable number of stocks, represented by their stock market symbol (a String):
Note You may find that calling the list’s remove() method while iterating the list seems to work.
The problem is that it’s not guaranteed to work and will produce unexpected results.
Remember to always remove elements through the iterator when iterating over any Collection.
The ArrayList is a very useful data structure that should normally be used in place of the array type.
It provides much more flexibility than a simple array, in that elements can be added and removed dynamically with ease.
While it is true that ArrayList uses an array internally, you benefit from optimized add() and remove() operations that are implemented for you.
Refer to the online Java documentation for further details (http://download.oracle.com/javase/7/docs/api/java/util/ArrayList.html)
You have created a custom collection–based class that wraps (instead of extends) the underlying collection type.
Without exposing the internal implementation details of your class, you would like objects of your class to be iterable, especially with the use of a foreach statement.
Have your class extend the Interable<T> interface, where T is the element type of the collection to be iterated.
Implement the iterator() method to return the Iterator<T> object from this collection.
We would like users of our class to be able to treat StockPortfolio objects as iterable objects using a foreach statement.
The main() method creates a StockPortfolio and then calls the add() method to add a number of Stocks to the portfolio.
A foreach loop is then used to loop over and print all the stocks in the portfolio.
Note The order of the lines in the output may be different when you run the StockPortfolio class in your environment because the underlying implementation uses a HashMap.
A HashMap does not guarantee the order of the elements stored in the map, and this extends to its iterators.
If we wanted our iterator to return elements sorted by the stock symbol, we could use one of the sorted collections, such as TreeMap or TreeSet, instead of HashMap.
The Iterable interface was introduced in Java 5 to support the enhanced for loop (also known as the foreach loop) which was introduced at the same time.
Along with these enhancements to the language, all Collection classes were retrofitted to implement the Iterable interface, thus allowing Collection classes to be iterable using the foreach loop.
The Iterable interface is a generic type defined as follows:
Typically, the Iteratorreturned is the default iterator of the underlying collection, however, it may also return an instance of a custom Iterator.
In the StockPortfolio class, a Map is used to represent thestock portfolio.
The key for each map entry is the stock symbol, and the value associated.
Maps in Java are not iterable; that is, they are not Collection classes, therefore, they do not implement Iterable.
However, both the keys and the values of a map are Collections, and therefore are Iterables.
We want our implementation of the Iterable iterator()method to return an Iterator over the values (Stock references) of the portfolio map; therefore, our Iterable implementation is parameterized by the Stock type:
The Map values() method returns the Collection of map values; in this case, a Collection of Stocks.
Our iterator() method implementation can then simply return the Iterator for this Collection:
With this implementation of Iterable<Stock>, a foreach loop can be used to iterate a StockPortfolio instance and print each Stock:
You will notice that StockPortfolio also contains the add(List<Stock>) method, which allows the portfolio to be populated from a List.
This method also uses a foreach loop to iterate through the input List.
Note that this method is never called in the code; it exists only for illustration purposes.
We have gone to great lengths to not expose the internal implementation details of our class (the portfolio map)
This allows us to change the implementation without affecting StockPortfolio client code.
However, when we implemented Iterable, we effectively exported the underlying portfolio map through the iterator() method.
As was demonstrated in recipe 4-5, an Iterator allows the underlying collection to be modified by calling its remove() method.
As we have seen in this recipe, the Iterable interface allows you to create iterable objects that are compatible with the foreach loop.
This is very useful when you wish to design a custom collection-based class that encapsulates implementation details.
Just keep in mind that in order to enforce the encapsulation and prevent modification of your underlying collection, you should implement one of the solutions mentioned in the preceding note.
You are using one of the Map classes, such as HashMap or TreeMap, and you need to iterate over the keys, values, or both.
You may also want to remove elements from the map while you are iterating over it.
The method you chose should depend on what portions of the map you need to access and whether you need to remove elements from the map while iterating.
The StockPortfolio1 class is a continuation of the StockPorfolio class shown in the previous recipe.
The summary() method uses a foreach loop to iterate over the portfolio map’s Entry set.
The Map entrySet() method returns a Set of Map.Entry objects.
Within the loop, you then have access to the key and value for the current Map.Entry by calling the respective methods, key() and value(), on that entry.
Use this method of iterating when you need to access both the map keys and values while iterating, and you don’t need to remove elements from the map.
The alertList() method uses a foreach loop to iterate over just the values of the portfolio map.
The Map values() method returns a Collection of the map values; in this case, a Collection of Stocks.
Use this method of iterating when you only need access to the map values and you don’t need to remove elements from the list.
Similarly, if you only need access to the map keys (again, without the need to remove elements), you can iterate using the keySet() method:
If you also need to also access the map value while iterating using the key set, avoid the following, as it is very inefficient:
Instead, use the method of iteration shown in the summary() method.
This method iterates over the portfolio map keys using the keySet() iterator, removing the current map entry if it is one of the stocks specified for removal.
Notice that the map element is removed through the iterator’s remove() method.
This is possible because the key set is backed by the map, so changes made through the key set’s iterator are reflected in the map.
You could also iterate over the portfolio map using its values() iterator:
As with the key set, the values collection is backed by the map, so calling remove() through the values iterator will result in removal of the current entry from the portfolio map.
This is the only safe way to remove map elements during iteration.
Otherwise, if you don’t need to remove map elements, prefer the use of a foreach loop and use one of the methods of iteration shown in the alertList() or summary() methods.
On enterprise applications, there is always the need of obtaining and manipulating the I/O terminals.
In today’s operating systems, that usually means file access and network connectivity.
Java has been slow to adopt good file and network framework because when standing true to its roots of write once, read everywhere, a lot of the original file I/O and network connectivity needed to be simple and universal.
If any Java developer wanted to get features like folder monitoring or scalable sockets, she would usually go out and create (or use) native code, but since Java 7, the wait is over!
With Java 7, file and network I/O has evolved into a much better framework for handling files, network scalability, and ease of use.
This is in addition to the already robust library for handling input and output streams, and serializing (and deserializing) object information.
I/O streams are the foundation of most of the Java I/O and include a plethora of ready-made streams for any occasion, but it is very confusing on how to use them if some context is not provided.
A stream (like a river) represents an inflow/outflow of data.
When you type, you create a stream of characters that the system receives (input stream)
When the system produces sounds, it sends them to the speaker (output stream)
The system could be receiving keystrokes and sending sound all day long, and thus the streams can be either processing data or waiting for more data.
When a stream doesn’t receive any data, it waits (nothing else to do, right?)
As soon as data comes in, the stream starts processing this data.
The stream then stops and waits for the next data item to come.
This keeps going until our proverbial river becomes dry (the stream is closed)
Like a river, streams can be connected to each other (this is the decorator pattern)
For the content of this chapter, there are mainly two input streams that we care about.
One of them is the file input stream, and the other is the network socket input stream.
These two streams are a source of data for our I/O programs.
There are also their corresponding output streams: file output stream and the network socket output streams (how creative isn’t it?)
Like a plumber, we can hook them together and create something new.
For example, we could weld together a file input stream to a network output stream to (for example) send the contents of the file through a network socket.
Or we could do the opposite and connect a network input.
In I/O parlance, the input streams are called sources, while the output streams are called sinks.
There are other input and output streams that can be glued together.
The decorator pattern allows you to keep plucking streams together to get many different effects.
The beauty of this design is that you can actually create a stream that will take any input and produce any output, and then can be thrown together with every other stream.
Problem You need to serialize a class (save the contents of the class) so that you can restore it at a later time.
There you will see ObjectOutputStream being used to serialize the settings object in preparation for writing the object to disk:
How It Works Java supports serialization, which is the capability of taking an object and creating a byte representation that can be used to restore the object at a later time.
By using an internal serialization mechanism, most of the setup to serialize objects is taken care of.
Java will transform the properties of an object into a byte stream, which can then be saved to a file or transmitted over the wire.
There are plenty of open source frameworks that offer different trade-offs depending on your need (speed versus size versus ease of use)
For a class to be serializable, it needs to implement the Serializable interface, which is a Marker interface: it doesn’t have any methods, but instead tells the serialization mechanism that you have allowed the ability of your class to be serialized.
While not evident from the onset, serialization exposes all the internal workings of your class (including protected and private members), so if you want to keep secret the authorization code for a nuclear launch, you might want to make the class that contains that information nonserializable.
All primitives―int, long, double, float (plus their wrapper classes)―and the String class are serializable by design.
For example, you can’t serialize any Swing components (like JButton, JSpinner), and you can’t serialize File objects, but you can serialize the Color class (awt.color, to be more precise)
As a design principle you don’t want to serialize your main classes, but instead you want to create classes that contain only the properties that you want to serialize.
It will save a lot of headache in debugging because serialization becomes very pervasive.
If you mark a major class as serializable (implements Serializable), and this class contains many other properties, you need to declare those classes as serializable as well.
If your Java class inherits from another class, the parent class must also be serializable.
In that way, you will find marking classes serializable when they really shouldn’t be.
A possible solution to not declare a property serializable is to declare it as transient.
Transient properties tell the Java compiler that you are not interested in saving/loading the property value, so it will be ignored.
Some properties are good candidates for being transient, like cached calculations, or a date formatter that you always instantiate to the same value.
By the virtue of the Serialization framework, static properties are not serializable; neither are static classes.
The reason is that a static class is supposed to never have any instances at any time.
So if we save and then load the static class at the time, we will have loaded another copy of the static class, throwing the JVM for a loop.
The Java serialization mechanism works behind the scenes to convert and traverse every object within the class that you specify to be serialized.
If you have objects within objects and you crossreference objects, the Serialization framework will resolve it and not store two copies of the object―but only one.
For the curious, if you look at the file generated (even in a text editor), you can see the class name as almost the first part of the file.
Even a perceived slight modification of the class (for example: changing an int to a long property) will generate a new SUID.
A class that has been saved with a prior SUID cannot be deserialized on the new SUID.
You can actually tell the Java class to use a specific SUID.
This will allow you to serialize classes, modify them, and then deserialize the original classes while implementing some backward compatibility.
Renaming or removing fields will generate an exception as the class is being deserialized.
Caution  Due to the nature of serialization, don’t expect constructors to be called.
What this means is that if you have initialization code in constructors that is required for your object to function properly, you may need to refactor them out of the constructor to allow to be executed after construction.
The reason is that in the deserialization process, the deserialized objects are “restored” internally (not created) and don’t invoke constructors.
Problem You want to serialize a class, but want to make the output more efficient, or smaller in size, than that generated by the built-in serialization method.
How It Works The Java Serialization framework does provide the ability for you to specify exactly how to serialize an object.
As such, it requires implementing the Externalizable interface in lieu of the Serializable interface.
By implementing these methods, you are telling the framework how to encode/decode your object.
The writeExternal() method will pass in as a parameter an ObjectOutput object.
This object will then let you write your own encoding for the serialization.
Please note: Java doesn’t have a byte primitive, so an int is used as a parameter, but only the leastsignificant byte will be written.
Please note: Only the two leastsignificant bytes will be written.
The reason you might want to implement the Externalizable interface instead of the Serializable.
Because the Java Serialization framework needs to make sure that every object (and dependent object) is serialized, it will write even objects that have default values or that might be empty and/or null.
Implementing the Externalizable interface also allows you more finer-grained control on how your class is being serialized.
Note You will need an empty (no-arg) constructor for classes that implement the Externalizable interface.
You would like to save and load your objects using XML.
Solution In this example, one uses the XMLEncoder object to encode our own Settings object, which contains program settings information and writes it to the settings.xml file.
The XMLDecoder takes the settings.xml file and read is as a stream, decoding the Settings object.
How It Works The XMLEncoder and XMLDecoder, like the Serialization framework, use reflection to find out what fields they contain, but instead of writing these fields in binary, they are written in XML.
Objects that are to be encoded don’t need to be serializable, but they do need to follow the Java Beans specification.
Java Bean is the name of any object that conforms to the following contract:
Tip  It is a good idea to register an Exception Listener when encoding/decoding.
If an object appears more than once when being persisted in the object graph (for example, an object is inside a Map from the main class, but is also as the DefaultValue property), then the XMLEncoder will only encode it once, and link up a reference by putting a link in the xml.
The recommendation is to not persist your main classes (even though the XMLEncoder is more forgiving), but to create special objects that are simple, hold the basic information, and don’t do a lot by themselves.
Problem You need to open a network connection, and send/receive objects from it.
Also, you have heard that the traditional Java 6 way of doing that doesn’t scale well, it’s a pain, it’s blocking, and it holds kittens hostage.
How It Works At its basic level, sockets require a type, IP address, and port.
While sockets literature has consumed whole books, the main idea is pretty straightforward.
The advantage of the new NIO.2 is that it is asynchronous in nature.
By using asynchronous calls, you can scale your application without creating thousands of threads for each connection.
In our example, we have taken the asynchronous calls and wait for a connection (effectively making it singlethreaded for the sake of the example), but don’t let that stop you for enhancing this example with more asynchronous calls.
Check the recipes on the multithreaded section of this book.
For a client to connect, it requires a socket channel.
Once a socket channel is created, it will need an address to connect to.
The Future object allows a Java program to continue what it is doing and just query the status of the submitted task.
To take the analogy further, instead of waiting at the front door for your mail to arrive, you go do other stuff, and “check” periodically to see whether the mail has arrived.
It also has the get() method, which allows you to actually wait for the task to finish.
In our example, we use the Future.get() to wait for the client connection to be established.
Using the decorator pattern, we decorate the outputStream with our ObjectOutputStream to finally send objects through the socket.
Server socket connections allow more than one connection to happen, thus they are used to monitor or receive connections instead of initiating a connection.
For this reason, the server is usually waiting for a connection asynchronously.
In our example, the server connection simply calls future.get(), which will block (stop the execution of the program) until a connection is accepted.
The server then proceeds to loop and read each object coming from the ObjectInputStream.
If the object received’s toString() method equals “EOF”, the server stops looping, and the connection is closed.
Caution  Using an ObjectOutputStream and ObjectInputStream to send and receive a lot of objects can lead to memory leaks.
ObjectOutputStream keeps a copy of the sent object for efficiency.
If you were to send the same object again, ObjectOutputStream and ObjectInputStream will not send the same object again, but instead send a previously sent Object ID.
This behavior or just sending the Object ID instead of the whole object raises two issues.
The first issue is that objects that are changed in-place (mutable) will not get the change reflected in the receiving client when sent through the wire.
The reason is that because the object was sent once, the ObjectOutputStream believes that the object is already transmitted and will only send the ID, negating any changes to the object that have happened since it was sent.
To avoid this, don’t make changes to objects that were send down the wire.
This rule also applies to subobjects from the object graph.
The second issue is that because ObjectOutputStream keeps a list of sent objects and their Object ID, if you send a lot of objects the dictionary of sent objects to keys grows indefinitely, causing memory starvation on a longrunning program.
Problem You want to get the path where the Java program is running.
How It Works When a Java program starts, the JRE updates the user.dir system property to record from where the JRE was invoked.
The solution example passes the property name “user.dir” to the getProperty method, which returns the value.
Problem You need to copy a file from one folder to another.
Solution From the default FileSystem, you create the “to” and “from” paths where the files/folders exist and then use the Files.copy static method to copy files between the created paths:
How It Works In the new NIO.2 libraries, Java works with an abstraction level that allows for more direct manipulation of file attributes belonging to the underlying operating system.
For example, running this example in Windows will get you a WindowsFileSystem; if you were running this example in Linux, a LinuxFileSystem object would be returned.
AllFileSystems supports basic operations; in addition, each concrete FileSystem provides access to the unique features offered for that operating system.
After getting the default FileSystem object, you can query for file objects.
In the NIO.2 file, folders and links are all called paths.
Once you get a path, you can then perform operations with it.
In this example, Files.copy is called with the source and destination paths.
The different copy options are file-system dependent so make sure that the one that you choose is compatible with the operating system you intend to run the application in.
Problem You need to move a file instead of just copying it around.
Solution As in Solution 5-6, you use the default FileSystem to create the “to” and “from” paths, and invoke the Files.move() static method:
How It Works Same as copying a file, you create the path of source and destination.
After having the source and destination path, Files.move will take care of moving the file for you.
Other methods provided by the Files object are the following:
Delete (path): Deletes a file (or a folder, if it’s empty)
Problem You need to create a directory from your Java application.
By default, the directory created will inherit the default permissions.
If you wanted to specify specific permissions in Linux, you can use the PosixAttributes as an extra parameter in the createDirectory() method.
Solution Using the NIO.2, create a FileVisitor and visit the folder.
How It Works Before NIO.2, trying to traverse a directory tree involved recursion, and depending on the implementation, it could be very brittle.
The calls to get files within a folder were synchronous and required the scanning of the whole directory before returning, generating what appears to be an.
The only thing you provide to the NIO.2 API is a class that tells it what to do when a file/folder is found (SimpleFileVisitor implementation)
Also, because NIO.2 uses a Visitor pattern, it doesn’t need to prescan the whole folder, but instead processes files as they are being iterated over.
When you override this method, you can put the behavior of what do when a file is encountered.
This enum then tells the FileVisitor what action to take:
CONTINUE: Will continue with the traversing of the directory tree.
SKIP_SIBLINGS: Skips the other directories at the same tree level than the current.
The SimpleFileVisitor class, aside from the visitFile() method, also contains the following:
Problem You need to get information about a particular file, such as file size, whether it’s a directory, etc.
Also, you might want to mark a file as Archived in the Windows operating system or grant specific POSIX file permissions in the Linux operating system (refer to Recipe 5-8)
Solution Using Java NIO.2 you can get a lot more information on a file/directory than you could do with the regular NIO.
How It Works Java NIO.2 allows much more flexibility in getting and setting file attributes.
NIO.2 abstracts the different operating system attributes into both a “Common” set of attributes and an “OS Specific” set of attributes.
Also, NIO.2 allows entering the specific attributes of the underlying operating system.
Once you get the view, you can query and change the OS-specific attributes.
Problem You need to keep track when a directory’s content has changed (for example, a file was added, changed, or deleted) and act upon those changes.
Solution By using a WatchService, you can subscribe to be notified on events happening on that folder.
How It Works With NIO.2, you now have a built-in poll mechanism to watch for changes in the FileSystem.
Using a poll mechanism allows you to wait for events and check them at an interval.
Once an event happens, you can process it, and, at the end of processing it, consume it.
A consumed event tells the NIO.2 framework that you are ready to handle a new event.
To start watching a folder, create a WatchService that you can use to poll for changes.
After the WatchService is created, you should register the WatchService with a path.
When the WatchService is registered with the path, you define what kinds of events you want to receive (see Table 5-2)
After registering the WatchService with the path, you can then “poll” the WatchService for events.
If the watchService receives an event, or if the allowed time has passed, then it will continue execution.
Because many events can happen at the same time (say, for example, moving a whole folder or pasting a bunch of files in a folder), the WatchKey might contain more than one event.
Each watchEvent contains information on the actual file or folder that the event refers to (for example, a whole subfolder could have been moved or deleted), and the event type (add, edit, delete)
The only event types that you will be notified of are the eventTypes registered for when creating the watchService.
The event types you can register are listed in Table 5-2
Once an event has been processed, it is important to call the EventKey.reset()
The reset will return a Boolean value determining whether the WatchKey is still valid or not.
A WatchKey becomes invalid if it is cancelled or if its originating watchService is closed.
If the eventKey returns false, you should break from the watch loop.
Problem You need to create some settings for your program that needs to be editable either with text or programmatically.
Solution Using the Properties object, we load properties stored in the properties.conf file.
For certain properties, if not present in the file, we use a default value.
Toward the end of the example, we rewrite the properties.conf file, saving the properties back to the file:
The Properties object can be instantiated either without a file or with a preloaded file.
The files that the Properties object read are in the form of [name]=[value] and are textually represented.
If you need to store values in other formats, you need to write to and read from a String.
If you are expecting the files to be modified outside the program (the user directly opens a text editor and changes the values), be sure to sanitize the inputs; like trimming the values for extra spaces and ignoring case if need be.
The method will return null if the property is not found.
Alternatively, you can invoke the getProperty (String,String) method, on which if the property is not found in the Properties object, it will return the second parameter as its value.
It is a good practice to default values in case the file doesn’t have an entry for a particular key.
If you look at the generated property file, you will notice that the first two lines indicate the description of the file, and the date when it was modified.
These two lines start with #, which in Java property files is the equivalent of a comment.
When starting a line with #, the Properties object will skip that line when processing the file.
Caution  If you allow users to modify your configuration files directly, it is important to have validation in place when retrieving properties from the Properties object.
One of the most common issues encountered in the value of properties is leading and/or trailing spaces.
If specifying a Boolean or integer property, be sure that they can be parsed from a String.
At a minimum, catch an exception when trying to parse to survive an unconventional value (and log the offending value)
Problem You have to uncompress and extract files from a compressed .zip file.
Solution Using the Java.util.zip package, you can open a .zip file and loop through its entries.
If we find a directory entry, we create the directory.
If we find a file entry, we write the decompressed file to the file .unzipped.
How It Works By creating a ZipFile object, you get access to the .zip file information.
Each ZipFile object will contain a collection of entries, and by looping through the entries you can get information on each of the compressed files in the Zip folder.
Each ZipEntry instance will have the compressed and uncompressed size, the name, and the input stream of the uncompressed bytes.
By hooking up to the input stream, we can then read the uncompressed bytes into a byte buffer to then (in our case) write it to a file.
Using the fileStream we ask how many bytes we can read without blocking the process.
Once we read these many bytes, we then in turn write the read bytes directly into the output file.
We keep doing this until we read the number of bytes of the uncompressed file.
Caution  Reading the whole file in memory might not be a good idea if the file is extremely large in size.
If you need to work with a large file, it would be best to first write it uncompressed to disk (as in the example) and then open it and load it in chunks.
If the file that you are working on is not large (you can limit the size by checking the getSize() method) you can probably load it in memory.
Exceptions are a way of describing exceptional circumstances within a program.
They are a way of signaling that something unexpected (exceptional) has happened.
For that reason, exceptions are efficient at interrupting the current flow of the program and signaling that there is something that requires attention.
As such, programs that judiciously use exceptions benefit from a better control flow and become more robust.
Within Java, exceptions are said to be thrown and caught.
Throwing an exception involves telling the code that you have encountered an exception and involves using the throw keyword to signal the JVM to find any code capable of handling this exceptional circumstance within the current stack.
Catching an exception involves telling the compiler which exceptions you can handle, and on which part of the code you want to monitor for these exceptions occurring.
This is denoted by the try/catch Java syntax (described in recipe 6-1)
All exceptions inherit from Throwable, as shown in Figure 6-1
Classes that are inherited from Throwable are allowed to be defined in the catch clause of a try/catch statement.
The Error classes are primarily used by the JVM to denote serious and/or fatal errors.
According to the Java documentation, applications are not expected to catch Error exception as they are considered fatal (think computer being on fire)
The bulk of exceptions within a Java program will be inherited from the Exception class.
An important aspect of exceptions is that within the JVM there are two types of exceptions: checked and unchecked.
In the method signature, one can specify what kind of exceptions the method can throw.
This requires any caller of this method to create a try/catch block that handles the exceptions that the method declared on its signature.
Unchecked exceptions don’t require such as stringent convention and are free to be thrown anywhere without enforcing the implementation of a try/catch block.
Even so, unchecked exceptions (as described on recipe 6-6) are usually discouraged because they can lead to threads unraveling (if nothing catches the exception) and poor visibility of problems.
Be aware that the act of throwing exceptions is expensive (compared with other language construct alternatives), and as such throwing exceptions makes a poor substitute for control flow.
Logging within an application helps understand what is happening without the need for debugging the code.
This is especially true in production environments where there isn’t the opportunity for live debugging.
In that sense, logging collects clues on what is happening (most likely what went wrong) and helps with troubleshooting production problems.
A solid logging framework with a sound logging methodology will save many late-nights at work wondering “what happened?”
Using the built-in try/catch language construct allows you to catch exceptions.
In this example, there is a function that returns true/false if a string is shorter than five characters long.
The try keyword tells the Java program that the enclosing code segment could raise a potential exception.
At the end of the try block we add the catch clauses.
Each catch clause then specifies what exception they are catching for.
If you do not provide a catch clause for a checked exception, the compiler will generate an error.
Two possible solutions are to add a catch clause or to include the exception in the throws clause of the enclosing method.
Any checked exceptions that are thrown but not caught will propagate up the call stack.
If this method doesn’t catch the exception, the thread that executed the code terminates.
If the thread terminating is the only thread in the program, it terminates the execution of the program.
Caution  When throwing an exception, be sure that you really want to throw it.
If the thrown exception is not caught, it will propagate up the call stack; and if there isn’t any catch clause capable of handling the exception, it will cause the running thread to terminate (also known as unraveling)
If your program has only one main thread, an uncaught exception will terminate your program.
You want to write code that executes when control leaves a code segment, no matter whether that control leaves due to an error being thrown or the segment ending normally.
For example, you have acquired a lock and want to be sure that you are releasing it correctly.
You want to release the lock in the event of an error and also in the event of no error.
Use a try/catch/finally block to properly release locks and other resources that you acquire in a code segment.
In the example, the finally keyword specifies a code block that will always execute, regardless of whether an exception was thrown in the try block.
Within the finally block, the lock is released by calling lock.unlock():
Caution  If you need to return a value on a method, be very careful of returning values in the finally block.
A return statement in the finally block will always execute, regardless of any other return statements that might have happened within the try block.
You need to account for an exceptional problem by throwing an exception from within your code.
You don’t want the execution to continue on the current code path.
You want to abort the execution of the current code path by throwing the exception.
Using the throw keyword, one can signal the current thread to look for try/catch blocks (at the current level and up the stack) that can process the thrown exception.
The throw keyword allows you to explicitly generate an exceptional condition.
When the current thread throws an exception, it doesn’t execute anything beyond the throw statement and instead transfers control to the catch clause (if there are any) or terminates the thread.
Caution  When throwing an exception, be sure that you really want to throw it.
If an exception is not caught as it propagates up the stack, it will terminate the thread that is executing (also known as unraveling)
If your program has only one main thread, an uncaught exception will terminate your program.
You want to catch multiple exceptions that might happen within a try block.
By using different catch clauses (ordered from the most specific to the most general), you can catch multiple exceptions:
By using different catch clauses you can adjust what gets executed when a particular exception is thrown.
Sometimes we are just catching all the checked exceptions that can be thrown in a given code and want to handle it the same way (logging them, for example)
Note  If catching an exception in multiple catch blocks (Solution 1), make sure that the catch blocks are defined from the most specific to the most general.
Failure to follow this convention will prevent an exception from being handled by the more-specific blocks.
This is most important when there are catch (Exception e) blocks, which catch almost all exceptions.
When creating a Java thread, sometimes you want to catch not only checked exceptions but also any type of exceptions, at least to properly log them, or to "keep going" and avoid termination of the executing thread.
To that effect, Java allows you to register an ExceptionHandler() either per thread or globally.
This is the last code executed on that thread before it terminates.
Again, in either situation, the thread originating the exception will terminate.
Tip   When dealing with multiple threads, it is always a good practice to explicitly name these threads.
It makes life easier to know that the exception was caused by the DatabaseThread, instead of Thread-## (the default naming pattern of unnamed threads)
You need to make sure that if an exception is thrown, the resources that are being used in the try/catch block are released.
By using the new Java 7 Automatic Resource Management (ARM) feature, you can specify a try-withresources block:
Before Java 7, managing resources was problematic if an exceptional condition happened.
Usually you want to cleanly close/dispose of resources that are acquired within a try/catch block.
If a program doesn’t close/dispose of its resources or does so improperly, the resources could be acquired indefinitely.
Most resources are limited (file handles or database connections) and as such will cause performance degradation (and more exceptions to be thrown)
To avoid that, Java 7 provides a way of automatically releasing resources when an exception occurs within a try/catch block.
By declaring a try-with-resources block, you are guaranteed that if there is an exception thrown within the block, the resource on which the try block was checked will be closed.
Also, third-party implementers can create resources that will work with the try-with-resources statements by implementing the AutoCloseable interface.
The syntax for the try-with-resources block involves the try keyword, followed by an opening parenthesis and then followed by all the resource declarations that you would want to be released in case of an exception, and ending with a closing parenthesis.
Please note that if you try to declare a resource/variable that doesn’t implement the AutoCloseable interface, you will get a compiler error.
After the closing parenthesis, the syntax of the try/catch block is the same as previously used.
The main advantage of the try-with-resources Java 7 feature is that it allows a cleaner release of resources.
Usually when acquiring a resource, there are a lot of interdependencies (creating file handlers, which are wrapped in output streams, which are wrapped in buffered streams)
By contrast, the try-with-resources construct causes the JVM to take care of proper disposal of resources, even in exceptional conditions.
Note  A try-with-resources block will always close the defined resources, even if there were no exceptions thrown.
By extending RuntimeException, you can create exceptions that are not required to be checked, but instead can happen at any time.
By extending Exception, you create a checked exception that needs to be either caught or rethrown up the stack.
Sometimes you want to create your own exceptions, especially when creating an API.
The usual recommendation is to use one of the available Exception classes provided by the JDK.
If there isn’t a JDK exception that fits cleanly, you can always extend Exception or RuntimeException and implement its own family of exceptions.
Depending on the base class, creating an Exception class is fairly straightforward.
Extending RuntimeException allows you to be able to throw the resulting exception any time without requiring anyone to catch it.
This is advantageous in that RuntimeException is a more lax contract to work with, but throwing such an exception can lead to thread termination if there isn’t anyone catching the exception.
Extending Exception instead allows you to clearly force any code that throws the exception to be able to handle it in a catch clause.
The checked exception is then forced by contract to implement a catch handler, potentially avoiding a thread termination.
In practice, we discourage extending RuntimeException because it can lead to poor exception handling.
Our rule of thumb is that if it’s possible to recover from an exception, you should create the associated exception class by extending Exception.
Sometimes you have a multicatch statement, but want to re-throw the original exception with the exception type that was caught.
Before Java 7, re-throwing the same exception involves a series of catch statements for each specific exception and then a throw on that exception, making the code verbose.
You need to rethrow the same exception type as you caught.
Now you can just throw the exception from a catch block, and it will rethrow it on the same type as it was caught:
Starting with Java 7, you can simply throw the exception that you’ve caught, and the JVM will bubble the exception to the appropriate type.
Note that if you are throwing a checked exception, then these have to be also defined in the Method declaration.
You like to start logging events, debug messages, error conditions, and so on in your application.
Use SLF4J, along with the Java Logging API to implement your logging solution.
The following example first creates a logger object with the name of recipeLogger.
The example then proceeds to log an informational message, a warning message, and an error message:
Then, within the start method of the recipe, the code acquires a logger object named recipeLogger.
More information on the actual logging parameters can be found in recipe 6-10
This is the main .jar file that contains the SLF4J API (on which your program can call and log information)
This .jar represents the native Java Logging Framework (known as jdk.1.4 logging)
The logging level can then be used to filter which messages are actually logged.
The ability to filter messages by log level is useful because there might be a lot of informational or debugging information being logged.
If there is the need to troubleshoot an application, the logging level can be changed, and more information is visible in the logs without changing any code.
The ability to filter messages through their level is called setting the log level.
Each logging framework reference has its own configuration file that sets the log level (among other things, such as the logging file name and logging-file configurations)
Error Use for exceptions, actual errors, and things that you really need to know.
Note When setting the log level, loggers will log at that level and below.
So if a logging configuration sets the log level to info, messages at the Info, Warn, Error, and Fatal levels will be logged.
You have started to log information, but the information logged keeps growing out of control.
You would like to only keep the last 250KB worth of log entries in your log files.
In this recipe, we get the logger named recipeLogger and log many times into this logger.
The output will produce rolled log files with the most recent logged information in the important Log0.log file.
FileHandler is specified in the recipe, which logs messages to files.
Other possible handlers are the ConsoleHandler (logs to the system.output device), SocketHandler (logs to a socket), and MemoryHandler (keeps logs in a circular buffer in memory)
There is also the possibility of specifying your own handler implementation by creating a class that extends the Handler abstract class.
Within a logging framework there is the concept of separate logger objects.
A logger can carry different configurations (for example, different logging levels), and can be identified in the log file.
The formatter indicates how the log information will be written to disk.
The simpleFormatter writes the information as plain text, with a line indicating the date and time, a line with the logging level, and the message to be logged.
The other default choice for the formatter is the XMLFormatter, which will create XML markup containing the date, time, logger name, level, thread, and message information for each log event.
You can create your own formatters by extending the Formatter abstract class.
The count defines the maximum index of log files to keep (in this recipe’s case: 4)
The logging level can be changed from the logging configuration file.
From the previous recipes you know how to catch exceptions and how to log information.
You want to be able to record exceptions in your log file.
By using SLF4J and try/catch blocks you can log exceptions to the error log.
When logging an exception, it is good to include the stack trace showing where the exception was thrown.
The applicationLogger object includes a method that takes a String and a Throwable as parameters.
When you invoke that function, the logger will record the stack trace of the Throwable object in the log file.
Note If an exception is thrown repeatedly, the JVM tends to stop populating the stack trace in the Exception object.
This is done for performance reasons because retrieving the same stack trace becomes expensive.
If this happens, you will see an exception with no stack trace being logged.
When that happens, check the log’s previous entries and see whether the same exception was thrown.
If the same exception has been thrown previously, the full stack trace will be present on the first logged instance of the exception.
Programming languages have changed a great deal since the first days of application development.
Back in the day, procedural languages were state-of-the-art; as a matter of fact, there are still thousands of COBOL applications in use today.
As time went on, coding became more efficient; and reuse, encapsulation, abstraction, and other object-oriented characteristics became fundamental keys to application development.
As languages evolved, they began to incorporate the idea of using objects within programs.
Object-oriented programs consist of many different pieces of code that all work together in unison.
Rather than having a long list of statements and commands, an object-oriented philosophy is to break functionality up into different objects.
Programming techniques such as using methods to encapsulate functionality and copying the functionality of another class began to catch on as people noticed that object orientation equated to productivity.
In this chapter, we will touch upon some of the key object-oriented features of the Java language.
From the basic recipes such as learning about access modifiers, to the advanced recipes such as inner classes, this chapter contains recipes that will help you understand Java’s object-oriented methodologies.
You want to create some class members that are not accessible from any other class.
Create private instance members rather than making them available to other classes (public or protected)
For instance, suppose you are creating an application that will be used to manage a team of players for a sport.
You create a class named Player that will be used to represent a player on the team.
You do not want the fields for that class to be accessible from any other class.
To designate a class member as private, prefix its declaration or signature using the private keyword.
The private access modifier is used to hide members of a class so that outside classes cannot access them.
Any members of a class that are marked as private will be available only to other members of the same class.
Any outside class will not be able to access fields or methods designated as private, and an IDE that uses code completion will not be able to see them.
As mentioned in the solution to this recipe, there are three different access modifiers that can be used when declaring members of a class.
Members that are declared as public are available for any other class.
Those that are declared as protected are available for any other class within the same package.
It is best to declare public or protected only those class members that need to be directly accessed from another class.
Hiding members of a class using the private access modifier helps to enforce better object orientation.
You would like to create private instance members so that outside classes cannot access them directly.
However, you would also like to make those private members accessible via a controlled method.
Encapsulate the private fields by making getters and setters to access them.
The following code demonstrates the declaration of a private field, followed by accessor and mutator methods that can be used to obtain or set the value of that field from an outside class:
The getFirstName() method can be used by an outside class to obtain the value of the firstName field.
Often when fields are marked as private within a class, they still need to be made accessible to outside classes.
Why not just work with the fields directly and make them public then? It is not good programming practice to work directly with fields of other classes because by using accessors and mutators, access can be granted in a controlled fashion.
By not coding directly against members of another class, you also decouple the code, which helps to ensure that if one object changes, others that depend upon it are not adversely affected.
As you can see from the example in the solution to this recipe, hiding fields and working against public methods to access those fields is fairly easy.
Simply create two methods; one is used to obtain the value of the private field, the “getter” or accessor method.
And the other is used to set the value of the private field, the “setter” or mutator method.
In the solution to this recipe, the getter is used to return the unaltered value that is contained within the private field.
Similarly, the setter is used to set the value of the private field by accepting an argument that is of the same data type as the private field and then setting the value of the private field to the value of the argument.
The class that is using the getters or setters for access to the fields does not know any details behind the methods.
Furthermore, the details of these methods can be changed without altering any code that accesses them.
Note Using getters and setters does not completely decouple code.
In fact, many people argue that using getters and setters is not a good programming practice because of this reason.
Objects that use the accessor methods still need to know the type of the instance field they are working against.
That being said, getters and setters are a standard technique for providing external access to private instance fields of an object.
To make the use of accessor methods in a more object-oriented manner, declare them within interfaces and code against the interface rather than the object itself.
You would like to create a class for which only one instance can exist in the entire application, so that all application users interact with the same instance of that class.
A class implementing the Singleton pattern allows for only one instance of the class and provides a single point of access to the instance.
Suppose that you wanted to create a statistics class that would be used for calculating the statistics for each team and player within an organized sport.
It does not make sense to have multiple instances of this class within the application, so you want to create the statistics class as a Singleton in order to prevent multiple instances.
If another class attempts to create an instance of this class, it will use the getInstance() accessor method to obtain the Singleton instance.
Create an enum and declare a single element named INSTANCE within it.
Then declare other fields within the enum that you can use to store the values that are required for use by your application.
The following enum represents a singleton that will provide the same abilities as that of solution 1:
Note  There is a test class within the recipe7_03 package that you can use to work with the enum Singleton solution.
The Singleton pattern is used to create classes that cannot be instantiated by any other class.
This can be useful in cases in which you only want one instance of a class to be used for the entire application.
The Singleton pattern can be applied to a class by following three steps.
First, make the constructor of the class private so that no outside class can instantiate it.
Next, define a private static final field that will represent an instance of the class.
Create an instance of the class and assign it to the field.
In the solution to this recipe, the class name is Statistics, and the field definition is as follows:
Last, implement an accessor method called getInstance() that simply returns the instance field.
To use the Singleton from another class, call the Singleton’s getInstance() method.
The following code shows an example of another class obtaining an instance to the Statistics Singleton that was defined in solution 1 to this recipe.
Any class that calls the getInstance() method of the class will obtain the same instance.
Therefore, the fields contained within the Singleton have the same value for every call to getInstance() within the entire application.
Solution 2 demonstrates a different way to create a Singleton, which is to use a Java enum rather than a class.
Using this approach can be beneficial because an enum provides serialization, prohibits multiple instantiation, and allows one to work with code more concisely.
In order to implement the enum Singleton, create an enum and declare an INSTANCE element.
This is a static constant that will return an instance of the enum to classes that reference it.
You can then add elements to the enum that can be used by other classes within the application to store values.
As with any programming solution, there is more than one way to skin a cat.
Some believe that the standard Singleton pattern demonstrated in solution 1 is not the most desirable solution.
Others do not like the enum solution for different reasons.
Both of them will work, although you may find that one works better than the other in certain circumstances.
In one of your applications, you would like to provide the ability to generate instances of an object on the fly.
Each instance of the object should be ready to use, and the creator should not need to know about the details of the object creation.
Make use of the factory method pattern to instantiate instances of the class while abstracting the creation process from the creator.
Creating a factory will enable new instances of a class to be returned upon invocation.
The subclass of Player that is returned depends upon what String value is passed to the createPlayer method.
If a class wants to use the factory, it simply calls the static createPlayer method, passing a String value representing a new instance of Player.
The following code represents one of the Player subclasses; the others are very similar:
Each of the Player subclasses is very similar to the Goalie class.
The most important code to note is the factory method, createPlayer, which can be used to create new instances of the Player class.
Usually they are used to abstract the actual creation of an object from its creators.
This can come in very handy for cases where the creator does not need to know about the actual implementation details of generating the new object.
The factory pattern can also be useful when controlled access to the creation of an object is required.
In order to implement a factory, create a class that contains at least one method that is used for returning a newly created object.
This method doesn’t do anything special behind the scenes; it simply instantiates a new Player instance depending upon the String value that is passed to the method.
Another object that has access to the PlayerFactory class can use createPlayer to return new Player objects without knowing how the object is created.
While this does not hide much in the case of the createPlayer method, the PlayerFactory abstracts the details of which class is being instantiated so that the developer only has to worry about obtaining a new Player object.
The factory pattern is an effective way for controlling how objects are created and making it easier to create objects of a certain type.
Imagine if a constructor for an object took more than just a handful of arguments; creating new objects that require more than just a couple of arguments can become a hassle.
Generating a factory to create those objects so that you do not have to hard-code all the arguments with each instantiation can make you much more productive!
You would like to generate an object that could be used to represent something within your application.
For instance, suppose that you are creating an application that will be used for generating statistics and league information for different sports teams.
Create a JavaBean that can be used to represent the object that you want to create.
JavaBean objects provide the capability for object fields to be declared as private, and they also allow the attributes to be read and updated so that an object can be passed around and used within an application.
This recipe demonstrates the creation of a JavaBean named Team.
The Team object contains a few different fields that can be used to hold information:
As you can see, the object in this solution contains three fields, and each of those fields is declared as private.
However, each field has two accessor methods getter and setter that allow for the fields to be indirectly accessible.
The JavaBean is an object that is used to hold information so that it can be passed around and used within an application.
One of the most important aspects of a JavaBean is that its fields are declared as private.
Instead, each field should be encapsulated by methods defined in order to make them accessible to other classes.
Methods used for accessing the field data should be named using a prefix of get, followed by the field name.
Methods used for setting the field data should be named using a prefix of set, followed by the field name.
For instance, in the solution to this recipe, the Team object contains a field with the name of players.
In order to access that field, a method should be declared that is named getPlayers.
That method should return the data that is contained within the players field.
Likewise, to populate the players field, a method should be declared that is named setPlayers.
JavaBeans can be used to populate lists of data, written to a database record, or used for a myriad of other functions.
It also helps to increase the likelihood of future code enhancements because very little code implementation is required.
Another benefit of using JavaBeans is that most major IDEs will auto-complete the encapsulation of the fields for you.
You would like to generate an abstract type that can be used as a common template to expose the methods and constants that a class implements.
Generate a Java interface to declare each of the constant fields and methods that a class must implement.
Such an interface can then be implemented by a class, and used to represent an object type.
The following code is a simple interface that is used to declare the methods that must be implemented by a Team object:
It is also possible to include static final variable declarations in an interface.
A Java interface is a construct that is used to define the structures, be it variables or methods, that a class must implement.
Any class that implements an interface must include implementations for the methods that are declared within the interface unless it is an abstract class (see recipe 7-11 for more details)
An interface does not include any method implementations; rather, it only includes method signatures.
Interfaces can include variables that are implicitly static and final.
In the solution to this recipe, the interface does not include any constant variable declarations.
All the method signatures have no access modifier specified because all declarations within an interface are implicitly public.
Interfaces are used to expose a set of functionality; therefore, all methods exposed within an interface must be implicitly public.
As mentioned previously, only method signatures are present within an interface no implementations.
Any class that implements an interface will provide the implementation for the methods declared in the interface, with the exception of an abstract class, in which case it may leave the implementation for one of its subclasses.
While the Java language does not allow multiple inheritance, a Java class can implement multiple interfaces, allowing for a more controlled form of multiple inheritance.
The following code demonstrates a class implementing an interface: the Team object declaration implements the TeamType interface.
To learn more about using classes to implement interfaces, see recipe 7-8
Interfaces can be used to declare a type for an object.
Any object that is declared to have an interface type must adhere to all the implementations declared in the interface.
For instance, the following variable declaration defines an object that contains all the properties that are declared within the TeamType interface:
Interfaces can also implement other interfaces (thus the same type of theory that is provided by multiple inheritance)
However, because no method implementation is present in an interface, it is much safer to implement multiple interfaces in a Java class than it is to extend multiple classes in C++
Interfaces are some of the single most important pieces of the Java language.
Although it is possible to create entire applications without using interfaces, they help to promote object orientation and hide class implementation from other classes.
Your application requires the ability to construct instances of the same object, but each object instance needs to contain different values; thereby creating different types of the same object.
Make use of the builder pattern in order to build different types of the same object using a step-by-step procedure.
For instance, suppose that you are interested in creating the different teams for a sports league.
Each of the teams need to contain the same attributes, but the values for those attributes vary by team.
So you create many objects of the same type, but each of the objects is unique.
The following code demonstrates the builder pattern, which can be used to create the teams that are required.
First, you need to define a set of attributes that each team needs to contain.
To do this, a Java interface should be created, containing the different attributes that need to be applied to each team object.
This class needs to implement the TeamType interface that was just created so that it will adhere to the format that is required to build a team:
Now that the Team class has been defined, a builder needs to be created.
The purpose of the builder object is to allow for a step-by-step creation of a team object.
In order to abstract the details of building an object, a builder class interface should be created.
The interface should define any of the methods that would be used to build the object as well as a method that will return a fully built object.
In this case, the interface will define each of the methods needed to build a new Team object, and then the builder implementation will implement this interface.
Although the following code would not create a custom player list, it contains all the features required to implement the builder pattern.
The details of creating a more customized player list can be worked out later, probably by allowing the user to create players via a keyboard entry.
Furthermore, the TeamBuilder interface could be used to implement different types of sport teams.
Last, use the builder by calling upon the methods defined in its interface to create teams.
The following code demonstrates how this builder could be used to create one team.
You can use the Roster class within the sources for this recipe to test this code:
Although this demonstration of the builder pattern is relatively short, you can see how it would be valuable by making objects easier to build.
You do not need to know the implementation details of the methods within the builder; you only need to call upon the methods.
The builder pattern provides a way to generate new instances of an object in a procedural fashion.
It abstracts away the details of object creation, so the creator does not need to do any specific work in order to generate new instances.
By breaking the work down into a series of steps, the builder pattern allows objects to implement its builder methods in different ways.
Because the object creator only has access to the builder methods, it makes creation of different types of objects much easier.
There are a few classes and interfaces that are necessary for using the builder pattern.
First, you need to define a class and its different attributes.
As the solution to this recipe demonstrates, the class may follow the JavaBean pattern (see recipe 7-5 for more details)
By creating a JavaBean, you will be able to populate the object by using its setters and getters.
Next, you should create an interface that can be used for accessing the setters of the object that you created.
Each of the setter methods should be defined in the interface, and then the object itself should implement that interface.
As seen in the solution, the Team object contains the following setters, and each of them is defined in the TeamType interface:
In real life, a team will probably contain more attributes.
For instance, you’d probably want to set up a mascot and a home stadium name and address.
The code in this example can be thought of as abbreviated because it demonstrates the creation of a generic “team object” rather than show you all the code for creating a team that is true to life.
After the object and its interface have been coded, the actual builder needs to be created.
The builder consists of an interface and its implementation class.
To start, you must define the methods that you want to have other classes call upon when building your object.
When a class wants to build one of these objects later, it will only need to call upon these defined methods in order to do it.
The implementation class will implement the methods defined within the builder interface, hiding all the details of those implementations from the object creator.
In the solution to this recipe, the builder class, Hockey TeamBuilder, implements the TeamBuilder interface.
When a class wants to create a new Team object then it simply instantiates a new builder class.
To populate the newly created class object, the builder methods are called upon it.
Using this technique provides a step-by-step creation for an object.
The implementation details for building that object are hidden from the object creator.
It would be easy enough for a different builder implementation to use the same TeamBuilder interface for building team objects for different types.
For instance, a builder implementation could be written for generating team objects for hockey, and another one could be defined for generating team objects for baseball.
However, both of them could implement the same interface; TeamBuilder, and the creator could simply call upon the builder methods without caring about the details.
You have created a class that implements an interface, or class type.
You would like to interact with the methods of that class by working with the interface rather than working directly with the class.
Declare a variable of the same type as an interface.
You can then assign classes that implement the interface to that variable and call upon the methods declared in the interface to perform work.
In the following example, a variable is declared to be of type TeamType.
Looking back at recipe 7-7, you can see that the class Team implements the TeamType interface.
The variable that is created in the following example holds a reference to a new Team object.
Because the Team class implements the TeamType interface, the methods that are exposed in the interface can be used:
Two of the most important use cases for interfaces are conformity and abstraction.
Interfaces define a model, and any class that implements the interface must conform to that model.
Therefore, if there is a variable defined within the interface, it will automatically be available for use in the class.
If there is a method defined within the interface, then the class must implement that method.
Interfaces provide a nice way to allow classes to conform to a standard.
Interfaces hide unnecessary information from any class that does not need to see it.
Any method that is defined within the interface is made public and accessible to any class.
As demonstrated in the solution to this recipe, an object was created and declared to be the type of an interface.
The interface in the example, TeamType, only includes a small subset of methods that are available within the Team object.
Therefore, the only methods that are accessible to any class working against an object that has been declared to be of TeamType are the ones that are defined within the interface.
The class using this interface type cannot see any of the other methods or constants, nor does it need to.
Interfaces are a great way for hiding logic that does not need to be used by other classes.
Another great side effect: A class that implements an interface can be changed and recompiled without affecting code that works against the interface.
However, if an interface is changed, there could be an effect on any classes that implement it.
Therefore, if the getFullName() method implementation changes, any class that is coded against the TeamType interface will not be affected because the interface is unchanged.
The implementation will change behind the scenes, and any class working against the interface will just begin to use the new implementation without needing to know.
They hide away implementation details of methods that are declared in an interface from any class that may call that method using the interface.
As mentioned in the previous paragraph, if a class is calling the getFullName() method against the TeamType interface, it does not need to know the implementation details of that method as long as the result is returned as expected.
The Enterprise JavaBean (EJB) 3.0 model used interfaces for interacting with methods that performed database work.
This model worked very well for hiding the details and logic that were not essential for use from other classes.
Other frameworks use similar models, exposing functionality through Java interfaces.
Interface use has proven to be a smart way to code software because it promotes reusability, flexibility, and security.
You would like to enable a class to be cloned by another class.
Implement the Cloneable interface within the class that you want to clone; then call that object’s clone method to make a copy of it.
The following code demonstrates how to make the Team class cloneable:
Next, to make a deep copy of a Team object, the clone() method needs to be called against that object.
To make a shallow copy of the object, the shallowCopyClone() method must be called.
Although this code does not do very much, it demonstrates how to make a clone of an object.
There are two different strategies that can be used to copy an object: shallow and deep copies.
A shallow copy can be made that would copy the object without any of its contents or data.
Rather, all the variables are passed by reference into the copied object.
After a shallow copy of an object has been created, the objects within both the original object and its copy refer to the same data and memory.
Thus, modifying the original object’s contents will also modify the copied object.
By default, calling the super.clone() method against an object performs a shallow copy.
The shallowCopyClone() method in the solution to this recipe demonstrates this technique.
The second type of copy that can be made is known as a deep copy, which copies the object including all the contents.
Therefore, each object refers to a different space in memory, and modifying one object will not affect the other.
In the solution to this recipe, the difference between a deep and a shallow copy is demonstrated.
This is an example of a shallow copy of an object.
In order to make an exact copy of an object (deep copy), you must serialize the object.
In order to make an object cloneable, it must implement the Cloneable interface and override the default clone() method.
You can make a deep copy of an object by serializing it through a series of steps, such as writing the object to an output stream and then reading it back via an input stream.
The steps shown in the clone() method of the solution to this recipe do just that.
Once that has occurred, the object has been serialized, which creates the deep copy.
The clone() method in the solution to this recipe has been overridden so that it creates a deep copy.
Once these steps have been followed and an object implements Cloneable as well as overrides the default Object clone() method, it is possible to clone the object.
In order to make a deep copy of an object, simply call that object’s overridden clone() method.
Cloning objects is not very difficult, but a good understanding of the differences that can vary with object copies is important.
Your application requires the capability to compare two or more objects to see whether they are the same.
To determine whether the two object references point to the same object, make use of the == and != operators.
The following solution demonstrates the comparison of two object references to determine whether they both refer to the same object.
These object references do NOT refer to the same object.
To determine whether the two objects contain the same values, use the equals() method.
The object being compared must implement equals() and hashCode() in order for this solution to work properly.
Following is the code for the Team class that overrides these two methods:
The following solution demonstrates the comparison of two objects that contain the same values.
The comparison operator (==) can be used to determine the equality of two objects.
This equality does not pertain to the object values, but rather to the object references.
Often an application is more concerned with the values of objects; in such cases, the equals() method is the preferred choice because it compares the values contained within the objects rather than the object references.
The comparison operator takes a look at the object reference and it determines whether it points to the same object as the object reference that it is being compared against.
If the two objects are equal to each other, a Boolean true result will be returned; otherwise, a Boolean false result will be returned.
The equals() method can be used to test whether two objects contain the same values.
In order to use the equals() method for comparison, the object that is being compared should override the Object class equals()and hashCode() methods.
The equals() method should implement a comparison against the values contained within the object that would yield a true comparison result.
The following code is an example of an overridden equals() method that has been placed into the Team object:
As you can see, the overridden equals() method first checks to see whether the object that is passed as an argument is referencing the same object as the one that it is being compared against.
If both objects are not referencing the same object in memory, the equals() method checks to see whether the fields are equal to each other.
In this case, any two Team objects that contain the same values within the name and city fields would be considered equal.
Once the equals() method has been overridden, the comparison of the two objects can be performed, as demonstrated in solution 2 to this recipe.
The hashCode() method returns an int value that must consistently return the same integer.
There are many ways in which to calculate the hashCode of an object.
Perform a web search on the topic and you will find various techniques.
One of the most basic ways to implement the hashCode() method is to concatenate all the object’s variables in String format and then return the resulting String’s hashCode()
It is a good idea to cache the value of the hashCode for later use because the initial calculation may take some time.
Comparing Java objects can become confusing, considering that there are multiple ways to compare objects.
If the comparison that you want to perform is against the object identity, use the comparison (==) operator.
However, if you want to compare the values within the objects, or the state of the objects, then the equals() method is the way to go.
One of your applications contains a class that you would like to use as a base for another class.
You want your new class to contain the same functionality of this base class, but also include additional functionality.
Extend the functionality of the base class by using the extends keyword followed by the name of the class that you would like to extend.
The first class, named HockeyStick, represents a hockey stick object.
It will be extended by the second class named WoodenStick.
By doing so, the WoodenStick class will inherit all the properties and functionality that is contained within HockeyStick, with the exception of private variables and those that have the default access level.
First, the HockeyStick class contains the basic properties of a standard hockey stick:
Next, we will look at the subclass of HockeyStick: a class named WoodenStick.
Object inheritance is a fundamental technique in any object-oriented language.
Inheriting from a base class adds value because it allows code to become reusable in multiple places.
If a change is made in the base class, it will automatically be inherited in the child.
On the other hand, if you had duplicate functionality scattered throughout your application, one minor change could mean that you would have to change code in many places.
Object inheritance also makes it easy to designate a base class to one or more subclasses so that each class can contain similar fields and functionality.
The Java language only allows a class to extend one other class.
This differs in concept from other languages such as C++; which contain multiple inheritance.
Although some look at single class inheritance as a hindrance to the language, it was designed that way to add safety and ease of use to the language.
You would like to define a template that can be used to generate objects containing similar functionality.
Define an abstract class that contains fields and functionality that can be used in other classes.
The abstract class can also include unimplemented methods, called abstract methods, which will need to be implemented by a subclass of the abstract class.
The following example demonstrates the concept of an abstract class.
The abstract class represents a team schedule, and it includes some basic field declarations and functionality that every team’s schedule will need to use.
The Schedule class is then extended by the TeamSchedule class, which will be used to implement specific functionality for each team.
First, let’s take a look at the abstract Schedule class:
Next, the TeamSchedule extends the functionality of the abstract class.
As you can see, the TeamSchedule class can use all the fields and methods that are contained within the abstract Schedule class.
It also implements the abstract method that is contained within the Schedule class.
By the way, do not attempt to figure out what exactly these classes will do in the end because they are provided for this basic example only.
I am not a professional sports schedule implementer, nor do I claim to be; these are just a few fields and methods that came to mind when thinking about what it may take to create a team’s schedule.
Abstract classes are labeled as such, and they contain field declarations and methods that can be used within subclasses.
What makes them different from a regular class? Abstract classes can contain abstract methods, which are method declarations with no implementation.
They can contain fields and completely implemented methods as well.
Abstract classes cannot be instantiated; other classes can only extend them.
When a class extends an abstract class, it gains all the fields and functionality of the abstract class.
However, any abstract methods that are declared within the abstract class must be implemented by the subclass.
You may wonder why the abstract class wouldn’t just contain the implementation of the method so that it was available for all its subclasses to use.
If you think about the concept, it makes perfect sense.
One type of object may perform a task differently from another.
Using an abstract method forces the class that is extending the abstract class to implement it, but it allows the ability to customize how it is implemented.
One of your classes requires the use of another class’s functionality.
Furthermore, no other class requires the use of that same functionality.
Rather than creating a separate class that includes this additional functionality, you’d like to generate an implementation that can only be used by the class that needs it.
Create an inner class within the class that requires its functionality.
The result of running this code is a listing of the players on the team.
Sometimes it is important to encapsulate functionality within a single class.
Other times it does not make sense to include a separate class for functionality that is only used within one other class.
Imagine that you are developing a GUI and you need to use a class to support functionality for one button.
If there is no reusable code within that button class, it does not make sense to create a separate class and expose that functionality for other classes to use.
Instead, it makes sense to encapsulate that class inside of the class that needs the functionality.
This philosophy is one use case for inner classes (also known as nested classes)
An inner class is a class that is contained within another class.
The inner class can be made public, private, or protected just like any other class.
It can contain the same functionality as a normal class; the only difference is that the inner class is contained within an enclosing class, otherwise referred to as an outer class.
The Player class is a JavaBean class that represents a Player object.
As you can see, the Player object has the capability to inherit functionality from its containing class, including its private fields.
This is because inner classes contain an implicit reference to the outer class.
It can also be accessed by the containing TeamInner class, as demonstrated within the constructPlayer() method:
Outer classes can instantiate an inner class as many times as needed.
In the example, the constructPlayer() method could be called any number of times, instantiating a new instance of the inner class.
However, when the outer class is instantiated, no instances of the inner class are instantiated.
Inner classes can reference outer class methods by referring to the outer class and then referring to the method that it wants to call.
The following line of code demonstrates such a reference using the same objects that are represented in the solution to this recipe.
Suppose that the Player class needed to obtain the player list from the outer class; you would write something similar to the following:
Although not very often used, classes other than the outside class can obtain access to a public inner class by using the following syntax:
Furthermore, they allow inheritance of private fields, which is not possible using a standard class.
Concurrency is one of the toughest topics to handle in modern computer programming; understanding concurrency requires the capacity of thinking abstractly, and debugging concurrent problems is like trying to pilot an airplane by dead reckoning.
Even so, with today’s Java 7, it has become easier (and more accessible) to write bug-free concurrent code.
Let’s start with definitions; concurrency is the ability of a program to execute different (or the same) instructions at the same time.
A program that is said to be concurrent has the ability to be split up and run on multiple cpus.
By making concurrent programs, you take advantage of today’s multicore CPUs.
You can even see benefit on single-core CPUs that are I/O intensive.
In this chapter, we present the most common need for concurrency tasks—from running a background task to splitting a computation into work units.
You have a task that needs to be run outside of your main thread.
The Thread class allows executing code in a new thread (path of execution), distinct from the current thread.
The Thread constructor requires as a parameter a class that implements the Runnable interface.
The Runnable interface requires the implementation of only one method: public void run()
That method will in turn create the new thread and invoke the run() method of the Runnable.
Within the JVM are two types of threads: User and Daemon.
User threads keep executing until their run() method finishes, whereas Daemon threads can be terminated if the application needs to exit.
An application exits if there are only Daemon threads running in the JVM.
When you start to create multithreaded application, you must be aware of these differences and when to use each type of thread.
Usually, Daemon threads will have a Runnable interface that doesn’t finish; for example a while (true) loop.
This allows these threads to periodically check or perform a certain condition through the life of the program and be discarded when the program is done executing.
In contrast, User threads, while alive, will execute and prevent the program from terminating.
If you happen to have a program that is not closing and/or exiting when expected, you might want to check the thread types that are actively running (See recipe 9-8 for getting a Thread dump)
By default, Thread instances are created as User thread types.
Caution  This recipe shows the simplest way to create and execute a new thread.
The new thread created is a User thread, which means that the application will not exit until both the main thread and the background thread are done executing.
You need to update a Map object from multiple threads, and you want to make sure that the update doesn’t break the contents of the Map object and that the Map object is always in a consistent state.
You also want to traverse (look at) the content of the Map object while other threads are updating the Map object.
Each thread then tries to modify the Map at the same time.
The main thread then waits for a second, and proceeds to iterate through the Map (even when the other threads are still modifying the Map):
ConcurrentHashMap allows for multiple threads to modify the table concurrently and safely.
In our example, we have 1,000 threads over a second modifying the Map.
Note ConcurrentMap iterators, while thread safe, don’t guarantee that you will see entries added/updated after thre iterator was created.
You need to put a key/value pair in a Map only if the key is not present, and the Map is being constantly updated by other threads.
You need to check for the key’s presence first, and you need assurance that some other thread doesn’t insert the same key after you check and before you insert yourself.
For example, the following code uses the method to check and insert in a single step, thus avoiding the concurrency problem:
Updating a Map concurrently is hard because it involves two operations: a check-then-act type of operation.
First, the Map has to be checked to see whether an entry already exists in it.
If the entry doesn’t exist, you can put the key and the value into the Map.
On the other hand, if the key exists, the value for the key is retrieved.
To do so, we use the ConcurrentMap’s putIfAbsent atomic operation.
This ensures that either the key was present and the value is not overwritten, or the key was not present and the value is set.
For the JDK implementations of ConcurrentMap, the putIfAbsent() method will return null if there was no value for the key or return the current value if the key has a value.
By asserting that the putIfAbsent() method returns null, you are assured that the operation was successful and that a new entry in the map has been created.
There are cases when putIfAbsent() might not be efficient to execute.
For example, if the result is a large database query, executing the database query all the time and then invoking putIfAbsent() will not be efficient.
In this kind of scenario, you could first call the map’s containsKey() method to ensure that the key is not present.
If it’s not present then call the putIfAbsent() with the expensive database query.
There might be a chance that the putIfAbsent() didn’t put the entry, but this type of check reduces the number of potentially expensive value creation.
In this code, the first operation is to check whether the key is already in the map.
If the key is not present, you can proceed to execute the putIfAbsent() operation.
If you are accessing the values of the map from different threads, you should make sure that the values are threadsafe.
This is most evident when using collections as values because they then could be used from different threads.
Having the main map threadsafe will prevent concurrent modifications to the map, but once you get access to the values of the map, you should exercise good concurrency practices around the values of the map.
Note ConcurrentMaps don’t allow null keys, which is different from its non–threadsafe cousin HashMap (which allows null keys)
You need to iterate over each element in a collection, but the collection is always being changed by other threads.
Also, a synchronizedList() provides a way to synchronize safely on the list while iterating through it (which is done in the for loop)
The selection of the collection to use depends on how the read operations compare with write operations.
If there are the same number of writes and reads, using a SynchronizedList is the preferred choice.
If another thread modifies the list as one is iterating through it, the changes to the modified list will not be visible when iterating.
Caution  Locking properly depends on the type of collection used.
Solution 2 creates a synchronized list, which is created by using the Collections helper class.
Every time that you need to iterate over a list (either by using the for-each statement or using an iterator) you must be aware of the concurrency implications for that list’s iterator.
In the solution, the list can safely be iterated while inside the synchronized(list) block.
When synchronizing on the list, no read/updates/other iterations can happen until the synchronized(list) block is completed.
You need to modify different but related collections at the same time and want to be sure that no other thread see these structures until they are done being modified.
By synchronizing on the principal collection, you can guarantee that collection can be updated at the same time.
In the following example, the fulfillOrder needs to both check the inventory of the order to be fulfilled, and if there is enough inventory to fulfill the order it needs to add the order to the customersOrders list.
The fulfillOrder() method synchronizes on the inventoryMap map and modifies both the inventoryMap map and the customerOrders list before finishing the synchronized block.
Using a reentrant lock, you can prevent multiple threads accessing the same critical area of the code.
Any other thread that tries to acquire the inventoryLock lock will have to wait until the inventoryLock lock is released.
If you have different structures that are required to be modified at the same time, you need to make sure that these structures are updated atomically.
An atomic operation refers to a set of instructions that can be expected to be executed as a whole or none at all.
The atomic operation is visible to the rest of the program only when it is complete.
In solution 1 (atomically modifying both the inventoryMap map and the customerOrders list), you pick a “principal” collection on which you will lock (the inventoryMap)
By locking on the principal collection, you guarantee that if another thread tries to lock on the same principal collection, it will have to wait until the lock on the collection is released by the current executing thread.
Note Notice that even though displayOrders doesn’t use the inventoryMap, you still synchronize on it (in solution 1)
Because the inventoryMap is the main collection, even operations done on secondary collections will still need to be protected by the main collection synchronization.
Solution 2 is more explicit, offering an independent lock that is used to coordinate the atomic operations instead of picking a principal collection.
Locking refers to the ability of the JVM to restrict certain code paths to be executed by only one thread.
The way locking works is that threads try to get the lock (locks are provided, for example, by a ReentrantLock instance, as shown in the example)
The lock can be given to only one thread at a time.
If other threads were trying to acquire the same lock, they will be suspended (WAIT) until the lock is available.
The lock becomes available when the thread that currently holds the lock releases it.
When a lock is released, it can then be acquired by one (and only one) of the threads that were waiting for that lock.
Locks by default are not “fair.” What that means is that the order of the threads that requested the lock is not kept; this allows for very fast locking/unlocking implementation in the JVM, and in most situations it is generally okay to have unfair locks.
On a very highly contended lock, if you really need to evenly distribute the lock (make it fair), you do so by setting the setFair property on the lock.
Once the lock is acquired, no other thread will be able to execute within the locked block.
It is common practice when working with Lock objects (ReentrantLock, ReadLock, WriteLock) to surround the use of these Lock objects by a try/finally clause.
After opening the try block, the first instruction would be a call to the lock.lock() method.
This guarantees that the first instruction executed is the acquisition of the lock.
The release of the lock (by calling lock.unlock()) is done in the matching finally block.
Having the lock be unlocked in the finally clause allows that, in the event of a RuntimeException happening while you have acquired the lock, that one doesn’t “keep” the lock and prevent other threads to acquire it.
The use of the ReentrantLock object offers additional features that the synchronized statement doesn’t offer.
As an example, the ReentrantLock has the tryLock() function, which attempts to get the lock only if no other threads have it (the method doesn’t make the invoking thread wait)
If another thread holds the lock, the method returns false but continues executing.
It is better to use the synchronized keyword for synchronization and use ReentrantLock only when its features are needed.
For more information on the other methods provided by the ReentrantLock, visit http://download.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html.
Caution   While this is only a recipe book, and proper threading techniques span their own volumes, it is important to raise awareness of deadlocks.
Deadlocks happen when two locks are involved (and are acquired in reverse order in another thread)
The simplest way to avoid deadlock is to not let the lock “escape.” This means that the lock, when acquired, should execute nothing that calls other methods that could possibly acquire a different lock, and if that’s not possible, release the lock before calling such a method.
See recipe 9-8 for information on finding and troubleshooting deadlocks.
Care should be taken in that any operation that refers to one or both collections needs to be protected by the same lock.
Operations that depend on the result of one collection to query the second collection need to be executed atomically; they need to be done as a unit in which neither collection can change until the operation is completed.
You have work that can be split into separate threads and want to maximize the use of available CPU resources.
Use a ThreadpoolExecutor instance, which allows you to break the tasks into discrete units.
In the following example, you create a BlockingQueue and fill it with Runnable object (which describe what needs to be done)
A ThreadPoolExecutor consists of two components: the Queue of tasks to be executed, and the Executor, which tells how to execute the tasks.
The Queue is filled with Runnable objects, on which the method run() contains the code to be executed.
The Queue used by a ThreadPoolExecutor is an implementer of the BlockingQueue interface.
The BlockingQueue interface denotes a queue in which the consumers of the queue will wait (be suspended) if there are no elements in the Queue.
The first step is to fill the Queue with the tasks that need to be done in parallel.
This is done by calling the Queue’s add() method and passing it a Runnable interface implementer.
The ThreadPoolExecutor constructor has many options in its constructor; the one used in the solution is the simplest one.
CorePoolSize The minimum number of threads that are created as tasks are submitted.
MaximumPoolSize The maximum number of threads that the Executor would create.
KeepAliveTime The time that the waiting threads will wait for work before being disposed (as long as the number of live thread is still more than the CorePoolSize)
WorkQueue The Blocking queue that contains the tasks to be processed by the Executor.
To wait for all the tasks to be completed, you can call the shutdown() method of the ThreadPoolExecutor.
By calling this method, you instruct the ThreadPoolExecutor to not accept any new events from the queue (previously submitted events will finish processing)
This is the first step in the orderly termination of a ThreadPoolExecutor.
To wait for all the tasks in the ThreadPoolExecutor to be done, call the awaitTermination() method.
Note A ThreadPoolExecutor needs to be configured correctly to maximize CPU usage.
The most efficient number of threads for an executor depends on the types of tasks that are submitted.
If the tasks are CPUintensive, having an executor with the current number of cores would be ideal.
If the tasks are I/O-intensive, the executor should have more threads than the current number of cores of threads.How many threads an executor should have depends on how intensive the I/O operations are; the more I/O-bound, the higher the number of threads.
Your application requires that two or more threads be coordinated to work in unison.
In this solution, the main thread waits for the objectToSync object until the database loading thread is done.
Once the databaseloading thread is done, it notifies the objectToSync that whomever is waiting on it can continue executing.
The same process happens when loading the orders into our system.
After ensuring that both the inventory and the orders are loaded, the main thread executes the processOrder() method to process all orders.
With a CountDownLatch object, you can control when the main thread continues.
In the following code, a countdownLatch with an initial value of 2 is created; then the two threads for loading the inventory and loading the order information are created and started.
As each of the two threads finish executing, they call the CountDownLatch’s countDown() method, which decrements the latch’s value by one.
The main thread waits until the CountDownLatch reaches 0, at which point it resumes execution.
By using Thread.join(), you can wait for a thread to finish executing.
The following example has a thread for loading the inventory and another thread for loading the orders.
There are many ways of coordinating threads in Java, and these coordination efforts rely on the notion of making a thread wait.
When a thread waits, it suspends execution (it doesn’t continue to the next instruction and is removed from the JVM’s thread scheduler)
If a thread is waiting, it can then be awakened again by notifying it.
Within the Java’s concurrency lingo, the word notify implies that a thread will stop being in its waiting state and resume execution (the JVM will add the thread to the thread scheduler)
So in the natural course of thread coordination, the most common sequence of events is a main thread waiting, and a secondary thread then notifying the main thread to continue (or wake up)
Even so, there is the possibility of a waiting thread being interrupted by some other event.
If you look at the previous code, the thread that runs this code would never terminate because it loops forever and waits for an item to be processed.
If there are no items in the Queue, the main thread waits until there is something added to the Queue from another thread.
You couldn’t graciously shut down the previous code (especially if the thread running the loop is not a Daemon thread)
Solution 1 shows the most common (oldest) form of coordination.
The solution requires making a thread wait, suspending execution, until the thread gets notified (or awakened) by another thread.
For solution 1 to work, the originating thread needs to acquire a lock.
This lock will then be the “phone number” on which another thread can notify the originating thread to wake up.
After the originating thread acquires the lock (phone number), it proceeds to wait.
As soon as the wait() method is called, the lock is released, allowing other threads to acquire the same lock.
The secondary thread then proceeds to acquire the lock (the phone number) and then notifies (which, in fact, would be like dialing a wake-up call) the originating thread.
In the solution 1 code, the lock is a dummy object called objectToSync.
In practice, the object on which you locks for waiting and notifying could be any valid instance object in Java; for example, you could have used the this reference to make the main thread wait (and within the threads you could have used Recipe 8_7_1.this variable reference to notify the main thread to continue)
The main advantage of using this technique is the explicitness of controlling on whom to wait and when to notify (and the ability to notify all threads that are waiting on the same object; see the following tip)
Tip Multiple threads can wait on the same lock (same phone number to be awakened)
When a secondary thread calls notify, it will wake up one of the “waiting” threads (there is no fairness about which is awakened)
Sometimes you will need to notify all the threads; you can call the notifyAll() method instead of calling the notify() method.
This is mostly used if you are preparing many threads to take some work, but the work is not yet done setting up.
When setting up, you say how many “counts” the latch will have.
When the latch reaches 0, the main thread will wake up and continue execution.
If the latch’s current value reaches 0, the main thread that was waiting on the CountDownLatch will wake up and continue execution.
The main advantage of using CountDownLatches is that you can spawn multiple tasks at the same time and just wait for all of them to complete (in the solution example, you didn’t need to wait until one or the other thread were completed before continuing, they all were started, and when the latch was 0, the main thread continued)
Solution 3 instead offers a solution in which we have access to the thread we want to wait on.
For the main thread, it’s just a matter of calling the secondary thread’s join() method.
Then the main thread will wait (stop executing) until the secondary thread finishes.
The advantage of this method is that it doesn’t require the secondary threads to know any synchronization mechanism.
As long as the secondary thread terminates execution, the main thread can wait on them.
You need to create an object that is threadsafe because it will be accessed from multiple threads.
Use synchronized getters and setters, and protect critical regions that change state.
In the following example, you create an object with getters and setters that are synchronized for each internal variable, and you protect the critical regions by using the synchronized(this) lock:
Create an immutable object (an object that, once created, doesn’t change its internal state)
In the following code, the internal variables to the object are declared final, and are assigned at construction.
By doing so it is guaranteed that the object is immutable:
Solution 1 relies on the principle that any change done to the object is protected by a lock.
Using the synchronized keyword is a shortcut to writing the expression synchronized (this)
By synchronizing your getters and setters (and any other operation that alters the internal state of your object), you guarantee that the object is consistent.
Also, it is important that any operations that should occur as a unit (say something that modifies two collections at the same time, as listed in recipe 8-5) are done within a method of the object and are protected by using the synchronized keyword.
Even though it looks that the statement is concise, another thread can change the contents of the object between getting the size and getting the item number.
Immutable objects don’t change their internal state, and objects that don’t change their internal state (are immutable) are by definition threadsafe.
If you need to modify the immutable object because of an event, instead of explicitly changing its property, create a new object with the changed properties.
This new object then takes the place of the old object, and on future requests for the object, the new immutable object is returned.
This is by far, the easiest (albeit verbose) method for creating threadsafe code.
You need a counter that is threadsafe so that it can be incremented from different execution threads.
By using the inherently threadsafe Atomic objects, you can create a counter that guarantees thread safety and has an optimized synchronization strategy.
In the following code, you create an Order object, which requires a unique order ID generated by using the AtomicLong incrementAndGet() method:
AtomicLong (and its cousin AtomicInteger) are built to be used safely in concurrent environments.
They have methods to atomically increment (and get) the changed value.
Even if two or hundreds of threads were to call the AtomicLong increment() method, their returned value will always be unique.
If you need to make decisions and update the variables, always use the atomic operations that are offered by the AtomicLong; for example, compareAndSet.
The following code illustrates several code safety issues to be aware of.
First is that changing a long value may be done in two memory write operations (as allowed by the Java Memory Model), and thus two threads could end up overlapping those two operaitons in what might on the surface appear to be threadsafe code.
The result would be a completely unexpected (and likely wrong) long value:
This code also suffers from unsafe publication, which refers to the fact that a variable might be cached locally (in the CPU’s internal cache) and might not be commited to main memory.
If another thread (executing in another CPU) happens to be reading the variable from main memory, that other thread might miss the changes made by the first thread.
The changed value might be cached by the first thread’s CPU, and not yet committed to main memory where the second thread can see it.
For safe publication, you must use the volatile Java modifier (see http://download.oracle.com/javase/tutorial/essential/concurrency/atomic.html)
A final issue with the preceding code is that it is not atomic.
Even though it looks like there is only one operation to increment the counter, in reality there are two operations that happen at the machine language level (a retrieve of the variable and then an increment)
There could be two or more threads that get the same value as they both retrieve the variable but haven’t incremented it yet.
Then all the threads increment the counter to the same number.
You have an algorithm that benefits from using a divide-and-conquer strategy, which refers to the ability of breaking down a unit of work into two separate subunits and then piecing together the results from these subunits.
The subunits can then be broken down into more subunits of work until reaching a point where the work is small enough to just be executed.
By breaking down the unit of work into subunits, you can take advantage of the multicore nature of today’s processors with minimum pain.
The new Fork/Join framework in Java 7 makes applying the divide-and-conquer strategy straightforward.
The following example creates a representation of the Game of Life.
The code uses the Fork/Join framework to speed up the calculation of each iteration when advancing from one generation to the next:
The first part of the example creates a ForkJoinPool object.
The default constructor provides reasonable defaults (such as creating as many threads as there are CPU cores) and sets up an entry point to submit divide-and-conquer work.
While the ForkJoinPool inherits from an ExecutorService, it is best suited to handle tasks that extend from RecursiveAction.
The second part of the solution creates the GameOfLifeAdvancer class, which extends the RecursiveAction class.
By extending the RecursiveAction class, you can split the work to be done.
The GameOfLifeAdvancer class advances the Game of Life board to the next generation.
The constructor takes a two-dimensional boolean array (which represents a Game of Life board), a start row/column, an end row/column, and a destination two-dimensional boolean array, on which the result of advancing the Game of Life for one generation is collected.
In this method, you figure out how much work there is to be done.
If the work is small enough, the work is done directly (achieved by calling the computeDirectly() method and returning)
If the work is not small enough, the method splits the work by creating two GameOfLifeAdvancer instances that process only half of the current GameOfLifeAdvancer work.
This is done by either splitting the number of rows to be processed into two chunks or by splitting the number of columns into two chunks.
The two GameOfLifeAdvancer instances are then passed to the ForkJoin pool by calling the invokeAll() method of the RecursiveAction class.
The invokeAll() method takes the two instances of GameOfLifeAdvancer (it can take as many as needed)
In this way, the GameOfLifeAdvancer instance is broken down into new GameOfLifeAdvancer instances that each processes only part of the Game of Life board.
Each instance waits for all the subordinate parts to be completed before returning control to the caller.
The resulting division of work can take advantage of the multiple CPUs available in the typical system today.
Tip The ForkJoinPool is generally more efficient than an ExecutorService because it implements a workstealing policy.
Each thread has a Queue of work to do; if the Queue of any thread gets empty, the thread will “steal” work from another thread queue, making a more efficient use of CPU processing power.
To effectively debug, you must be able to “think” like a computer and dive into the code, deconstructing every step that lead to the logic error that you’re working to resolve.
In the beginning of computer programming, there weren’t a lot of tools to help in debugging.
Mostly, debugging involved taking a look at your code and spotting inconsistencies; then resubmit the code to be compiled again.
Today, every IDE offers the ability of using breakpoints and inspecting memory variables, making it much easier to debug.
Outside the IDE there are other tools that help in daily debugging, building, and testing of your project; and these tools ensure that your code is being continually tested for errors introduced when programming.
In this chapter, you explore the different tools that will help aid in debugging, analyzing, and testing Java software.
Hopefully these recipes will help you debug faster, and burn less of that midnight oil.
Problem You caught and logged an Exception (as described in solution 6-1), and need to understand what happened.
Every program keeps track of how it got to a specific part of the code.
Stack trace‘s output  refer to the stack that was in memory when an error occurred.
Exceptions thrown in Java keep track of where they happened and what code path was taken to when the exception was thrown.
Stack trace shows from the most specific place where the exception happened (the line where the exception occurred) to the top-level invoker of the offending code (and everything in-between)
This information then allows you to pinpoint what kind of method calls were done, and might shed some light on why the exception was thrown.
Sometimes, when looking at the Stack trace’s output , you will see methods that don’t belong to the project.
This happens naturally as sometimes method calls are generated in other parts of a working system.
It is, for example, very common to see AWT methods in Swing applications when an exception is raised (due to the nature of the EventQueue)
If you look at the more specific function calls (earliest),you will eventually run with the project’s own code and can then try to figure out why the exception was thrown.
Note The Stack trace output will contain line number information if the program is compiled with “Debug” info.
By default, most IDEs will include this information when running in a Debug configuration.
Problem You need to lock down the behavior of your class and want to create unit tests that verify that behavior in your application.
Solution Use JUnit to create unit tests that verify behavior in your classes.
To use this solution, you need to include the JUnit dependencies.
When JUnit becomes part of your project, you will be able to include the org.junit and junit.framework namespaces.
In this example you create two unit tests for the MathAdder class.
It contains two methods: addNumber (int, int) and substractNumber (int,int)
These two methods return the addition (or subtraction) of their passed parameters (a simple class)
The unit tests (marked by the @Test annotation) verifies that the MathAdder class does, in fact, add and/or subtract two numbers.
How It Works Unit tests are a way of enforcing expected behaviors on your classes.
Having unit tests in your project makes it less likely to break old functionality when adding or refactoring it.
When you create unit tests, you are specifying how an object should behave (what is referred to as its contract)
The unit tests will then test that the expected behavior happens (they do this by verifying the result of a method and using the different JUnit.Assert methods)
The first step to write a unit test is to create a new class that describes the behavior you want to verify.
The Unit test class (MathAdderTest) will contain methods that check and verify the behavior of the class.
Annotation refers to the capability of Java of adding extra information to a class/method that doesn’t necessarily change the code.
This extra information is not used by the program, but by the compiler/builder (or external tools) to guide the compilation, building, and/or testing of the code.
For unit testing purposes, you annotate the methods that are part of the unit test by writing @Test before each method name.
While the scope of this class is trivial, it shows the bare minimum requirements to have a fully functional unit test.
If the Assert call succeeds, it gets reported in the unit test framework as a “Passed” test; if the Assert call fails, then the unit test framework will stop and display a message showing where the unit test failed.
While it is true that IDEs can run unit tests while developing, they are created with the intention of being run automatically (usually triggered by a scheduled build or by a version control system’s checkin), which is what the recipe 9-3 talks about.
Uncompress Apache Ant into a folder (for example, c:\ant for Windows systems)
Windows, this means adding the apache-ant/bin folder to the path as follows:
In the System Variables list, double-click the variable name PATH.
Click OK (on each of the popup boxes that were opened before) to accept the changes.
In Windows, this means adding a new environment variable called JAVA_HOME.
Test that you can reach Ant, and that Ant can find your JDK installation.
To test that the changes took effect in Windows, do the following:
If you receive the message “Ant is not recognized as an internal or external command”, redo the first steps of setting up the PATH variable (the first set of instructions)
If you receive the message “unable to locate tools.jar” You need to create and/or update the JAVA_HOME path for your installation (the second set of instructions)
The message “Buildfile: build.xml does not exist!”means that your setup is ready to be built using Ant.
Note When changing environment variables in Microsoft Windows, it is necessary to close previous command line windows and reopen them because changes are only applied to new command windows.
To open a command window in Microsoft Windows, click Start, type CMD, and press Enter.
Create build.xml at the root of your project, and put the following bare-bones Ant script as the contents of the build.xml file.
This particular build.xml file contains information that Ant will use to compile and test this  recipe.
Note To execute this recipe, open a command line window, navigate to the Chapter 9 folder, type ant, and press Enter.
How It Works Apache Ant (or simply Ant) is a program that allows you to script your project’s build and unit testing.
By configuring Ant, you can build, test, and deploy your application using the command line (In turn, it can then be scheduled to be run automatically by the operating system)
Ant can have tasks to automatically run unit tests and give a report on the result of these tests.
These results can then be analyzed after each run to pinpoint changes in behavior.
Although Ant might be difficult to understand, it allows for a lot of flexibility on how to compile, build, and weave code.
By using Ant, you are allowing utmost configuration on how your project is built.
Tip Visit http://ant.apache.org/manual/tutorial-helloworldwithant.html for a more in-depth tutorial of Ant.
The build.xmlfile contains instructions on how to compile your project, which classpath to use, and what unit tests to run.
Each build.xml will have a <project> tag that contains the steps to build the project.
Within each <project> there are targets, which are “steps” in the build process.
A <target> can depend on other targets, allowing you to establish dependencies in your project (in this recipe’s example, the target “test” depends on the target “build”; meaning that to run the test target, Ant will first run the build target)
These tasks are extensible, and there is a core set of tasks that you can use out of the box.
The <javac>task will compile a set of Java files specified in the src attribute and write the output to the dest attribute.
As part of the <javac> task, you can specify the classpath to use.
In this example, the classpath is specified by referring to a previously defined path, called build.path.
In this recipe, the classpath is defined as any file that has the .jar extension located in the dep folder.
The other task in the build target is the <junit> task.
This task will find unit test specified in its task and run it.
By using the <fileset> property, you tell JUnit to find any file that has the word Test in its name and ends with the .java extension.
Once the JUnit runs each test, it will write out a summary to the console and write a report on the results of the unit tests to the reports.tests folder.
Problem You need to generate reports on how much of your project the unit tests cover.
Solution Use the Emma code coverage tool to create code coverage reports.
For example, the following is a new version of build.xml that adds Emma code coverage to our unit testing:
To run this recipe, you will need to download and add the Emma code coverage .jar files.
To do so, go to http://emma.sourceforge.net/ and download the latest Emma code coverage version.
After downloading, uncompress the Emma download into a folder in your computer.
Copy the /lib folder from the uncompressed Emma folder into dep/emma in your application.
Note To execute this recipe from Ant, open a command-line window, navigate to the Chapter 9 folder, type ant –f emmabuild.xml and press Enter.
How It Works An important feature of creating unit tests is measuring how much code they execute of the tested classes.
The more project code the unit tests execute, the safer it is to assume that changes in expected behavior will be caught by the unit tests.
Code coverage is defined as the percentage of lines of code that the unit tests have run versus the total lines of code the project has.
By having a larger code coverage, most of the code base is being verified.
A typical code coverage goal is about 80 percent of the lines of code tested; more coverage than that and you might be testing trivial functionality such as getters and setters of a simple Java class.
By combining Emma, Ant, and JUnit you can get code coverage reporting for your application.
Code coverage is a very important measure for a lot of programming disciplines.
It offers a way of understanding how effectively the current codebase is covered, and how solid the unit tests are in terms of covering functionality.
In this build.xml file, there are new sections that describe how to measure code coverage.
The first section of build.xml defines a new Emma task that can be used by Ant.
The way Emma’s code coverage works is by going through a process called instrumentation, which refers to a task that changes the compiled bytecode.
In Emma’s case, it’s adding extra instructions that record coverage information.
Using the recorded coverage information, Emma puts together a report that shows code coverage that was achieved when running the unit tests.
For the recipe, the files to instrument are located in the /build folder.
Overwrite instrumentation means that Emma takes the original class file, instruments it (changes the content to add the new instructions), and saves it with the same name.
Within our instrumentation step, you also specify to exclude any file that has the Test name in it because it is a common practice not to include unit test lines of code as part of the code coverage.
This is very similar to recipe 9-3; even so, there are a couple of differences.
The first difference is that you specify the unit tests to run as .class files instead of.java files.
The second difference is that there are new JVM arguments added for unit tests.
These properties tell the instrumented classes that information related to code coverage should be written to a file named coverage.emma, and that it should be done in aggregate (don’t overwrite the file for each unit test being executed)
This is due to an incompatibility between Emma and the new Java 7 bytecode, which the jvmarg property fixes.
This is done by adding a new <emma><report> task that specifies the location and formatting of the report.
By using these three tools (Ant, JUnit, and Emma) you have created an automated build that runs unit tests and reports on code coverage exercised by unit tests.
Problem You want to find the most number of bugs at design time.
The following is our new build.xml file that adds FindBugs reporting:
Uncompress into a folder in your computer; then copy the contents of the ./lib/ folder into your project’s /dep/findbugs folder (create the /dep/findbugs folder if necessary)
It will parse your program’s compiled file and spot errors in coding (not syntax errors, but certain types of logic errors)
As an example, one of the errors that FindBugs will spot is comparing two Strings using == instead of String.equals()
The analysis is then written as HTML (or text) that can be viewed with a browser.
Catching errors from FindBugs is easy, and adding it as part of your continuous integration process is extremely beneficial.
At the beginning of build.xml, you define the FindBugs tasks.
The build.xml also has a new target project called “findbugs.” The findbugs target compiles the source files with debug information (having debug information helps on the FindBugs report as it will include the line# when reporting errors), and then proceeds to analyze the bytecode for errors.
Tip To invoke Ant to run the default “target” (as specified in the build.xml), you just type ant.
Problem You notice that your application seems to be slowing down and suspect that there are garbage collections happening.
These parameters will allow you to log garbage collection information to the gc.log file, including the time garbage collections happen and the details (if it was a minor or major garbage collection and how long it took)
Ant target that executes Recipe 9_6 with garbage logging on.
In this build.xml file, the Java task is being used to add the arguments for garbage collection logging to the compiler before launching the application.
Solution 2 Analyze your program’s memory consumption by using VisualVM (an external GNU Open Source Java profiler and visualization tool).To use and install VisualVM, go to http://visualvm.java.net/, download and follow the steps for installation (usually uncompressing in the folder of your choice and then clicking the provided executable)
How It Works Adding the flag to log garbage collection in solution 1 will cause your Java application to write minor and major garbage collections information into a log file.
This allows you to “reconstruct” in time what happened to the application and allows you to spot probable memory leaks (or at least other memoryrelated issues)
This is the preferred troubleshooting method for production systems as it is usually lightweight and can be analyzed after the fact.
Solution 2 instead involves using an open-source tool called VisualVM.
It is a great tool to understanding in situ what’s happening inside your application, as you can see real-time monitoring of CPU consumption, garbage collections, threads created, and classes loaded.
VisualVM has its own extensive list of features that should be visited and that every Java developer should have as part of his or her arsenal of tools.
You will see that there is a list of running virtual machines on the left tree view (under Local)
Double-click the Recipe9_6 virtual machine, and you should see the current Memory consumption under the Monitor tab.
Problem You notice that your application keeps consuming memory until it cannot continue working.
Solution Use VisualVM to take and view the memory dump.
For this recipe, run the Recipe9_7 program in the example download.
On this frame there is a button called Let’s Create Windows that when clicked will create a new frame.
The frame also has another button (Let’s Close The Windows) that when clicked will close all the created frames.
This program has a memory leak, and the memory leak is apparent when looking at the VisualVM memory graph.
You should be able to see in the Monitor tab what the current memory consumption is.
By clicking the Let’s Create Windows button and the Let’s Close The Windows button, you will see that the Memory consumption in the Monitor tab keeps going up.
Look at Figure 9-3 for an example of what you should see.
After the memory size is up around 250Kb, click the button called Heap Dump, which will take a memory dump.
The heap dump then will describe what is being held onto memory.
How It Works VisualVM allows you to take a snapshot on what is happening in the JVM.
When hunting for memory leaks, you want to concentrate on what is the object that has the most memory allocation (the usual suspects are Maps)
Once you find the objects that use the most memory, it is a matter to see who has the reference to it.
By then removing the references to the object (for example, removing it from the map) you can gain control of memory and fix memory leaks.
Note VisualVM will satisfy most of the needs when it comes to troubleshooting memory issues, but there are JDK-provided tools as well.
The most well-known is JMap, which will get a memory dump from the application specified by the process ID (PID)
Memory dumps collected using JMap can be viewed in VisualVM.
When you take a heap dump (as described in this recipe), VisualVM will open up a new tab that shows the contents of the heap.
For the purpose of this recipe, you will need to click the Classes button, which will give you a screen similar to Figure 9-4
On this view, if you sort by Size (by clicking the Size column), you will notice that object that uses the most memory is the int[] (an Int array)
Even though the recipe’s program doesn’t have any Int arrays defined, the memory leak seems to be related to those Int arrays.
To explore the int[], double-click the int[] at the beginning.
It will take you to the Instances tab, and describe all the int[] instances that are currently defined in your application.
When debugging memory leaks, sometimes it is not obvious where is the leak coming from.
This particular example shows int[] as the cause of the leak, even though when looking at the recipe’s code there isn’t any int[]
This happens because you have not defined int[], but instead have defined something that uses int[]
You will find out at the end of the recipe what object was defining and causing the leak.
For this exercise, click an int[] instance that has the size of 1800024, and look at the references.
On the references, you can expand to “walk upwards” on who owns the int[]
After expanding the references, you will eventually see that they are being held by an Icon, which in turn is held by a JFrame.
This presents the clue that JFrames are being held in memory and that the JFrames are not being disposed of.
See Figure 9-5 for a screenshot on where to spot the JFrame (it’s in the selected row of the bottom-right table)
With this newfound knowledge that JFrames is what is being “held,” you can then go back to the Classes tab and search for JFrame.
Clicking the JFrame will give you the list of instances of the JFrame and you can drill down on “who” is holding a reference to the JFrame.
After some digging through VisualVM (as shown in Figure 9-6), you find out that the reference to the JFrame is being held by the created Windows set.
Upon closer inspection of the code, you can see that the created Windows set is populated with newly created JFrames, but never “emptied.” So the JFrame, being “held” by the set, couldn’t be garbage collected when closed.
The fix for the leak can be found in Recipe9_7_Fixed for the curious at heart.
In short, finding memory leaks usually involves following strange paths.
At the beginning of this recipe, the memory dump showed int[] as the culprit, but in the end, it was a Set that held a reference to the JFrames that was never cleared, which in turn held an Icon, which in turn held an int[]
Problem Your program seems to “hang” without doing anything, and you suspect that there might be a deadlock.
Solution Use JStack to get a thread dump, and then analyze the thread dump for deadlocks.
The following JStack is a thread dump from Recipe 9_8, which creates a deadlock:
If you have this path, you can run the tools such as JStack and JPS.
The JStack command uses as an argument –l (a dash and the letter L), which specifies a Long listing (it does extra work to get more information about the threads running)
The JStack also needs to know the PID of the target VM.
A quick way to list all running JVMs is to type JPS and press Enter.
How It Works JStack allows you to see all the stack traces that the current running threads have.
JStack will also try to find deadlocks (circular dependencies of locks) that might be stalling your system.
Deadlocks happen because one thread is waiting for a resource that another thread has, and the second thread is waiting for a resource that the first thread has.
In this situation, neither thread can continue because both are waiting for each other to release the resource that each one owns.
Deadlocks don’t only happen between two threads, but can also involve a “string” of threads so that Thread A is waiting for Thread B is waiting for Thread C is waiting for Thread D is waiting for the original Thread A.
It is important to understand the dump to find the culprit resource.
Thread-0 cannot acquire the lock because it is held by the main thread.
This is a textbook definition of a deadlock on which each thread is forever waiting for each other to release the lock the other thread has.
Aside from deadlock, looking at thread dumps gives you an idea about what your program is doing in realtime.
Especially in multithreaded systems, using thread dumps will help clarify where a thread is sleeping or what condition it is waiting for.
Tip JStack is usually lightweight enough to be run in a live system, so if you need to troubleshoot live problems, you can safely use JStack.
This chapter describes only some of the most frequent and common tasks that programmers must perform when developing internationalized applications.
Because Java 7 adds new features around its abstraction of languages and regions, this chapter describes some of the new ways you might use the Locale class.
Please see the introductory chapters for instructions on how to find and download sample source code.
You want to convert a Unicode digit character to its respective integer value.
For example, you have a string containing the Thai digit for the value 8 and you wish to generate an integer with that value.
Your console may not print all the character glyphs shown in this example because of font or platform differences.
Note that the digit() method is overloaded to accept either char or int arguments.
These terms are beyond the scope of this recipe, but you can learn more about these and other Unicode concepts from the Unicode web site at http://unicode.org or from the Character class Java API documentation.
You want to display numbers, dates, and time in a user-friendly way that conforms to the language and cultural expectations of your customers.
The display format for numbers, dates, and time varies across the world and depends upon your user’s language and cultural region.
By determining and using your customer’s locale, you can apply that locale to a variety of format classes that create user-visible data in expected forms.
Classes that use Locale instances to modify their behavior for a particular language or region are called locale-sensitive classes.
You can learn more about locale-sensitive classes in the “Numbers and Dates” chapter.
That chapter shows you how to use Locale instances in the NumberFormat and DateFormat classes.
In this recipe, however, you will learn options for creating these Locale instances.
Create a Locale instance in any of the following ways:
Use the Locale.Builder class to configure and build a Locale object.
The “How It Works” section will describe the BCP 47 standard in more detail.
For now, you should simply understand that a Builder creates Locale instances that comply with that standard.
You use the created locales in locale-sensitive classes to produce culturally correct display formats:
The previous code prints the following to the standard console:
This method allows you to use BCP 47 language tag arguments.The following code uses the forLanguageTag() method to create three locales from their corresponding language tags:
The output is similar to the results created from the Builder-generated locale instance:
Other constructors allow you to pass fewer or more arguments.
The argument parameters can include language, region, and optional variant codes.
Finally, the Locale class has many predefined static instances for some commonly used cases.
Because the instances are predefined, your code needs to reference only the static instances.
For example, the following example shows how to reference existing static instances representing fr-FR, ja-JP, and en-US locales:
Refer to the Locale Java API documentation for examples of other static instances.
The Locale class gives locale-sensitive classes the context they need to perform culture-sensitive data formatting and parsing.
A Locale instance identifies a specific language, and can be finely tuned to identify languages written in a particular script or spoken in a specific world region.
Locale is an important and necessary element for creating anything thathas dependencies on language or regional influences.
Although the existing Locale constructors continue to be compatible with prior versions of the Java platform, the constructors do not support the additional script tags.
Because the Locale constructors do not enforce strict BCP 47 compliance, you should avoid the constructors in any new code.
Instead, developers should migrate their code to use the new Builder class and the forLanguageTag() method.
A Locale.Builder instance has a variety of setter methods that help you configure it to create a valid, BCP 47–compliant Locale instance:
The language parameter must be a valid two or three-letter ISO 639 language identifier.
Finally, the script parameter must be a valid four-letter ISO 15924 script code.
The Builder lets you configure it to create a specific BCP 47–compliant Locale.
Once you set all the configurations, the build() method creates and returns a Locale instance.
Notice that all the setters can be chained together for a single statement.
The Builder pattern works by having each configuration method return a reference to the current instance, on which further configuration methods may be called.
The BCP 47 document and the standards that comprise it can be found at the following locations:
You want to set the default locale for all locale-sensitive classes.
This example code demonstrates how to set the default locale for all locale-sensitive classes:
You can also set the default for two additional locale categories, DISPLAY and FORMAT:
You can create code that uses these specific locale categories within your application to mix locale choices for different purposes.
For example, you may choose to use the DISPLAY locale for ResourceBundle text while using the FORMAT locale for date and time formats.
The Locale class allows you to set the default Locale for two different categories.
Setting the default DISPLAY locale means that the ResourceBundle class can load user interface resources for that particular locale independently from the FORMAT locale.
Setting the FORMAT default locale affects how the various Format subclasses behave.
For example, a default DateFormat instance will use the FORMATdefault locale to create a locale-sensitive output format.
Again, these two categories are independent, so you can use different Locale instances for different needs.
This method always resets both DISPLAY and FORMAT locales to match the system locale.
When creating a new resource bundle, the ResourceBundle class uses the system locale by default.
However, by providing a locale instance argument, you tell the bundle to load resources for a specific locale.
For example, this code attempts to load a language bundle for es-MX even though the system locale is still Locale.FRANCE:
To use the DISPLAY default locale in a ResourceBundle(), you must explicitly provide it as an argument.
You want to find or match Unicode characters in a String.
The easiest way to find or match characters is to use the String class itself.
String instances store Unicode character sequences and provide relatively simple operations for finding, replacing, and tokenizing characters using regular expressions.
To determine whether a String matches a regular expression, use the matches() method.
The matches() method returns true if the entire string exactly matches the regular expression.
The regular expression matches simply confirm that the strings match a particular pattern as defined in the variables enRegEx and jaRegEx.
Use the replaceFirst() method to create a new String instance in which the first occurrence of the regular expression in the target text is replaced with the replacement text.
The replaceAll() method replaces all occurrences of the expression with the replacement text.
Finally, the split() method creates a String[] that contains text that is separated by the matched.
In other words, it returns text that is delimited by the expression.
Optionally, you can provide a limit argument that constrains the number of times the delimiter will be applied in the source text.
The following code demonstrates the split() method splitting on space characters:
Split: The Split: fat Split: cat sat on the mat with a brown rat.
A Matcher works on a String instance using the pattern.
All Matcher operations perform their functions using Pattern and String instances.
The following code demonstrates how to search for both ASCII and non-ASCII text in two separate strings.
The demoComplex() method finds two Japanese symbols in a string:
Running these two methods on the previously defined English and Japanese text shows the following:
The String methods that work with regular expressions are the following:
The Java regular expressions are similar to those used in the Perl language.
Although there is a lot to learn about Java regular expressions, probably the most important points to understand from this recipe are these:
Your regular expressions can definitely contain non-ASCII characters from the full range of Unicode characters.
Because of a peculiarity of how the Java language compiler understands the backslash character, you will have to use two backslashes in your code instead of one for the predefined character class expressions.
The most convenient and readable way to use non-ASCII characters in regular expressions is to type them directly into your source files using your keyboard input methods.
Operating systems and editors differ in how they allow you to enter complex text outside of ASCII.
Regardless of operating system, you should save the file in the UTF-8 encoding if your editor allows.
As an alternate but more difficult way to use non-ASCII regular expressions, you can encode characters using the \uXXXX notation.
The Java language’s regular expression support includes special character classes.
You want to display a number value using a currency that is not associated with the default locale.
Take control of what currency is printed with a formatted currency value by explicitly setting the currency used in a NumberFormat instance.
The following example assumes that the default locale is Locale.JAPAN.
You will use a NumberFormat instance to format currency values.
The previous formatter will use your default locale’s preferences for formatting numbers as currency values.
Also, it will use a currency symbol that is associated with the locale’s region.
However, one very common use case involves formatting a value for a different region’s currency.
Use the setCurrency()  method to explicitly set the currency in the number formatter:
It allows you to create currency objects in two ways:
The first getInstance call uses a Locale instance to retrieve a currency object.
The Java platform associates a default currency with the locale’s region.
In this case, the default currency currently associated with the United States is the U.S.
The second getInstance call uses a valid ISO 4217 currency code.
Once you have a currency instance, you simply have to use that instance in your formatter:
This formatter now is configured to use the default locale’s number format symbols and patterns to format the number value, but it will display the targeted currency code as part of the displayable text.
This allows you to mix the default number format patterns with other currency codes.
A currency code always refers to the three-letter ISO 4217 code.
A currency formatter will typically use a symbol when formatting a number in the default locale using the currency of that locale’s region.
However, when you explicitly change the currency of a formatter, the formatter doesn’t always have knowledge of a localized symbol for the target currency.
In that case, the format instance will often use the currency code in the displayed text.
You need to convert characters in a byte array from a legacy character set encoding to a Unicode String.
Convert legacy character encodings from a byte array to a Unicode String using the String class.
Later in this same example, the code demonstrates how to convert from Unicode back into the Shift-JIS byte array.
The previous code prints out the converted text, which is “Hello, world!” in Japanese:
Use the getBytes() method to convert characters from a String to a byte array.
Building upon the previous code, convert back to the original encoding with the following code, and compare the results:
As expected, the output indicates that the round-trip conversion back to the legacy encoding was successful.
The original byte array and the converted byte array contain the same bytes:
The Java platform provides conversion support for many legacy character set encodings.
When you create a String instance from a byte array, you must provide a Charset argument to the String constructor so that the platform knows how to perform the mapping from the legacy encoding to Unicode.
The number of bytes in the original array does not usually equal the number of characters in the result string.
In this recipe’s example, the original array contains 18 bytes.
The 18 bytes are needed by the Shift-JIS encoding to represent the Japanese text.
There is not a 1:1 relationship between bytes and characters.
In this example, each character requires two bytes in the original Shift-JIS encoding.
The number of encodings is dependent upon your Java platform implementation.
However, you are guaranteed support of several of the most common encodings, and your platform most likely contains many more than this minimal set:
When constructing a Charset, you should be prepared to handle the possible exceptions that can occur when the character set is not supported:
You need to convert large blocks of Unicode character text to and from an arbitrary byte-oriented encoding.
Large blocks of text may come from streams or files.
The following code uses an InputStreamReader to read and convert a potentially large block of text bytes from a file in the classpath.
Similarly, you can use an OutputStreamWriter to write text to a byte stream.
The following code writes a String to a UTF-8 encoded byte stream:
Retrieve an encoder or decoder from a Charset instance with the newEncoder() or newDecoder() method.
Then use the encoder’s encode() method to create byte buffers.
Streams are convenient abstractions that can assist you in converting text using a variety of sources and targets.
A stream can represent incoming or outgoing text in an HTTP connection or even a file.
If you use an InputStream to represent the underlying source text, you will wrap that stream in an InputStreamReader to perform conversions from a byte stream.
The reader instance performs the conversion from bytes to Unicode characters.
Using an OutputStream instance to represent the target text, wrap the stream in an OutputStreamWriter.
A writer will convert your Unicode text to a byte-oriented encoding in the target stream.
To effectively use either an OutputStreamWriter or an InputStreamReader, you must know the character encoding of your target or source text.
When you use an InputStreamReader, the target encoding is always Unicode.
You must supply the source text encoding as an argument so that the reader understands how to convert the text.
Converting to Unicode in this discussion always means converting to UTF-16
Converting to a byte-oriented encoding usually means to a legacy non–Unicode charset encoding.
Yet another way to perform encoding conversions is to use the CharsetEncoder and CharsetDecoder classes.
A Charset represents a character set encoding in defined in the IANA Charset Registry.
When creating a Charset instance, you should use the canonical or alias names of the charset as defined by the registry.
Remember that your Java implementation will not necessarily support all the IANA charset names.
However, all implementations are required to support at least those shown in recipe 10-6 of this chapter.
Almost any nontrivial application contains a database of some sort.
Some applications use in-memory databases, while others use traditional relational database management systems (RDBMSs)
Whatever the case, it is essential that every Java developer have some skills working with databases.
Over the years, the Java Database Connectivity (JDBC) API has evolved quite a bit, and with Java SE 7 there are a couple of major advancements.
This chapter will cover the basics of using JDBC for working with databases.
You will learn how to perform all the standard database operations, as well as some advanced techniques for manipulating data.
You’ll also learn how you can help to create secure database applications and how to save some time on development using some of the latest advancements in the API.
In the end, you will be able to develop Java applications that can work with traditional RDBMSs such as Oracle database and MySQL.
Note To follow along with the examples in this chapter, run the create_user.sql script to create a database user schema.
You want to create a connection to a database from within a desktop Java application.
Do this by creating a new connection object, and then load the driver that you need to use for your particular database vendor.
Once the connection object is ready, call its getConnection() method.
The following code demonstrates how to obtain a connection to an Oracle database.
The method portrayed in this example returns a Connection object that is ready to be used for database access.
The DataSource object must have been properly implemented and deployed to an application server environment.
After a DataSource object has been implemented and deployed, it can be used by an application to obtain a connection to a database.
The following code shows code that one might use to obtain a database connection via a DataSource object:
Notice that the only information required in the DataSource implementation is the name of a valid DataSource object.
All the information that is required to obtain a connection with the database is managed within the application server.
There are a couple of different ways to create a connection to a database within a Java application.
How you do so depends on the type of application you are writing.
Web-based and intranet applications commonly rely on the application server to provide the connection for the application via a DataSource object.
First, you need to determine which database driver you will need to use.
After you’ve determined which driver you will need to use then download the.
Therefore, the ojdbc6.jar JAR file (or the most recently available JDBC driver) is downloaded and placed into the CLASSPATH.
However, other database vendors will provide different JDBC drivers packaged in JAR files that have different names; please consult the documentation for your particular database for more information.
Once you have the JAR file in your application CLASSPATH, you can use a JDBC DriverManager to obtain a connection to the database.
As of JDBC version 4.0, drivers that are contained within the CLASSPATH are automatically loaded into the DriverManager object.
If you are using a JDBC version prior to 4.0, the driver will have to be manually loaded.
To obtain a connection to your database using the DriverManager, you need to pass a String containing the JDBC URL to it.
The JDBC URL consists of the database vendor name, along with the name of the server that hosts the database, the name of the database, the database port number, and a valid database username and password that has access to the schema that you want to work with.
Many times, the values used to create the JDBC URL are obtained from a Properties file so that they can be easily changed if needed.
To learn more about using a Properties file to store connection values, please see Recipe 11-5
The code that is used to create the JDBC URL for Solution #1 looks like the following:
Once all the variables have been substituted into the String, it will look something like the following:
The preferred way to obtain a database connection is to use a DataSource when running on an application server or to have access to a Java Naming and Directory Interface (JNDI) service.
To work with a DataSource object, you need to have an application server to deploy it to.
Most of the application servers contain a web interface that can be used to easily deploy a DataSource object.
However, you can manually deploy a DataSource object by using code that will look like the following:
This code instantiates a new DataSource driver class and then it sets properties based upon the database that you want to register.
DataSource code such as that demonstrated here is typically used when registering a DataSource in an application server or with access to a JNDI server.
Application servers usually do this work behind the scenes if you are using a web-based administration tool to deploy a DataSource.
Most database vendors will supply a DataSource driver along with their JDBC drivers, so if the correct JAR resides within the application or server CLASSPATH, it should be recognized and available for use.
Once a DataSource has been instantiated and configured, the next step is to register the DataSource with a JNDI naming service.
The following code demonstrates the registration of a DataSource with JNDI:
Once the DataSource has been deployed, any application that has been deployed to the same application server will have access to it.
The beauty of working with a DataSource object is that your application code doesn’t need to know anything about the database; it only needs to know the name of the DataSource.
Usually the name of the DataSource begins with a jdbc/ prefix, followed by an identifier.
To look up the DataSource object, an InitialContext is used.
In Solution #2, you can see that the InitialContext returns an object that must be casted as a DataSource.
If the DataSource is a connection pool cache, it will send one of the available connections within the pool when an application requests it.
The following line of code returns a Connection object from the DataSource:
The DataSource technique is preferred over the DriverManager because database connection information is only stored in one place: the application server.
Once a valid DataSource is deployed, it can be used by many applications.
After a valid connection has been obtained by your application, it can be used to work with the database.
A database activity in your application has thrown an exception.
You need to handle that SQL exception so that your application does not crash.
Use a try-catch block in order to capture and handle any SQL exceptions that are thrown by your JDBC connection or SQL queries.
The following code demonstrates how to implement a try-catch block in order to capture SQL exceptions:
Your code will not compile if these exceptions are not handled, and it is a good idea to handle them in order to prevent your application from crashing if one of these exceptions is thrown.
In fact, nested try-catch blocks are often required to handle all the possible exceptions.
You need to ensure that connections are closed once work has been performed and the Connection object is no longer used.
Because Statement and Connection objects need to be closed, it is common to see try-catchfinally blocks used to ensure that all resources have been tended to as needed.
It is not unlikely that you will see JDBC code that resembles the following style:
As seen in the previous pseudo code, nested try-catch blocks are often required in order to clean up unused resources.
Proper exception handling sometimes makes JDBC code rather laborious to write, but it will also ensure that an application requiring database access will not fail, causing data to be lost.
A process in your application needs to query a database table for data.
Once you’ve executed the query, you can retrieve the results of the query into a ResultSet object.
The following example queries a database table named RECIPES and prints results:
String qry = "select recipe_num, name, description from recipes"; Statement stmt = null;
If you execute this code using the database script that is included with Chapter 11, you will receive the following results:
One of the most commonly performed operations against a database is a query.
Performing database queries using JDBC is quite easy, although there is a bit of boilerplate code that needs to be used each time a query is executed.
First, you need to obtain a Connection object for the database and schema that you want to run the query against.
You can do this by using one of the solutions found in Recipe 11-1
Next, you need to form a query and store it in String format.
The Connection object is then used to create a Statement.
Your query String will be passed to the Statement object’s executeQuery() method in order to actually query the database.
String qry = "select recipe_num, name, description from recipes"; Statement stmt = null;
As you can see, the Statement object’s executeQuery() method accepts a String and returns a ResultSet object.
The ResultSet object makes it easy to work with the query results so that you can obtain the information you need in any order.
If you take a look at the next line of code, a while-loop is created on the ResultSet object.
This loop will continue to call the ResultSet object’s next() method, obtaining the next row that is returned from the query with each iteration.
In this case, the ResultSet object is named rs, so while rs.next() returns true, the loop will continue to be processed.
Once all the returned rows have been processed, rs.next() will return a false to indicate that there are no more rows to be processed.
The ResultSet object is parsed to obtain the values of the given column names with each pass.
Notice that if the column is expected to return a String, you must call the ResultSet getString() method, passing the column name in String format.
Similarly, if the column is expected to return an int, you’d call the ResultSet getInt() method, passing the column name in String format.
In the example in the solution to this recipe, those values are stored into local variables.
Once the column value has been obtained, you can do what you want to do with the values you have stored within local variables.
In this case, they are printed out using the System.out() method.
Notice that there is a try-catch-finally block used in this example.
You must provide exception handling to handle errors in these situations.
The catch block then handles a SQLException, so if one is thrown the exception will be handled using the code within the catch block.
Sounds easy enough, right? It is, but you must do it each time you perform a database query.
Inside the finally block, you will see that the Statement and Connection objects are closed if they are not equal to null.
They might occur if an attempt is made to close a null object.
It is always a good idea to close statements and connections if they are open.
This will help ensure that the system can reallocate resources as needed, and act respectfully on the database.
It is important to close connections as soon as possible so that other processes can reuse them.
You need to have the ability to perform standard database operations within your application.
That is, you need the ability to create, retrieve, update, and delete (CRUD) database records.
The following code excerpts demonstrate how to perform each of the CRUD operations using JDBC:
The same basic code format is used for performing just about every database task.
Close the statement (and database connection if finished using it)
The main difference between performing a query using JDBC and using data manipulation language (DML) is that you will call different methods on the Statement object, depending on which operation you want to perform.
To perform a query, you need to call the Statement executeQuery() method.
In order to perform DML tasks such as insert, update, and delete, call the executeUpdate() method.
The performCreate() method in the solution to this recipe demonstrates the operation of inserting a record into a database.
To insert a record in the database, you will construct an SQL insert statement in String format.
To perform the insert, pass the SQL string to the Statement object’s executeUpdate() method.
If the insert is performed, an int value will be returned that specifies the number or rows that have been inserted.
If the insert operation is not performed successfully, either a zero will be returned or an SQLException will be thrown, indicating a problem with the statement or database connection.
The performRead() method in the solution to this recipe demonstrates the operation of querying the database.
To execute a query, you will call the Statement object’s executeQuery() method, passing an SQL statement in String format.
The result will be a ResultSet object, which can then be used to work with the returned data.
For more information on performing queries, please see Recipe 11-3
The performUpdate() method in the solution to this recipe demonstrates the operation of updating record(s) within a database table.
First, you will construct an SQL update statement in String format.
Next, to perform the update operation you will pass the SQL string to the Statement object’s executeUpdate() method.
If the update is successfully performed, an int value will be returned, which.
If the update operation is not performed successfully, either a zero will be returned or an SQLException will be thrown, indicating a problem with the statement or database connection.
The last database operation that needs to be covered is the delete operation.
The performDelete() method in the solution to this recipe demonstrates the operation of deleting record(s) from the database.
First, you will construct an SQL delete statement in String format.
Next, to execute the deletion, you will pass the SQL string to the Statement object’s executeUpdate() method.
If the deletion is successful, an int value specifying the number of rows deleted will be returned.
Otherwise, if the deletion fails, a zero will be returned or an SQLException will be thrown, indicating a problem with the statement or database connection.
Almost every database application uses at least one of the CRUD operations at some point.
This is foundational JDBC that needs to be known if you are working with databases within Java applications.
Even if you will not work directly with the JDBC API, it is good to know these foundational basics.
In order to work with the database, you need to open a connection.
Rather than code the logic to open a database connection every time you need to access the database, you’d like to use a single class to perform that task.
Write a class to handle all the connection management within your application.
Doing so will allow you to call that class in order to obtain a connection, rather than setting up a new Connection object each time you need access to the database.
Perform the following steps to set up a connection management environment for your JDBC application:
Place the file somewhere on your CLASSPATH so that the CreateConnection class can load it.
The following code is a listing of the CreateConnection class that can be used for centralized connection management:
String hostname = null; String port = null; String database = null; String username = null; String password = null; String jndi = null;
Next, the following lines of text are an example of what should be contained in the properties file that is used for obtaining a connection to the database.
Finally, use the CreateConnection class to obtain connections for your application.
Obtaining a connection within a database application can be code intensive.
Moreover, the process can be prone to error if you retype the code each time you need to obtain a connection.
By encapsulating database connection logic within a single class, you can reuse the same connection code each time you require a connection to the database.
This increases your productivity, reduces the chances of typing errors, and also enhances manageability because if you have to make a change, it can occur in one place rather than in several different locations.
Creating a strategic connection methodology is beneficial to you and others who might need to maintain your code in the future.
Although data sources are the preferred technique for managing database connections when using an application server or JNDI, the solution to this recipe demonstrates the use standard JDBC DriverManager connections.
One of the security implications of using the DriverManager is that you will need to store the database credentials somewhere for use by the application.
It is not safe to store those credentials in plain text anywhere, and it is also not safe to embed them in application code, which might be decompiled at some point in the future.
As seen in the solution, a properties file that on disk is used to store the database credentials.
Assume that this properties file will be encrypted at some point before deployment to a server.
As seen in the solution, the code reads the database credentials, hostname, database name, and port number from the properties file.
That information is then pieced together to form a JDBC URL that can be used by DriverManager to obtain a connection to the database.
Once obtained, that connection can be used anywhere and then closed.
Similarly, if using a DataSource that has been deployed to an application server, the properties file can be used to store the JNDI connection.
That is the only piece of information that is needed to obtain a connection to the database using the DataSource.
To the developer, the only difference between the two types of connections would be the method name that is called in order to obtain the Connection object.
One could develop a JDBC application so that the code that is used to obtain a connection needs to be hard-coded throughout.
Instead, this solution enables all the code for obtaining a connection to be encapsulated by a single class so that the developer does not need to worry about it.
Such a technique also allows the code to be more maintainable.
For instance, if the application were originally deployed using the DriverManager, but then later had the ability to use a DataSource, very little code would need to be changed.
To reduce the chances of an SQL injection attack, you need to ensure that no unfiltered Strings of text are being appended to SQL statements and executed against the database.
Tip  Prepared statements are for more than just protecting against SQL injection.
They also give you a way to centralize and better control the SQL used in an application.
Instead of creating multiple, possibly different versions of the same query, for example, you can create the query once as a prepared statement and invoke it from many places in your code.
Any change to the query logic need happen only at the point that you prepare the statement.
PreparedStatements send a precompiled SQL statement to the DBMS rather than a String.
In the following code example, a PreparedStatement is used to query a database for a given record.
Assume that the String recipeNumber is passed to this code as a variable.
The next example demonstrates the use of a PreparedStatement for inserting a record into the database.
Assume that the Strings recipeNumber, title, description, and text are passed to this code as variables.
In this last example, a PreparedStatement is used to delete a record from the database.
Again, assume that the String recipeNumber is passed to this code as a variable.
As you can see, a PreparedStatement is very much the same as a standard JDBC Statement object, but instead it sends precompiled SQL to the DBMS rather than Strings of text.
While standard JDBC statements will get the job done, the harsh reality is that they can sometimes be insecure and difficult to work with.
For instance, bad things can occur if a dynamic SQL statement is used to query a database, and a user-accepted String is assigned to a variable and concatenated with the intended SQL String.
In most ordinary cases, the user-accepted String would be concatenated, and the SQL String would be used to query the database as expected.
The use of PreparedStatements prevents such malicious Strings from being concatenated into a SQL string and passed to the DBMS because they use a different approach.
PreparedStatements use substitution variables rather than concatenation to make SQL strings dynamic.
They are also precompiled, which means that a valid SQL string is formed prior to the SQL being sent to the DBMS.
Moreover, PreparedStatements can help your application perform better because if the same SQL has to be run more than one time, it has to be compiled only once.
After that, the substitution variables are interchangeable, but the overall SQL can be executed by the PreparedStatement very quickly.
Let’s take a look at how a PreparedStatement works in practice.
If you look at the first example in the solution to this recipe, you can see that the database table RECIPES is being queried, passing a RECIPE_NUM and retrieving the results for the matching record.
Everything looks standard with the SQL text except for the question mark (?) at the end of the string.
Placing a question mark within a string of SQL signifies that a substitute variable will be used in-place of that question mark when the SQL is executed.
The next step for using a PreparedStatement is to declare a variable of type PreparedStatement.
This can be seen with the following line of code:
Now that a PreparedStatement has been declared, it can be put to use.
However, use of a PreparedStatement might or might not cause an exception to be thrown.
Therefore, any use of a PreparedStatement should occur within a try-catch block so that any exceptions can be handled gracefully.
For instance, exceptions can occur if the database connection is unavailable for some reason or if the SQL string is invalid.
Rather than crashing an application due to such issues, it is best to handle the exceptions wisely within a catch block.
The following try-catch block includes the code that is necessary to send the SQL string to the database and retrieve results:
First, you can see that the Connection object is used to instantiate a PreparedStatement object.
The SQL string is passed to the PreparedStatement object’s constructor upon creation.
Next, the PreparedStatement object is used to set values for any substitution variables that have been placed into the SQL string.
As you can see, the PreparedStatement setString() method is used in the example to set the substitution variable at position 1 equal to the contents of the recipeNumber variable.
The positioning of the substitution variable is associated with the placement of the question mark (?) within the SQL string.
The first question mark within the string is assigned to the first position, the second one is assigned to the second position, and so forth.
If there were more than one substitution variable to be assigned, there would be more than one call against the PreparedStatement, assigning each of the variables until each one has been accounted for.
PreparedStatements can accept substitution variables of many different data types.
For instance, if an int value were being assigned to a substitution variable, a call to the setInt(position, variable) method would be in order.
Please see online documentation or your IDE’s code completion for a complete set of methods that can be used for assigning substitution variables using PreparedStatement objects.
Once all the variables have been assigned, the SQL string can be executed.
The PreparedStatement object contains an executeQuery() method that is used to execute a SQL string that represents a query.
The executeQuery() method returns a ResultSet object, which contains the results that have been fetched from the database for the particular SQL query.
Next, the ResultSet can be traversed to obtain the values retrieved from the database.
Again, positional assignments are used to retrieve the results by calling the ResultSet object’s corresponding getter methods and passing the position of the column value that you want to obtain.
The position is determined by the order in which the column names appear within the SQL string.
In the example, the first position corresponds to the RECIPE_NUM column, the second corresponds to the NAME column, and so forth.
If the recipeNumber String variable was equal to “11-1”, the results of executing the query in the example would look something like the following:
Of course, if the substitution variable is not set correctly or if there is an issue with the SQL string, an exception will be thrown.
This would cause the code that is contained within the catch block to be executed.
You should also be sure to clean up after using PreparedStatements by closing the statement when you are finished using it.
It is a good practice to put all the cleanup code within a finally block to be sure that it is executed even if an exception is thrown.
In the example, the finally block looks like the following:
You can see that the PreparedStatement object that was instantiated, pstmt, is checked to see whether it is NULL.
If not,  it is closed by calling the close() method.
Working through the code in the solution to this recipe, you can see that similar code is used to process database insert, update, and delete statements.
The only difference in those cases is that the PreparedStatement executeUpdate() method is called rather than the executeQuery() method.
The executeUpdate() method will return an int value representing the number of rows affected by the SQL statement.
The use of PreparedStatement objects is preferred over JDBC Statement objects.
This is due to the fact that they are more secure and perform better.
They can also make your code easier to follow, and easier to maintain.
The way in which your application is structured requires a sequential processing of tasks.
One task depends upon another, and each process performs a different database action.
If one of the tasks along the way fails, the database processing that has already occurred needs to be reversed.
Set your Connection object auto-commit to false and then perform the transactions you want to complete.
Once you’ve successfully performed each of the transactions, manually commit the Connection object; otherwise roll back each of the transactions that have taken place.
In the following code example, you can see transaction management take place.
If you look within the main() method of the TransactionExample class, you will see that the Connection object’s autoCommit() preference has been set to false; then the database transactions are performed.
If all the transactions are successful, the Connection object is manually committed by calling the commit() method; otherwise, all the transactions are rolled back by calling the rollback() method.
In the end, if any of the statements fails, all transactions will be rolled back.
However, if all the statements execute properly, everything will be committed.
Transaction management can play an important role in an application.
This holds true especially for applications that perform different tasks that depend upon each other.
In many cases, if one of the tasks that is performed within a transaction fails, it is preferable for the entire transaction to fail rather than having it only partially complete.
For instance, imagine that you were adding database user records to your application database.
Now let’s say that adding a user for your application required a couple of different database tables to be modified, maybe a table for roles, and so on.
What would happen if your first table was modified correctly, and the second table modification failed? You would be left with a partially complete application user addition, and your user would most likely not be able to access the application as expected.
In such a situation, it would be nicer to roll back all the already-completed database modifications if one of the updates failed so that the database was left in a clean state and the transaction could be attempted once again.
By default, a Connection object is set up so that auto-commit is turned on.
That means that each database insert, update, or delete statement is committed right away.
Usually, this is the way that we would like for our applications to function.
However, in circumstances where we might have many database statements that rely upon one another, it is important to turn off auto-commit so that all the statements can be committed at once.
To do so, call the Connection object’s setAutoCommit() method and pass a false value.
As you can see in the solution to this recipe, the setAutoCommit() method is called passing a false value, the database statements are executed.
Doing so will cause all the database statement changes to be temporary until the Connection object’s commit() method is called.
This provides you with the ability to ensure that all the statements execute properly before calling commit()
Take a look at this transaction management code that is contained within the main() method of the TransactionExample class within the solution to this recipe:
Note that the commit() method is only called if all transaction statements were processed successfully.
If any of them fail, the successFlag is equal to false, which would cause the rollback() method to be called instead.
In the solution to this recipe, the second call to insertRecord() attempts to insert a NULL value into the RECIPE.ID column, which is not allowed.
Therefore, that insert fails and everything, including the previous insert, gets rolled back.
You want to store those results in an object that will allow you to traverse forward and backward through the results, updating values as needed.
Create a scrollable ResultSet object and then you will have the ability to read the next, first record, last, and previous record.
Using a scrollable ResultSet allows the results of a query to be fetched in any direction so that the data can be retrieved as needed.
The following example method demonstrates the creation of a scrollable ResultSet object:
Executing this method will result in the following output using the data that was originally loaded for this chapter:
Ordinary ResultSet objects allow results to be fetched in a forward direction.
That is, an application can process a default ResultSet object from the first record retrieved forward to the last.
Sometimes an application requires more functionality when it comes to traversing a ResultSet.
For instance, let’s say you want to write an application that allows for someone to display the first or last record that was retrieved, or perhaps page forward or backwards through results.
You could not do this very easily using a standard ResultSet.
However, by creating a scrollable ResultSet, you can easily move backwards and forwards through the results.
To create a scrollable ResultSet, you must first create an instance of a Statement or PreparedStatement that has the ability to create a scrollable ResultSet.
That is, when creating the Statement, you must pass the ResultSet scroll type constant value to the Connection object’s createStatement() method.
Likewise, you must pass the scroll type constant value to the Connection object’s prepareStatement() method when using a PreparedStatement.
There are three different scroll type constants that can be used.
You must also pass a ResultSet concurrency constant to advise whether the ResultSet is intended to.
In the solution to this recipe, a PreparedStatement object is used, and the code to create a PreparedStatement object that has the ability to generate a scrollable ResultSet looks like the following line:
Once the PreparedStatement has been created as such, a scrollable ResultSet is returned.
You can traverse in several different directions using a scrollable ResultSet by calling the ResultSet methods indicating the direction you want to move or the placement that you want to be.
The following line of code will retrieve the first record within the ResultSet:
The solution to this recipe demonstrates a few different scroll directions.
Specifically, you can see that the ResultSet first(), next(), last(), and previous() methods are called in order to move to different positions within the ResultSet.
For a complete reference to the ResultSet object, please see the online documentation that can be found at http://download.oracle.com/javase/7/docs/api/java/sql/ResultSet.html.
They are one of those niceties that are there when you need them, but they are also something that you might not need very often.
An application task has queried the database and obtained results.
You have stored those results into a ResultSet object, and you want to update some of those values in the ResultSet and commit them back to the database.
Make your ResultSet object updatable and then update the rows as needed while iterating through the results.
The following example method demonstrates how to make ResultSet updatable and then how to update content within that ResultSet, eventually persisting it in the database:
This method could be called passing a String value containing a recipe number.
Suppose that the recipe number “11-1” was passed to this method; the following output would be the result:
Sometimes it makes sense to update data as you are parsing it.
Usually this technique involves testing the values that are being returned from the database and updating them if they compare to some other value in one way or another.
Doing so will allow the Statement or PreparedStatement object that is returned as a result of calling those methods to produce an updatable ResultSet.
Note Some database JDBC drivers do not support updatable ResultSets.
Please see the documentation for your JDBC driver for more information.
The format for creating a Statement that will produce an updatable ResultSet is to pass the ResultSet type as the first argument and the ResultSet concurrency as the second argument.
The following code demonstrates this technique by creating a Statement object that will produce a scrollable and updatable ResultSet object:
The format for creating a PreparedStatement that will produce an updatable ResultSet is to pass the SQL string as the first argument, the ResultSet type as the second argument, and the ResultSet concurrency as the third argument.
The solution to this recipe demonstrates this technique using the following line of code:
Both of the lines of code discussed in this section will produce scrollable and updatable ResultSet objects.
Once you have obtained an updatable ResultSet, you can use it just like an ordinary ResultSet for fetching values that are retrieved from the database.
In addition, you can call one of the ResultSet object’s updateXXX() methods to update any value within the ResultSet.
In the solution to this recipe, the updateString() method is called, passing the position of the value from the query as the first argument and the updated text as the second argument.
In this case, the fourth element column listed in the SQL query will be updated.
Finally, to persist the values that you have changed, call the ResultSet updateRow() method, as seen in the solution to this recipe:
Creating an updatable ResultSet is not something that you will need to do every day.
In fact, you might never need to create an updatable ResultSet.
However, for the cases in which such a strategy is needed, this technique can come in very handy.
You want to work with data from a DBMS when you are in a disconnected state.
That is, you are working on a device that is not connected to the database, and you still want to have the ability to work with a set of data as though you are connected.
For instance, you are working with data on a small portable device, and you are away from the office without a connection.
You want the ability to query, insert, update, and delete data, even though there is no connection available.
Once a connection becomes available, you want to have your device synchronize any database changes that have been made while disconnected.
Use a CachedRowSet object to store the data that you want to work with while offline.
This will afford your application the ability to work with data as though it were connected to a database.
Once your connection is restored or you connect back to the database, synchronize the data that has been changed within the CachedRowSet with the database repository.
The following example class demonstrates the usage of a CachedRowSet.
Suppose that there was no main() method, though, and that another application on a portable device were to invoke the methods of this class.
Follow the code in the example and consider the possibility of working with the results that are stored within the CachedRowSet while not connected to the database.
For instance, suppose that you began some work in the office while connected to the network and are now outside of the office, where the network is spotty and you cannot maintain a constant connection to the database:
Running this example code will display output that looks similar to the following code, although the text might vary depending upon the values in the database.
Notice that the database record for Recipe 11-2 has a changed description after the update of the CachedRowSet.
It is not possible to remain connected to the Internet 100 percent of the time if you are working on a mobile device and traveling.
Nowadays there are devices that allow us to perform substantial work while we are on the go, even when we are not connected directly to a database.
In such cases, solutions like the CachedRowSet object can come into play.
The CachedRowSet is the same as a regular ResultSet object, except it does not have to maintain a connection to a database in order to remain usable.
You can query the database, obtain the results, and place them into a CachedRowSet object; and then work with them while not connected to the database.
If changes are made to the data at any point, those changes can be synchronized with the database at a later time.
There are a couple of different ways to create a CachedRowSet.
However, you can also use the CachedRowSet default constructor to create a new instance.
Doing so would look like the following line of code:
Once instantiated, you need to set up a connection to the database.
There are also a couple of ways to do this.
Properties could be set for the connection that will be used, and the solution to this recipe demonstrates this technique within comments.
The following excerpt from the solution sets the connection properties using the CachedRowSet object’s setUsername(), setPassword(), and setUrl() methods.
Each of them accepts a String value, and in the example that String is obtained from the CreateConnection class:
Another way to set up the connection is to wait until the query is executed and pass a Connection object to the executeQuery() method.
This is the technique that is used in the solution to this recipe.
But before we can execute the query, it must be set using the setCommand() method, which accepts a String value.
In this case, the String is the SQL query that we need to execute:
Next, if a CachedRowSet will be used for updates, the primary key values should be noted using the setKeys() method.
This method accepts an int array that includes the positional indices of the key columns.
In this case, the first column listed in the query, ID, is the primary key:
Finally, execute the query and populate the CachedRowSet using the execute() method.
As mentioned previously, the execute() method optionally accepts a Connection object, which allows the CachedRowSet to obtain a database connection.
Once the query has been executed and the CachedRowSet has been populated, it can be used just like any other ResultSet.
You can use it to fetch records forward and backward, or by specifying the absolute position of the row you’d like to retrieve.
The solution to this recipe only demonstrates a couple of these fetching methods, but the most-often-used ones are listed in Table 11-2
It is possible to insert and update rows within a CachedRowSet.
Then populate a row by using the various methods [CachedRowSet, updateString(), updateInt(), and so on] that correspond to the data type of the column you are populating within the row.
Once you have populated each of the required columns within the row, call the insertRow() method, followed by the moveToCurrentRow() method.
The following lines of code demonstrate inserting a record into the RECIPES table:
Simply update the values using the CachedRowSet object’s methods [updateString(), updateInt(), and so on] methods that correspond to the data type of the column that you are updating within the row.
Once you have updated the column or columns within the row, call the updateRow() method.
This technique is demonstrated in the solution to this recipe.
To make any updates or inserts propagate to the database, the acceptChanges() method must be called.
This method can accept an optional Connection argument in order to connect to the database.
Unfortunately, because time might have elapsed since the data was last retrieved for the CachedRowSet, there could be conflicts.
You can catch these exceptions and handle the conflicts manually using a SyncResolver object.
However, resolving conflicts is out of the scope of this recipe, so for more information, please see the online documentation that can be found at http://download.oracle.com/javase/tutorial/jdbc/basics/cachedrowset.html.
CachedRowSet objects provide great flexibility for working with data, especially when you are using a device that is not always connected to the database.
However, they can also be overkill in situations where you can simply use a standard ResultSet or even a scrollable ResultSet.
You want to join two or more RowSets while not connected to a database.
Perhaps your application is loaded on a mobile device that is not connected to the database 100 percent of the time.
In such a case, you are looking for a solution that will allow you to join the results of two or more queries.
Use a JoinRowSet to take data from two relational database tables and join them.
The data from each table that will be joined should be fetched into a RowSet and then the JoinRowSet can be used to join each of those RowSet objects based upon related elements that are contained within them.
For instance, suppose that there were two related tables contained within a database.
One of the tables stores a list of authors, and the other table contains a list of chapters that are written by those authors.
The two tables can be joined using SQL by the primary and foreign key relationship.
Note A primary key is a unique identifier within each record of a database table, and a foreign key is a referential constraint between two tables.
However, the application will not be connected to the database to make the JOIN query, so it must be done using a JoinRowSet.
The following class listing demonstrates one strategy that can be used in this scenario:
Running this class will result in output that resembles the following:
A JoinRowSet is a combination of two or more populated RowSet objects.
It can be used to join two RowSet objects based upon key value relationships, just as if it were a SQL JOIN query.
In order to create a JoinRowSet, you must first populate two or more RowSet objects with related data, and then they can each be added to the JoinRowSet to create the combined result.
Following along with the main() method, first the BOOK_AUTHOR table is queried, and its results are fetched into a CachedRowSet using the queryBookAuthor() method.
For more details regarding the use of CachedRowSet objects, please see Recipe 11-10
Next, another CachedRowSet is populated with the results of querying the AUTHOR_WORK table, as the queryAuthorBook() method is called.
At this point, there are two populated CacheRowSet objects, and they can now be combined using a JoinRowSet.
In order to do so, each table must contain one or more columns that relate to the other table.
The final method that is invoked within the main() is joinRowQuery()
This method is where all the JoinRowSet work takes place.
First, a new JoinRowSet is created by instantiating a JoinRowSetImpl() object:
Note You will receive a compile-time warning when using JoinRowSetImpl because it is an internal SUN proprietary API.
However, the Oracle version is OracleJoinRowSet, which is not as versatile.
Next, the two CachedRowSet objects are added to the newly created JoinRowSet by calling its addRowSet() method.
The first is the name of the RowSet object that you want to add to the JoinRowSet, and the second is an int value indicating the position within the CachedRowSet, which contains the key value that will be used to implement the join.
The JoinRowSet can now be used to fetch the results of the join, just as if it were a normal RowSet.
When calling the corresponding methods [getString(), getInt(), and so on] of the JoinRowSet, pass the name of the database column corresponding to the data you want to store:
Although a JoinRowSet is not needed every day, it can be handy when performing work against two related sets of data.
This especially holds true if the application is not connected to a database all the time, or if you are trying to use as few Connection objects as possible.
Your application queries the database and returns a large number of rows.
The number of rows within the cached ResultSet is too large for the user to work with at one time.
You would like to limit the number of rows that are made visible so that you can perform different activities with different sets of data that have been queried from the table.
Use a FilteredRowSet to query the database and store the contents.
The FilteredRowSet can be configured to filter the results that are returned from the query so that the only contents visible are the rows that you want to see.
In the following example, a filter class is created that will be used to filter the results that are returned from a database query.
The filter in the example is used to limit the number of rows that are visible based upon author name.
The filter is used by a FilteredRowSet to limit the visible results from a query.
The results of running this code would look similar to the following lines.
Notice that only the rows of data corresponding to the authors listed in the filter are returned with the FilteredRowSet.
Often, the results that are returned from a database query contain a large number of rows.
As you probably know, too many rows can create issues when it comes to visually working with data.
It usually helps to limit the number of rows that are returned from a query by using a WHERE clause on an SQL statement.
However, if an application retrieves data into an in-memory RowSet and then needs to filter the data by various criteria without additional database requests, an approach other than a query needs to be used.
A FilteredRowSet can be used to filter data that is displayed within a populated RowSet so that it can be more manageable to work with.
First, a filter needs to be created that will be used to specify how the data should be filtered.
There should be multiple constructors, each accepting a different set of arguments, and the filter should contain multiple evaluate() methods that each accept different arguments and contain different implementations.
The constructors should accept an array of contents that can be used to filter the RowSet.
They should also accept a second argument, either the column name that the filter should be used against or the position of the column that the filter should be used against.
In the solution to this recipe, the filter class is named AuthorFilter, and it is used to filter data per an array of author names.
Its constructors each accept an array containing the author names to filter, along with either the column name or position.
Each of the evaluate() methods has the task of determining whether a given row of data matches the specified filter; in this case, the author names that have been passed in via an array.
The first evaluate() method is called if a column name is passed to the filter rather than a position, and the second evaluate() method is called if a column position is passed.
The final evaluate() method accepts the RowSet itself, and it does the work of going through it and returning a Boolean to indicate whether the corresponding column name/position values match the filter data.
The second part of the FilteredRowSet implementation is the work of the FilteredRowSet.
The FilteredRowSet will actually use the filter class that we’ve written to determine which rows to display.
You can see that the array of values that will be passed to the filter class is the first declaration within the method.
The second declaration is the instantiation of the filter class AuthorFilter.
Of course, the array of filter values and the column position that corresponds to the filter values is passed into the filter constructor.
To instantiate a FilteredRowSet, create a new instance of the FilteredRowSetImpl class.
After it is instantiated, simply set the SQL query that will be used to obtain the results using the setCommand() method and then execute it by calling the executeQuery() method.
Note You will receive a compile-time warning when using FilteredRowSetImpl because it is an internal SUN proprietary API.
Actually, at this point what we have is a scrollable RowSet that is populated with all the results from the query.
To apply the filter, use the setFilter() method, passing the filter as an argument.
Once that has been done, the FilteredResultSet will display only those rows that match the criteria specified by the filter.
Again, the FilteredRowSet is a technique that has its place, especially when you are working with an application that might not always be connected to a database.
It is a powerful tool to use for filtering data, working with it, and then applying different filters and working on the new results.
It is like applying WHERE clauses to a query without querying the database.
The application that you are developing requires the storage of Strings of text that can include an unlimited number of characters.
Because the size of the Strings that need to be stored is unlimited, it is best to use a character large object (CLOB) data type to store the data.
The code in the following example demonstrates how to load a CLOB into the database and how to query it:
If your application requires the storage of String values, you need to know how large those Strings might possibly become.
Most databases have an upper boundary when it comes to the storage size of VARCHAR fields.
For instance, the Oracle database has an upper boundary of 2000 characters and anything exceeding that length will be cut off.
If you have large amounts of text that need to be stored, use a CLOB field in the database.
A CLOB is handled a bit differently from a String within Java code.
In fact, it is actually a bit odd to work with the first couple of times you use it because you have to create a CLOB from a Connection.
Note In reality, CLOBs and BLOBs (binary large objects) are not stored in the Oracle table where they are defined.
Instead, a large object (LOB) locator is stored in the table column.
Oracle might place the CLOB in a separate file on the database server.
When Java creates the Clob object, it can be used to hold data for update to a specific LOB location in the database or to retrieve the data from a specific LOB location within the database.
Let’s take a look at the loadClob() method that is contained in the solution to this recipe.
As you can see, a Clob object is created using the Connection createClob() method.
Once the Clob has been created, you set its contents using the setString() method by passing the position indicating where to place the String, and the String of text itself:
Once you have created and populated the Clob, you simply pass it to the database using the PreparedStatement setClob() method.
In the case of this example, the PreparedStatement performs a database insert into the RECIPE_TEXT table by calling the executeUpdate() method as usual.
As you can see in the readClob() method that is contained within the solution to this recipe, a PreparedStatement query is set up an the results are retrieved into a ResultSet.
The only difference between using a Clob and a String is that you must load the Clob into a Clob type.
Calling the Clob getString() method will pass you a funny-looking String of text that denotes a Clob object.
Therefore, calling the Clob object’s getAsciiStream() method will return the actual data that is stored in the Clob.
This technique is used in the solution to this recipe.
Although Clobs are fairly easy to use, they take a couple of extra steps to prepare.
It is best to plan your applications accordingly and try to estimate whether the database fields you are using might need to be CLOBs due to size restrictions.
Proper planning will prevent you from going back and changing standard String-based code to work with Clobs later.
The database you are working with includes some VARRAY columns that need to be populated by your application.
Note This recipe solution is specific to the Oracle database, but other vendors have similar data structures that can be used in a similar manner.
To create a VARRAY type within an Oracle database, you must first define a TYPE, which you would like to use for the VARRAY.
The following SQL declares a TYPE of CHAP_LIST_TYPE, which will be used to create the VARRAY column.
Now that an SQL TYPE has been created, it can be used to represent a VARRAY column in a database table.
The following SQL can be used to create a table that contains a VARRAY column of the CHAP_LIST_TYPE type:
Executing the class in this example will cause a record to be inserted into the AUTHOR_RECIPES table, including the array of content that lists the chapters that have been written by the corresponding author.
Most databases contain a data type that can be mapped to a Java array.
Such data types allow an array of data to be stored within a single column of a database table.
Such is the case with the table that is used in the solution to this recipe: AUTHOR_RECIPES.
This table contains a column that accepts an array of NUMBER values that correspond to the chapter numbers that were written by the author that is tied to the AUTHOR_ID.
There are a couple of steps that need to be taken on a standard Java array before it can be inserted into a database.
If you take a look at the storeArray() method in the solution to this recipe, you can see that an Object[] has been declared that contains a set of numbers.
These numbers correspond to the chapters that we want to populate into the database VARRAY column.
Next an ArrayDescriptor is created, which will identify the VARRAY type within the database.
The chapterArray is now in a format that can be inserted into the database.
This is done by using the PreparedStatement setArray() method, passing the position of the parameter along with the ARRAY.
Different RDBMSs contain different implementations of the array data type.
The Oracle database uses the VARRAY, and this solution will work for the purpose of inserting objects into that data type.
However, the same solution will work for inserting into other database array types.
All you need to do is substitute the specific RDBMS data type that is used to convert the standard Java array.
You have stored some objects into a database in VARRAY format and would like to retrieve them via your application.
Note This recipe solution is specific to the Oracle database, but other vendors have similar data structures that can be used in a similar manner.
Load the contents of a VARRAY or another database array type into a java.sql.Array object.
Once they have been loaded into an Array, extract the contents into a standard array corresponding to the data type of the values that are contained within the array.
The following class queries a database table that contains a VARRAY column.
The VARRAY column is populated with data that corresponds to the database NUMBER data type.
The results of running this code will look something like the following, depending upon the data that is contained within your local database:
In order to work with data that has been stored in an array format within a database table, you must convert the data into a standard Java array so that it can be parsed.
In the solution to this recipe, an Oracle database table that contains a VARRAY column is queried and then the results of the VARRAY column are converted into a standard Java array.
After the conversion has taken place, the results are printed out.
To retrieve the Oracle VARRAY data, create a java.sql.Array object and fetch the contents into it using the PreparedStatement getArray() method.
In the solution to this recipe, a java.sql.Array object named chapters is used to hold the data from the database VARRAY column.
After the java.sql.Array has been populated with the data, it can be converted into a standard Java array by calling the getArray() method and casting it based upon the data type of the values contained within the array.
Because the Oracle type was defined as an array of type NUMBER, the values are returned to Java as an array of type BigDecimal.
Once the standard Java array object has been populated, the values can be used.
In the solution to this recipe, the values are printed out.
Although this example was written against an Oracle database that contains a table with a VARRAY column, the same techniques could be used to extract the data from another RDBMS that contained a table with an array type column.
Some logic that is required for your application is written as a database stored procedure.
You require the ability to invoke the stored procedure from within your application.
The following block of code shows the PL/SQL that is required to create the stored procedure that will be called by Java.
The functionality of this stored procedure is very minor; it simply accepts a value and assigns that value to an OUT parameter so that the program can display it:
Do something, in this case the IN parameter value is assigned to the OUT parameter msg :=text; end;
The CallableStatement in the following code executes this stored procedure that is contained within the database, passing the necessary parameters.
The results of the OUT parameter are then displayed back to the user.
Running the example class for this recipe will display the following output, which is the same as the input.
This is because the DUMMY_PROC procedure simply assigns the contents if the IN parameter to the OUT parameter.
Once the CallableStatement has been instantiated, it can be used just like a PreparedStatement for setting the values of parameters.
In the solution to this recipe, the OUT parameter is in the second position and it has a VARCHAR type.
To execute the stored procedure, call the executeQuery() method on the CallableStatement.
Once this has been done, you can see the value of the OUT parameter by making a call to the CallableStatement getXXX() method that corresponds to the data type:
Calling a stored database function is essentially the same as calling a stored procedure.
To call a stored function, change the call within the curly braces to entail a returned value using a ? character.
For instance, suppose that a function named DUMMY_FUNC accepted one parameter and returned a value.
The following code would be used to make the call and return the value:
A call to cs.getString(1) would then retrieve the returned value.
Rather than manually opening and closing resources with each database call, you would prefer to have the application handle such boilerplate code for you.
Use the try-with-resources syntax to automatically close the resources that you open.
The following block of code uses this tactic to automatically close the Connection, Statement, and ResultSet resources when it is finished using them:
The resulting output from running this code should look similar to the following:
Handling JDBC resources has always been a pain in the neck.
There is a lot of boilerplate code that is required for closing resources when they are no longer needed.
Through the use of this technique, the developer no longer needs to close each resource manually, which is a change that can cut down on many lines of code.
In order to use this technique, you must instantiate all the resources for which you want to have automatic handling enabled within a set of parentheses after a try clause.
In the solution to this recipe, the resources that are declared are Connection, Statement, and ResultSet.
Once those resources are out of scope, they are automatically closed.
This means there is no longer a requirement to code a finally block to ensure that resources are closed.
The solution to this recipe executes the same query as that of Recipe 11-3
Go back and compare the amount of code that is written in order to handle the resources manually with this code using the automatic resource handling; it can leave a developer wondering what they are going to do with all their newly found “free time”!
Other operations such as File I/O adhere to the new API as well.
To put things simply, Java 2D is an API to render two-dimensional graphics on surfaces such as computer screens, printers, and devices.
This powerful API allows you to do things such as drawing geometric shapes, image processing, alpha compositing (combining images), text font rendering, antialiasing, clipping, creating transformations, stroking, filling, and printing.
Breaking news! When giving news I’m sure you’ve heard people say, “I’ve got good news and bad news”
Well, in the case of Java 2D, it is good news and more good news.
XRender will have access to hardware accelerated features on systems with modern graphics processing units (GPUs)
This is great news to many existing Java applications that use Java 2D already because they will gain excellent rendering performance without changing any code.
Things can only get better as the major players get onboard with the Open JDK initiative.
Regarding the 2D API, you will notice that most recipes will rely on a utility helper class to launch an application window to display the examples.
This helper class allows you to focus on the actual recipe solution without having to see the application’s launching and displaying details.
Most of the recipes in this chapter extend the JComponent class and also containing a main() method.
This ensures that graphics rendering will happen on the event dispatching thread.
This code will display your GUI in a threadsafe manner using Swing’s invokeLater():
The Graphics object (system generated) that is passed into the paintComponent() method is the heart of Java 2D API and Swing API.
It is the workhorse responsible for rendering all the pixels that we see on the screen today.
To learn how to execute a Java program with passed-in arguments via the command line or terminal, please see recipe 1-4
Next, you will be looking at recipes that will help you understand the Java 2D API basics such as creating points, drawing lines, drawing shapes, and painting colors.
Note For more on painting using Java’s Swing, see the web article Painting in AWT and Swing, by Amy Fowler at http://java.sun.com/products/jfc/tsc/articles/painting (Oracle Corporation, 1999)
Problem You want to create points that are similar to points on a Cartesian coordinate system.
By using the correct constructor your points can maintain different number types with integer or decimal precision.
Following is the source code that uses the three Point2D subclasses:
How It Works When using any of the three Point2D subclasses, keep in mind that the methods getX() and getY() in all cases will return a double precision number.
The derived class Point2D.Float will allow the user of the API to access public instance variables x and y that will hold values of type float; while the java.awt.Point class will also have public instance variables, but hold values of type int.
Keep in mind that the values can be positive or negative in order to represent points in a Cartesian coordinate system also called user space.
Now that you know what kind of values are able to be stored you will want to plot or use points to draw lines, shapes, and so on.
It is important to know how to draw on a computer screen (also known as the device space)
The device space is the physical surface in which drawing will take place.
Figure 12-1 shows the device space and the output from this recipe’s code.
You may be wondering how to plot things onto the surface using points similar to a Cartesian graph or user space.
The x-coordinate values on the x-axis are positive values that increase from zero to the width of the device (as in user space)
The coordinate’s values are also positive, but increase in a downward direction to the bottom of the screen (opposite of user space)
In other words, all visible pixels on the device surface are positive values, including zero for (x, y) in device space.
Your x and y values can be negative values, but those pixels won’t be displayed on the screen.
Shown in Figure 12-1 are shapes drawn on the device space.
Since these objects represent points similar to Euclidean geometry, the 2D API also has other methods such as determining the distance between two points.
By definition, points do not have size nor color, so Java does not have a method such as drawPoint()
Problem You want to draw lines on the computer screen.
How It Works Although the code in the recipe solution looks simple, there is a lot of magic going on behind the scenes, and I would like to share with you some of the fundamentals.
Once you get the fundamentals down, the rest of the recipes will be easier to digest and understand.
There are three basic steps when drawing lines or shapes: painting, stroking, and drawing.
I would like to explain the code block right before you get to the code that actually draws lines.
In this case, the call isn’t necessary because our DrawLine class is directly extending from the JComponent class (which is the base class of all Java Swing components and therefore doesn’t have any descendents to draw)
Shown here is the DrawLines class that extends from the JComponent class and overrides the paintComponent() method:
Shown here is the Graphics object cast into a Graphics2D:
Finally, you will be painting the background with a color of light gray.
The width and height are derived from the parent container (in this case, the JFrame)
Because the paintComponent() method will be called during a resizing of the window, the clearRect() method will dynamically fill the background to gray as we resize the window.
For example, this code is clearing the background based on the dimensions of the parent container (JComponent):
The first step in drawing a line is setting the paint color.
The Color class has many predefined colors to choose from, but also there are many ways to construct a custom color (see recipe 12-4)
Shown here is how to set the graphic context with the predefined color red:
A stroke is synonymous with an artist’s paintbrush or a pencil, except you are using virtual ink to draw shapes.
By creating Stroke objects you will be able to influence a shape’s appearance such as its thickness, endpoint style, join point style, and dashed pattern.
I chose the BasicStroke constructor with the larger number of parameters in order for us to discuss all the ways you can create a stroke.
The dashed pattern represented an array of floats that is passed into the BasicStroke’s constructor.
Here’s an example of creating an instance of a BasicStroke:
Table 12-1 shows the available parameters when using one of the BasicStroke’s constructors.
This class is used to assist in drawing all shapes.
The kind of cap on the end of a line, curve, and open arc.
Dashed pattern alternating from visible to invisible based on a float value each representing the thickness.
Now that you understand how to set the stroke, the final step is to actually draw lines using the drawLine()method.
Fundamentally, lines in a Cartesian system are created using a starting point and an ending point.
In Java’s drawLine() method, it also needs a starting point and an ending point.
Looking at the source code for drawing the red line, you’ll notice it uses the standard drawLine() method, but the white and blue lines are drawn using the draw() method.
So, what is exactly the difference? The drawLine() method only draws lines using integer values for start- and endpoints, and the draw() method accepts any object of type java.awt.Shape.
The Line2D.Double class allows you to specify (x, y) coordinates for the start- and endpoints of a line with.
Here are two code statement examples that can be used to draw lines.
When shapes or lines join (or meet together), they can appear flat, pointed, or round, respectively.
As a reminder when using the constructor that has the parameter for miter limit, it will be ignored if the join style is not using JOIN_MITER.
Since you aren’t using the JOIN_MITER in this example, the miter parameters are set to zero.
Problem You want to draw shapes on the computer screen.
Solution Use Java’s many common shape classes that implement the java.awt.Shape interface.
Shown next is an example of drawing simple shapes such as an arc, ellipse, rectangle, and rounded rectangle:
Figure 12-3 shows the output of the DrawShapes recipe that draws simple shapes such as arcs, rectangles, and an ellipse.
Antialiasing is an excellent technique to smooth out the jaggies or pixelation when shapes are drawn using the default rendering algorithms.
In recipe 12-2, the lines didn’t appear straight or smooth.
The next step is obtaining the current transform to assist in placement of shapes on the drawing.
Transforms will be discussed in recipe 12-6, but suffice it to say that transforms enable the developer to position (translate), scale, rotate, and shear shapes.
Throughout the recipes you will use a common transform called translate to move the shape using its bounding box’s upper-left (x, y) coordinate.
For each shape you will set the upper-left location (translate) so that the shapes won’t overlap one another when they are drawn.
For example, the second arc will be positioned to the right of the previous arc by translating its x-coordinate.
In the recipe code, the second arc is positioned 10 pixels to the right of the first arc.
Shown here is the code snippet used to save the original transform for later reset:
At the top of the window there are three types of arcs shown consecutively.
You should notice a common pattern emerging when creating shapes.
There seems to be three ways to create the same kind of shape, and these types of shapes are based on using number values of type float, double, and int precision.
Extent float  270 When to stop drawing arc; stops drawing at (start angle + extent angle)
The following is an Arc2D constructor using a float precision:
When drawing an arc you will specify a bounding box similar to building a rectangle by specifying.
Once the bounding box is defined, you can think of it as an invisible ellipse inscribed in the bounding box.
Next, is defining the starting angle that is where to start drawing or tracing the ellipse.
After the start angle is specified, you will set the extent.
The extent is the angle in degrees plus the start angle to indicate where the stroking or tracing of the ellipse stops.
Finally, the arc type parameter is how the arc opening should connect.
The arc can appear open, a straight line (chord), or a shape of a pie wedge.
Figure 12-5 shows the three types of arcs: open, chord, and pie.
Later in this chapter, you will learn about transforms and how to use the translate() method, I will briefly explain how the shapes are drawn and positioned.
Next is drawing the chord type arc offset to the right of the previous open arc shape.
Here you will position the chord arc to the right of the previous open arc by translating its x-coordinate based on.
Finally, you will repeat the steps to draw the pie-shaped arc.
Once the three types of arcs are drawn, you will reset the current transform to the saved transform in order to draw the ellipse shape underneath the first arc shape (open arc)
Similar to the Arc2D shape, you will imagine drawing an invisible rectangle or a bounding box where the x, y coordinate is the upper-left corner and the width and height is specified to inscribe an ellipse by using the giving stroke.
The following code statements are the three ways to create an ellipse:
After drawing the ellipse, you will be drawing a rectangle using the Rectangle2D class.
Next you will draw the shape on the graphics surface with the Graphics2D object’s draw() method.
To make the corners rounded, you would specify the arc width and height.
When dealing with the arc width or height when the value is zero, it is identical to a regular rectangle, but as the value increases the arc becomes more curved moving away from the corner.
The following is the code to draw a rounded rectangle with 20 as its arc width and height:
Problem You want to fill shapes with color paints and display them on the computer screen.
Solution After drawing shapes, you will want to call the Graphics2D setPaint() method by passing in a color.
Next, you will actual fill the shape with the paint color using the fill() method on the Graphics object and passing in the shape.
The following code sets paint color and fills an ellipse shape:
Shown here is the code recipe on filling shapes with colors:
Figure 12-6 displays the various types of colorized fills that can be applied onto shapes.
A solid black line (as depicted in Figure 12-6) also appears in the recipe to demonstrate the transparency of the shape’s color.
How It Works The recipe first clears the background to white and sets antialiasing on (smooth rendering)
The color black is used when drawing the ellipse outline.
After the ellipse is drawn, you will use the Graphics2D’s method fill() to fill the interior of the ellipse with the color red.
The order of drawing a shape prior to filling a shape can matter depending on.
In our current example you will draw an ellipse with a thickness of 3 and then fill it with the color red.
Imagine if you will, an ellipse that is drawn with three pencils held together where the center pencil is the outline of the actual ellipse shape and some of the inner outline is considered inside (interior) of the ellipse, and the outer outline is the outside area surrounding the ellipse.
Knowing this, you will see that the red paint fills the ellipse and therefore overwrites the inner part of the ellipse including some of the inner outline.
This will leave the outer part of the outline black.
Colors can be defined with four components: red, green, blue, and alpha channel.
Although there are many ways to create colors, a common method is representing each component as an integer value range of 0–255
The red, green, and blue (RGB) components will mix colors based a web standard color model.
Next is filling the rectangle shape with the color orange and having the alpha channel set to be partially transparent.
Finally, you will use the predefined color green to fill the round rectangle shown here:
Problem You want to fill shapes by using color gradients to be displayed on the computer screen.
Next, you will actually fill the shape with the paint color using the fill() method on the Graphics object and passing in the shape.
This code creates a gradient paint and fills the shape:
The following code uses the preceding classes to add radial and linear gradient colors as well as.
You will be using an ellipse, rectangle, and rounded rectangle in this recipe.
A solid black line (as depicted in Figure 12-8) also appears in the recipe to demonstrate the transparency of the shape’s color.
Figure 12-8 displays the various types of gradient fills that can be applied onto shapes.
How It Works Similar to past recipes, you will clear the background and set antialiasing on before you begin to draw onto the graphics surface.
This recipe is the same as recipe 12-4, but instead of using simple solid colors to fill shapes, you will be using gradient paint.
Gradients provide a way to fill shapes by interpolating between two or more colors.
For example, when using a starting color of white and an end color as black, the gradient color will gradually go from light to dark with varying shades of gray in between.
The pattern is a smooth transition from one color to another in a linear fashion.
Running the example code, you will see three main shapes filled with a gradient color.
The first shape is an ellipse using a radial gradient from red to black.
To define the center of the gradient, you pass in the cx and cy parameters.
The center of the gradient can be positioned anywhere within the ellipse, allowing you to give the illusion of changing the light source angle onto the shape.
The fractions array (floats) denotes the distribution of colors when moving from the center out to the perimeter.
An array of colors specifies the start and end colors used when painting the gradient.
The following code paints a radial gradient onto an ellipse shape (Red Ellipse):
To create a linear gradient paint, you will specify startX, startY, endX, and endY for the start- and.
The start- and endpoint coordinates denote where the gradient pattern begins and stops.
The fractions array is the amount of distribution as it interpolates over a color.
This code instantiates a yellow, semitransparent, linear gradient paint object that fills a rectangle:
Notice a rounded rectangle with a repeating pattern of a gradient using green and black in a.
The cycle parameter is set to true, which will cause the gradient pattern to repeat or cycle between the colors giving the illusion of glowing bars or pipes.
Problem You want to shear, rotate, scale, and translate shapes on the screen.
Shown here is the recipe that will transform a square by shearing, rotating, scaling, and translating:
Figure 12-9 shows four squares that demonstrate the different transforms.
How It Works Pictured in the output are four squares (rectangles) transformed.
Starting from left to right and top to bottom, you will have a square, rhombus, diamond, and a larger square.
The square is considered the original object without any transforms applied.
You’ll notice an initial translate operation right before the desired transform.
The translate transform will move and position the shape (relative to the preceding shape) on the graphics surface, making it appear as if it occupies one of four quadrants.
An example of the translate operation before the desired transform follows:
This allows you to save the original state of the Graphics2D object before you begin moving or transforming shapes.
This shape is reused to transform the other three shapes described earlier.
That is, you will draw the shape four times, transforming it each time, and translating (placing) it relative to the preceding shape.
Next, you will shear the shape by instantiating an AffineTransform and invoking the shear()
Compared to the original square shape, you will notice the shape forms as a parallelogram or a.
The (x, y) coordinates are transformed using these equivalent equations:
After drawing the rhombus, you will draw a rectangle using the original shape to then position it.
By using the rotate() method, you pass in a radian angle and a point on the shape to rotate around.
This code moves and rotates the square displayed below the original square:
Finally, you will scale the original rectangle by a scaling by a factor of 1.5 along the x-axis and y-axis direction.
The stroke thickness is even sized by the factor given.
A neat is to use negative values that will flip the shape along the x- and y-axis.
The following code snippet scales a rectangle shape by increasing its size:
Note For more on AffineTransforms go to the Javadoc at http://download.oracle.com/javase/7/docs/api/index.html?java/awt/geom/AffineTransform.html.
Problem You want to draw complex shapes on the screen.
How It Works If you have gotten this far, you will notice we have done the same thing as before in previous recipes; you will clear the graphics surface and turn antialiasing on.
Before you begin, you’ll notice code statements that employ the translate() method, which repositions shapes.
Most recipes often use the translate operation, via the AffineTransform class, to move shapes, so I will not go into great detail about the translate operation (refer to recipe 12-6 to see more)
Let’s dive into the shapes and see how they are drawn.
A control point is a point that pulls the curve toward it.
Figure 12-11 depicts a cubic curve with two control points positioned above and below the start point and end point, respectively.
When using the Path2D class, you will be using it like a pencil on a piece of graph paper moving from point to point.
Between any points you can decide to draw the following: line, quadratic curve or cubic curve.
Once you have finished the drawing, the last point can close the path forming a shape using the closePath() method.
The following code creates the path shape forming an ice cream cone:
Third, you will be drawing a quadratic parametric curve using the (QuadCurve2D) class.
Shown here is a QuadCurve2D constructor used in this example to form a smile:
Last, you have a created a shape that looks like a tasty donut.
We aren’t going into all the operations, which are beyond the scope this book.
In this example, you will simply create a big ellipse representing the whole donut and a smaller ellipse representing the hole of the donut to subtract.
This code creates a donut shape by using the area’s subtract() method:
You can finish the donut area like any other shape, such as filling it in with a color.
Then reuse the shape by shifting it diagonally to the upper left by three pixels and fill it with a solid orange color.
You can then outline the donut to give it a cartoonish look.
Problem You want to interact with a shape by manipulating its points with the mouse pointer.
The major classes or interfaces used in this recipe are these:
Interacting with the shape via the mouse pointer will dynamically change or move the shape about the screen, thus transforming it.
For the sake of brevity, I will not be discussing transforms in detail.
Shown here is the recipe that creates an application to allow the user to manipulate a cubic curve shape by using the mouse pointer to move positioning handles:
Figure 12-13 depicts the application interacting with a cubic curve shape.
How It Works This recipe involves using your mouse pointer to interact with a shape on the graphics surface.
Let’s start with some instructions on how to interact with the shape being displayed.
Here are the commands to interact with a quadratic curve shape:
Hover: Move the mouse pointer over the shape to create a gray dotted bounding box region around the shape.
Select shape: Click the mouse button to select the shape.
This creates a red dotted bounding box region around the shape with positioning handles on the starting, ending, and control points (QuadCurve2D attributes)
Move shape: Press the mouse button inside the shape’s region while dragging the shape across the screen.
Change starting point: While the shape is selected with a mouse press, hold and drag the positioning handle (situated at the start of the curve) to stretch or squeeze the curve’s length.
Change ending point: While the shape is selected with a mouse press, hold and drag the positioning handle (situated at the end of the curve) to stretch or squeeze the curve’s length.
Change control point: While the shape is selected with a mouse press, hold and drag the positioning handle (control point) of a quadratic curve (bottom center)
The MouseListener interface contains methods that are responsible for mouse events such as pressing, releasing, clicking, entering, and exiting a component.
In our case, the whole graphics surface is a component (JComponent), and you are only focusing on the mousePressed() and mouseReleased() methods.
The mousePressed() method basically determines when the shape is selected and what positioning handle was selected before a drag operation is performed.
The mouseReleased() method is responsible for when the user releases the mouse after a drag operation.
Also, it will reset the transform on the shape for subsequent mouse events.
The mouseMoved() method is basically responsible for bringing focus to the shape by creating a gray dotted bounding box region.
When moving away from the shape, the gray box disappears.
In the class InteractiveShapes there are instance variables that maintain the state of the user’s actions and the shape’s information while being modified.
Table 12-3 lists the instance variables used in this recipe to maintain the state of the shape to be manipulated:
The (x, y) coordinate of the translate transform of the shape when being moved by the mouse.
Keeps track of the dragging action the user is currently performing.
Are they dragging the start point, control point, or end point; or moving the bounding rectangle?
The key to this recipe is to understand the order or workflow of events occurring before the shape is actually rendered.
When a user uses the mouse, the various methods are being invoked by listening to mouse events.
The methods that handle these mouse events will update state information (instance variables) and call the component’s repaint() method.
This will call the paintComponent() method to render the shape on the graphics surface.
Problem You want to change the default text font to be used to draw on the graphics surface.
Solution Before drawing text, set the graphics context to a new font style by using the java.awt.Font class and the Graphics object’s setFont() method.
The code recipe here prints the book’s title in four different font styles, including a drop shadow effect:
Figure 12-15 displays the book title in four font styles with varying colors.
How It Works The recipe begins by clearing the background to white and turning antialiasing on.
The first text string rendered is the title of the book, Java 7 Recipes, in red with a drop shadow.
What’s really happening are two calls to the drawstring() method, which first draws the text lettering in gray and then applies the red lettering on top.
When drawing the drop shadow, you will create a gray, semitransparent, 30-point, plain serif font.
Next, you will use the same font style in the color red and invoke the drawstring() method.
Positioning the text string just 2 pixels diagonally to the upper left gives the appearance of a drop shadow adding depth to the text.
Shown here is how you will set the font with a Serif font:
The rest of the text font renderings are the same as the previous code snippet.
For example, you want to set the color on an individual or a range of characters.
Some of the types of attributes are color, bold, italic, strikethrough, and font style.
Following is a code example to specify various attributes onto your text to be displayed on the graphics surface:
Figure 12-16 shows various attribute types applied to the text.
How It Works I was trying to be creative by adding different attributes to different parts of the title of the book “Java 7 Recipes.” Here is a rundown of the requirements:
The first thing you do is to instantiate an instance of the AttributedString with the text you want to add attributes to.
TextAttribute has many attribute types that can be applied to text.
Problem You want to align text to display left-, center-, or right-justified on the display area like a word processor would shift a sentence.
Solution Create an application that will demonstrate text drawn to be positioned left-, center-, or right-justified.
Also allow the user to select menu options to justify the lines of text.
Shown here is the code recipe that creates an application that will allow the user to choose left, center, or right justification of the current text on the graphics surface.
Currently, there are two lines of text being displayed that contain the phrases “The quick brown fox jumped” and “over the lazy dog.” When the user has selected the menu option “left,” the two phrases will be aligned to the left margin of the display area.
When selecting the “right” menu option, the two phrases will be aligned to the right margin.
The center menu option when selected will align the text phrases between the left and right margins.
Figure 12-17 shows the application displaying the text phrases with a center justification.
How It Works Before going about creating this recipe example, you will notice the MeasuringText class that implements the AppSetup interface.
This interface is co-located with the SimpleAppLauncher class from the very first recipe.
The AppSetup interface has only one method: the apply() method.
This method is a way for the SimpleAppLauncher class to invoke the apply() method.
As you saw in the first recipe example in this chapter, the SimpleAppLauncher class is responsible for creating the main application window or, in this case, a new JFrame.
In this recipe, you will implement the apply() method to add menus to the main JFrame window.
This provides a simple facility to allow (you) the developer to wire up menus and allow the application launcher to launch the window in a threadsafe way.
Did you ever wonder how to justify text similar to word processors? Here is an example in which you can left-, center-, and right-justify text on the graphics surface.
Before you begin to determine the size or bounding box of text, you must obtain the font that will be used in the rendering of text.
These parts make up the height measurements of a text font character.
The first thing to know about font metrics is where the baseline is located.
The baseline is an invisible line that the characters will sit on top of (similar to primary school handwriting paper)
When using the drawString() method, you will specify the x and y, which is where the baseline will begin.
The ascent is the distance from the top of the character to the baseline.
The descent is the distance of how far parts of a character font will extend below the baseline, such as the lowercase letters g or j.
Last is the leading that is used when characters are positioned beneath another character to provide proper spacing so they won’t appear to be touching.
The code snippet here determines the space needed for the second row of text:
When the user chooses the justification through the menu selection option, I used the Java 7 nifty.
Here, I use simple math to move the x coordinates to position the sentences based on the width of the JComponent.
The code here uses the bounds width to calculate the center justification of text (center justify):
Next up is how to display large text passages having multiple lines that will word wrap text as the.
Problem You want to fit large passages of text into your window area.
In other words, you want to word wrap the text when the sentence runs beyond the right edge of the window area.
Solution Create an application that allows the user to view text with the ability to word wrap when the user resizes the window.
Shown here is the code recipe to display a large text passage having the ability to word wrap based.
Figure 12-18 depicts an application containing a large text passage wrapping words based on the width of the window.
How It Works Most word processors and even simple editors have a word wrap feature.
Long text strings go beyond the width of the window and move to the next line as if someone were hitting the carriage return key.
To perform this behavior, you will first obtain the font to be added as an attribute to the text by using the AttributedString class.
By determining the width of the JComponent or visible graphics surface area, you can then use that width to help determine where to perform a line break.
In this case, it is a matter of moving the text down the y-axis according to the ascent and leading height.
The following code iterates through each text layout, based on a wrap width and height calculation to determine its y-coordinate to position words to the next line:
Problem You want to create a drop shadow effect when drawing shapes on the graphics surface.
Solution Use a simple technique by drawing two congruent shapes on top of one another except one shape is slightly offset relative to the other, and the bottom shape is filled with a dark color that appears as a drop shadow.
The following code recipe is an application that will display a donut shape appearing with a drop shadow effect.
Figure 12-19 displays a donut shape with an applied drop shadow effect.
How It Works Amazingly, there are numerous ways to produce the drop shadow effect on shapes and images when rendering things on the canvas.
To simply create a drop shadow effect, draw the shape a little offset with the color black.
Then draw the shape again with a different color over the top of the previous shape (black shadow)
Repeating the last strategy using gradient paint instead of black provides another simple way to produce a shadow.
The gradient drop shadow technique was used in recipe 12-7
Of course, you’ll notice that this tasty donut looks vaguely familiar because it’s the same shape also used in recipe 12-7
Interestingly enough, I went the extra mile and decided to use yet another strategy to produce a cool-looking drop shadow effect.
You will be using the ConvolveOp class to blur pixels, which gives the shadow a misty appearance.
When using the ConvolveOp class, you will need to create a source and a resultant (destination) image.
You can think of the ConvolveOp as a filter that takes the source image as input and converts the pixels onto the resultant image.
The following code creates a source and destination image for you to perform the convolve operation:
To blur an image using the Java2D API, you will need to use a Kernel class, which represents a.
The total matrix value will determine the destination pixel value.
When adding all values of this matrix together, the total matrix.
Shown here is the code used to create a 7x7 matrix or kernel to blur an image:
Once you create an instance of a ConvolveOp, you can perform the filter() method that makes the mysterious shadowy donut.
The following code creates an instance of a ConvolveOp used to apply a blur filter:
To know many more filter operations, see the Javadoc on ConvolveOp.
Problem You want to print the graphics surface onto a printer.
Solution Create an application allowing the user to print the graphic surface using the following classes:
The code recipe here generates an application similar to recipe 12-9 that displays the book title with varied font styles.
Although it is quite similar, this recipe will allow the user to print the graphics surface.
Figure 12-20 shows the Print dialog box that is launched after the user selects Print.
However, in this recipe, the device space will be your printer.
Let’s begin with the main application class that implements the (Printable) interface.
The (Printable) interface has a method called print(), which is the code that interacts with the PrinterJob object (aka “the printer”)
The following code statement is the print() method on the (Printable) interface:
So, what actually got refactored? Well, I moved all the drawing code from the paintComponent() method into another method called draw()
This allows us to see and print the graphics surface at the same time.
This recipe is assembled using Java Swing API to create menu options for the user to select and print the display.
You will notice the apply() method creates a JMenuItem instance with an inner class definition containing an actionPerformed() method.
The actionPerformed() method is responsible for presenting the Print dialog box to the user.
Shown here is the code snippet to launch the Print dialog box :
Problem You have digital images on the file system that you want to load and display in your application.
Solution Create an application that will allow you to provide a file chooser to select a file to load and display.
The following are the main classes used in this recipe:
The following code listing is an application that loads and displays image from the file system:
Figure 12-21 depicts an open dialog box to load an image file.
How It Works Every time you see an advertisement on a new camera being sold you seem to immediately pay attention to the number of megapixels or the other cool features.
Of course, you know that the higher the megapixels the better the image quality.
With the increase in the number of megapixels, viewing and loading images can often make applications appear quite sluggish.
When developing Swing GUI applications, it is imperative to understand how to effectively interact with its event dispatching thread (EDT)
Things such as disk I/O should not be included in the same transaction (method call)
The key is to delegate work to another thread (worker thread)
Because the EDT is single threaded, it is important to offload work onto a separate thread so it doesn’t block.
When blocking occurs, the application will freeze the GUI window, and users will become upset.
Because of this common scenario, the guys and gals on the Java client/UI team have included a SwingWorker class in Java 6 that provides the callback behavior that you are looking for.
The following code lines are two ways to instantiate the SwingWorker class:
The SwingWorker class uses generics to enable the user of the API to specify types of result objects returned during and after the worker thread task is completed.
When instantiating an instance of a SwingWorker, the T (Type) is the result object after the doInBackground() method has been called.
Once the doInBackground() method is complete, it returns the image object and hands off the control to the done() method (on the EDT)
While inside the done() method you will encounter the get() method that returns the image object from the doInBackground() method (non-EDT)
The SwingWorker’s V (Value) is an intermediate object that is updated and used by publish() and process() methods.
In our example, you only care about the loaded image, and V is declared Void.
You’ll also notice a shortcut notation whenever you are instantiating objects with generics by using the less-than and greater-than symbol: <>
To cut down on verbosity, new to Java 7 is what is known as the diamond operator.
It isn’t really an operator; it’s a type inference notation for constructors.
Either way you look at it, on the productivity side of things there is less to type and your code is a lot easier to read.
Another thing to note is when using the diamond notation make sure your IDE has its Source/Binary format set to JDK 7, or else your code won’t compile.
Shown here is the before and after using the diamond operator notation:
Loading an image is pretty simple: you basically invoke the ImageIO.read() method by passing in a File object representing the image file on the file system.
You can also load an image via a URL by using the following code snippet:
Java can currently load .jpg, .gif, and .png image formats.
There are many overloaded drawImage() methods on the Graphics object used to draw images.
Here, I’ve only provided the most common method signature to render an image on the graphics surface.
One of the many overloaded drawImage() methods you can use is shown here:
Keep in mind that the underlying Graphics object is a Graphics2D class that contains even more.
You might want to explore the interesting effects that can be applied to images.
To learn more about Graphics2D’s drawImage() methods, please see the Javadoc for details.
Because you aren’t monitoring the process of the image loading, I passed in a null into the parameter observer.
When drawing on the graphics surface, you will use the drawImage() method as shown here:
Problem After loading an image, you want to simulate a special effect similar to night vision goggles.
Solution Alter the image’s underlying pixel information by removing the red and blue component of each pixel in the image.
Prepare the ARGB array argbData = new int[width * height];
Figure 12-23 displays a picture altered by removing the red and blue components of image data.
How It Works To make things a little more interesting, I wanted to simulate night vision goggles similar to the ones used by Navy Seal teams.
I thought it would be easy to just remove the red and blue components from each colored pixel from the image and leave the green and alpha components alone.
When manipulating an image (BufferedImage), you have the opportunity to get color information detailing each pixel.
The default getRGB() method returns an int (integer) value representing the four components(alpha, red, green, and blue) of a pixel.
If you understand the RGB color space, you will be moving right along.
However, if you do not understand it, refer to recipe 12-4
The first step is to obtain pixel data for examination and to invoke the setRGB()method that updates the pixel information, thus altering the image.
Instead of returning a single pixel at a time by using the getRGB(x, y) method, I used the overloaded getRGB() method that returns an array of int (integer) values.
The code here shows the BufferedImage’s getRGB() method that returns an array of ints:
When calling the getRGB() method to return an array of ints, you can do one of two things.
Either you can construct an integer array to be populated or you can pass in a null into the rgbArray parameter.
In our example, I created an array of ints to be populated:
Finally, the pixel data will be manipulated by using the setRGB() method.
In a simple for loop, I simply mask each int in the array by making the red and blue components to zero.
Here is the code to create a loop to alter an image’s pixel data:
Problem You want to load an image and save it to your file system as another file name.
Solution Create an application that will load your image into memory to be later saved as another file name onto your file system.
The code listed here creates an image loader application that has the ability to save an image file to the file system:
Figure 12-24 shows the image loader application with an image loaded and displayed onto the screen:
Figure 12-25 depicts the Save dialog box that allows the user to save the image to the file system with a specified file name.
Notice the file extension is .png, which is one of the supported image file formats.
How It Works Before we discuss saving an image, I want to remind you that the recipe application requires the user to load an image first.
Because loading and drawing an image onto the graphics surface is discussed in earlier recipes, I need not go into those details any further.
Once an image is loaded and displayed in the application, the user can select the menu option Save Image As to save the image as a file onto the file system.
The Save dialog box application expects the user to select or type in a file name with a valid graphic format file extension.
The valid graphics format file extensions are .jpg, .gif and .png.
In this example I am saving the file as a .png image file format.
The user will receive an alert dialog box if the file name is not valid.
Figure 12-26 shows a warning dialog message letting the user know that the file has an invalid file extension:
Assuming that the user has entered a valid file name and clicked the Save button in the Save dialog box, the application will convert and save the image into a valid graphics file format.
ImageIO.write() method needs to know the type of graphics format to save the image file as.
Here is the code used to save a BufferedImage image:
Notice that the Save Image As dialog code is rather bare where the code performs the.
Why is this such a bad thing? Well, saving an image could take longer than 250 milliseconds making your GUI application appear frozen (while the user clenches his jaw)
To fix this problem, surround the code with a SwingWorker class.
In order to do this, place the call ImageIO.write() inside of the doBackground() method, thus deferring work off of the EDT.
Writing 3D applications used to be hard because a developer needed to know math, have intimate hardware knowledge, and it that hardware knowledge usually didn’t transfer very well across platforms.
A typical application would have to be programmed for a specific video card.
As time progressed, there were new abstractions that within a platform allowed the use of a common API.
This common API then either used the capabilities of the video card or implemented them in software, but it was still OSdependent (Direct3D for Windows, OpenGL for Windows, and other OSs)
While 3D programming still requires (some) math, at the very least there aren’t drivers to worry about.
It’s more about what you want to create than the hardware details of how to create it.
Tip  The source code for this chapter contains an actual game that puts all the chapter’s recipes together.
If you would like to see the different interactions between recipes, you should take a look at the source of SpaceGame.java.
Problem You need to install Java3D for use by your application.
Solution Download Java3D from java.net’s web site and install it locally.
Your application should have then access to the Java3D classes and methods.
How it works After installing the Java3D package, you will have access to the accelerated graphics environment provided by the computer’s video card.
Java3D uses OpenGL/Directx (depending on the operating system running), and has native libraries for the major operating systems.
This is why you need to specify the target operating system when downloading Java3D.
Problem You want to create a Java3D object and display it on the screen.
The following example creates a color cube object, which is a cube with different colors on each side, and displays it onscreen at the default view location (which is looking straight at the cube):
The SimpleUniverse offers a way of creating a simplified 3D universe; the difference is that it makes certain assumptions like not needing different canvases, and gets sensible defaults for the viewing platform.
The viewing platform is the “eye” positioned within the universe.
Only objects that are “in front” and “visible” through the eye are rendered in the canvas.
The universe can be very big, and the position (where it is within the universe) and direction (where is it pointing at) determines what do we see in the canvas.
In the example, the viewing platform is located at the origin of the universe (0,0,0), and points toward the depth (-z) space (default)
The root node is where a scene starts, and it will include different nodes that represent the objects to be rendered.
Each root node will have children nodes that describe transformations on an object.
The leaf nodes of the tree will contain actual 3D objects to be rendered.
To render an object you add the 3D object to a node and then add the node to the universe.
Within a tree, there are two main types of nodes: branch group nodes and transformation nodes.
Transformation nodes are nodes that specify a change for their children.
A transformation node can have as children other branch group nodes, other transformation nodes, or the actual 3D objects.
Any children of the transformation node will have the transformation (rotation, translation, scaling) applied to all its children as a whole.
Branch group nodes, on the other hand, allow grouping of children nodes and/or 3D objects as a single unit.
By adding children to branch group nodes, a branch group node can be manipulated as a single unit.
An example would be having a chair composed of different individual 3D objects (six boxes)
Each box will be added to a transform group (where the position of each box is specified)
After the transform nodes are created, you can add them to a single group node that represents a single “chair.” This group node can be rotated as a unit by attaching it to a transformation node.
An example of such a hierarchy is presented in Figure 13-3
Most of the measures are done in meters; even so the universe supports any arbitrary distance unit convention.
As long as your objects (and your viewing platform) within the universe agree on their relative scale, the universe will render correctly.
Problem Now that you have an object rendered in the canvas, you want to place it in a specific place on a specific rotation.
Solution By creating a TransformGroup object and specifying transformations, you can define how an object looks in the canvas.
The following example builds on our red cube from the previous recipe by rotating it so that you view two sides at once:
In this code, the colorCube is created, and then added to a rotationTransform.
Following the first transform group, another transform group is created that translates (moves) the object to the x,z coordinates specified in the function.
Note that the location transform adds the rotationTransform as a child.
The translation transform is then added to the universe (not shown)
How It Works The transform group node is a node in the universe tree that specifies the transformations that are going to be applied to any children of it.
A TransformGroup object can have a leaf as a child (like a colorCube or a pyramid) or it can have other transform groups/branch groups as children.
The transform group changes the object’s rotation, scaling, and/or location.
After rotating, you add another transform group that translates the location of the rotated group.
This is a common process when creating and adding objects to a scene.
Chaining up transform groups (with branch groups and all) allows for expressing complex behavior with simple building blocks.
Each transform group needs a transform3D object to specify the changes to the children of the transform group.
Within 3D development, there is the concept of transformation matrices.
Problem Now that you have the object looking as you wished, you want to animate it by moving it or rotating it.
Solution By specifying interpolators, you can change a transform group on a timed interval.
In this example, you create an interpolator (which is the class responsible for animating and changing the transform group)
Figure 13-5 shows a frame of the resulting spinning cubes.
How It Works There are three main concepts that you have to understand to achieve animation.
The first is the Alpha class, which specifies the timing and repeatability of an animation.
You can choose between a linear and an exponential approach.
Each subclass of interpolators changes a specific property of a transform group.
But even so, the rotation will take the same number of seconds to finish.
When you create an interpolator, you add it as a child of the transform group you want animated.
Finally, the animation occurs only when the viewer is within certain bounds.
If the viewer is outside of those bounds, the Canvas3D will not animate the object.
To do so, you specify the setTransformBounds property on each transformGroup.
If an object is very far away, it might not be necessary or useful to animate it.
Specifying the transform bounds allows you to lower the amount of CPU that is devoted to transformations because it will only animate when the view is within those bounds.
The bounds are specified by an implementer of the Bounds class.
The boundingSphere is the simplest implementation because it just involves a sphere centered where the transform group is, with a specified sphere ratio.
So far, before the current recipe, there were only “static” scenes, on which things have been added at the beginning and then rendered without any animation.
As you move into changing objects by time (or by responding to things such as key presses), you must make each branch group/transform group aware that you are going to change their state after you add them to their universe.
This signals the universe that you might go and revisit this transform group and change its transformation parameters by using the rotation interpolator.
Problem You are creating the 3D universe by adding transform/branch groups and want to navigate it.
The following example creates a cluster of cubes, on which you can navigate by using the keyboard or the mouse.
Figure 13-6 shows a screenshot of what the example looks like.
Pressing the keyboard’s navigation keys moves the viewing platform around the universe.
The scheduling bound allows Java3D to figure out whether we are close enough to check for the iteration and move the transform group.
The use of SchedulingBounds is common in all objects that cause an interaction with the universe; it should be the first thing to debug when the universe doesn’t respond to the intended stimuli.
The mouseRotate behavior allows you to use the mouse to rotate a transform group’s children.
By creating a transform group that contains the whole scene in the universe, you can use mouseRotate to rotate the universe.
Caution  Having these utility classes will interfere with any other viewer positioning and/or behavior that you later add in your program.
If you intend to introduce different navigation by keyboard, you should remove the keyboard/mouse navigators in this recipe.
Problem You need to change the universe when someone presses a key.
Solution Use behaviors to capture keyboard events, and change transform groups in response to the behaviors.
The following recipe solution moves our spaceship left or right depending on the key pressed.
The KeyboardBehavior extends the Behavior class and implements the initialize() and.
The initialize() method registers the stimuli that the behavior class will respond to.
How It Works Behavior classes allow you to register callbacks on certain conditions called stimuli (like a key press or an object collision)
When the stimulus happens, the behavior then calls its processStimulus method with information about the stimulus (for example, what key was pressed)
Within the processStimulus, you can then make changes to a transform group (or add/remove children groups) to update the universe.
The behavior class can be used to register for many types of stimuli, allowing for an efficient event dispatching.
Like any other Java3D that receives information at runtime, the behavior classes have a scheduling bound on which they will listen for the stimuli to happen.
Note When a behavior processes a stimulus, it is necessary to reregister the stimuli that we want the behavior to listen to.
This is done by making a call to the wakeupOn() method at the end of the processStimulus() method.
This gives you the choice of keeping listening to the stimulus (by reregistering it) or listening to another set of stimuli altogether.
Problem You want your object to look illuminated by a light source.
Solution Using the Appearance class, you can set the rendered object’s attribute such as color, material, and shade model.
Figure 13-7 shows an example of  a rendered planet in the game.
How It Works You can set the appearance of each leaf (primitive) object.
The Appearance class describes information on the color of the object, the material (different materials will render differently under a light source), and the shade model.
The shade model describes the detail on which the Java3D renders the color of the model.
All objects (even smooth ones like spheres) are composed of geometric primitives (like triangles and squares)
When painting the surface of an object, it is quicker to paint each primitive on a solid color (FLAT_SHADING), but it’s not very realistic-looking.
In contrast, GOURAUD_SHADING paints each primitive by interpolating the colors of the primitive with its neighbors.
It creates a very smooth surface, but requires more CPU processing.
There are four light sources that you can choose for Java3D.
Ambient light A light that shines everywhere (everything gets shaded by its color)
Directional light A light that has a source (that is infinitively large), so that its light always comes at the same angle for all objects.
Spot light A point light for a specific direction only.
Note For a light to work, you need to define an object’s appearance (including material), a light source, and the influencing bounds of the light source (Up to what distance can it affect other objects)
If any one of these is missing, objects will not render with a light source.
A light gets added to a group (usually a transform group)
Depending on the type of light, it either affects objects uniformly (ambient, directional) or affects them proportionally from the location of the light.
By specifying influencing bounds, you are telling the light to affect every object that is within the bounds of the light.
Lights influence any object in the scene graph that is in its influencing bounds.
It is not limited to the group that the light is a child of.
Figure 13-8 shows a screenshot of the completed space game.
The object of the game is to avoid (or destroy) the asteroids that are in your path.
To do so, you use the left and right keys to move your spaceship and then use the spacebar to fire your laser gun.
The Java Swing API is a GUI toolkit for developers to build client-side, cross-platform desktop applications.
Swing is based on the Model View Controller (MVC) architectural framework pattern.
Long before the Swing API, the Abstract Window Toolkit (AWT) alone provided an abstraction layer over the native platform to enable standard windowing functionality.
With the creation of Swing, a new dimension was added that allows greater cross-platform capabilities.
Some of these capabilities include pluggable look and feel, advanced components (not found in AWT), and keyboard event bindings.
Swing goes beyond AWT’s abilities by rendering lightweight components that are platform independent.
Swing and its foundational toolkit AWT are still heavily used.
Swing is a mature GUI toolkit that has been used in the enterprise for over a decade and still remains to be a viable desktop development solution today.
As we move into the future, some user interfaces can become dated or lacking in cultural appeal.
Swing was designed from the ground up to keep up with many modern look and feels by allowing many third parties to develop different themes (skins)
Later in this chapter, you will learn how to set the look and feel of our applications.
Although there is a vast array of books about Swing, I will touch on the fundamentals and key concepts that will allow you to hit the ground running.
In this chapter you will learn how the Swing API allows developers to create windows, custom layouts, buttons, menus, dialog boxes, animation, validation icon feedback, saving data to a database, and much more.
The following classes are the main classes used in this recipe:
The following code will create a simple GUI application using Java’s Swing API.
When the GUI application is launched, you will see a blank window with a title bar with the standard minimize, maximize, and close buttons.
Figure 14-1 shows the output from executing the preceding code.
Shown here is a basic Swing GUI application with a title and standard window buttons.
How It Works This recipe is pretty straightforward and is the way most Java Swing GUI applications are started and run.
They are similar to Java command-line applications, in which they use the main() method as an entry point when executing programs.
However, Swing applications will additionally launch a separate thread responsible for displaying the application’s UI and graphics.
Knowing this fact, it is important to know the appropriate way to manage resources between the main and GUI thread.
What is thread safety and how does it affect your applications?
Thread safety sounds quite scary at first, but it means that concurrent threads that operate on a single resource (data object) can cause any number of issues such as data corruption, race conditions, and even dead locks.
However, more often when we talk about it in the GUI world, thread safety is mainly about blocking the GUI thread.
In layman’s (caveman) terms, your GUI application is frozen (GUI bad)
Like most GUI toolkits, Swing uses a single-threaded model in which any GUI renderings are.
The EDT expects events to be queued and ready to be invoked.
So what is the big deal with the EDT? Well, let’s say you are periodically retrieving data and updating your GUI screen.
The retrieval of the data can be pretty expensive, which can spend approximately one to five seconds (a lifetime IMO)
If the retrieval code is called from the EDT, many controls such as buttons, graphics, and animations will typically appear frozen for long periods of time.
It is important to defer non-GUI–related work on a separate thread so that blocking doesn’t occur.
When it’s time to render Swing GUI components, you should allow the EDT to execute the code, but most often it’s hard to distinguish a thread’s context.
The Swing API has a convenient way to ensure GUI code gets run on the EDT.
Shown here is the method call to queue GUI work onto the EDT:
This may not be obvious, but when you run a Java application it is run on the main thread and not the EDT.
This is an important concept because, as in the example scenario relating to the periodic retrieval of data (non-GUI–related work), the work should be deferred on a separate thread; likewise non-GUI threads should not call GUI-related work.
If you ignored the use of the invokeLater() method, your application would likely render GUI widgets incorrectly.
The following code snippet shows how to dispatch GUI work onto the EDT:
Having said all those rules relating to the EDT, you’re probably wondering why the two code lines.
Well, I have to tell you about an exception to the rule.
Let me restate one of the rules mentioning threading responsibilities: non-GUI threads should not call GUI-related work.
The exception to the rule is that it is okay if the GUI has not been realized.
Being realized means the components are about to be shown or are currently being shown.
Now that you know how to safely display a GUI, let’s look at the method displayGUI()
It is responsible for the actual creation of the GUI application.
It first creates an instance of JFrame with a title.
The JFrame is a native window frame that will house your Swing application along with GUI components.
Next, you will set the default behavior when the user clicks the close button on the window.
You will then take the component passed in to be placed in the content pane using the JFrame’s default layout called the BorderLayout.
Later, in recipe 14-4 you’ll see how to align and position components using layouts.
Once components are placed in the content pane along with the layout, you will invoke the JFrame’s pack() method.
The pack() method is responsible for taking preferred width, window dimension, and other sizing information to properly calculate GUI components that eventually is shown.
Following the pack() method you will do a little math to center the window frame on the monitor display.
Lastly, you will call the JFrame’s setVisible() to true to display to display the GUI.
When the pack() and setVisible() methods are called to show the components in the window frame, the displayed components are now considered to be realized.
Solution 2: Execute a .jar Executable Double click a .jar executable or on the command prompt type the following and then press Enter: java –jar myapp.jar.
Figure 14-2 shows an example of the sort of button you might see.
The first two solutions are run on the command line, and the last is via a link on a web page or an icon on your desktop.
Solution 1 is used when your class files are available in your classpath (compiled)
This solution is as easy as running any Java application on the command line.
To learn how to execute Java applications and pass arguments via the command line or terminal, please see recipe 1-4
Solution 2 is used when the Java Swing application is packaged in a file called a .jar file (better known as a Java archive)
Java archives that are run as a Swing application are specially built to contain metadata on details such as what class file contains a main() method as its entry point.
To see more on how to create .jar file executables, see recipe 14-22
Solution 3 is used when a user clicks a special hyperlink on a web page that launches the Swing application that will be pushed (installed) onto the local workstation.
Underneath the covers, Java Web Start provides a network launching protocol called JNLP.
This file is hosted on the web server along with the .jar file ready to be served up.
When a Swing application is launched, you will be presented with a dialog box relating to security (certificates and trusted authorities) and asking the option to put an icon on your desktop.
Problem Your boss has trouble remembering names of people and needs a way to capture a person’s contact information.
Solution Create a simple GUI application with some of Swing’s standard UI components representing labels and input fields to allow a user to enter a person’s name.
I want to remind you that this recipe does not save any information.
The following Swing-based UI components used in this recipe example are listed here:
In this recipe you will be creating a simple form type application that allows you to type in a person’s first and last name.
The application screen will contain labels beside the text fields to describe the input field.
The form also has a save button to simulate the ability to save the information to a data store.
Later in this chapter, you will learn how to save data into an embedded database.
The following code listing is a simple form-type application containing some of Swing’s standard UI components:
Shown here is the AppSetup interface (AppSetup.java) used in later chapters to allow the SimpleAppLauncher class to apply UI components to the main application window.
This is primarily used to add menu options to the main application window (JFrame)
It is not used in this recipe, but is mentioned in future recipes.
Figure 14-3 displays a simple form containing some of Swing’s standard UI components used to allow a user to enter a person’s first and last name.
How It Works When adding components to a GUI application, the first thing you will need is a container to hold components to eventually be displayed.
In Swing, a common container that is often used is the JPanel class, which is not only a container but also a component (JComponent)
In the inheritance hierarchy, all Swing components such as the JLabel, JTextField and JPanel classes extend from the JComponent class.
By default, the JPanel uses a FlowLayout layout to position and size components according to certain layout constraints.
In short, the flow layout will lay out the components horizontally and move them to the next line if the component reaches beyond the edge of the panel.
Later, we will discuss layouts, but for now let’s add some components onto the GUI.
In our default constructor, you will use JPanel’s add() method to put components into the container.
You will first add a JLabel component that represents a read-only label denoting the first name beside the input field.
Next is an input field using Swing’s JTextField component, allowing the user to enter and edit text.
After the first name components are added, the last name components are added using the same steps as before.
Finally, you will add a JButton component onto the JPanel.
The following code line adds a save button onto the JPanel panel:
I know the UI form doesn’t look very attractive, and the button doesn’t do much of anything, you’ll see in later recipes how to remedy these things.
If you must know, go ahead and jump to layouts (recipe 14-4)
This convenient method simply displays content in a JFrame window while honoring thread safety (EDT)
The SimpleAppLauncher helper class is actually a refactoring of recipe 14-1, which abstracts away common GUI application code.
Creating this helper class will enable us to focus on key concepts without being bogged down with application details.
The AppSetup interface contains a single method called apply() that provides an opportunity for the developer to apply settings or menu components onto the parent application window (JFrame) independent of the launching code.
The following code is the apply() method from the AppSetup interface:
Continuing with the rest of the displayGUI() method, I will detail the code line steps to launch and display the application window.
Shown here is the code line to set the application window frame’s default close operation when the user clicks the close button:
Most of the recipe code examples in this chapter will call the displayGUI() method by passing in the GUI content or component (JPanel container)
When component is passed in, you may want to know the dimensions of the panel while the window is being resized.
Shown here is the code snippet to add a component listener to output the component’s dimension when the window is resized:
Next, you will want to set the component panel as the content pane and set the minimum size of the window frame based on the panel.
Later, we will discuss layouts, but for now the main content pane by default uses a border layout (BorderLayout) that has a center content area.
The center area will take up all the available space when other content areas (North, South, East, and West) don’t contain any content.
Once the frame’s content pane and dimension is set, you will need to invoke the pack() method on the window frame to notify the Swing toolkit to perform a layout on the UI components and apply constraints on the parent window.
Shown here is the pack() method to notify the Swing toolkit to perform a layout:
Then you will want to center the application window frame.
Next, you will calculate the window frame’s upper-left coordinate in order to center the screen.
Once calculated, you will set the location and display the application window to the user.
Shown here is the code to center the application window (JFrame) and display to the user:
With all the necessary code to launch Swing-based GUIs, it’s nice to think of SimpleAppLauncher as a mini utility or application framework to launch applications easily while adhering to thread safety so you can focus on making your GUIs look amazing!
Problem Your boss complains about how ugly the UI looks and asks to have components laid out similar to a grid.
Solution Create a custom layout to position your UI components in a grid-like display.
You will create a simple input form like the recipe before that allows a user (your absent-minded boss) to enter a person’s first and last name.
The following are the main classes used and discussed in this recipe:
In the previous recipe, you created a GUI form application that allows the user to enter a person’s first and last name where the components were not laid out nicely.
In this recipe, you will be able to lay out the same UI components in a grid-like form by creating a custom layout.
The custom layout will allow you to add components similar to a table in HTML or Swing’s GridBagLayout, except it will be a lot simpler to use.
To add components to the layout, you will be able to programmatically specify in which column and row (cell) it will reside.
You will also be able to align components using a constraint object within its respective cell based on the column and row.
The MyCustomGridLayout class is the custom layout that will be used to display UI controls in a grid-like display.
The MyCellConstraint class is used to set constraints to align UI controls within a cell.
The code listing shown here is a custom layout called the MyCustomGridLayout class.
This class is responsible for allowing the developer to specify a cell constraint for a UI component within a cell (as long as there is a UI control within that cell):
Figure 14-4 displays a form-type application using a custom layout, allowing a user to enter a person’s first and last name.
How It Works When developing GUI applications, it is ideal for an application to allow the user to move and adjust the size of their viewable area while maintaining a pleasant user experience.
The Java Swing API provides many layouts to choose from straight out of the box.
The most common layouts used are BorderLayout, FlowLayout, and GridBagLayout.
Note I will discuss the common layouts very briefly and will not go into detail.
My reasoning is that there are numerous sources detailing the common layouts and don’t often see many examples of real world layouts that behave well.
In other words, in this recipe you will be creating a custom layout in which you will have more control of components.
It also gives you a chance to see how things work under the hood.
Before you get into the code, I will briefly explain the commonly used layouts.
When using the JPanel component without a layout manager, it defaults to Swing’s FlowLayout manager.
The FlowLayout manager simply lays out components horizontally on a row.
The FlowLayout manager will honor a component’s preferred size; however, a component’s position can move depending on the available space width-wise.
Similar to a word processor or text editor having word wrap on, whenever a window is resized smaller than the width of the row components, the FlowLayout manager will reposition the component to the next row.
Like all Layout managers, the FlowLayout manager has constraints or settings which allow you to control the alignment of components.
The following code statement sets a JPanel component with a FlowLayout manager with a center constraint:
This is probably the case because it is similar to web pages in a browser.
Web pages often have navigation at the top, bottom, left, or right side of the display area and a main content region in the center.
The BorderLayout class calls these areas surrounding the center content region NORTH, SOUTH, EAST, and WEST.
When adding components to the surrounding regions, it is similar to the FlowLayout where the preferred size is used and positioning occurs based on the width of the region.
When adding a component to the center region, the layout manager will give the component as much of the available space as possible.
Shown here is the code that sets a JPanel container with a BorderLayout and adds a component in the center content region:
This layout is used to have finergrain control over the placement and constraints of components.
To set constraints for each component, you would use the GridBagConstraints class.
Typically, this layout is used to present a tablelike structure.
By using the GridBagConstraints class, you can let the layout manager know how to treat components’ sizes in each cell in the grid table.
Often, constraints can often be so complicated and unwieldy that you have to start all over from scratch.
Let’s get to the code, shall we? For starters, when developing or designing user interfaces you will need to have requirements.
Most applications in the business world are data entry type interfaces or better known as forms.
Form interfaces are often symmetrical and similar to a grid-type layout.
You are probably thinking about the GridBagLayout, but in our custom layout the API is simpler to use and has expected (predictable) behavior.
Pretend your boss is requesting a form interface to enter contact information.
You’ll begin with a simple form mockup that has labels, fields, and a button.
Before getting into the guts of our custom layout implementation, it is better to explain how to use the layout’s API first.
A similar scenario is pretending the layout manager has already been created, and the developer is using the API.
Align components left, right, or center within a cell width default (left)
When using the already created layout (custom layout), you can specify the horizontal gap, vertical gap, number of columns, and number of rows through its constructor.
Shown here is setting up the JPanel with the MyCustomGridLayout layout:
Next, you will set constraints in order to let the custom layout decide where to position and size.
I created a constraint object called MyCellConstraint which is a plain old Java object (POJO) used when calling the add(JComponent comp, Object constraint) method of a JPanel component.
The MyCellConstraint class allows the user of the API to specify which cell in the grid to.
The three alignments are left, right, or center where left is the default.
In this code recipe, I used the Builder pattern, so specifying cell constraints will resemble a more declarative feel and not be as verbose as using the GridBagConstraints object.
When you set the JPanel component’s layout, the add() method will delegate to the custom layout’s layoutContainer() method to position and size components.
You’ll also notice it here when specifying properties of the MyCellConstraint object:
Now that you know how to use the custom layout, we can discuss how it was implemented.
The MyCustomGridLayout class begins by implementing the Swing’s LayoutManager2 interface.
This is in support for the MyCustomGridLayout custom layout class.
When calculating a component’s bounds, it takes into account the horizontal gap, vertical gap, parent’s insets, component’s preferred width/height, and cell constraint.
When a layout occurs (invalidation), the layoutContainer() will be called to reposition components.
This method first obtains the parent’s insets to calculate the available width and height you can use to resize components within each cell.
Although these variables (availableWidth, availableHeight) aren’t used, I implemented them and left them for you as an exercise if you want to make this layout more robust.
You may want to create thresholds for components to expand and contract.
Next, you will iterate through all the columns to determine the widest component in each column.
You will also iterate through all rows to determine the largest height for each row that makes things spaced like a grid.
The cell sizes are being determined by obtaining the UI component’s preferred size and horizontal and vertical gaps.
Each component’s upper-left bounding box (x, y) coordinate is updated to be positioned within the cell.
With a parallel array containing each cell constraint the (x, y) coordinate gets updated based on the cell constraint’s alignment (RIGHT, CENTER, and LEFT)
Layout management can be quite challenging at times, but understanding the fundamentals will help you decide the best approach when building aesthetically pleasing applications.
When developing small applications you should use the stock layouts.
But for larger-scale applications you might want to explore more powerful solutions.
Shown here are layouts that I highly recommend when creating professional looking applications:
Problem As a hard worker you often get stressed out and are in search of an easy button.
Solution Create and application with an easy button that will offer calming advice.
The main classes you will be using in this recipe are the following:
The following code listing creates an application that will display a button that when pressed will display text.
Figure 14-5 depicts the initial window that displays when the application is launched.
How It Works You want your button to do something when you press it.
You’ll also notice the method begins with the word add and not set, meaning you can add many actions to the button.
Whenever a button is pressed, all ActionListener instances will be notified, so they can carry out their action.
Here you will create an anonymous inner instance of an ActionListener that sets the JLabel’s text when the user presses the button.
AbstractAction class, which is also an ActionListener instance but can do much more (toolbar, property change support, and so on)
Problem When copying many files, you want to display the status and percentage being completed in a GUI that is updated periodically.
Solution Create an application to simulate files being copied or transferred.
This application will contain a start button, cancel button, progress bar, and text area displaying the amount of time in milliseconds each file is being transferred.
The primary class you will be focusing on is Java’s SwingWorker class, which will be used to update the GUI periodically.
Shown here is the code to create an application that simulates a file transfer:
Figure 14-6 depicts an application that simulates files being copied or transferred.
How It Works In recipe 14-1 we discussed the importance of thread safety and using the EDT.
The goal of this recipe is to create a responsive GUI which operates while expensive work is being done in the background, and still allow the user to interact with the application.
Because this is a common behavior in GUI development, the amazing client-side Java engineers created a convenience class called the SwingWorker class.
The SwingWorker class will properly handle non-GUI work and direct GUI events onto the EDT, thus abiding the thread safety rules in Swing.
In this recipe, you will simulate files being transferred and concurrently displaying status to inform the user the percentage of files being transferred.
As files are being transferred, the worker thread will update the text area with the amount of time in milliseconds.
Before I discuss the details of the SwingWorker class, however, let’s set up a GUI window with components.
First, you will add components onto the JPanel using a BorderLayout.
On the north region, you will add a JProgressBar instance to let the user know the percentage of files transferred.
Next, you want the percentage string to be displayed while the progress bar is being updated by calling the setStringPainted() method with a value of true.
The progress bar’s minimum and maximum values are then set.
The following code instantiates a new progress bar component (JProgressBar):
You will add components to the south area of the BorderLayout manager consisting of buttons and a JTextArea component that will display the elapsed times in milliseconds when individual files are transferred.
The buttons allow the user to start and stop the file transfer process.
The application doesn’t actually transfer files, but simulates the process by generating random sleep times to block the thread as if it were doing work.
The start button’s action listener will generate an instance of a SwingWorker class to begin execution while the cancel button’s action listener will have a reference to the same worker thread to cancel the operation.
Note Remember that all actionPerformed() methods are called via the EDT, so expensive calls are frowned upon.
That is where the SwingWorker class will come to the rescue!
You will create a method called createWorker() to return new instances of swing workers and execute them when the user presses the start button.
In this case, T will be a Boolean type that I chose to denote a successful transfer of all files.
Second, you will want to define the type for the intermediate result values.
Intermediate result values are strings representing the time in milliseconds that will be displayed in the text area component.
Here are the methods that you will implement from the SwingWorker class:
The following methods describe the life cycle of a SwingWorker class:
The doInBackground() method can call the publish() method to queue data for the process() method.
A list of objects will be queued up for this method to process.
The method is using the EDT thread to update the GUI based on a list of data elements.
The method is using the EDT thread to update the GUI with a final result to the caller.
Problem After creating a GUI form–type application to capture a person’s name, you want to store that information locally onto your computer.
Solution Use an embedded database such as the Derby database.
When using relational databases, you will be using the Java Database Connectivity (JDBC) API.
The following code recipe is an application that allows a user to enter a person’s first and last name to be saved into a database:
This recipe will be using an embedded database called Derby from the Apache group at http://www.apache.org.
As a requirement, you will need to download the Derby software.
To download the software, visit http://db.apache.org/derby/derby_downloads.html to download the latest version containing the libraries.
Once it is downloaded, you can unzip or untar into a directory.
To compile and run this recipe, you will need to update the classpath in your IDE or environment variable to point to Derby libraries (derby.jar and derbytools.jar)
Shown here is the code listing of our database utility class DBUtils.java, which is capable of performing database transactions:
Figure 14-7 depicts the form application allowing a user to save a person’s name information into a local database.
How It Works When creating form interfaces, there will be a point in time when you have to write the data somewhere.
I’ve been fortunate to work on projects in the past where data is stored locally in an embedded database.
In this recipe, I chose the popular embedded database called Derby.
Just as a heads-up on being able to run this recipe, you must include the derby.jar and derbytools.jar libraries into your classpath.
When working with form-based applications, you should separate your GUI code from your action code.
You will notice in the doInBackground() method’s call to saveContact(), which will return a primary key (on a non-event dispatch thread)
The doInBackground() method is not performing the work on the EDT (hence the name) and could take awhile to save the data.
Once the doInBackground() method is completed and has returned the primary key the object will be available when the done() method calls the get() method.
When inside the done() method, you are now on the EDT where you have an opportunity to update the GUI.
Shown here is the done() method calling the get() method that contains the primary key:
In the code recipe you will simply send the primary key to standard out.
Next, the DBUtils class is responsible for persisting form data.
To simplify things for this example I coded things to create the database and contact table in the beginning and later drop the table when done.
So, feel free to take out these lines when creating a real application.
Here is a quick rundown of what is going on in the saveContact() method.
First, it receives the contact information from the caller and derives a primary key using a hash of the first name and last name as a relatively unique identifier for a row in the database.
Next, the call to loadDriver() will load the JDBC Derby driver.
Then it prepares properties to connect to the database and sets the auto-commit to false.
After setting the transactions to auto-commit mode false, you will create a table that will hold our contact information.
The contact table contains three fields, the ID, first name, and last name.
Id is a data type of int, and the name fields are of type varchar(40)
Next, you will create a prepared statement that binds our data elements.
Once the prepared statement is executed via executeUpdate() method, it will indicate to the database a transaction is ready to be committed.
Last, you will perform the commit() on the connection to flush changes to the database.
The rest of the code basically drops the table and closes all resources.
Problem You want to create an application that generates random quotes displayed in individual windows inside the application (similar to a mini-desktop)
Solution Create a multi-window application with display content using the JDesktopPane and JInternalFrame classes.
The following code recipe creates an application that allows a user to pop up internal windows with random quotes:
Figure 14-8 shows the application displaying multiple internal windows, each containing a random quote.
How It Works Java Swing’s JDesktopPane is a container component similar to a JPanel except that it manages mini internal frames (JInternalFrame) similar to a virtualized desktop.
These internal frames act very similar to JFrames on your host desktop.
Just like JFrames, you may add menu items and any swing components into internal frames.
To create a multi-window application, you will first extend from the JDesktopPane class with a default constructor.
Notice that the MultiWindowGUI class extends from JDesktopPane class and therefore it is a JDesktopPane instance.
Shown here is the code to launch and display the application window (JFrame) having a desktop pane (JDesktopPane):
When you place the JDesktopPane instance in the main JFrame window, it is placed in the center content region using the BorderLayout.
Placing the JDesktopPane into the center will allow the virtualized desktop to take up all the available space.
In the constructor, the call to setDragMode() sets the effect when you drag the internal windows across the desktop.
With certain environments that have high latency or lower bandwidths, rendering internal frames across the network can be too expensive (for example, remoting using a VPN)
In our example, I also implement the AppSetup to add menu options enabling the user to create new internal frames (JInternalFrame) with random quotes when displayed.
You might also notice that the menu has the keyboard shortcut Ctrl+n.
Implementing keyboard shortcuts for menus are discussed in recipe 14-16
In this recipe, you will want to focus your attention on the newWindowMenu variable, in which you will add an ActionListener.
This is where an internal frame is instantiated and placed onto the desktop area.
Your objective is to allow the user to select the menu option to create internal frames that will be staggered similarly on most windowed desktops.
Each internal frame created will have a title denoting the sequence number or count of the frame when instantiated.
You’ll notice the call to super() where you will pass in Booleans to the super class to set the JInternalFrame object to be resizable, closable, maximizable, and iconifiable.
Next, you will pick a random quote from the static String array rndQuotes.
The random quote is placed in a scrollable (JScrollPane) text area (JTextArea) with text wrapping set to true.
Problem You are asked to create a UI for a building security application to allow a user to select items to control.
Solution Create standard menu options to be added to your application.
Shown here is the code recipe to create a menu-driven UI that simulates a building security application:
Figure 14-9 shows an application with menus, submenus, radio button menu items, and check box menu items.
How It Works Menus are standard ways on windowed platform applications to allow users to select options.
Menus should also have the functionality of hotkeys or accelerators or mnemonics.
Often users will want to use the keyboard instead of the mouse to navigate the menu.
When creating menus, you can only add them to the Swing JFrame or JInternalFrame container classes.
First, you will implement the AppSetup interface to allow the developer an opportunity to add components into the main window frame (JFrame)
There you will create an instance of a JMenuBar that will contain one-to-many menu (JMenu) objects.
Second, you will create menu (JMenu) objects that contain one-to-many menu item (JMenuItem)
A thing to note is that menu item can have icons in them.
I don’t showcase this in the recipe, but I encourage you to explore the various constructors for all JMenuItems.
The ButtonGroup class is also used on regular JRadioButtons to allow one selected option only.
At times you may want some menu items separated by using visual line separators.
Please refer to the Javadoc to see more on JMenuItems.
Solution Create an application with tabs using the Swing container JTabbedPane class.
The code here builds and presents an application with tabs that can be arranged in different orientations.
The application will consist of a menu option that allows the user to choose a left, right, top, and bottom orientation.
Figure 14-10 depicts an application with a menu selection used to choose different tab orientations.
You first will create a JTabbedPane contain class that will hold one-to-many JPanels.
Each JPanel object added to the container becomes a tab.
In the constructor, I created 10 tabs with a JLabel containing the numbered tab (zero relative)
Once the individual tabs were created, I set the tab layout policy to SCROLL_TAB_LAYOUT.
Setting the layout policy will create button-like controls to paginate when too many tabs are being displayed at once.
To make things interesting, I created menu options to allow the user to view the tab placement to showcase them displayed on the left, right, top, or bottom.
Each menu option will add an instance of a TabPlacementAction that is responsible for calling the tabbed pane’s setTabPlacement() method.
Problem You came across a great idea while at work and you must write it down before you forget.
Sadly, your company has just cut its office supply budget, leaving you without pencil or paper.
The following code recipe creates a doodle application allowing you to use your mouse pointer to draw on a canvas:
Figure 14-11 depicts a doodle application with a text label, text field, and a drawing surface.
How It Works When you want to draw on a surface in Swing, you simply override the paintComponent() method of a JComponent class.
In this recipe, I wanted to draw and have text components on the same surface; so, instead of extending from the JComponent class, I extended the JPanel container class.
Once the paintComponent() method is overridden, you will be able to use the Graphics2D object to draw on the surface.
Before getting into the implementation, I want to point out the instance variables at the top of the class.
Once a mouse releases, the current path instance is added to this list.
When an initial mouse press occurs, the anchor point is assigned before a mouse drag event occurs.
Also adds the current path instance into the list of Path2D objects.
You’ll notice in the code that each method has a repaint() method.
The repaint() method notifies the graphics context to repaint the surface via the paintComponent() method.
In the paintComponent() method, you will set the background to white, set anti-aliasing on, and set the color of the stroke to be black.
You will draw the current path instance and then loop through the list of previously stored paths (drawings) to be drawn.
Problem You want to load icons and position text on buttons and labels.
The following code recipe creates an application to demonstrate loading icons and label as well as positioning text:
Figure 14-12 shows the application displaying labels and buttons with positioned text and icons.
How It Works Before we discuss the code details, I would like to mention layout.
For this recipe you will be using the CustomGridLayout manager to position the UI components in a grid-like table display.
For brevity, I will not go into great detail, but will refer you to recipe 14-4, in which the custom grid layout is discussed more in depth.
When using JLabels and JButtons, you can easily add icons along with the text when displayed.
Another nice functionality of the JLabel and JButton components is to set the text position relative to the icon image.
In the recipe code, I created a convenience method called createImageIcon() to load and return an ImageIcon object.
The code here is the createImageIcon() method that creates and returns an icon (ImageIcon) loaded from a URL:
Note To run this recipe using the NetBeans IDE, you may have to perform a clean and build of the project to ensure the images get copied properly to reside on the classpath.
After instantiating the ImageIcon class, the method returns to the caller a newly loaded instance of an ImageIcon object.
When creating new instances of a JLabel, I chose the constructor that receives three parameters: the text, icon, and horizontal alignment.
Problem You want to preview different types of borders while changing its color.
Solution Create an application with sample borders and color selections to allow the user to design a border.
The following code recipe creates an application with sample borders and color selections to allow the user to design a border:
Figure 14-13 depicts the border designer application with drop-down menus, allowing the user to select border styles and color.
How It Works Borders are simply a way to decorate a component’s bordering edges.
Throughout most of the recipes in this chapter, Swing components extend from the JComponent class.
Knowing this fact means you can set the border on any Swing component using the JComponent’s setBorder() method.
In this recipe you will present to the user choices of different border styles and color options.
The options to set color are only for the lined type borders such as the DashedBorder, StrokeBorder, and TitledBorder classes.
Before I discuss the methods that dynamically change the borders, I want to describe the constant (static final) variables that contain the various border types and colors to choose from.
You’ll notice that in the static initializer block below the BORDERS array declaration are eight instances of type Border created using the BorderFactory’s many create methods.
Table 14-3 lists the descriptions of the static final collection and arrays.
Table 14-3.Static map and array variables containing border type information.
BORDER_TYPES String[] An array of eight strings denoting the border type.
In the BorderDesigner class’s constructor is where the components are laid out.
Then you will create a component using an instance of a JPanel with a default border and a dimension of 200x100
Next you will create a combo box component with the types using the array of strings to allow the user to choose the type of border to display.
Added to the combo box is an ActionListener that swaps out the currently displayed border component to the user.
Last, you will create a combo box that will apply a chosen color from the user to the appropriate lined type border.
Actually, it calls the BorderFactory create methods to generate a brand new border with the color applied.
Problem Your million dollar idea (see recipe 14-11) must be protected from prying eyes.
Solution Create a login screen having username and password text fields and a login button.
The main classes used in this recipe are JTextField, JPasswordField, and JTextArea classes.
When using JTextArea, you should also use a JScrollPane to create scrollbars for larger text content.
Figure 14-14 shows the login application complete with a text field, password field, text area, and login button.
How It Works Have you ever seen a login screen? I’m sure you have.
All login screens look the same where the display contains a username, password and login button.
In this recipe I will be discussing common text components that are used in form interfaces.
Advanced text components such as a JTextPane will be discussed in recipe 14-17
Here we will talk about components of type JTextField, JPasswordField, and JTextArea.
You will begin by using the custom layout to place labels and input fields.
If you don’t understand custom layouts, please refer to recipe 14-4
Moving onto UI controls, you will want to add the JLabel’s object into the first column (column zero)
Next is adding the JTextField into the second column (column 1) for the username.
Then you will create a JPasswordField for the password input field.
Added next is a JButton for the simulated login button.
Last, you will create a JTextArea for the status in which messages are output when the user presses the login button to confirm.
Instead of using an action listener I used an AbstractAction class with a command string as “login” that is set in the constructor.
You’ll see later in recipe 14-16 the difference between the AbstractAction and ActionListener classes.
The last thing to point out is the actionPerformed() method, which checks the username and password.
The JPasswordField UI component has a getPassword() method that returns an array of characters instead of a string.
When systems use encryption, byte arrays are normally used not strings.
Of course, you’ll never see this kind of code in production, but to not make things obvious I’ve obfuscated the admin password.
Problem You want to create a simple editor with editing actions such as undo and redo.
Solution Use the StyledDocument class to create a simple text editor and the UndoManager class to handle undo and redo actions.
The following code recipe constructs a simple text editor that demonstrates the ability to handle undo and redo actions.
The keyboard shortcut used to perform undo and redo operations is Ctrl+z and Ctrl+y, respectively.
Figure 14-15 depicts a simple text editor about to perform an undo operation.
How It Works Every editor that I’ve experienced has an undo or redo feature (vi does, too) when users edit text.
A really nice feature in Swing is the UndoManager class.
It manages keystrokes, text, and font changes as the user is editing text in a text component.
In this recipe, you will be using the text component JTextArea.
All text components contain a Document object that is the back end for many GUI text components.
In other words, all the text content is maintained in a Document object.
You will begin by creating a JTextArea with a JScrollPane for the user to type text into.
Next, you will call the JTextArea’s getDocument() method to obtain the Document object.
Then it gets cast to an AbstractDocument to be referenced later on.
This code line obtains the Document object from a text component:
The UndoManager will maintain an ordered list of all edit actions in the Document object.
For instance when the last edit was a word being deleted, the UndoManager can restore the word and its attributes.
The following code shows UndoAction and RedoAction created with a reference to the UndoManager:
Because UndoAction and RedoAction are closely connected, I created methods to allow them to reference each other.
The following code lines set the RedoAction and UndoAction objects to reference each other:
Once UndoAction and RedoAction have been set and associated, you will need to set the Document.
The listener will add UndoableEdit objects every time an edit occurs in the document.
After adding a UndoableEdit object to the UndoManager the UndoAction and RedoAction updateState() method is called to update its enabled state so that menu buttons could be grayed-out.
Any time there are undo or redo events, the UndoManager will record the change such as a user pressing Backspace to delete a character.
When a group of changes occur such as a word being bolded, an undo being performed will revert the whole word and its attributes.
To implement the UndoAction and RedoAction classes, you will need to extend the AbstractAction class.
Each action will invoke the putValue() method to set up the keyboard shortcuts to allow the user to use the keystrokes Ctrl+z and Ctrl+y to undo and redo an edit, respectively.
When the action is triggered via a keyboard shortcut, the actionPerformed() method will be invoked.
To implement the actionPerformed() method, you will call the UndoManager to perform an undo or redo of the edit and call the updateState() to update the action’s enabled state that actually will update the menu options’ enabled state and its text.
Problem You want to create keyboard shortcuts or hot keys to quickly select menu options without having to use the mouse.
The following code recipe is an application with menu options assigned keyboard shortcuts.
A “New” button is also displayed that is assigned a keyboard shortcut.
Alt+n will invoke the action to pop up a dialog box alerting the user of the new option being selected.
This action is also bound to the “New” button, as mentioned before.
When the user presses the Ctrl+s key combination a popup will display a “saved…” message dialog box.
In the application there are three menu options with designated keyboard shortcuts along with a “New” button, as shown in Figure 14-16
How It Works When creating menu items, you can set a mnemonic (Alt key) that associates a key on the keyboard to allow the user to select the menu item when the parent menu is visible.
For example, when pressing Alt+f, the “File” menu is displayed, which is the parent menu of the menu item for the “New” option (Alt+n)
Here you can press Alt+n (or n) to invoke the action to pop up the message dialog box.
The same action attached to the “New” menu option is also attached to the “New” button, to also be invoked immediately with a hot key (Alt+n)
Menu items can also be set to associate with key combinations that are called key accelerators (for example, Ctrl+S in Windows)
An example is when a user wants to save a file using a key combination (shortcut) instead of using the mouse to navigate through menus.
The following code sets the “Save” menu item’s key mnemonic and key accelerator with the letter s.
The s or Alt+s (mnemonic) can be used if the “File” menu is visible.
If the Ctrl+s (accelerator) is pressed, the dialog box is immediately shown.
In this recipe code listing, actions (AbstractActions) can also contain keyboard shortcuts via the putValue() method.
Because an AbstractAction object can contain keyboard shortcuts and because it is an ActionListener, you can not only set them in menu items but also set them in JButtons.
Shown here is an AbstractAction instance bound to a menu item and a button:
This is also convenient because you can have one action that can control two or more components at the same time.
This can allow the developer to disable a menu item and button simultaneously.
The problem is that you are too cheap to buy Microsoft Word, and your broadband connection has been severed in the middle of your Open Office download.
Solution Create a simple word processor that can change the font, size, and style of the text.
The following code recipe creates a simple word processor application that allows you to select font, size, and style of your text:
Figure 14-17 depicts the simple word processor that allows you to change the font, size, and style of the text.
How It Works Most desktop operating systems often provide simple editor applications that allow users to type stylized text.
In the Microsoft world there is an application called WordPad that is similar to Notepad, but allows the user to create documents with stylized text and even allows images to be embedded.
In this recipe, you will be creating a WordPad-like application.
The application will allow the user to change a font’s type (family), size, and style (attribute)
You will start off in the constructor, in which you will create a JTextPane component in a BorderLayout’s center content region.
This will allow the text editing area to take up the available space when the window is resized.
Next, you will learn how to set up menu options to change the fonts when the user types into the text pane area.
Interestingly, JTextPane components can have different types of editor kits.
Editor kits are implementations of editors for different document content types.
When talking about stylized text, there are currently three editor kit types in Java: HTMLEditorKit, RTFEditorKit, and the default StyledEditorKit.
Editor kits have many actions defined to allow the developer to change font styles and even cut and paste actions.
An editor kit is just that, a mini editor connected to your JTextPane component.
So, let’s look at the apply() method where all the actions are attached to menu items.
First menu section is the “Fonts” menu where the user is able to change the font family.
Because a JTextPane’s default editor kit is a StyledEditorKit, you will create an instance of a FontFamilyAction and set it into the menu option.
When the menu option is selected, the font style will be applied to the selected text.
The second menu section is the “Size” menu, in which the user can change the font’s size.
Last is our “Style” menu section, in which the user can change the font’s attributes such as bold, underline, and italic.
Shown here is the code used to set an ItalicAction instance on a JCheckBoxMenuItem menu item:
Problem When creating an application, you want to prompt a user with a window popup to simulate changing a password.
You want to present to the user a modal or non-modal dialog box.
Solution Create an application with a menu option to prompt the user with a dialog box (JDialog)
Also, you will create menu option with the ability to change the dialog box’s modality.
The following code creates an application with a menu option to allow a user to change their password.
It will also demonstrate the ability to change the popup dialog box’s modal state:
How It Works Oh, brother is this recipe about another login form? Well, this time it’s about changing your password with a similar login form.
Of course, I don’t have a second password field to confirm that it’s the same as the first, but I digress.
Actually, this recipe is about the JDialog box and setting modality.
Before discussing the apply() method in which the menu items are created to manage the dialog box, we will talk about the JDialog container class.
I hope you’ll believe me when I tell you how simple it is to create a JDialog.
It is as simple as extending the JDialog and adding components onto its content pane.
It’s just like any other container class except it is a real window similar to the JFrame class.
In the MyDialog class, you will extend from JDialog class; however, there is a minor detail, to point out in our constructor.
In our constructor you should specify the owner or parent window that the dialog box is called from (JFrame)
When calling super() and passing in the owner, this will enable the window toolkit to display the dialog box based on its modal state in relation to the parent window.
For instance, if a dialog box’s modality is set to non-modal or false, the user will be able to click items in the parent window.
When set to modal or true, the user will not be able to click items in the parent and must respond to the dialog such as a login screen.
Back to our constructor, you will simply add the components on the content area like other examples.
Finally, you will add an ActionListener to the change password button (JButton)
The change password button will dismiss the dialog box that simulates a password change.
In the apply() method, you will begin by instantiating an instance of the MyDialog class, as mentioned previously.
Next, you create a “Home” menu with menu items to show the dialog and menu items that set the dialog’s modal state.
In the “change password” menu item, the ActionListener will show the dialog box just as you would with a JFrame.
To show the dialog box, you will call the pack() method.
You will then center the window and call the setVisible() method to display the dialog box.
Finally, to set the dialog box’s modal state, you will call the JDialog’s setModal() method with a Boolean value before displaying the dialog box again.
Shown in this code is the menu item’s action that sets the dialog box’s modal state to false.
Problem You are tired of looking up words in the dictionary that you don’t know how to spell.
Solution Create a dictionary application with a simple auto-completion component.
The following code recipe creates a dictionary application with an auto-completion component narrowing a search as the user types the beginning of the word to search:
Figure 14-19 depicts the dictionary application narrowing a search as the user types a word.
How It Works Did you ever notice when you begin to type the name of a contact in an e-mail application or a phone number on your smartphone, the application begins to search and display similar names? Well, this can easily be done with Swing’s DocumentListener interface.
In the recipe example, you will create an input area and a list box below to show the similar items as the user types letters.
The Document object allows the developer to add listeners to monitor document events that correspond to the user’s interactions with the text component (JTextField)
You will first create a class that implements the DocumentListener interface.
Shown here are three methods that you will be implementing in order to listen to document events:
You will only really have to implement the insertUpdate() and removeUpdate() methods to monitor.
In the constructor you’ll notice it takes a reference to a JListBox; this is where to display the words as the user is typing characters.
The methods insertUpdate() and removeUpdate() simply call the searchDictionary() method to compare the beginnings of the words that match and place them into the JList component’s ListModel model.
Now that you have a reusable class such as the MyDocumentListener class, you can now create a simple auto-completion application.
Second, you will need to create an instance of a DefaultListModel class because (remember the code detailing the searchDictionary() method) it obtains the list model and expects it to be a DefaultListModel object through a cast.
The following two lines of code will create a JList and DefaultListModel:
Shown here is the creation of a custom search text field component:
Problem You want to format text in Swing’s label and button components with basic HTML.
Solution Create a simple demonstration application with labels and button.
Use basic HTML to apply styling when setting the text for the components.
The following code recipe will create three labels in a column to the left and three buttons also in a column to the right.
All labels and buttons with HTML applied will have varying text font, size, and style attributes.
Figure 14-20 shows the various labels and buttons styled with HTML:
How It Works Well, isn’t that just dandy? That’s a phrase used a long time ago to describe something or someone as having good quality of appearance.
In this recipe, you will be able to change the appearance of labels and buttons with simple HTML.
Recipe 14-17 shows that it involves a tad more work to change a text’s attributes.
Amazingly, the JLabel and JButton components have HTML formatting baked into it.
It’s as simple as specifying a string containing HTML markup.
Shown here is the code to format a JLabel component’s text with HTML:
The HTML code makes the text Label 1 centered and bold.
It then breaks to a new line with the text.
Problem You want to change your application’s UI look and feel or theme.
The following code listing builds an application showcasing many of Swing’s standard components with the new Nimbus Look ‘n’ Feel:
The API allows developers to create themes or skins for Swing components.
A pluggable Look ‘n’ Feel can virtually transform the appearance and behavior of all components.
Although it is beyond the scope of this book to dig into those APIs, I’ll show you how to set the Look ‘n’ Feel of choice.
So I decided to just present a handful of common Swing components in the Nimbus Look ‘n’ Feel.
Each element (LookAndFeelInfo) in the list is compared using its name to locate the Nimbus Look ‘n’ Feel.
Once determined, the Look ‘n’ Feel is set on the UIManager.
The following code sets the Look ‘n’ Feel using a string with the class’s fully qualified name:
Solution 1: Create an Executable Jar File Here are the steps to create an executable jar file to run a Java Swing application:
Step 1: Create a text file called manifest.mf with the following contents:
Note The last line of the file must be an end of line or carriage return.
Step 2: Jar up your application along with the manifest file by typing the following:
Step 2: Create a .jnlp file named “myapp.jnlp” as an XML file with the contents shown below.
The following XML file myapp.jnlp file specifies deployment information contained in a .jnlp file:
Step 3: Create an HTML file named “myapp.html” which will contain the contents shown below.
Shown here is the code to create an HTML file (myapp.html) that will launch as a Java Web Start.
How It Works Once you have created your awesome Swing GUI application, you will want to distribute or deploy your application.
Solution 1 is about creating a single jar file as an executable so a user can launch it by double-clicking or running it on the command-line prompt.
Solution 2 is a more modern approach: it pushes changes onto the workstation, essentially installing the application locally.
Solution 1 assumes that your files are in a directory relative to your class files.
You will begin by creating a manifest.mf file in order to reference the entry point or the class containing a main() method.
In Step 2, you will only be jarring up class files, not other resources.
To jar other items, please refer to the documentation on the Ant jar task.
The downside is getting the jar file to your user’s workstation.
Solution 2 is almost the same with the first step, except it needs two addition files.
Keep in mind that these three files will be deployed on a web server to be served up.
So in order to launch the application, they will be clicking a button or link represented in a .jnlp file.
In Step 2, you will create a .jnlp file that the user will click to launch the application.
The .jnlp element’s attribute codebase will contain your web server URL.
If you are using Apache or Tomcat it would probably be something like.
The codebase and href are optional in Java 6 and above.
You’ll also notice the application-desc element’s attribute main-class containing the class that has the main() method.
Last but not least, you will create the HTML file that represents the web page in the user’s browser to be able to launch the application.
In this HTML file, you’ll notice the script element containing a JavaScript library (deployJava.js) to generate the commonly recognized orange Java Web Start button along with your .jnlp URL.
The following code line creates the Java Web Start button:
With solution 2’s files all created and ready to go, you will need to copy them over to a web server.
Any web server will do, but it is very important to ensure the mime types are set up properly.
If not, the user will just see the .jnlp document as an XML text.
If you are using Apache Tomcat you can set the mime type in the web.xml file using the following elements:
Following are some useful references that you can use when implementing the technique shown in this recipe:
Problem You want to create a glow effect on a button.
The following code creates an application that demonstrates a glowing animation effect when the user’s mouse pointer hovers over the button:
Figure 14-22 shows the application with its glowing animated button effect.
How It Works When you run this example, you may be wondering where is the animation I speak of? Well, just because it doesn’t move around the screen doesn’t mean it’s not being animated.
In this example, the button starts off with its text Press Me! colored black, then as the user begins to hover over the button using the mouse pointer, the text gradually turns red, appearing as if it is pulsing or glowing.
Fundamentally, animation is an illusion of things changing over time.
Quite similar to a cartoon flip book, each page represents a frame or picture that will be displayed on the timeline for a period of time.
To mimic an animation timeline you will be using Swing’s Timer API.
Relating to the analogy of a flip book in which each frame can be shown for a certain amount of time; however, in our simple example each frame will be the same amount of time (30 milliseconds, to be precise)
Here you will create a linear interpolation that changes the foreground color gradually as it approaches the allotted time.
To create timed cycles in support of animating our button, I used the Swing Timer object.
The duration of the entire animation is 250 milliseconds using the variable animDuration.
When animDuration has run out, the timer’s stop() method is invoked.
Also, when the user moves the mouse cursor away from the button, the timer’s stop() method is invoked to stop the animation.
In the actionPerformed() method that is responsible for interpolating the color of the foreground of the button, the repaint() method is called to refresh the GUI.
Problem You want to validate a field on a form by warning the user with an icon to indicate the problem.
Shown here is the code recipe used to build a simple application that validates an e-mail field and displays icon indicators when the e-mail is typed incorrectly.
The validation rule that alerts the user with an error icon is when the user has not entered the required e-mail symbols such as.
A warning icon is displayed when the domain contains more than three characters.
Figure 14-23 depicts the application validating an invalid e-mail address:
Figure 14-24 shows the application displaying a warning icon when the user has typed in a root domain with more than three characters.
How It Works Hopefully you have gone through most of the recipes in this chapter to give you an idea of how to build a GUI application.
Most of the recipes try to touch on all the aspects of building form-type applications from entering data to submitting form information to a database.
Validation can be applied on all layers of a multitier system.
I believe it’s imperative to have server-side validation, but for better usability, client-side validation can add that extra polish your application needs.
In this recipe, you will not only validate a field but also present to the user an error or warning indicator on top of the components.
I created a simple form with one input field to allow the user to enter an e-mail address.
If the user enters an invalid e-mail address, an error icon is displayed.
Now, if an e-mail is valid, but its root domain is more than three characters, a warning icon is displayed.
In our UsingJXLayer class constructor, you will lay components down on the panel as usual, except you will want to associate a JLayer to the e-mail field (JTextField) for validation with an icon feedback.
When instantiating a JLayer, it expects two parameters: the e-mail field (JTextField) and the.
To create a validation layer on top of an ordinary component, extend from the LayerUI generic class.
You can think of the LayerUI class as a piece of glass over the top of a component (JTextField)
Any time a change occurs in the text field, the paint() method is notified.
The paint() method is where the developer will have an opportunity to draw on the imaginary glass layer.
In this scenario, you will be drawing an error or warning icon overlaid to the right side of the component.
You’ll notice in the paint() method how you would obtain the JLayer and the text field by calling the JLayer.getView() method.
After obtaining the text from the e-mail field, you can now validate the data.
When encountering pattern matches such as an e-mail address, you will want to use Java’s regular expressions to validate fields.
At last, you will implement the conditionals that decide whether the layer should display an error or a warning icon by drawing an image onto the Graphics object, as shown here:
To see more details on drawing images, refer to recipe 12-16
Problem You want to print items that are contained in a table component similar to a spreadsheet.
The code recipe here constructs a simple timesheet application containing the days of the week with hours worked.
As the timesheet is displaying the hours worked, you can click the Print button to send the timesheet to the printer.
Figure 14-26 depicts the Print dialog box after the user has clicked the Print button.
How It Works On the surface, Java’s Swing API may look just like an ordinary GUI toolkit, but this powerful API has a lot of built-in features that you would never expect to see.
For instance, recipe 14-20 discussed how JLabels and JButtons contain the ability to format text using HTML.
And in recipe 14-17, you learned that a Document object has editor kits that can handle many content types.
But some components just have printing baked into it, and you don’t have to mess with those APIs.
The component I used in this recipe is a JTable that contains this built-in print() method.
In this recipe, the GUI application simulates a weekly timesheet with days and hours, table cells similar to spreadsheet applications (MS Excel)
To print your timesheet, just press the Print button, and you’ll see a print dialog box.
It can’t get any simpler than that! Shown here is the Print button’s actionPerformed() method that will launch the Print dialog box:
The JavaFX 2.0 API is Java’s next generation GUI toolkit for developers to build rich cross-platform applications.
JavaFX 2.0 is based on a scene graph paradigm (retained mode) as opposed to the traditional immediate mode style rendering.
JavaFX’s scene graph is a tree-like data structure that maintains vector-based graphic nodes.
The goal of JavaFX is to be used across many types of devices such as mobile devices, smartphones, TVs, tablet computers, and desktops.
Before the creation of JavaFX, the development of rich Internet applications (RIAs) involved the gathering of many separate libraries and APIs to achieve highly functional applications.
Because integrating these APIs together can be rather difficult, the talented engineers at Sun Microsystems (now Oracle) created a new set of JavaFX libraries that roll up all the same capabilities under one roof.
JavaFX 2.0 is a pure Java (language) API that allows developers to leverage existing Java libraries and tools.
Depending on who you talk to, you will likely encounter different definitions of “user experience” (or in the UI world, UX)
But one fact still remains; the users will always demand better content and increased usability from GUI applications.
In light of this fact, developers and designers often work together to craft applications to fulfill this demand.
JavaFX provides a toolkit that helps both the developer and designer (in some cases, they happen to be the same person) to create functional yet esthetically pleasing applications.
Another thing to acknowledge is that if you are developing a game, media player, or the usual enterprise application, JavaFX will not only assist in developing richer UIs but.
Again, I want to remind you that there are entire books written on JavaFX, and it would be impossible for us to cover all the capabilities of the toolkit.
Hopefully, these recipes can lead you in the right direction by providing practical and real-world examples.
So I encourage you to explore other resources to gain further insight into JavaFX.
This book goes in depth to help you create professional grade applications.
In this chapter you will learn the fundamentals of JavaFX to rapidly develop RIAs.
Before we begin I want to give you a heads up relating to the recipes in this chapter and how much they resemble prior chapters.
Problem You want to start developing JavaFX applications, but you don’t know what software is required to be installed.
Solution You’ll need to install the following software in order to get started with JavaFX:
Note As of this writing, things are subject to change.
By the time you read this; you will likely find JavaFX able to run on your favorite OS.
For this recipe, I assume that Java 7 is already installed so I won’t detail those installation steps.
Following are steps to install all other required software components:
Once you have launched the JavaFX SDK setup executable you will see the start of the wizard in Figure 15-2
After you click Next, the components will install and the screen shown in Figure 15-4 will appear.
Figure 15-4 displays the progress indicator installing the last components before completing.
Install the NetBeans IDE, which includes the JavaFX 2.0 plug-in.
Configuring your environment variable CLASSPATH to include the JavaFX runtime library.
You may need to modify your steps slightly when installing JavaFX 2.0 on other operating systems as they become available.
Although the steps described here are for NetBeans, you can also develop using other IDEs such as Eclipse, IntelliJ, or vi.
While most of the example recipes were created using the NetBeans IDE, you can also compile and run JavaFX applications using the command-line prompt.
To compile and run JavaFX applications using the command-line prompt you will need to configure your CLASSPATH.
Setting this library will later assist in compiling and running JavaFX-based applications on the command-line.
The following code configures your CLASSPATH environment variable based on your platform:
In recipe 15-2 you will learn how to create a simple Hello World application.
Once your Hello World application is created, you will be able to compile and run a JavaFX-based application.
Problem You want to create, code, compile, and run a simple JavaFX Hello World application.
To quickly get started with creating, coding, compiling, and running a simple JavaFX HelloWorld application using the NetBeans IDE, follow these steps:
Change or accept the defaults for the Project Location and Project Folder fields.
Make sure the Create Application Class check box option is selected.
In the NetBeans IDE on the Projects tab, select the newly created project.
Figure 15-5 depicts the JavaFX tab detailing its SDK home, Runtime, and Javadoc directory locations.
Solution 2 Use your favorite editor to code your JavaFX Hello World application.
Once the Java file is created you will use the command-line prompt to compile and run your JavaFX application.
Following are the steps to create a JavaFX Hello World application to be compiled and run on the command-line prompt.
The following source code is a JavaFX Hello World application: package helloworldmain;
How It Works Following are descriptions of the two solutions.
I cover how to install required software in recipe 15-1
In Solution #1 you will be creating a JavaFX application using the NetBeans IDE.
Solution #2 allows you to choose your favorite editor and use the commandline prompt to compile and execute JavaFX programs.
Finally, in Step 11 you will run the JavaFX Hello World application by selecting the Run Main Project menu option.
If you are not experiencing this issue, the NetBeans team may have already corrected the problem.
Once the source code is entered into your favorite editor and the source file has been saved, you will want to compile and run your JavaFX program.
Here I would like to point out the way you compile the file using the command javac -d.
This lets the Java compiler know where to put class files based on their package name.
In this scenario, the HelloWorldMain package statement is helloworldmain, which will create a subdirectory under the current directory.
When finished compiling, your directory structure should resemble the following:
With the preceding directory structure in mind, the following commands will compile and run our JavaFX Hello World application:
Note There are many ways to package and deploy JavaFX applications.
To learn more, please see “Learning how to deploy and package JavaFX applications” at http://blogs.oracle.com/thejavatutorials/entry/javafx_2_0_beta_packager.
The Application class provides application life cycle functions such as launching and stopping during runtime.
This also provides a mechanism for Java applications to launch JavaFX GUI components in a threadsafe manner.
Keep in mind that synonymous to Java Swing’s event dispatch thread, JavaFX will have its own JavaFX application thread.
To learn more about thread safety refer to Chapter 14 Swing API.
Once the application is in a ready state, the framework internals will invoke the start() method to begin.
You’ll notice that some objects are oddly named, such as Stage or Scene.
The designers of the API have modeled things similar to a theater or a play in which actors perform in front of an audience.
With this same analogy, in order to show a play, there are basically one-to-many scenes that actors perform in.
And, of course, all scenes are performed on a stage.
You may think of a Scene object as a content pane capable of holding zero-to-many Node objects.
A Node is a fundamental base class for all scene graph nodes to be rendered.
Similar to a tree data structure, a scene graph will contain children nodes by using a container class Group.
We’ll learn more about the Group class later when we look at the ObservableList, but for now we can think of them as Java Lists or Collections that are capable of holding Nodes.
Once the child nodes have been added, we set the primaryStage’s (Stage) scene and call the show() method on the Stage object to show the JavaFX window.
One last thing: in this chapter most of the example applications will be structured the same as this example in which recipe code solutions will reside inside the start() method.
Having said this, most of the recipes in this chapter will follow the same pattern.
In other words, for the sake of brevity, much of the boiler plate code will not be shown.
To see the full source listings of all the recipes, please download the source code from the book’s web site.
Problem You want to draw text onto the JavaFX scene graph.
As Text nodes are to be placed on the scene graph, you decide you want to create randomly positioned Text nodes rotated around their (x, y) positions scattered about the scene area.
Figure 15-8 shows random Text nodes scattered about the JavaFX scene graph.
In this example you’ll notice text objects with random colors and positions scattered about the Scene area.
First, we create a loop to generate random (x,y) coordinates to position Text nodes.
Second, we create random color components between (0–255 rgb) to be applied to the Text nodes.
Third, the rotation angle (in degrees) is a randomly generated value between (0–360 degrees) to cause the text to be slanted.
The following code creates random values that will be assigned to a Text node’s position, color, and rotation:
Once the random values are generated, they will be applied to the Text nodes, which will be drawn.
The following code snippet applies position (x, y), color (rgb), and rotation (angle in degrees) onto the Text node:
You will begin to see the power of the scene graph API by its ease of use.
Although the text is colorized, they still tend to be somewhat boring.
However, in the next recipe we will demonstrate how to change a text’s font.
Problem You want to change text fonts and add special effect to Text nodes.
Solution Create a JavaFX application that uses the following classes to set the text font and apply effects on Text nodes:
The code that follows sets the font and applies effects to Text nodes.
We will be using the Serif, SanSerif, Dialog, and Monospaced fonts along with the drop shadow and reflection effects:
Figure 15-9 shows the JavaFX application setting various font styles and applying effects (drop shadow and reflection) to the Text nodes.
Hopefully you read recipe 12-9, in which I created a drop shadow effect by creating two separate text drawings.
In this recipe the drop shadow is a real effect (DropShadow) object and actually applied to a single Text node instance.
The DropShadow object is set to be positioned based on an x and y offset in relation to the Text node.
Also we can set the color of the shadow; here we set it to gray with a .588 opacity.
Following is an example of setting a Text node’s effect property with a drop shadow effect (DropShadow):
Although this is about setting text fonts, we applied effects to Text nodes.
I’ve added yet another effect (just kicking it up a notch)
While creating the last Text node using the monospaced font, I applied the popular reflection effect.
Problem You want to create shapes to be placed on the scene graph.
Figure 15-10 displays the sine wave, ice cream cone, smile, and donut shapes that we have created using JavaFX:
Here, we simply used the same coordinates, stroke, and color values to render the same kind of shapes.
For brevity I will not go into details relating to stroking, color, transforms, paths, and curve control points (they are all mentioned in Chapter 12)
But I will go over the JavaFX conventions, concepts, and APIs to render shapes.
But, right off the bat in the source code listing in the solution section, you’ll notice that I didn’t use the usual new CubicCurve() constructor like the previous snippet, but instead I use a class having a suffix of Builder on the end of it.
Builder classes are convenience classes that follow a design pattern called the Builder pattern.
Builder classes provide a way to method chain invocations by enabling the developer to specify attributes in an ad hoc way (declarative)
This makes code more readable and less verbose, thus increasing developer productivity.
When using this facility while developing graphics applications, you may also find that coding tends to be more expressive and reminiscent of the JavaFX 1.x script language when using declarative syntax to construct UI objects.
Back to CubicCurveBuilder; we begin with the create() method that will instantiate a Builder class.
Next is specifying a cubic curve’s attributes in any order.
Similar to mutators or setter methods, you simply pass a single value to the method.
The convention is that the set prefixed on the method is removed, and the method returns the this pointer of the builder object instance.
By returning itself it allows you to continue to use the dot notation to specify parameters, thus the method chaining behavior.
Once finished with specifying values on the Builder class, a call to the build() method will return an instance of the desired class (in this case, the CubicCurve class)
Here, instead of using the builder convenience classes, I resorted to the verbose Java code style.
So you won’t be able to instantiate a LineTo class to be put in the scene graph.
Just remember that the classes with To as a suffix is a path element, not a real Shape node.
For example, the MoveTo and LineTo object instances are Path elements added to a Path object, not shapes that can be added to the scene.
Shown following are Path elements added to a Path object to draw an ice cream cone:
Rendering the QuadCurve (smile) object I used the QuadCurveBuilder similar to the CubicCurveBuilder class, and you’ll notice the simplicity of creating such a shape.
Once your builder class is complete you will finish things off by invoking the build() method.
Last is our tasty donut shape with a drop shadow effect.
When creating the donut, we begin by creating two circular ellipses.
By subtracting the smaller ellipse (donut hole) from the larger ellipse area, a newly derived shape is created and returned using the Path.subtract() method.
Following is the code snippet that creates the donut shape using the Path.subtract() method:
Next, is applying a drop shadow effect onto our donut.
This time instead of drawing the shape twice, similar to a prior recipe we draw it once and use the setEffect() method to apply a DropShadow object instance.
Similar to our prior technique, we can set the offset of the shadow by calling setOffsetX() and setOffsetY()
Problem You want to fill your shapes with simple colors and gradient colors.
Solution In JavaFX, all shapes can be filled with simple colors and gradient colors.
The following are the main classes used to fill shape nodes:
Figure 15-11 displays the various types of colorized fills that can be applied onto shapes.
How It Works Figure 15-11 shows shapes displayed from top to bottom starting with an ellipse, rectangle, and a rounded rectangle having colored gradient fills.
When drawing the eclipse shape you will be using a radial gradient that appears as if it were a 3D spherical object.
Next, you will be creating a rectangle filled with a yellow semitransparent linear gradient.
A thick black line shape was drawn behind the yellow rectangle to demonstrate the rectangle’s semitransparent color.
Last, you will implement a rounded rectangle filled with a green-and-black reflective linear gradient resembling 3D tubes in a diagonal direction.
The amazing thing about colors with gradients is that they can often make shapes appear threedimensional.
Gradient paint allows you to interpolate between two or more colors, which gives depth to the shape.
JavaFX provides two types of gradients: a radial (RadialGradient) and a linear (LinearGradient) gradient.
For our ellipse shape you will be using a radial gradient (RadialGradient)
Angle in degrees from the center of the gradient to the focus point to which the first color is mapped.
Next, you will be creating a rectangle having a yellow semitransparent linear gradient.
For our yellow rectangle you will be using linear gradient (LinearGradient) paint.
To create a linear gradient paint you will specify the startX, startY, endX, and endY for the start and.
The start and end point coordinates denote where the gradient pattern begins and stops.
Finally, you’ll notice a rounded rectangle with a repeating pattern of a gradient using green and black in a diagonal direction.
Problem You want to create standard menus in your JavaFX applications.
Solution Employ JavaFX’s menu controls to provide standardized menuing capabilities such as check box menus, radio menus, submenus, and separators.
The following are the main classes used to create menus.
Figure 15-12 shows a simulated building security application containing radio, checked, and submenu items.
How It Works Menus are standard ways on windowed platform applications to allow users to select options.
Menus should also have the functionality of hot keys or keyboard equivalents.
Often users will want to use the keyboard instead of the mouse to navigate the menu.
Because this recipe parallels recipe 14-9, you’ll notice lots of similarities.
First, we create an instance of a MenuBar that will contain one to many menu (MenuItem) objects.
Secondly, we create menu (Menu) objects that contain one-to-many menu item (MenuItem) objects.
I don’t showcase this in the recipe, but I encourage you to explore the various constructors for all menu items (MenuItem)
When creating a radio menu item (RadioMenuItem), you should be aware of the ToggleGroup class.
The ToggleGroup class is also used on regular radio buttons (RadioButtons) to allow one selected option only.
The following code creates radio menu items (RadioMenuItems) to be added to a Menu object:
At times you may want some menu items separated with a visual line separator.
To create a visual separator, create an instance of a SeparatorMenuItem class to be added to a menu via the getItems() method.
As you will see later in recipe 15-11, you will learn about the ability to be notified when items in a collection are altered.
Prior to our adding the menu bar to the scene, you will notice the bound property between the preferred width of the menu bar and the width of the Stage object via the bind() method.
When binding these properties you will see the menu bar’s width stretch when the user resizes the screen.
Later you will see how binding works in recipe 15-10, “Binding Expressions.” This code snippet shows the binding between the menu bar’s width property and the stage’s width property.
Problem You want to add UI components to a layout similar to a grid type layout.
Figure 15-3 depicts a small form containing UI controls laid out using a grid pane layout node.
How It Works One of the greatest challenges in building user interfaces is the laying out of controls onto the display area.
When developing GUI applications it is ideal for an application to allow the user to move and adjust the size of their viewable area while maintaining a pleasant user experience.
Similar to Java Swing, JavaFX layout has stock layouts that provide the most common ways to display UI controls on the scene graph.
You may recall recipe 14-4, in which we implemented a custom layout to display components in a grid-like manner.
You may notice similarities, but I left a lot of implementation features out such as adjusting min/max sizes, padding, and vertical alignments.
Amazingly, the JavaFX team has created a robust grid-like layout called the GridPane.
Next, we set the padding by using an instance of an Inset object.
After setting the padding, we simply set the horizontal and vertical gap.
The following code snippet instantiates a grid pane (GridPane) with padding, horizontal, and vertical gaps set to 5 (pixels):
The padding is the top, right, bottom, and left spacing around the region's content in pixels.
When obtaining the preferred size, the padding will be included in the calculation.
Setting the horizontal and vertical gaps relate to the spacing between UI controls within the cells.
Next is simply putting each UI control into its respective cell location.
The layout also allows you to horizontally or vertically align controls within the cell.
Problem You want to create and customize borders around an image.
Solution Create an application to dynamically customized border regions using JavaFX’s CSS styling API.
The following code creates an application that has a CSS editor text area and a border view region surrounding an image.
By default the editor’s text area will contain JavaFX styling selectors that create a dashed-blue line surrounding the image.
You will have the opportunity to modify styling selector values in the CSS Editor by clicking the Bling! button to apply border settings.
How It Works JavaFX is capable of styling JavaFX nodes similar to Cascading Style Sheets (CSS) in the world of web development.
This powerful API can alter a node’s background color, font, border, and many other attributes essentially allowing a developer or designer to skin GUI controls using CSS.
This recipe allows a user to enter JavaFX CSS styles in the left text area and, by clicking the Bling! button below, to apply the style around the image shown to the right.
Based on the type of node there are limitations to what styles you can set.
To see a full listing of all style selectors refer to the JavaFX CSS Reference Guide:
In the first step of applying JavaFX CSS styles, you must determine what type of node you want to.
When setting attributes on various node types, you will discover that certain nodes have limitations.
In our recipe the intent is to put a border around the ImageView object.
Because ImageView is not extending from Region it doesn’t have border style properties.
So, to resolve this I simply create an HBox layout to contain the imageView and apply the JavaFX CSS against the HBox.
Shown here is code to apply JavaFX CSS border styles to a horizontal box region (HBox) using the setStyle() method:
There is more than one scenario to consider when binding values or properties.
The following code is a console application implementing these three strategies.
The console application will output property values based on various binding scenarios.
The first scenario is a bidirectional binding between a String property variable and a String property owned by a domain object (Contact) such as the firstName property.
The next scenario is a high-level binding using a fluent interface API to calculate the area of rectangle.
The last scenario is using a low-level binding strategy to calculate the volume of a sphere.
The difference between the high-and low-level binding is that the high level uses methods such as multiply(), subtract() instead of the operators * and -
When using lowlevel binding, you would use a derived NumberBinding class such as a DoubleBinding class.
With a DoubleBinding class you will override its computeValue() method so that you can use the familiar operators such as * and - to formulate complex math equations:
How It Works Binding has the idea of at least two values being synchronized.
This means when a dependent variable changes the other variable changes.
JavaFX provides many binding options that enable the developer to synchronize properties in domain objects and GUI controls.
One of the easiest ways to bind variables is a bidirectional bind.
This scenario is often used when domain objects contain data that will be bound to a GUI form.
In our recipe we create a simple contact (Contact) object containing a first name and last name.
In order for these properties to be bound, they must be the same data type.
Once they have been created we bind them bidirectionally to allow changes to update on either end.
So if you change the domain object, the other bound properties get updated.
And when the outside variables are modified, the domain object’s properties get updated.
The following demonstrates bidirectional binding against string properties on a domain object (Contact):
Binding numbers is simple when using the new Fluent API.
Basically, a formula is “bound” to change its result based on changes to the variables it is bound to.
Please look at the Javadoc for details on all the available methods and number types.
In this example we simply create a formula for an area of a rectangle.
The area (NumberBinding) is the binding, and its dependencies are the width and height (IntegerProperty) properties.
When binding using the fluent interface API, you’ll notice the multiply() method.
The last scenario on binding numbers is considered more of a low-level approach.
Here we use a DoubleBinding class to solve the volume of a sphere given the radius.
Shown is the low-level binding scenario to compute the volume of a sphere by overriding the computeValue() method:
Problem You want to create a GUI application containing two list view controls allowing the user pass items between the two lists.
The following code creates a GUI application containing two lists that allow the user to send items contained in one list to be sent to the other.
Here you will create a contrived application to pick candidates to be considered heroes.
The user will pick potential candidates from the list on the left to be moved into the list on the right to be considered heroes.
This demonstrates UI list controls’ (ListView) ability to be synchronized with back-end store lists (ObservableList)
How It Works When dealing with Java collections you’ll notice there are so many useful container classes that represent all kinds of data structures.
When building applications with domain objects that contain an ArrayList, a developer can easily manipulate objects inside the collection.
But, in the past (back in the day), when using Java Swing components combined with collections can often be a challenge, especially updating the GUI to reflect changes in the domain object.
How do we resolve this issue? Well, JavaFX’s ObservableList to the rescue!
Speaking of rescue, I’ve created a GUI application to allow users to choose their favorite heroes.
This is quite similar to application screens that manage user roles by adding or removing items from list box components.
In JavaFX we will be using a ListView control to hold String objects.
Before we create an instance of a ListView we create an ObservableList containing our candidates.
Here you’ll notice the use of a factory class called FXCollections, in which you can pass in common collection types to be wrapped and returned to the caller as an ObservableList.
In the recipe I passed in an array of Strings instead of an.
ArrayList, so hopefully you get the idea about how to use the FXCollections class.
I trust you will use it wisely: “With great power, there must also come great responsibility”
This code line calls the FXCollections class to return an observable list (ObservableList):
Once manipulated, the ListView will be notified and automatically updated to reflect the changes of the ObservableList.
The following code snippet implements the event handler and action event when the user presses the send right button:
When setting an action we use the generic class EventHandler to create an anonymous inner class with the handle() method to listen for a button press event.
When a button press event arrives, the code will determine which item in the ListView was selected.
Once the item was determined, we clear the selection, remove the item, and add the item to the hero’s ObserverableList.
Problem You want to create a GUI application that simulates the copying of files using background processing while displaying the progress to the user.
Solution Create an application typical of a dialog box showing progress indicators while copying files in the background.
The following are the main classes used in this recipe:
The following source code is an application that simulates a file copy dialog box displaying progress indicators and performing background processes:
Figure 15-16 shows our Background Processes application simulating a file copy window.
How It Works One of the main pitfalls of GUI development is knowing when and how to delegate work (Threads)
We are constantly reminded of thread safety, especially when it comes to blocking the GUI thread.
As in recipe 14-6, we discuss and implement the SwingWorker object to defer non-GUI work off of the event dispatch thread (EDT)
Similar patterns and principles still apply in the world of JavaFX.
Again, this recipe will be a JavaFX version of recipe 14-6
We begin by creating not one but two progress controls to show off to the user the work being done.
One is a progress bar, and the other is a progress indicator.
The progress indicator shows a percentage below the indicator icon.
The following code snippet shows the initial creation of progress controls:
Next, we create a worker thread via our createWorker() method.
Unlike the SwingWorker class, the Task object is greatly simplified and easier to use.
If you’ve compared the last recipe you will notice that none of the GUI controls is passed into the Task.
The clever JavaFX team has created observable properties that allow us to bind to.
This fosters a more eventdriven approach to handling work (tasks)
When creating an instance of a Task object you will implement the call() method to do work in the background.
During the work being done, you may want to queue up intermediate results such as progress or text info, you can call the updateProgress() and updateMessage() methods.
These methods will update information in a threadsafe way so that the observer of the progress properties will be able to update the GUI safely without blocking the GUI thread.
The following code snippet demonstrates the ability to queue up messages and progress:
After creating a worker Task we unbind any old tasks bound to the progress controls.
Shown here is the code used to rebind a new Task object to the progress UI controls:
Next, we implement a ChangeListener to append the queued results into the TextArea control.
Another remarkable thing about JavaFX Properties is that you can attach many listeners similar to Java Swing components.
Finally our worker and controls are all wired up to spawn a thread to go off in the background.
The following code line shows the launching of a Task worker object:
The cancel button will simply call the Task object’s cancel()
Once the task is cancelled the progress controls are reset.
Once a worker Task is cancelled it cannot be reused.
That is why the start button re-creates a new Task.
The following code line will cancel a Task worker object:
Problem You want to create keyboard shortcuts for menu options.
Solution Create an application that will use JavaFX’s key combination APIs.
The main classes you will be using are shown here:
The following source code listing is an application that displays the available keyboard shortcuts that are bound to menu items.
When the user performs a keyboard shortcut the application will display the key combination on the screen:
Figure 15-17 displays an application that demonstrates keyboard sequences or keyboard shortcuts.
Seeing that the previous recipe was a tad boring, I decided to make things a little more interesting.
This recipe will display Text nodes onto the scene graph when the user performs the key combinations.
When displaying the Text nodes I applied an inner shadow effect.
The following code snippet creates a Text node with an inner shadow effect:
So to create a keyboard shortcut you simply call a menu or button control’s setAccelerator() method.
In this recipe we use a Builder class and set the key combination using the accelerator() method.
The following code line specifies the key combinations for a control N:
Problem You want to display items in a UI table control similar to Java Swing’s JTable component.
The TableView control provides the equivalent functionality similar to Swing’s JTable component.
To exercise the TableView control you will be creating an application that will display bosses and employees.
On the left you will implement a ListView control containing bosses, and employees (subordinates) will be displayed in a TableView control on the right.
Shown here is the source code of a simple domain (Person) class to represent a boss or an employee to be displayed in a ListView or TableView control:
The following is our main application code that displays a list view component on the left containing bosses and a table view control on the right containing employees:
The following code is the getPeople() method contained in the WorkingWithTables main application class.
This method helps to populate the UI TableView control shown previously:
Figure 15-18 displays our application that demonstrates JavaFX’s TableView control.
How It Works Just for fun I created a simple GUI to display employees and their bosses.
You notice in Figure 15-18 on the left is a list of people (Boss)
When users click and select a boss, their employees will be shown to in the TableView area to the right.
You’ll also notice the tooltip when you hover over the selected boss.
Before we begin to discuss the TableView control I want to explain about the ListView that is responsible for updating the TableView.
In model view fashion we first create an ObservableList containing all the bosses for the ListView control’s constructor.
In my code I was politically correct by calling bosses leaders.
Next, we create a cell factory to properly display the person’s name in the ListView control.
With your trusty NetBeans IDE, it will pregenerate things such as the implementing method call()
Next is the variable cell of type ListCell<Person> (within the call() method), in which we create an anonymous inner class.
To implement the updateItem() method you will obtain the person information and update the Label control (leadLbl)
Finally, we get to create a TableView control to display the employee base on the selected boss from the ListView.
When creating a TableView we first create the column headers.
Once you have created a column, you’ll notice the setProperty() method, which is responsible for.
So when the list of employees is put into the TableView, it will know how to pull the properties to be placed in each cell in the table.
We simply create and add a ChangeListener to listen to selection events.
When a user selects a boss, the TableView is cleared and populated with the boss’ employees.
Actually it is the magic of the ObservableList that notifies the TableView of changes.
Problem You want to split up a GUI screen by using split divider controls.
The split control allows the user to use the mouse to move the divider between any two split regions.
The three windowed regions are a lefthand column, an upper-right region, and a lower-right region.
In addition, you will be adding Text nodes into the three regions.
How It Works If you’ve ever seen a simple RSS reader or the Javadocs, you’ll notice that the screen is divided into sections with dividers that allow the user to adjust.
In this recipe, three areas are on the left, upper right, and lower right.
I begin by creating a SplitPane that divides the left from the right area of the scene.
Then I bind its width and height properties to the scene so the areas will take up the available space as the user resizes the Stage.
Next I create a VBox layout control representing the left area.
In the VBox (leftArea), I loop to generate a bunch of Text nodes.
Next is creating the right side of the split pane.
The following code snippet allows the split pane control (SplitPane) to divide horizontally:
At last we assemble the split panes and adjust the dividers to be positioned so that the screen real.
The following code assembles the split panes and iterates through the list of dividers to update their positions:
Problem You want to create a GUI application with tabs.
The following code example creates a simple application having menu options that allow the user to choose a tab orientation.
The available tab orientations are top, bottom, left, and right.
Figure 15-20 displays the tabs application, which allows a user to change the tab orientation.
How It Works When you use the TabPane control, you might already know the orientation in which you want your tabs to appear.
This application allows you to set the orientation by the menu options for Left, Right, Top, and Bottom.
To use the TabPane you will immediately notice how similar it is to Java Swing’s JTabbedPanel.
The following code snippet adds Tab controls into a tab pane control:
When changing the orientation the TabPane control, use the setSide() method.
The following code line sets the orientation of the tab pane control:
Problem You want to create an application that simulates a change password dialog box.
The following source code listing is an application that simulates a change password dialog box.
The application contains menu options to pop up the dialog box.
In addition to the menu options, the user will have the ability to set the dialog box’s modal state (modality)
Figure 15-21 depicts our change password dialog box application with the Non Modal option enabled.
How It Works Here we go again… Not another recipe with a login screen! Well, this time it’s rewritten in JavaFX so it’s got to be better.
Recipe 14-18 discussed modality and how JDialog is similar to JFrame.
Remember recipe 14-18, in which I stated how simple it is to create a JDialog window? It is even simpler in JavaFX.
Similar to extending from a JDialog class, you simply extend from a Stage class.
You have the opportunity (as in Swing) to pass in the owning window in the constructor, which then calls the initOwner() method.
Next is setting the modal state of the dialog box using the initModality() method.
Following is a class that extends from the Stage class having a constructor initializing the owning stage and modal state:
The rest of the code creates a scene (Scene) similar to the main application’s start() method.
Because login forms are pretty boring, I decided to create an animation of a bouncing ball while the user is busy changing the password in the dialog box.
You will see more about creating animation in recipe 16-2
Have you ever heard someone say, “When two worlds collide”? This expression is used when a person from a different background or culture is put in a situation where they are at odds and must face very hard decisions.
When we build a GUI application needing animations, we are often in a collision course between business and gaming worlds.
In the ever-changing world of RIAs, you probably have noticed an increase of animations such as pulsing buttons, transitions, moving backgrounds, and so on.
When GUI applications use animations, they can provide visual cues to the user to let them know what to do next.
With JavaFX, you will be able to have the best of both worlds.
In this chapter you will create images, animations, and Look ‘N’ Feels.
Fasten your seatbelts; you’ll discover solutions to integrate cool game-like interfaces into our everyday applications.
Note Refer to Chapter 15 if you are new to JavaFX.
Among other things, it will help you get an environment created in which you can be productive in using JavaFX.
Problem There are photos in your file directory that you would like to quickly browse through and showcase.
Figure 16-2 depicts the drag-and-drop operation that gives the user visual feedback with a thumbnail-sized image over the surface.
In the figure, I’m dragging the image onto the application window.
Figure 16-3 shows that the drop operation has succesfully loaded the image.
How It Works This recipe is a simple application that allows you to view images having file formats such as .jpg, .png, and .gif.
Loading an image requires using the mouse to drag and drop a file into the window area.
The application also allows resizing of the window, which automatically causes scaling of the image’s size while maintaining its aspect ratio.
After a few images are successfully loaded, you will be able to page through each image conveniently by clicking the left and right button controls, as shown in Figure 16-3
Table 16-1 describes instance variables for our sleek image viewer application.
A list of Strings, each containing an image’s absolute file path.
When dragging an image into the application, the imageFiles variable will cache the absolute file.
If a user drags the same image file into the display area, the list will contain duplicate strings representing the image file.
That imageFiles list points to the String representing the current image file.
As the user clicks the buttons to display the previous and next image, the currentIndex will decrement or increment, respectively.
Next, you will walk through the code detailing the steps on how to load and display an image.
Later I will discuss the steps on paging through each image with the next and previous buttons.
Using the ImageView node will enable you to create special effects on the image to be displayed without manipulating the physical Image.
To avoid performance degradation when rendering many effects, you can use numerous ImageView objects that reference a single Image object.
Many types of effects include blurring, fading, and transforming an image.
One of the requirements is preserving the displayed image’s aspect ratio as the user resizes the window.
Here, you will simply call the setPreserveRatio() method with a value of true to preserve the image’s aspect ratio.
Remember that because the user resizes the window, you want to bind the width of the ImageView to the Scene’s width to allow the scaling of the image to take effect.
After setting up the ImageView, you will want to pass it to an HBox instance (pictureRegion) to be put into the scene.
The following code creates the ImageView instance, preserves the aspect ratio, and scales the image:
Next, I want to introduce JavaFX’s new native drag-and-drop support, which offers many scenarios a user can perform, such as dragging visual objects from an application to be dropped into another application.
In this scenario, the user will be dragging an image file from the host windowing operating system to your image viewer application.
When performing this scenario, you must create EventHandler objects to listen to DragEvents.
To fulfill this requirement, you only need to set-up a Scene’s drag-over and drag-dropped event handler methods.
Here you will implement the handle() method to listen to the drag-over event (DragEvent)
In the handle() method notice the event (DragEvent) object’s invocation to the getDragboard() method.
The call to getDragboard() will return the drag source (Dragboard), better known as the clipboard.
When you obtain the Dragboard object, you can determine and validate what is being dragged over the surface.
In this scenario, you are trying to determine whether the Dragboard object contains any files.
Otherwise it should consume the event by calling the event.consume() method.
The following code demonstrates setting up a Scene’s OnDragOver attribute by instantiating an inner class of type EventHandler with a formal type parameter <DragEvent> and overriding its handle() method:
Once the drag-over event handler attribute is set, you must create a drag-dropped event handler.
Listening to a drag-dropped event is similar to listening to a drag-over event in which you will implement the handle() method.
Once again you obtain the Dragboard object from the event to determine whether the clipboard contains any files.
If so, you will iterate over the list of files and their names to be added to the imageFiles list.
This demonstrates setting up a Scene’s OnDragDropped attribute by instantiating an inner class of type EventHandler with a formal type parameter <DragEvent> and overriding its handle() method:
As the last file is determined, the current image is displayed.
For the last requirements relating to the image viewer application, you will be creating simple controls that allow the user to view the next or previous image.
I emphasize “simple” controls because JavaFX contains two other methods for creating custom controls.
One way (CSS Styling) is discussed later in recipe 16-5
To explore the other alternative, please refer to the Javadoc on the Skin and Skinnable APIs.
Next is adding an EventHandler that listens to mouse-pressed events that will load and display the appropriate image based on enums ButtonMove.PREV and ButtonMove.NEXT.
You will find the EventHandler indispensible and useful in so many ways.
When implementing the handle() method I determine which button was pressed; it then returns the index into the imageFiles list of the next image to display.
When loading an image using the Image class you can load images from the file system or a URL, but in this recipe I am using a File object.
The right button’s (rightButton) event handler is identical, so I trust you get the idea.
The only thing different is determining whether the previous button or the next button was pressed via the ButtonMove enum.
This is passed to the gotoImageIndex() method to determine whether an image is available in that direction.
To finish the image viewer application, you have to bind the rectangular buttons control to the Scene’s width and height, which repositions the control as the user resizes the window.
Once your buttons control is bound, your user will experience user interface goodness.
The following code uses the Fluent API to bind the button control’s properties to the Scene’s properties:
For example, you want to create a news ticker and photo viewer application with the following requirements:
It will have a news ticker control that scrolls to the left.
It will fade out the current picture and fade in the next picture as the user clicks the button controls.
It will fade in and out button controls when the cursor moves in and out of the scene area, respectively.
To fade out the current picture and fade in next picture, you need the following classes:
To fade in and out button controls when the cursor moves into and out of the scene area, respectively, the following classes are needed:
Shown here is the code used to create a news ticker control:
The following code is used to fade in and out the button controls when the cursor moves into and out of the scene area, respectively:
How It Works In the photo viewer application I decided to incorporate animation effects.
The main animation effects I focus on are translating and fading.
Next, you will apply another fading effect when the user clicks the previous and next buttons to transition from the current image to the next.
Before I begin to discuss the steps to fulfill the requirements, I want to mention the basics of JavaFX animation.
The JavaFX animation API allows you to assemble timed events that can interpolate over a node’s attribute values to produce animated effects.
Each timed event is called a keyframe (KeyFrame), which is responsible for interpolating over a Node’s property over a period of time.
Knowing that a keyframe’s job is to operate on a Node’s property value, you will have to create an instance of a KeyValue class that will reference the desired Node property.
The idea of interpolation is simply the distributing of values between a start and end value.
Shown here is a keyframe and key value to interpolate a rectangle’s x property for 1000 milliseconds:
When creating many keyframes that are assembled consecutively, you need to create a TimeLine.
The cycle count is the number of times you want the timeline to play the animation.
The auto-reverse is the capability for the animation to play the timeline backward.
By default, the cycle count is set to 1, and the auto-reverse is set to false.
The following code snippet demonstrates a timeline playing indefinitely and auto-reverse set to true:
With this knowledge of timelines you can animate any graph node in JavaFX.
You are probably wondering whether there are easier ways to express common animations.
Good news! JavaFX has transitions (Transition), which are convenience classes to perform common animated effects.
The first requirement in our problem statement is to create a news ticker.
When creating a news ticker control, Text nodes will scroll from right to left inside a rectangular region.
When the text scrolls to the left edge of the rectangular region you will want the text to be clipped to create a view port that only shows pixels inside of the rectangle.
Here, I first create a Group to hold all the components that comprise a ticker control.
Next is the creation of a rectangle using the RectangleBuilder to build a white rounded rectangle filled with 55 percent opacity.
Figure 16-5 shows a rounded rectangular area as a clip region:
Once the ticker control is created, you will bind the translate Y based on the Scene’s height property minus the ticker control’s height.
You will also bind the ticker control’s width property based on the width of scene minus the button control’s width.
By binding these properties, the ticker control can change its size and position whenever a user resizes the application window.
This makes the ticker control appear to float at the bottom of the window.
The following code binds the ticker control’s translate Y, width, and clip region’s width property:
Now that you have finished creating a ticker control, you will need to create news to feed into it.
You will create a Text node with text that represents a news feed.
The following code adds a Text node to the ticker control:
For instance, in the scenario in which you use translate X on a Text node, there are methods fromX() and toX()
The fromX() is the starting value and the toX() is the end value that will be interpolated.
Finally, I set the cycle count to 1, which will animate the ticker once based on the specified duration.
When the ticker’s news has scrolled completely off of the ticker area to the far left of the Scene, you.
Once the animation is defined, you simply invoke the play() method to get it started.
Now that you have a better understanding of animated transitions, what about a transition that can trigger any number of transitions? JavaFX has two transitions that provide this behavior.
The two transitions can invoke individual dependent transitions sequentially or in parallel.
When creating the previous and next button’s event handlers, you first determine the next image to be displayed by calling the gotoImageIndex() method.
For the last requirements relating to fading in and out, you use the button controls.
You will yet again use the FadeTransition to create a ghostly animated effect.
It is easy peasy to add mouse events to the Scene; all you have to do is override the handle() method where the inbound parameter is a MouseEvent type (the same as its formal type parameter)
Inside of the handle() method, you will create an instance of a FadeTransition object by using the constructor that takes the duration and node as parameters.
The following code adds an EventHandler to create the fade-in effect when the mouse cursor is positioned inside of the Scene:
Last but not least, the fade-out EventHandler is basically the same as the fade-in, except that the.
Problem You want to create a way to animate shapes along a path.
Solution Create an application that allows a user to draw the path for a shape to follow.
The main Java classes used in this recipe are these:
The following code demonstrates drawing a path for a shape to follow:
Figure 16-6 shows the drawn path the circle will follow.
When the user performs a mouse release, the drawn path will disappear, and the red ball will follow the path drawn earlier.
How It Works In this recipe you’ll be creating a simple application enabling you to animate objects by following a drawn path on the Scene graph.
You will allow the user to draw a path on the scene surface by pressing the mouse button like a drawing program.
Once you are satisfied with the path drawn, you will release the mouse press that triggers the red ball to follow the path similar to objects moving through pipes inside a building.
You will create two instance variables to maintain the coordinates that make up the path.
Shown here is adding the instance variable onePath onto the Scene graph:
Later, you will see how these variables will be updated based on mouse events.
Shown here are the instance variables that maintain the currently drawn path:
To create a spherical-looking ball you will create a gradient color RadialGradient that will be used to paint or fill a circle shape.
Refer to recipe 15-6 for how to fill shapes with gradient paint.
Once you have created the red spherical ball you need to create PathTransition object to perform the path following animation.
The cycle count is the number of times the animation cycle will occur.
Next, you will set the node to reference the red ball (sphere)
Then, you will set the path() method to the instance variable onePath, which contains all the coordinates and lines that make up a drawn path.
After setting the path for the sphere to animate, you should specify how the shape will follow the path such as perpendicular to a tangent point on the path.
The following code creates an instance of a path transition:
After the creation of your path transition you will want it to clean up when the animation is.
To reset or clean up the path variable when the animation is finished, you will create and add an event handler to listen to the onFinished property event on the path transition object.
The following code snippet adds an event handler to clear the current path information:
With the shape and transition all set up, you will next respond to mouse events that will update the instance variable mentioned earlier.
You will be listening to mouse events occurring on the Scene object.
Here, you will once again rely on creating event handlers to be set on the Scene’s onMouseXXXProperty methods where the XXX denotes the actual mouse event name such as pressed, dragged, and released.
When a user draws a path, he or she will perform a mouse press event to begin the start of the path.
To listen to a mouse-pressed event, you will create an event handler with a formal type parameter of MouseEvent.
As a mouse-pressed event occurs, you want to clear the instance variable onePath of any prior drawn path information.
Next, you will simply set the stroke width and color of the path so the user can see the path being drawn.
Finally, you will add the starting point to the path using an instance of a MoveTo object.
Shown here is the handler code to respond when the user performs a mouse press:
Once the mouse-pressed event handler is in place, you will be creating another handler for mousedragged events.
Inside the overridden handle() method you will be taking mouse coordinates that will be converted to LineTo objects to be added to the path (Path)
The following code is an event handler responsible for mouse-dragged events:
Finally, you will be creating an event handler to listen to a mouse-released event.
When a user releases the mouse, the path’s stroke is set to zero to appear as if it were removed.
Then you will reset the path transition by stopping it and playing it from the start.
The following code is an event handler responsible for mouse-released event:
Problem You want to create a nice-looking form type user interface using grid type layout.
It will toggle the display of the Grid layout’s grid lines for debugging.
It will adjust the horizontal gap between cells in the GridPane.
It will adjust the vertical gap between cells in the GridPane.
The following code is the main launching point for the form designer application:
When the form designer application is launched, the target form to be manipulated will be shown to the right side of the window’s split pane.
Shown following is the code of a simple grid-like form class that extends from GridPane that will be manipulated by the form designer application:
When the form designer application is launched, the grid property control panel will be shown to the left side of the window’s split pane.
The property control panel will allow a user to manipulate the target form’s grid pane attributes dynamically.
The following code represents the grid property control panel that will manipulate a target grid pane’s properties:
Figure 16-7 shows a form designer application with the GridPane property control panel on the left and the target form on the right.
How It Works The form designer application will allow the user to adjust properties dynamically using the GridPane property control panel to the left.
While adjusting properties from the left control panel the target form on the right side will be manipulated dynamically.
When creating a simple form designer application you will be binding controls to various properties onto the target form (GridPane)
Second, MyForm is the target form that will be manipulated.
Next, you will simply create a dummy form that I’ve called MyForm.
This form will be your target form that the property control panel will be manipulating.
In the MyForm’s constructor you will create and add controls to be put into the form (GridPane)
To learn more about the GridPane refer to recipe 15-8
The following code is a target form to be manipulated by the form designer application:
This class is responsible for binding the target form’s grid pane properties to UI controls that allow the user to adjust values using the keyboard and mouse.
As you learned earlier in recipe 15-10, you can bind values with JavaFX Properties.
But instead of binding values directly, you can also be notified when a property has changed.
Another feature that you can apply to properties is that you can add change listeners.
Similarly, when a bean’s property value has changed you will want to be notified of that change.
Change listeners are designed to intercept the change by making the old and new value available to the developer.
You will start by creating a JavaFXchange listener for the toggle button to turn gridlines on or off.
When a user interacts with the toggle button, the change listener will simply update the target’s grid pane’s gridlinesVisible property.
Because a toggle button’s (ToggleButton) selected property is a Boolean value, you will instantiate a ChangeListener class with its formal type parameter as Boolean.
Next, you will be applying a change listener to a slider control that allows the user to adjust the target grid pane’s top padding.
Again, you will be overriding the changed() method with a signature the same as its formal type parameter Number.
When a change occurs, the slider’s value will be used to create an Insets object that becomes the new padding for the target grid pane.
Shown here is the change listener for the top padding and slider control:
Because the implementation of the other slider controls that handle left padding, horizontal gap, and vertical gap are virtually identical to the top padding slider control mentioned previously, you can fast forward to cell constraints controls.
The last bits of grid control panel properties that you want to manipulate are the target grid pane’s cell constraints.
For brevity I only allow the user to set a component’s alignment inside of a cell of a GridPane.
Figure 16-8 depicts the cell constraint settings for individual cells.
An example is to left-justify the label Age on the target grid pane.
Because cells are zero relative, you will enter 0 in the Cell Column field and two into the Cell Row field.
Again when creating EventHandlers you will be overriding the handle() method.
Inside of the handle() method you will basically iterate over all node children owned by the target grid pane to determine whether it is the specified cell.
Once the specified cell and child node is determined the alignment will be applied.
The following code is an EventHandler to apply cell constraint when the apply button is pressed:
Problem You want to change the Look ‘N’ Feel of the GUI interface.
Solution Use JavaFX’s CSS styling to be applied on graph nodes.
The following code demonstrates using CSS styling on graph nodes.
Each theme is defined using CSS and affects the Look ‘N’ Feel of a dialog box.
Following the code, you can see the two different renditions of the dialog box:
How It Works JavaFX has the capability to apply CSS styles onto the Scene graph and its nodes very much like browsers applying CSS styles onto elements in an HTML document object model (DOM)
In this recipe you will be skinning a user interface using JavaFX styling attributes.
I basically used the recipe’s UI to apply the various Look ‘n’ Feels.
To showcase the available skins, a menu selection allows the user to choose the Look ‘N’ Feel to apply to the UI.
Before discussing CSS styling properties, I want to show you how to load the CSS styles to be applied to a JavaFX application.
You will first need to create menu items to allow the user to choose the preferred Look ‘N’ Feel.
When creating a menu item you will create a convenience method to build a menu item that would load the specified CSS and an EventHandler action to apply the chosen CSS style onto the current UI.
To add the Caspian theme as a menu item you will notice that no resources are needed to be loaded because it is JavaFX’s current Look ‘n’ Feel.
Shown here is adding a menu item containing the Caspian Look ‘N’ Feel CSS style that can be applied to the current UI:
Shown here is adding a menu item containing the sky Look ‘N’ Feel CSS style ready to be applied to the current UI:
Calling the createMenuItem() method will also call another convenience method to load the CSS file.
It will also set the menu items onAction attribute with an appropriate EventHandler by calling the skinForm() method.
To recap, the loadSkin is responsible for loading the CSS file, and the skinForm() method’s job is to apply the skin onto the UI application.
Shown here are the convenience methods to build menu items that apply CSS styles onto a UI application:
Note To run this recipe example, make sure the CSS files are located in the compiled classes area.
Resource files can be loaded easily when placed in the same directory (package) as the compiled class file that is loading them.
The CSS files are co-located with this code example file.
In NetBeans, you can select Clean and build project or you can copy files to your classes build area.
Now, that you know how to load CSS styles, let’s talk about the JavaFX CSS selectors and styling properties.
Like CSS style sheets, there are selectors or style classes associated with Node objects in the Scene graph.
All Scene graph nodes have a method called setStyle() to apply styling properties that could potentially change the node’s background color, border, stroke, and so on.
Because all graph nodes extend from the Node class, derived classes will be able to inherit the same styling properties.
Knowing the inheritance hierarchy of node types is very important because the type of node will determine the types of styling properties you can affect.
For instance a Rectangle extends from Shape, which extends from Node.
The inheritance does not include -fx-border-style, which is the part of nodes that extends from Region.
Based on the type of node there are limitations to what styles you are able to set.
To see a full listing of all style selectors refer to the JavaFX CSS Reference Guide:
JavaFX provides a media-rich API capable of playing audio and video.
The Media API allows developers to incorporate audio and video into their RIAs.
One of the main benefits of the Media API is its crossplatform abilities when distributing media content via the Web.
With a range of devices (tablet, music player, TV, and so on) that need to play multimedia content, the need for a cross-platform API is essential.
Imagine a not-so-distant future where your TV or wall is capable of interacting with you in ways that you’ve never dreamed possible.
For instance, while viewing a movie you could select items or clothing used in the movie to be immediately purchased, all from the comfort of your home.
With this future in mind, developers seek to enhance the interactive qualities of their media-based applications.
In this chapter you will learn how to play audio and video in an interactive way.
Find your seats for Act III of JavaFX as audio and video take center stage as depicted in Figure 17-1
Problem You want to listen to music and become entertained with a graphical visualization.
Solution Create an MP3 player by utilizing the following classes:
The following source code is an implementation a of simple MP3 player:
How It Works Before we get started, let’s discuss the instructions on how to operate our MP3 player.
A user will be able to drag and drop an audio file into the application area to be subsequently played.
Located on the lower right of the application are buttons to stop, pause, and resume play of audio media.
As the music is playing, the user will also notice randomly colored balls.
Once the user is done with listening to music, he/she can quit the application by clicking the white rounded close button located in the upper-right corner.
It is similar to recipe 16-1, in which you learned how to use the drag-and-drop desktop metaphor to load files into a JavaFX application.
Instead of image files, however, the user will be using audio files.
To load audio files JavaFX currently supports the following file formats: .mp3, .wav, and .aiff.
Following the same look and feel, you will use the same style as recipe 16-1
In this recipe, I modified the button controls to resemble buttons, similar to many media player applications.
When the pause button is pressed, it will pause the audio media from playing and toggle to the play button control, thus allowing the user to resume.
As an added bonus, the MP3 player will appear as an irregular shaped, semitransparent window without borders that can also be dragged around the desktop using the mouse.
Now that you know how to operate the music player, let’s walk through the code.
First, you will create instance variables that will maintain state information for the lifetime of the application.
Table 17-1 describes all instance variables used in our music player application.
The first variable is a reference to a media player (MediaPlayer) object that will be created in conjunction with a Media object containing an audio file.
Next, you will create an anchorPt variable used to save the starting coordinate of a mouse press when the user begins to drag the window across the screen.
When calculating the upper-left bounds of the application window during a mouse-dragged operation, the previousLocation variable will contain the previous window’s screen X and Y coordinates.
In previous chapters relating to GUIs, you saw that GUI applications normally contain a title bar and.
Here, I wanted to raise the bar a little by showing you how to create irregularly shaped semitransparent windows, thus making things look more hip or modern.
The following code shows how to create a transparent window without a title bar or windowed borders:
With the invisible stage you will create a rounded rectangular region that will be the applications.
Next, you will notice the width and height of the rectangle bound to the scene object in case the window is resized.
Because the window isn’t going to be resized, the bind isn’t necessary (it will be needed, however in recipe 17-2, when you get a chance to enlarge your video screen to take on a full screen mode)
After creating a black, semitransparent, rounded, rectangular area (applicationArea), you’ll be creating a simple Group object to hold all the randomly colored Circle nodes that will show off graphical visualizations while the audio is being played.
The first event in this scenario is a mouse press, which will save the cursor’s current (X, Y) coordinates to the variable anchorPt.
The following code is adding an EventHandler to the mouse pressed property of the Scene:
After implementing the mouse press event handler, you can create an EventHandler to the Scene’s mouse-dragged property.
The mouse–dragged event handler will update and position the application window (Stage) dynamically, based on the previous window’s location (upper-left corner) along with the anchorPt variable.
Shown here is an event handler responsible for the mouse-dragged event on the Scene object:
Next, you will be implementing the drag-and-drop scenario to load the audio file from the file system (File manager)
When handling a drag-and-drop scenario, it is similar to recipe 16-1, in which you created an EventHandler to handle DragEvents.
Instead of loading image files we will be loading audio files from the host file system.
For brevity, I will simply mention the code lines of the drag-anddropped event handler.
Once the audio file is available, you will create a Media object by passing in the file as a URI.
The following code snippet is how to create a Media object:
Both the Media and MediaPlayer objects are immutable, which is why new instances of each will be created every time the user drags a file into the application.
The following code checks for a prior media player to be stopped:
For ease of coding you will be turning to the.
A MediaPlayer object is responsible for controlling the playing of media objects.
Notice that a MediaPlayer will treat sound or video media the same in terms of playing, pausing, and stopping media.
Setting the autoPlay attribute to true will play the audio media immediately after it has been loaded.
So, what exactly is this type of listener, you say? Well, according to the Javadocs, it states that it is an observer receiving periodic updates of the audio spectrum.
In layman’s terms, it is the audio media’s sound data such as volume and tempo, and so on.
Table 17-2 lists all inbound parameters for the audio spectrum listener’s method.
The duration of time (in seconds) the spectrum was computed.
Here, you will be creating randomly colored circle nodes to be positioned and placed on the scene based on the variable phases (array of floats)
Shown here is the code snippet that plots each randomly colored circle:
Once the ready event is realized the run() method will call the media player object’s play() method to begin the audio.
With the dragged-drop sequence completed, we appropriately notify the drag-and-drop system by invoking the event’s setDropCompleted() method with a value of true.
The following code snippet implements a Runnable to begin the media player as soon as the media player is in a ready state:
Finally you will be creating buttons with JavaFX shapes to represent the stop, play, pause, and close buttons.
When creating shapes or custom nodes, you can add event handlers to nodes in order to respond to mouse clicks.
Although there are advanced ways to build custom controls in JavaFX, I chose to build my own button icons from simple rectangles, arcs, circles and lines.
To see more-advanced ways to create custom controls, refer to the Javadocs on the Skinnable API or recipe 16-5
The following code demonstrates adding an EventHandler to respond to mouse press on the stopButton node:
Because all the buttons use the same preceding code snippet, I will only list the method calls that each button will perform on the media player.
The last button, Close, isn’t related to the media player, but it is how to exit the MP3 player application.
The following actions are responsible for stopping, pausing, playing, and exiting the MP3 player application:
Problem You want to view a video file complete with controls to play, pause, stop, and seek.
Solution Create a video media player by utilizing the following classes:
The following code is an implementation of a JavaFX basic video player:
The following code is a method that creates a slider control with a ChangeListener to enable the user to seek backward and forward through the video:
Figure 17-3 depicts a JavaFX basic video player with a slider control.
How It Works To create a video player you will model the application similar to recipe 17-1 by reusing the same application features such as drag-and-drop files, media button controls, and so on.
For the sake of clarity, I took the previous recipe and moved much of the UI code into convenience functions so you will be able to focus on the Media APIs without getting lost in the UI code.
The rest of the recipes in this chapter consist of adding simple features to the JavaFX basic media player created in this recipe.
This being said, the code snippets in the following recipes will be brief, consisting of the necessary code needed for each new desired feature.
Before we begin, I want to talk about media formats.
I don’t want to confuse you with the drama, but it is difficult to see how things will unfold as media formats become favored or considered obsolete.
Because JavaFX’s goal is to be cross-platform, it would seem logical to use the most popular codec on the Net, but you will be forced to obtain a license to encode your videos into the VP6 .flv file format.
So the bottom line is that JavaFX currently can only play video files that are encoded in VP6
I try to keep in mind that this is the state of media formats today, so don’t channel any frustrations toward the JavaFX SDK.
Please refer to the Javadoc API for more details on the formats to be used.
A word to the wise: beware of web sites claiming to be able to convert videos for free.
As of this writing, the only encoders capable of encoding video to VP6 legally are the commercial converters from Adobe and Wildform (http://www.wildform.com)
Now, that you know what is the acceptable file format you are probably wondering how to obtain such a file of this type if you don’t have encoding software.
If you don’t have an .flv file lying around, you can obtain one from one of my favorite sites called the Media College (http://www.mediacollege.com)
From photography to movies, Media College provides forums, tutorials, and resources that help guide you into the world of media.
There you will obtain a particular media file to be used in the remaining recipes in this chapter.
To obtain the .flv file you will navigate to the following URL: http://www.mediacollege.com/adobe/flash/video/tutorial/example-flv.html.
In order to download a link consisting of a file, right-click to select “Save target as” or “Save link as”
Once you have saved the file locally on your file system, you can drag the file into the media player application to begin the demo.
Note  As of the writing of this book, the JavaFX media player API currently supports the video format VP6 using an .flv container.
Just like the audio player created in the last recipe, our JavaFX basic video player has the same basic media controls, including stop, pause, and play.
In addition to these simple controls we have added new capabilities such as seeking and full screen mode.
You will also be creating a slider control to monitor the progress of the video, which is located at the lower left of the application shown in Figure 17-3
The slider control allows the user to seek backward and forward through the video.
The ability to seek will work only if the video is paused.
One last bonus feature is making the video become full screen by double-clicking the application window.
To restore the window, repeat the double click or press Escape.
After setting up the stage in the start() method, you will create a black semitransparent background by calling the createBackground() method (applicationArea)
Another EventHandler to be attached to the Scene will allow the user to switch to full screen mode.
To make a window turn into full screen mode, you will create a conditional to check for the double click of the application window.
Once the double-click is performed you will call the Stage’s method setFullScreen() with a Boolean value opposite of the currently set value.
Shown here is how to make a window go to full screen mode:
As we continue our steps inside the start() method, you will create a slider control by calling the convenience method createSlider()
The createSlider() method will instantiate a Slider control and add a ChangeListener to move the slider as the video is playing.
The ChangeListener’s changed() method is invoked any time the slider’s value changes.
Once the changed() method is invoked you will have an opportunity to see the old value and the new value.
The following code creates a ChangeListener to update the slider as the video is being played:
The goal is to determine whether the pause button was pressed before the user can move the slider.
Once a paused flag is determined, you will obtain the new value to be converted to milliseconds.
The dur variable is used to move the mediaPlayer to seek the position into the video as the user slides the control left or right.
The ChangeListener’s changed() method is invoked any time the slider’s value changes.
The following code is responsible for moving the seek position into the video based on the user moving the slider.
Moving right along, you will be implementing a drag-dropped EventHandler to handle the .flv media file being dropped into the application window area.
Here you’ll first check to see whether there was a previous mediaPlayer.
If so, you will stop the previous mediaPlayer object and do some cleanup:
As with the audio player, we create a Runnable instance to be run when the media player is in a ready state.
You’ll notice also that the progressSlider control being set up to use values in seconds.
Once the media player object is in a ready state you will be creating a MediaView instance to display the media.
Shown following is the creation of a MediaView object to be put into the scene graph to display video content:
Whew! We are finally finished with our drag-dropped EventHandler for our Scene.
Up next is pretty much the rest of the media button controls similar to the end of recipe 17-1
The only thing different is a single instance variable named paused of type boolean that denotes whether the video was paused.
This paused flag when set to true will allow the slider control to seek forward or backward through the video; otherwise false.
Following is the pauseButton and playButton controlling the mediaPlayer object and setting the paused flag accordingly:
So that is how to create a video media player.
In the next recipe, you will be able to listen to media.
Problem You want the media player to provide feedback in response to certain events.
An example is displaying the text “Paused” on the screen when the media player’s paused event is triggered.
Shown in Table 17-3 are all the possible media events that are raised to allow the developer to attach EventHandlers or Runnables.
The following code will present to the user a text “Paused” with “Duration” with a decimal of milliseconds which is overlaid on top of the video when the user clicks the pause button (see Figure 174):
How It Works An event driven architecture (EDA) is a prominent architectural pattern used to model loosely coupled components and services that pass messages asynchronously.
The JavaFX team has designed the Media API to be event driven.
This recipe will demonstrate how to implement in response to media events.
With event-based programming in mind, you will discover nonblocking or callback behaviors when invoking functions.
In this recipe you will implement the display of text in response to an onPaused event instead of placing your code into the pause button.
Instead of tying code directly to a button via an EventHandler, you will be implementing code that will respond to the media player’s onPaused event being triggered.
You’ll be happy to know that you’ve been using event properties and implementing Runnables all along.
Hopefully you noticed this in all the recipes in this chapter.
When the media player is in a ready state, the Runnable code will be invoked.
Why is this correct? Well, when the media player is finished loading the media, the onReady property will be notified.
That way you can be sure you can invoke the MediaPlayer’s play() method.
I trust that you will get used to event style programming.
The following code snippet demonstrates the setting of a Runnable instance into a media player object’s OnReady property:
You will be taking steps similar to the onReady property.
Once a Paused event has been triggered, the run() method will be invoked to present to the user a message containing a Text node with the word Paused and a duration showing the time in milliseconds into the video.
Once displayed, you might want to write down the duration as markers (as you’ll learn recipe 17-4)
The following code snippet shows an attached Runnable instance, which is responsible for displaying a paused message and duration in milliseconds at the point in which it was paused in the video:
Problem You want to provide closed caption text while playing a video in the media player.
By obtaining the marked durations (in milliseconds) from the previous recipe you will create media marker events at points into the video.
With each media marker you will associate text that will be displayed as closed captions.
When a marker comes to pass, a text will be shown to the upper-right side.
The following code snippet demonstrates media marker events being handled in the onDragDropped.
Shown following is a factory method that returns an area that will contain the closed caption to be displayed to the right of the video:
Figure 17-5 depicts the video media player displaying closed caption text.
How It Works The Media API has many event properties that the developer can attach EventHanders or Runnables instances so they can respond when the events are triggered.
The Marker property is responsible for receiving marker events (MediaMarkerEvent)
With an observable map, you can add key value pairs that represent each marker.
Adding keys should be a unique identifier, and the value is an instance of Duration.
For simplicity I used the closed caption text as the key for each media marker.
The marker durations are those written down as you press the pause button at points in the video from recipe 17-3
Please be advised that I don’t recommend doing this in production code.
After adding markers you will be setting an EventHandler into the MediaPlayer object’s OnMarker property using the setOnMarker() method.
Next, you will create the EventHandler instance to handle MediaMarkerEvents that are raised.
Once an event has been received, obtain the key representing the text to be used in the closed caption.
That goes to show you how you can coordinate special effects, animations, and so on during a video quite easily.
Problem You want to incorporate animated effects in your media display such as scrolling text “The End” after the video is finished playing.
The following code demonstrates an attached action when an end of a media event is triggered:
Figure 17-6 depicts the text node “The End” scrolling up after the OnEndOfMedia event is triggered.
How It Works In this recipe you will be able to synchronize events to animated effects.
In other words, when the video reaches the end, an OnEndOfMedia property event will initiate a Runnable instance.
So, let me describe the setOnEndOfMedia() method associated with the MediaPlayer object.
Just like recipe 17-3, we simply call the setOnEndOfMedia() method by passing in a Runnable that contains our code that will invoke an animation.
If you don’t know how animation works, please refer to recipe 16-2
Once the event occurs, you will see the text scroll upward.
For the sake of space, I trust you know where the code block would reside.
If not, you may refer to recipe 17-3, in which you will notice other OnXXX properties methods.
To see the entire code listing, visit the book’s web site to download the source code.
Last is setting up the Y property of the node to move from the bottom to the center of the Media view area.
The following code is an animation to scroll a node in an upward motion:
The Java language provides a rich infrastructure for creation of web-based applications.
Developing Java applications for the Web has become more popular throughout the years.
The servlet was one of the first technologies that allowed developers to create dynamic content for the Web.
Applets first appeared in the early days of Java development and they changed the concept of web development forever.
These two technologies have been around for the majority of the lifetime of the Java language itself, and they are both still going strong.
Although the direct usage of the Java servlet API has decreased over time, it still remains the base for most of the web application development frameworks that are widely used today.
Application frameworks such as Java Server Pages (JSP) and Java Server Faces (JSF) are built upon servlet technology.
Applets have also evolved over the years from using the Abstract Windowing Toolkit (AWT) to including Java Swing, and most recently JavaFX for deploying solid Java-based applications over the Web.
This chapter will get you started developing both servlets and applets.
The recipes within this chapter will teach you the basics for developing on each of these technologies, and they touch upon some of the most important concepts of each.
Download and install Apache Tomcat from the Tomcat web site.
The version used for this book is 7.0.20, and it can be downloaded from http://tomcat.apache.org/
Select the .zip or tar.gz download format, and decompress the downloaded files within a directory on your workstation.
Set the JAVA_HOME environment variable to point to your Java runtime.
Once you have unzipped the contents of the download, you are ready to start developing servlet applications.
You can use any Java servlet container for working with Java servlets, as long as you are using the correct JDK version for that container.
For the purposes of this chapter, we will utilize one of the most commonly used containers: Apache Tomcat.
You have a couple of options in order to set up your environment for running the examples within this chapter:
You can install an IDE such as NetBeans or Eclipse; then install Tomcat 7.0.20 separately and register it with the IDE.
You can install Tomcat 7.0.20 and set up your examples manually.
This involves creating directories by hand, compiling using the javac command via the command line and copying files to the correct deployment directories for testing.
Because we will not cover any specific IDE in this chapter, we will default to using the second option.
In order to install Tomcat 7.0.20, please download from the Tomcat site http://tomcat.apache.org.
Once you have obtained the .zip or .tar file, unzip it to the location on your machine that you want to install Tomcat; otherwise known as /JAVA_DEV/Tomcat for this chapter.
Note If you are running OS X, you may need to set the environment variable equal to the location in which OpenJDK is installed if Java 7 is not yet available on that platform.
After you perform these steps listed, you are ready to start using Tomcat.
To do so, enter a user account similar to the following (just be sure to include manager-gui and admin-gui as roles for the user you create):
Adding this line to the tomcat-users.xml configuration file will allow access to the web-based utilities that can be used for managing applications that you deploy.
Just be sure to keep this file safe as all passwords are in clear text.
This will cause the server to start, and once it is ready, you can open up a browser and point to http://localhost:8080 to see the default Tomcat home page.
This page gives you the ability to open up various management pages to help manage the Tomcat applications and environment.
If you have been successful in configuring the Tomcat environment and starting the server, you are ready to start developing Java servlets and applets.
You would like to create a web page that will serve some dynamic content.
Develop a Java servlet class, and compile it to run within a Java servlet container.
In the following example, a simple servlet is created that will display some dynamic content to the web page.
The first listing is the servlet code that contains the functionality for the servlet:
This file is required for application deployment to a servlet container.
It contains servlet configuration and mapping that maps the servlet to a URL.
In recipe 18-4 you will learn how to omit the servlet configuration and mapping from web.xml to make servlet development, deployment, and maintenance easier.
To compile the Java servlet, use the javac command line utility.
Once the servlet code has been compiled into a Java class file, it is ready to package for deployment.
Java servlets provide developers the flexibility to design applications using a request-response programming model.
Servlets play a key role in development of service-oriented and web application development on the Java platform.
There are different types of servlets that can be created, and each of them is geared toward providing different functionality.
The first type is the GenericServlet, which provides services and functionality.
The second type, HttpServlet, is a subclass of GenericServlet, and servlets of this type provide functionality and a response that uses HTTP.
The solution to this recipe demonstrates the latter type of servlet as it displays a result for the user to see within a web browser.
Servlets conform to a life cycle for processing requests and posting results.
Next, the container calls the servlet init() method, which is responsible for initializing the servlet.
Once the servlet has been initialized, it is ready for use.
Each servlet contains a service() method that does not have to be implemented, which handles the requests being made and dispatches them to the appropriate methods for request handling.
Finally, the container calls the servlet’s destroy() method, which takes care of finalizing the servlet and taking it out of service.
In the solution to this recipe, the servlet named SimpleServlet extends the HttpServlet class, which provides methods for handling HTTP processes.
In this scenario, a request is sent from the container to the servlet; then the servlet service() method dispatches the HttpServletRequest object and dispatches it to the appropriate method provided by HttpServlet.
Namely, the HttpServlet class provides the doGet(),doPut(), doPost(), and doDelete() methods for working with am HTTP request.
The HttpServlet class is abstract, so it must be subclassed and then an implementation can be provided for its methods.
In the solution to this recipe, the doGet() method is implemented, and a response is written to the browser using the PrintWriter.
Table 18-1 describes each of the methods available to an HttpServlet.
Input sent to the servlet must be included on the URL address.
Input can be sent to the servlet within HTML form fields.
A servlet generally performs some processing within the implementation of its methods and then.
The HttpServletRequest object can be used to process arguments that are sent via the request.
For instance, if an HTML form contains some input fields that are sent to the server, those fields would be contained within the HttpServletRequest object.
A GenericServlet can be used for providing services to web applications.
This type of servlet is often used for logging events because it implements the log() method.
A GenericServlet implements both the Servlet and ServletConfig interfaces, and to write a generic servlet only the service() method must be overridden.
You have written a Java servlet and would now like to package it and deploy it for use.
Compile the sources, set up a deployable application, and copy the contents into the Tomcat deployment directory.
From the command line, use the javac command to compile the sources:
After the class has been compiled, deploy it along with the web.xml deployment descriptor conforming to the appropriate directory structure.
To quickly get up and started with the packaging, compiling, and deployment of the example application for the servlet recipes in this chapter on Tomcat, follow these steps:
Create a single application named SimpleServlet by making that directory under Tomcat/webapps.
Drag the Chapter 18 sources (beginning with the org directory) inside the WEB-INF/classes directory you created.
Copy the web.xml file that is contained within the recipe18-02 directory into the WEB-INF directory you created.
In order to compile the sources, you can use your favorite Java IDE such as NetBeans or Eclipse, or you can use the command line.
For the purposes of this recipe, we will use the command line.
If using the command line, you must ensure that you are using the javac command that is associated with the same Java release that you will be using to run your servlet container.
In this example, we will say that the location of Java SE 7 installation is in the following path:
This path may differ in your environment if you are using a different operating system and/or installation location.
To ensure that the Tomcat servlet container is running under the Java runtime that is located at this path, set the JAVA_HOME environment variable equal to this path.
If you are using Windows, use the SET command within the command line to set up the JAVA_HOME environment variable:
Next, compile your Java servlet sources and be sure to include the servlet-api.jar that is packaged with your servlet container in your CLASSPATH.
You can set the CLASSPATH by using the –cp flag of the javac command.
The following command should be executed at the command line from within the same directory as the sources are located.
Next, package your application by creating a directory and naming it after your application.
In this case, create a directory and name it SimpleServlet.
Traverse into the WEB-INF directory and create another directory named classes.
Last, create directories within the classes directory in order to replicate your Java servlet package structure.
Create another directory within WEB-INF and name it lib, any .jar files containing external libraries should be placed within the lib directory.
In the end, your directory structure should resemble the following:
Restart the application server and visit http://localhost:8080/SimpleServlet/SimpleServlet to see the servlet in action.
Registering servlets in the web.xml file is cumbersome, and you would like to deploy servlets without the need to modify web.xml at all.
Make use of the @WebServlet annotation to register the servlet, and omit the web.xml registration.
This will alleviate the need to modify the web.xml each time a servlet is added to your application.
For instance, rename the file to old-web.xml, and then you can run the servlet using @WebServlet.
There are a couple of different ways to register servlets with a web container.
The first way is to register them using the web.xml deployment descriptor as demonstrated in recipe 18-2
The second way to register them is to use the @WebServlet annotation.
The new @WebServlet can be used rather than altering the web.xml to register each servlet in an application.
However, in some cases, it may make sense to continue using the deployment descriptor for servlet registration (for example, if you do not want to recompile sources when a URL pattern changes)
If you look at the web.xml listing in recipe 18-2, you can see the following lines of XML, which map the servlet to a given URL, and provide a name for the servlet.
These lines of XML perform essentially the same function as the @WebServlet annotation in this recipe:
Note It is possible for you to use the same application packaging for each recipe pertaining to servlets within this chapter.
That is, use the same directory structure you created within recipe 18-3, and append to it with each recipe you try.
The servlet package, name, and URL pattern are different in each recipe.
This makes each servlet unique, so each servlet can be mapped separately within the WEB.XML or as individual servlets with the @WebServlet annotation.
A servlet you are writing requires the ability to accept one or more parameters to be set upon initialization.
The following code listing sets an initialization parameter that is equal to a String value:
Place the init parameters inside of the web.xml deployment descriptor file.
The following lines are excerpted from the web.xml deployment descriptor for the SimpleServlet application.
Often, there is a requirement to set initialization parameters for a servlet in order to initialize certain values.
Servlets can accept any number of initialization parameters, and there are a couple of ways in which they can be set.
Therefore, the servlet must be registered with the web application via the @WebServlet annotation rather than within the web.xml file.
The @WebInitParam annotation accepts a name/value pair as an initialization parameter.
In the solution to this recipe, the parameter name is “name” and the value is “Duke”
The annotations have the benefit of providing ease of development and also make it easier to maintain servlets as a single package rather than jumping back and forth between the servlet and the deployment descriptor.
However, those benefits come at the cost of compilation because in order to change the value of an initialization parameter using the @WebInitParam annotation, you must recompile the code.
Such is not the case when using the web.xml deployment descriptor.
It is best to evaluate your application circumstances before committing to a standard for naming initialization parameters.
You would like to create a web form that accepts user input and supply a response based upon the input that has been received.
Create a standard HTML–based web form, and when the submit button is pressed invoke a servlet to process the end-user input and post a response.
In order to examine this technique, we will look at two different pieces of code.
The first code below is HTML that is used to generate the input form.
You will see that the action lists a servlet name, MathServlet.
Next, take a look at the code for a servlet named MathServlet.
This is the Java code that receives the input from the HTML code that is listed previously, processes it accordingly, and posts a response:
After following these steps, if the application is deployed in the Tomcat/webapps directory, you should be able to browse to http://localhost:8080/SimpleServlet/index.html to see the results if Tomcat is running.
Servlets make it easy to create web applications that adhere to a request and response life cycle.
They have the capability to provide HTTP responses and also process business logic within the same body of code.
The capability to process business logic makes servlets much more powerful than standard HTML code.
The solution to this recipe demonstrates a standard servlet structure for processing requests and sending responses.
An HTML web form contains parameters that are sent to a servlet.
The servlet then processes those parameters in some fashion and then publishes a response that can be seen by the client.
In the case of an HttpServlet object, the client is a web browser, and the response is a web page.
In the solution to this recipe, two values are accepted as input and they are referenced by their id attributes as numa and numb.
There are two more <input> tags within the form; one of them is used to submit the values to the form action, and the other is used to reset the form fields to blank.
The form action is the name of the servlet that the form values will be passed to as parameters.
The <form> tag also accepts a form processing method, either GET or POST.
In the example, the POST method is used because form data is being sent to the action; in this case, data is being sent to MathServlet.
You could, of course, create an HTML form as detailed as you would like and then have that data sent to any servlet in the same manner.
This example is relatively basic just to give you an understanding of how the processing is performed.
The <form> action attribute states that the MathServlet should be used to process the values that are contained within the form.
The MathServlet name is mapped back to the MathServlet class via the web.xml deployment descriptor or the @WebServlet annotation.
Looking at the MathServlet code, you can see that a doPost() method is implemented to handle the processing of the POST form values.
The values contained with the HTML form are embodied within the HttpServletRequest object.
In order to obtain those values, call the request object’s getParameter() method, passing the id of the input parameter that you want to obtain.
In the solution to this recipe, those values are obtained and stored within local String fields.
Once the values are obtained, they can be processed as needed.
In this case, those String value are converted into int values and then they are added together to generate a sum and stored into an int field.
That field is then presented as a response on a resulting web page.
As mentioned previously, the HTML form could be much more complex, containing any number of <input> fields.
Likewise, the servlet could perform more complex processing of those field values.
This example is merely the tip of the iceberg, and the possibilities are without bounds.
Servlet-based web frameworks such as JSP and JSF hide many of the complexities of passing form values to a servlet and processing a response.
However, the same basic framework is used behind the scenes.
You would like to enable all servlets within your application to have the capability to communicate with the servlet container to obtain the same set of information.
Furthermore, you’d like to set up some initialization parameters that can be shared by every servlet within the application.
Use a ServletContext object in order to allow each servlet within the application to communicate with the servlet container.
Because each application has only one ServletContext, every servlet within the application will see the same ServletContext, so this is the ideal location to place initialization parameters that are intended for application-wide use.
In the example that follows, application-wide parameters are set up to store an organization’s e-mail address and SMTP host for sending mail.
Those parameters are then used within a servlet in order to send e-mail to the organization.
The code below defines a servlet named MailServlet that is used for processing form values that were passed from an HTML form that is used by a client to submit feedback to an organization.
The servlet sends an e-mail to the organization that contains the user feedback.
The next code example demonstrates the HTML code that may be used to generate the web form for capturing the user feedback.
Finally, a look at the web.xml file, which declares the context parameters that can be utilized by any of the servlets within the application.
Stop and restart Tomcat to pick up the changes in context parameter strings.
The user feedback form will look something like the one shown in Figure 18-1
Some applications require the use of application-wide parameters that can be accessed from any servlet.
The solution to this recipe demonstrates this concept by setting up an organization’s e-mail address and SMTP host address as parameters.
Application-wide parameters must be configured within the web.xml deployment descriptor.
In the solution to this recipe, the two parameters are set up as follows:
Once configured within the deployment descriptor, these initialization parameters can be used by any of the servlets within an application by calling the servlet configuration’s getInitParameter() method and passing the name of the parameter that you want to obtain:
You would like to invoke certain processing if a specified URL is used to access your application.
For instance, if a specific URL is used to access your application, you would like to log the user’s IP address.
Create a servlet filter that will be processed when the specified URL format is used to access the application.
In this example, the filter will be executed when a URL conforming to the format of “/*” is used.
Therefore, any page will cause the servlet to be invoked.
The servlet could contain any processing; the important thing to note is that this servlet is processed when a specified URL is used to access the application.
Web filters are useful for preprocessing requests and invoking certain functionality when a given URL is visited.
Rather than invoking a servlet that exists at a given URL directly, any filter that contains the same URL pattern will be invoked prior to the servlet.
This can be helpful in many situations, perhaps the most useful for performing logging, authentication, or other services that occur in the background without user interaction.
Methods contained within this interface include init(), destroy(), and doFilter()
The init() and destroy() methods are invoked by the container.
The doFilter() method is used to implement tasks for the filter class.
As you can see from the solution to this recipe, the filter class has access to the ServletRequest and ServletResponse objects.
This means that the request can be captured and information can be obtained from it.
This also means that the response can be modified if need be.
For example, including the username in the request after an authentication filter has been used.
If you want to chain filters, or if more than one filter exists for a given URL pattern, they will be invoked in the order in which they are configured in the web.xml deployment descriptor.
It is best to manually configure the filters if you are using more than one per URL pattern rather than using the @WebFilter annotation.
Of course, the @WebFilter annotation takes care of the configuration for us, so in this case the manual configuration is not required.
You need to redirect the browser to another URL when a specific URL within your application is visited.
In the following example, when a URL that matches the /redirect pattern is used, the servlet will redirect the browser to another site:
In this example, the servlet will redirect to the http://www.java.net web site.
There are some cases in which a web application needs to redirect traffic to another site or URL within the same application.
The sendRedirect() method accepts a URL in String format and then redirects the web browser to the given URL.
Given the fact that sendRedirect() accepts a String-based URL makes it easy to build dynamic URLs as well.
For instance, some applications may redirect to a different URL based upon certain parameters that are passed from a user.
Dynamic generation of a URL in such cases may look something like the following:
The sendRedirect() method can also come in handy for creating the control for web menus and other page items that can send web traffic to different locations.
Note This simple redirect, as opposed to servlet chaining, does not pass the HttpRequest object along to the target address.
You would like to have the ability to listen for application startup and shutdown events.
Create a servlet context event listener to alert when the application has started up or when it has been shut down.
The following solution demonstrates the code for a context listener, which will log application startup and shutdown events and send e-mail alerting of such events:
Sometimes it is useful to know when certain events occur within the application server container.
This concept can be useful under many different circumstances, but most often it would likely be used for initializing an application upon startup or cleaning up after an application upon shutdown.
A servlet listener can be registered with an application to indicate when it is started up or shut down.
Therefore, by listening for such events, the servlet has the opportunity to perform some actions when they occur.
To register the listener with the container, you can use the @WebListener annotation as demonstrated by the solution to this recipe, register the listener within the web.xml application deployment descriptor, or use the addListener() methods defined on ServletContext.
For example, to register this listener within the web.xml, the following lines of XML would need to be added:
The only time that listener registration within the application deployment descriptor (web.xml) would be more helpful is if you had the need to disable the listener in some cases.
To disable a listener when it is registered using @WebListener, you must remove the annotation and recompile the code.
Altering the web deployment descriptor does not require any code to be recompiled.
There are many different listener types, and the interface that the class implements is what determines the listener type.
It is also possible to create a listener that implements multiple listener interfaces.
You want to be notified when an attribute has been set within a given application session.
Generate an attribute listener servlet to listen for such events as attributes being added, removed, or modified.
Messages will be displayed within the server log file indicating when attributes have been added, removed, or replaced.
In some situations it can be useful to know when an attribute has been set or what an attribute value has been set to.
The solution to this recipe demonstrates how to create an attribute listener in order to determine this information.
To create a servlet listener, you must implement one or more of the listener interfaces.
In the solution to this recipe, you can see that each of the three methods listed in the previous paragraph contains a similar implementation.
After these values are obtained, the application can do whatever it needs to do with them.
In this recipe, the attribute ID, name, and session ID are simply logged and printed:
In the end, the same routine is used within each to obtain the attribute name and value, and then something is done with those values.
There are a few different options that can be used to register the listener with the container.
The @WebListener annotation is the easiest way to do so, and the only downfall to using it is that you will need to recompile code in order to remove the listener annotation if you ever need to do so.
The listener can be registered within the web deployment descriptor, or it can be registered using one of the addListener() methods contained in ServletContext.
Although the example in the recipe does not perform any life-changing events, it does demonstrate how to create and use an attribute listener.
In the real world, such a listener could become handy if an application needed to capture the username of everyone who logs in, or to send an e-mail whenever a specified attribute is set.
Note This listener can be used in the same application that has been used since recipe 18-2 without any need for change in the web.xml deployment descriptor.
You would like to maintain some information regarding an individual session on a per-session basis when a user visits your site.
In order to do so, use the HttpServletRequest object to obtain access to the session and then use the getAttribute() and setAttribute() methods accordingly.
In the following scenario, an HTML page is used to capture a user’s e-mail address, and then the e-mail address is placed into a session attribute.
The attribute is then used by Java servlets across different pages of the application in order to maintain state.
The following code demonstrates what the HTML form might look like in this scenario:
Next, the Java servlet with named SessionServlet using a URL pattern of /sessionServlet is initiated when the form is submitted.
Any form input values are passed to SessionServlet and processed accordingly.
The final code is an example of a second servlet that could be invoked by the first.
This servlet also makes use of the same HTTP session attribute to show that state has been maintained:
In the end, the e-mail address that was entered within the original HTML form was captured and used throughout the different pages in the application.
Since the beginning of web development, session attributes have been used to retain important information regarding a user’s session.
This concept holds true when developing using Java servlets as well, and servlets make it easy to set and get the attribute values.
All HttpServlet classes must implement doGet() or doPost() methods in order to process web application events.
In doing so, these methods have access to the HttpServletRequest object as it is passed to them as an argument.
In the solution to this recipe, an HttpSession attribute is used to store an e-mail address.
That address is then used throughout the application within different servlet classes by obtaining the session object and then retrieving the attribute value.
Any attributes will remain in the HttpSession object as long as the session remains valid.
The session ID will remain consistent when traversing between pages.
You can see that the solution to this recipe obtains and prints the current session ID for reference.
Using attributes in the HttpSession is a good way to pass data around to maintain a session’s state.
There are some resources that you’d like to have your servlet clean up once the servlet is no longer in use.
First, provide code for doing any cleanup within the servlet destroy() method.
Second, when there are potentially long-running methods, code them so that will become aware of a shutdown and, if necessary, halt and return so that the servlet can shut down cleanly.
The following code excerpt is a small example of a destroy() method.
In this code, it is being used to initialize local variables and setting the beingDestroyed boolean value to indicate that the servlet is shutting down.
The code within the destroy() method may successfully achieve a full cleanup of the servlet, but if there is a long-running task, it must be notified of a shutdown.
The following excerpt is a block of code that signifies a long-running task.
The task should stop processing after the shutdown is indicated by the beingDestroyed value becoming true.
Finalization of a servlet can be very important, especially if the servlet is using some resources that may lead to a memory leak, making use of a reusable resource such as a database connection, or in order to persist some values for another session.
In such cases, it is a good idea to perform cleanup within the servlet destroy() method.
Every servlet contains a destroy() method (which may be implemented to overload default behavior) that is initiated once the servlet container determines that a servlet should be taken out of service.
The destroy() method is called once all the servlet’s service methods have stopped running.
However, if there is a long-running service method, a server grace period can be set, which would cause any running service to be shut down when the grace period is reached.
As mentioned earlier, the destroy() method is the perfect place to clean up resources and it is also good place to help clean up after long-running services.
Cleanup can be done by setting a servlet–specific local variable to indicate that the servlet is being destroyed, and having the long-running service check the state of that variable periodically.
If the variable indicates that the destroy() method has been called, it should stop executing.
You are interested in developing an application that can be accessed from a browser but contains the functionality that can be found within a desktop application.
Doing so will enable you to run the application within a web browser and also allow the application to be run on the client desktop so that it has similar abilities of a standard desktop application.
The following code is that of a Java applet class.
This applet consists of a button and a label of text.
It is a simple example just to show you how to make a very basic applet.
Some would argue that they are the cornerstones of the language itself.
Although applets are not as popular now as they were in the beginning of Java, they still play an important role in the ecosystem.
They are usually bound to a web page, yet they execute using the client Java runtime.
Therefore, although they are a web-based technology, they make use of local resources.
Applets are easy to make, and you can do a lot with them.
This recipe will cover only the basics of applet development, and if you are interested in learning more, there are plenty of excellent resources about Applets to read.
Applets must either extend the abstract Applet class or the abstract JApplet class.
The JApplet is used for creating applets that will include Swing components.
If you are interested in learning about JApplet, please see recipe 18-19
Lots of functionality is obtained by subclassing the Applet or JApplet class.
Specifically, all the code that coordinates the browser/Java interaction occurs behind the scenes within these abstract classes.
This allows applet developers to focus on the applet design rather than how it functions within the browser and on the client machine.
Applets have a life-cycle that can be traced by overriding four methods, those being: init(), start(), stop(), and destroy()
When an applet is invoked, the init() method is used to initialize the applet layout and components.
The init() method is usually overridden and implemented, as demonstrated in the solution to this recipe.
Looking at the example, you can see that the init() method contains the code necessary for building the user interface.
These two widgets are part of the AWT API, and their constructors accept a String representing the text that is displayed on the widget upon startup.
The AWT API, Java’s original user interface toolkit, provides graphics, windowing, and widgets that can be used to build user interfaces for Java applications.
Standard applets use AWT, whereas JApplets use Swing for construction of their user interface.
Following the declaration of the Button and Label widgets, the layout for the applet is set.
There are many different applet layouts to choose from, and the class you use for the layout will determine how the user interface widgets are organized within the applet.
This example uses the FlowLayout, which is arguably the easiest to work with.
All widgets within a FlowLayout will be placed next to one another.
Thus, they flow onto the applet in a horizontal manner.
Each of the different layouts is listed in Table 18-3, along with a brief description of how they work.
FlowLayout Widgets flow from left to right in one row until space runs out, and then they follow suit on the next line down (default applet layout manager)
GridLayout Constructs a grid of widgets using rows and columns.
Each card usually consists of a JPanel or some other container which holds other widgets.
One can then “flip” through each of the “cards”, displaying the different views.
The layout manager that you chose for your applet will determine how it looks and possibly even.
Layout managers are an important topic in Java user interface development.
As you can see from the solution, the layout is set against a variable named this.
The variable this refers to the class itself, and it is often the case that a small Java applet will be contained within one class, so you can refer to it using the this keyword.
Next, because the layout has been set, widgets are then added to this, constructing the user interface:
Doing so allows the applet to handle user interface interactions such as button clicks.
The method actionPerformed() must be implemented, adding functionality to the applet.
In the solution to this recipe, the button sets the applet itself as the action listener because it implements the ActionListener interface.
However, it is possible to set a separate ActionListener class to handle action events for the applet.
By setting the action on the button to the applet itself, it means that when the button is clicked, the actionPerformed() method will be invoked.
Any number of things can occur within the actionPerformed() method; in this example, the Label text is changed.
This ActionEvent represents the event that has triggered the call to this method.
Within the implementation in this example, Label widgets are altered, but the ActionEvent argument could have been used to gain access to the event.
Last, the applet’s setVisible() method is called passing a TRUE value.
This will make sure that the user interface becomes visible for the user to see.
You want to embed a Java applet into a web page.
Compile your Java code and package it into a .jar file.
Then create an HTML page that will be used to display the applet using the Invoke Deployment Toolkit (deployJava.js)
Lastly, place the .jar file in the same path that is listed in the HTML <script> attributes, and then open up the HTML page to view the running applet.
When compiling your applet, include all images and other resources in a separate directory.
To make things easier, use an IDE such as NetBeans to keep your applet project organized correctly.
Once compiled, package the applet project within a .jar file by traversing into the base directory of your project’s packages, and issuing the following command.
Next, create the HTML page with embedded script references to deploy the applet:
Note PATH_TO_JAR is a placeholder for the URI path to the .jar file in your application or HTML docbase.
If your application .jar file is in the root directory of y our application, it will simply be /
Visiting the HTML page will initiate the Java runtime on your desktop to run the applet.
Compile your Java code and package it into a .jar file.
Then create an HTML page that will be used to display the applet using the <applet> tag.
Looking at solution 1, you can see how to compile and package the applet and its resources into a .jar file.
The difference with this solution is that it uses the <applet> tag within an HTML page instead of using the Invoke Deployment Toolkit to run the applet.
The following HTML code demonstrates an example using the <applet> tag to invoke an applet named FirstApplet that is contained within a .jar file named FirstApplet.jar:
When it comes to embedding an applet within an HTML page, there are a few different options.
This recipe demonstrates two of those options: using the Invoke Deployment Toolkit, and using the <applet> tag for deployment.
The same steps are necessary for compilation and packaging of an applet using each tactic.
The only difference is how the applet is actually embedded within the HTML.
In order to run an applet, you first need to compile and package it appropriately.
Compilation of the applet involves ensuring that any external libraries that are used by your applet are within the CLASSPATH.
It also helps to use an IDE such as NetBeans or Eclipse to help package the applet and manage dependencies.
Usually, an IDE will take care of compilation and .jar creation behind the scenes so that the developer does not have to worry about it.
If you are working from the command line, the next step after compilation of the applet is to package it within a .jar file.
You can do this by issuing the JDK’s jar command.
To package an applet, the code needs to be placed within a directory separate from any images or resources used by the applet.
The jar command takes both of those directories and wraps them together into a single .jar file that can be deployed for use.
Once the code has been packaged into a .jar file, it is ready for deployment.
However, if your applet depends on any external libraries, their requisite .jar files will also need to be added to the HTML.
Please see recipe 18-17 for more details on adding external libraries.
As mentioned previously, there are a couple of options for embedding an applet within an HTML page.
The first solution to this recipe shows how to make use of the Invoke Deployment Toolkit.
This is essentially a JavaScript library that is used to load and run the applet.
This toolkit has been around since Java 6, and it allows for deployment across many different browsers.
To use this technique, first load the JavaScript file named deployJava.js, which is hosted by Oracle.
It is important to note that in order to use deployJava.js, the client browser must have access to the Internet.
The following line of code shows how to do this:
Next, set up any attributes, parameters, and a Java version that will need to be passed to the deployJava.js script.
The attributes will be passed as a list of values, using a name/value format.
Attributes that must be set are codebase, code, archive, width, and height.
You can see how this is done within the following code excerpt:
The parameters are set up the same way as the attributes, within a list of name/value pairs.
There may be zero or more parameters, and in solution 1 there is one:
Once you’ve done that, then you can pass the attributes, parameters, and version to the deployJava.js script.
It should be noted that you could also use a JNLP file to deploy an applet along with the Invoke Deployment Toolkit.
In order to reference a JNLP, include the jnlp_href parameter within the parameter list.
A JNLP file for the applet in the solution to this recipe may look something like the following:
You could then leave out the codebase and archive attributes, and use something like the following to initiate the applet via HTML:
However, if you are working within an environment in which you know.
The <applet> tag takes fewer configurations than using deployJava.js, so many people like to use it.
The only required attributes for using the <applet> tag are code, archive, width, and height.
Of course, you can also embed parameters into the <applet> tag to have them passed to the applet.
The following code excerpt shows how to use the <applet> tag to achieve the same embedded applet result as using the deployJava.js script.
Either option that you choose, embedding applets into web pages is quite trivial.
The more complicated piece of the puzzle tends to be the packaging of the applet itself.
Rather than having an applet run within a web browser, you’d like to make an applet that can be dragged off the page and run in its own window.
After using either of the previous solutions, visit the HTML page that was created to initiate the applet.
The applet can be dragged from within the browser to the desktop by holding down the Alt key while dragging the applet using the left mouse button.
This allows an applet to run within its own process so that it can be dragged from the browser to the desktop.
Configuration for making an applet draggable is minimal; you need to pass an extra parameter via the deployJava.js script or the <applet> tag.
In the solutions to this recipe, you can see that the parameter name is draggable and the value must be set to true.
However, the draggable applet may not work with every browser, so it is important to test and ensure that a compliant browser is used if this feature is required.
It is also possible to override some methods within the Applet class in order to perform activities when applets are dragged from the browser.
The following methods can be overridden in order to create customized functionality within an applet:
For more information regarding custom development for draggable applets, please reference online materials.
You would like to load Java libraries from an external .jar for use within your applet.
If necessary, sign the .jar files and then use a comma-separated list of values for the archive attribute to include the necessary .jar files for the external libraries that the applet requires.
In this example, an applet is created that generates a simple e-mail form.
When the send button is pressed, an e-mail message is sent using the JavaMail API.
As such, external libraries for JavaMail must be included with the applet when downloaded to the client.
The following code is the applet code that is used to create the email form:
Next is the HTML named mailApplet.html that is used to embed the applet.
Notice that there is more than one .jar file listed in the parameters section.
This is one way to include external .jar files with your applet.
When the page is visited, the simplistic e-mail applet will appear and the appropriate .jar files will be loaded into the local Java runtime.
Almost any substantial applet will require the use of external libraries.
As such, those external libraries will have to be included with the Java applet in order to run on a client machine.
As with many other solutions in the industry, there is more than one way to include external libraries within an applet.
In the solution to this recipe, the HTML code that is used to embed the applet is modified to contain a reference to any external .jar files that are required to run the code.
Referencing the .jar will make it download to the client machine along with the applet .jar file.
If using the <applet> tag, you can also include multiple .jar files by adding them using a comma-separated list to the archive attribute.
Your application requires the use of Swing, a highly adopted Java component library, in order to contain the GUI that is required.
The following applet class demonstrates this functionality by using Swing components rather than AWT widgets for constructing the user interface of the MailApplet that was introduced in recipe 18-17
The first class that is shown contains the actual Java Swing component code that is used to build the user interface.
It extends the JPanel component and implements ActionListener for button functionality:
The JApplet creates a new Runnable() that calls the class that was previously shown to instantiate the SwingMailPanel:
The resulting applet will look similar to the image shown in Figure 18-3
Developing applets that contain Swing components is a bit different from development using AWT because Swing components should be handled a bit differently from AWT.
Swing code should always be manipulated on the event-dispatching thread.
Doing so will ensure that the Swing code is executed on the appropriate thread.
Because the init() method of an applet is used to set up the layout, this is where the.
Using this technique, a new Runnable() will be created, which then executes a given block of code on the event-dispatching thread.
Typically, a separate method will be written to perform the invocation of another class that houses the Swing code.
In the solution to this recipe, a class named SwingMailPanel subclasses the JPanel component and implements ActionListener.
The code within the SwingMailPanel class is very similar to the code that was used within recipe 18-17, except the GUI is constructed using Swing components rather than AWT.
In the SwingMailPanel class, the first lines of code are declared and set up the Swing components that make up the user interface.
Because the class implements the ActionListener interface, the button calls the class itself in order to perform its task.
When the button is pressed, it will invoke the actionPerformed() method, which contains the code that calls the sendMail() method, changes the JLabel to display a different message, and repaints the GUI.
As mentioned previously, the most interesting code for creating the applet takes place within the SwingMailApplet class.
As you can see from the solution, this class subclasses the JApplet.
Using Swing components to construct an applet interface can significantly improve the look and feel.
Although Java Swing components could be added directly to the init() method of an applet, it can cause issues, so it is always best to perform any Swing manipulation on the event-dispatching thread.
In fact, it is possible to run entire Java Swing applications within the context of a JApplet.
The Android mobile operating system has become one of the hottest mobile platforms in use.
Developers of Android applications can create applications and distribute them within the Android marketplace.
Android application development makes use of the Java platform, along with an Android development environment.
This is a great benefit for the Android platform as it allows Android applications to make use of the wide variety of features and functionality that comes along with the Java platform.
The topic of developing Android applications can be daunting because there are a great many aspects to deal with.
From the creation of the user interface screens to handling application events, Android application development is very comparable to Java Swing development or web application development.
However, becoming an expert Android developer is only a matter of learning the different components that comprise an application and how to tie them together in order to make them work.
This chapter will show you how to get started developing applications for the Android platform.
You will learn how to set up an environment for developing applications and testing them.
You will learn the basic components that are required to build an application, and you will create a nontrivial application that features some advanced layout and user interface widgets.
In the end, you will have enough knowledge to begin developing applications for the Android platform, as this chapter will cover a broad aspect of Android application development.
You would like to develop an application for the Android mobile operating system and you need to set up a development environment.
Download a suitable version of Eclipse for your operating system and install it according to the instructions.
To find a download that will work for you, go to http://www.eclipse.org/downloads/
Make sure you take note of the name and location of the SDK installation directory because you may need to refer to it later.
Download and install the ADT plug-in for Eclipse according to the documentation that can be found at http://developer.android.com/sdk/eclipse-adt.html#installing.
After following these steps to install and configure your development environment, you will be ready to develop your first Android mobile application and test it using an AVD.
Before you can begin to develop applications for Android, you will need to set up a development environment.
There are several options to choose from depending upon the IDE you want to use and the Android device that you are developing against.
For the sake of maintaining an easy-to-use environment, this recipe discusses how to install the Eclipse IDE and ADT.
Eclipse is the preferred IDE for beginning Android developers because it is the best-documented and arguably includes the most tools.
To begin, determine which version of Eclipse will work best for your operating system and needs, and then download a package.
The preferred packages are the Eclipse Classic or the Eclipse IDE for Java Developers because they are preconfigured to be the best suited for Android development.
However, just about any Eclipse package will work if configured correctly.
Once downloaded, follow the installation instructions that come with the Eclipse package.
It is best to download the latest version of the SDK to ensure that you have access to the most recent new features.
To download the SDK, visit the SDK download page at http://developer.android.com/sdk/index.html and choose the correct package for your platform.
Either unzip it into a directory on your machine if you are using a non-Windows environment or run the Windows installer if you are using that platform.
In order to install the ADT plug-in for Eclipse, use the Update Manager feature of the Eclipse IDE.
Next, click Add in the upper corner to open the Add Repository dialog box.
The software that is available at the new repository will appear in the next dialog box.
Read the software licensing form and then click Finish when complete.
Once you’ve successfully installed the plug-in, it will need to be configured so that it points to the SDK that you downloaded previously.
To do this, open the Eclipse Preferences panel and select Android from the left panel.
In the right panel, click Browse to browse to the Android SDK you downloaded.
Once you have found it, click Open to populate the SDK Location.
The final steps to complete your Eclipse Android development environment are to add the components, add the platforms that you want to develop for, and create an AVD for each of the chosen platforms.
You can do these things from within the Android SDK and ADT Manager, which can be found within the Eclipse Window menu option.
Once the dialog box is open, you can add components that you will need for development.
To do so, select Available Packages on the left menu; then expand the Android Repository option within the Packages available for download list.
The Third Party Add-Ons repository can be used at some point in the future to add external libraries that can be used for development of your applications.
To get started, it is recommended that you download the following components:
Configure an AVD for each SDK platform that you downloaded.
You will use the AVDs that are configured for testing applications.
To create an AVD, select the Virtual Devices menu option in the left menu within the Android SDK and ADT Manager.
Click the New button in the right menu to open the Create New Android Virtual Device (AVD) dialog box.
Enter a name and select a target from the pulldown list.
The target list will contain the list of platforms that you have installed to develop against.
Once you’ve entered these two fields, click the Create AVD button.
You should now see the AVD that you created within the list of available AVDs.
For example, you’d like to begin with one that will display the current date.
Once created, modify the Java code within the Activity file, named todaysDate.java, which Eclipse has generated for you.
The code within todaysDate.java should be modified to look like the following:
After you have modified the activity code to resemble this code, your Android application is ready to compile and deploy for testing.
To learn more about compiling and deploying an application for testing, please see recipe 19-3
To create a new Android project within Eclipse, select the File menu, and then select the New and Other option.
This will open the Select a Wizard dialog box, in which you should make the Android Folder and Android Project selection; then click Next.
This will open up the New Android Project dialog box.
Once all those fields are filled in, click Next button.
In Figure 19-1, an application named Todays Date is being created.
After you’ve gone through the initial setup of an Android project, the IDE will automatically generate a Hello World view for your application, along with all the files that are required to make your application work.
If you are using the Eclipse Java layout, on the left side of the Eclipse window you will see the TodaysDate project, along with all its files.
Expand the project so that you can see the sources that are contained within the src folder.
Also, expand the res folder and the layout folder within it so that you can see the file named main.xml.
The todaysDate.java file contains the Java code that is used to create the activity, or view, of the application.
This application will only contain a single activity, and it will display a line of text that will show the current date and time.
The second file, main.xml, is used to build the view layout.
It contains a series of XML tags that correspond to the different activities of the application, which will produce the user interface.
Because there is only one activity, todaysDate.java, there is only one corresponding layout XML file.
As mentioned in the solution to this recipe, you should open up the todaysDate.java file and modify the code so that it resembles the one shown in the solution.
This file contains the code for an activity within the application.
To learn more specific details regarding implementing activities, please refer to recipe 19-4
The important changes that are made to the code for this example include the addition of two global variables: one of which corresponds to a widget known as a TextView, and the other corresponds to the layout.
The layout managers within Android applications are somewhat similar to those that are used in Swing development.
As you can see, a new LinearLayout is created and configured within a couple of lines of code and then the TextView, tv, is added to the layout.
Finally, the layout is set as the content view, which means that it will be displayed on the screen:
It creates a new java.util.Date object and then creates a new TextView widget.
The custom code is now complete, and the content layout that was set in the todaysDate activity will be used to populate the view that has been laid out within the main.xml file.
Those two files go hand in hand, and if you add more Activities in other applications, each one that contains a view will include a corresponding XML layout.
You have developed an application for the Android mobile operating system and need to compile it and test it in your development environment.
Use the Eclipse IDE to build and compile your Android project, and then deploy the application to the emulator.
To compile an Android project, right-click the Android project within Eclipse and choose the Run As menu option, followed by the Android Application menu option.
This will compile and build a deployable Android .apk file for your application.
It will then start up the corresponding AVD and deploy your application to it for testing.
Once the AVD boots and loads the application, a screen that resembles Figure 19-3 will appear.
You will also need to ensure that the Android project properties are set to use the same SDK as the emulator target platform.
You are interested in building a nontrivial user interface for an Android application using an XML file for the layout.
The application interface will contain a text box for user entry, a drop-down list that will allow a selection of text, and a button to submit the values that have been entered.
Develop the application screen, which is composed of views for each of the user interface components.
The screen will consist of an Activity class to handle the business logic and a corresponding layout XML file to define the layout.
The code for the screen’s Activity class is shown here:
As mentioned previously, the screen will also use an XML file to compose the overall layout.
Note This recipe discusses construction of the user interface only.
For information on handling events such as button clicks, please see recipe 19-6
Note In order to run this and the remaining examples in this chapter, merge the src and res folders from the book sources for Chapter 19 into your existing TodaysDate project.
Android user interfaces are constructed using a series of files that corresponds to different application screens.
An application can consist of one or more different application screens, and a user will only interact with one screen at a time.
Views are drawable objects and they are the building blocks of a user interface.
For instance, all user interface widgets are views; therefore, a button is a view, a text area is a view, and any other widget that is used within a screen is a view.
Each screen within an Android application consists of a single class known as an activity that is used to construct the views that will be used on that screen.
Hopefully by this point you are beginning to see that Android applications are constructed in a very logical and uniform fashion.
Each application screen has an Activity class that contains its application logic.
In order to build a user screen, you must create an Activity, which pertains to a single focused task that the user can perform.
An Activity can be stand-alone or embedded inside other activities.
Two of the most important methods include onCreate(Bundle) and onPause()
Every Android activity must override the onCreate(Bundle) method; it initializes the activity because it is the first method that is called when the Activity class is constructed.
The onCreate(Bundle) method is typically used to perform any necessary setup for building the layout of the screen that is associated with the activity.
As you can see in solution 1, the onCreate() method accepts a Bundle argument, which pertains to the saved instance state of the activity.
The first line within the onCreate() method should be a call to the Activity superclass, passing the Bundle as follows:
In the solution you can see that a strange looking object is passed to the setContentView method.
You may be wondering where the R came from because this class is not listed in the imports.
The R class is automatically generated when the application is compiled, and it contains the resource IDs for all the resources that are contained within the application’s res directory.
All resource IDs are stored within the R class, which can be used to retrieve the resource.
Note You should never have to manually access or change the R class.
The Android build process will take care of automatically generating the R class for you.
The R class contains the resource IDs, which are automatically generated for each resource.
The resource ID is always composed of the resource type and the resource name.
Every Android application contains resources that are used to compose the user interface.
These resources should always be externalized from application code so that they can be independently managed.
Therefore, resources are contained within XML files to make them more manageable.
All resources must be organized within the project’s res directory, and they must be organized into groups that categorize them based upon type and configuration.
Many different types of resources can be provided for an application, and they include the following:
They can also be accessed in the XML by using a special syntax that also corresponds to the resource ID defined within the R class (for example, @string/mystring)
For more detailed information regarding application resources, please visit the online documentation at http://developer.android.com/guide/topics/resources/index.html.
If you are using an XML file to construct the layout for the activity’s user interface, you do not need to write any more code within the Activity class unless you need to construct views or handle events.
In the solution to this recipe, a layout XML file is used, so no further coding is required to build the layout.
However, a widget called a Spinner is constructed within the activity as well.
The drop-down list of values can be constructed programmatically, and the strings that are contained within the drop-down list are defined within an XML resource file.
This Spinner was added to the user interface to provide a brief introduction to working with views within Android activities.
First, the Spinner widget is referenced using the R.id.spinner static integer, which corresponds to the Spinner tag that is located within the XML layout file (as seen in the second code listing within the solution)
Note You can reference any widget that is defined within an XML layout programmatically by using the findViewById(int) method, and passing the resource ID for the widget you are using.
An array is then constructed using the externally defined Strings to build the drop-down list of values.
It is worth noting that Android provides predefined templates for use with widgets, and often developers can make use of those templates in order to help reduce development time.
Such predefined templates are used to setup the drop ArrayAdapter for the Spinner view.
The complete construction of the Spinner view can be seen in the following code excerpt:
The next step after creating the Activity class is to construct a layout XML file.
An Activity class can have an optional corresponding layout XML file that is used to construct the layout in a visual manner.
An XML file that is used for the layout is not mandatory (this will be discussed more in recipe 19-5)
The layout XML file is used to organize the widgets that will be used to construct the user interface.
In the solution to this recipe, there are four subviews within the XML layout.
One of them is a layout object, which is used to define the manner in which its child views are positioned on the screen.
The solution uses a LinearLayout, which aligns all children in a single direction.
The orientation that is set for the layout determines in which direction the children will be aligned.
The solution aligns the children vertically, which means that each child will stack one on top of the other.
Note There are several layout objects that can be used within Android application screens.
To see a full list of layout objects along with details regarding usage, please refer to the documentation that is available at http://developer.android.com/guide/topics/ui/layout-objects.html.
The tags contained within the opening and closing tags of the LinearLayout tag define the children; in this case they are widgets that will be displayed on the screen.
Each of these XML tags contains attributes that are used to define the widget’s appearance and behavior.
As you can see, each of the tags, with the exception of the <Button>, contains an android:id attribute.
This declares the ID that can be referenced via the Activity class using the R.id.idnumber syntax.
Similar to the <Spinner> tag’s android:prompt attribute, the android:text attribute refers to a string element that is contained within the strings.xml resource file.
The android:onClick attribute specifies a method, in this case performAction, that is implemented within the corresponding Activity class that will be used as a listener for the button click.
For more information regarding listeners and event handling, please refer to recipe 19-6
The XML layout contains references to strings that have been declared within the strings.xml file for the application.
Assuming that this activity is being added to the Android project, which was created in recipe 19-2, the strings.xml file should look like the following:
As you can see, each string element contains a name and a value, and the array element contains a list of String items.
The string names can then be used within layout XML or programmatically as demonstrated in this solution.
To learn more about registering an activity, please see recipe 19-6
The resulting user interface screen will look similar to Figure 19-4
Note The name of the application is “Today’s Date” because this chapter assumes that you will build onto the project created in recipe 19-2
If you want to create a new Android project, please follow the steps within recipe 19-2
You could also change the string that is mapped to app_name within strings.xml, so a different name is displayed.
You are interested in building a non-trivial user interface for an Android application without using an XML file for the layout.
The application interface will contain a text box for user entry, a drop-down list that will allow a selection of text, and a button to submit the values that have been entered, just like the user interface that was developed in recipe 19-4
Develop the user interface entirely within the Activity class, and do not create an XML file for the layout.
The following code demonstrates how to construct the same user interface screen, which was built in recipe 19-4 by programmatically using a layout view and organizing subviews within it programmatically.
Note This recipe discusses construction of the user interface only.
For information on handling events such as button clicks, please see recipe 19-6
It is possible to construct a user interface entirely within Java code without the need for a corresponding XML layout file.
Why would you be interested in using this technique? Although defining an XML layout has the advantages of being easy to maintain and more readable, developing a layout entirely in code can provide more flexibility if the need arises.
To create a user interface without XML, you need to instantiate and configure the layout programmatically within the Activity class.
If using a layout object, that must be programmatically defined and each of its children must be added to it manually.
If you like Java Swing, the programmatic approach may be for you because there are some close similarities between the programmatic development of Android user interfaces and the construction of a Java Swing user interface.
The obligatory onCreate(Bundle) method is where the user interface construction takes place.
The first line within the method is a call to the super class’s onCreate() method, passing a Bundle that contains the saved instance state for the activity.
Next, a new LinearLayout instance is created, passing the Activity class as an argument via the this keyword.
Next, the child views that will go within the layout are constructed.
That is, each widget is now instantiated, and attributes are set accordingly.
The widgets can be defined and configured in any order.
First, the Button is instantiated, and its text is set.
Second, the EditText widget is instantiated, and its text is set.
If you read through recipe 194, you will notice that instead of passing a resource ID to the Spinner when instantiating it, the this keyword is passed.
Because there is no corresponding XML layout, there is no resource ID to pass.
The following code shows how the 4 is instantiated and constructed:
The final thing that needs to be completed is to add each of the widgets to the layout.
While adding widgets to the layout, the ordering is important.
The first widget that is added will be placed in the first position of the layout, and the others will follow suit according to the position in which they are added.
Finally, the layout itself is passed to the setContentView() method.
If you fail to do this, the user interface will be blank.
To learn more about adding listeners to buttons and handling events, please see recipe 19-6
You have developed an Android application user interface and would like to add some functionality to it.
For instance, you created a screen that includes a button and you would like to open another application screen when that button is clicked, passing information that was obtained from the original screen.
Develop a listener for the button by mapping the layout XML tag to an event handling method that resides within the corresponding activity.
To use this technique, your user interface must be composed of a layout XML file along with an associated Activity class.
Once the listener is invoked, use an Intent to pass data to the Activity class for another screen.
The following code excerpt shows what the XML within the layout would look like for the button:
In this case, a method named performAction() that resides within the Activity class will be triggered when the button is pressed.
Programmatically add an event listener to a button that is contained within the screen.
Using this technique, the button functionality takes place within the screen’s Activity class using Swing-like action listeners.
The following code can be used within the Activity class to programmatically add an event listener to the Button:
The performAction() method that is invoked within onClick() uses an Intent to pass data to a different Activity class.
Once again, there are two different ways to handle view events for a specified screen.
Using the technique specified in solution 1, you can choose to use a layout XML file to configure the layout for the screen, and use the XML tag attributes to assign listeners.
Note that the tag lists an android:onClick attribute with a listener method by the name of performAction.
This method resides within the Activity class for the screen.
When the button is clicked, the method is invoked and performs some work.
The standard approach for adding a listener to a button in this manner is to use an anonymous inner class to use as the listener.
What can you do within a listener method? You can do just about anything that is required to handle your event.
In the performAction method for this recipe, the text from within the widgets on the screen is sent to another screen using an Intent, which is a runtime binding between the code and different classes within the application.
They can be used to perform a number of operations, including starting a new activity, starting a service, and broadcasting.
In this case, the Intent is used to start a new activity, passing data along with it.
Each of the solutions in the recipe has a slightly different implementation of the performAction() method.
In the first solution, the resource ID for each widget is used to obtain the text that has been entered into the EditView or selected on the Spinner.
The second solution uses fields of the class to obtain the text from each widget.
All the other functionality is the same between the two methods.
To start a new activity, instantiate a new Intent, passing the current Activity class and the Activity class that you want to start:
Note Intents play an important role in Android application development.
To learn more, please see the online documentation available at http://developer.android.com/reference/android/content/Intent.html.
The activity process life cycle becomes important when you have an application that contains more than one activity.
Mobile devices need to maintain a close watch on system resources in an attempt to try and limit the amount of memory in use.
Doing so helps to ensure that the systems do not run low on the memory required to perform background processes such as receiving phone calls.
Because memory management on mobile devices is important, it is good to know how Android attempts to maintain processes.
The system will attempt to keep application processes around for as long as possible, but eventually they will need to be removed in order to reallocate memory for new processes to run.
An activity life cycle is used to help determine which processes are more important than others, and the less important processes will be killed first.
It is important to know when an activity will be closed or needs to be restored.
Sometimes such events can be critical to an application’s use.
Next, create a new Bundle to pass the data to the new activity.
The Bundle can contain any number of values, and in the solution to this recipe the text from both the EditView and Spinner widgets is added to the Bundle.
The Bundle is then added to the Intent by calling the Intent class’s putExtra() method.
Once the screen that pertains to the EnterInformation activity has been filled out, and the button has been clicked, the DisplayInformation activity will be activated.
The DisplayInformation activity is not very complex; it only displays a message that includes some content taken from the user in the previous screen.
Activities that are in the foreground of the screen are at the top of the stack.
Activities that are not in focus, but still remain visible are referred to as paused.
A paused activity is still alive and maintains state unless the system is running critically low on memory.
Activities that are completely obscured by another activity are referred to as stopped.
A stopped activity still retains state and information, but if it is completely hidden from the user interface, it will be killed by the system when memory is needed elsewhere.
Activities that are paused or stopped can be dropped by the system.
In order to do so, the system will ask it to finish, or simply kill it.
The next time the activity is needed, it must be completely restarted and restored to its previous state.
In the end, the resulting screen will look like Figure 19-5
This recipe only covers a small portion of what can be done with events and Intents on Android.
This is a very important topic, and there is a wealth of information on them that can be found online.
Please refer to the online documentation that can be found at http://developer.android.com/reference/android/content/Intent.html for more details.
An activity has been created for your application and you would like to register it to be loaded when the application is started.
If you’d like for the activity to be loaded at application startup, indicate that within the manifest as well.
The file must be located in the root directory of the application.
It includes information regarding the application’s components, processes, permissions, and more.
The manifest is read before any of the application’s code is executed.
As a matter of fact, the manifest is used to register Activity classes and determine which class is executed first when the application is started up.
The required android:name attribute should be set to the name of the class that corresponds to the activity.
The tag’s android:label attribute can be used to label the activity screen.
For normal activity registration, the <activity> tag is all that is required.
However, if you want to register an activity as the main activity that will be launched upon application startup, an intent filter must be registered.
Note The <activity> tag is quite involved, and contains a great many options.
For more details on using the <activity> tag, please see the online documentation available at: http://developer.android.com/guide/topics/manifest/activity-element.html.
As mentioned previously, the manifest is used for much more than registering activities.
To learn more about registering application permissions, please see recipe 19-11
When your users receive a phone call, the application you have written does not pause to allow the user to answer the call.
You would like to make your application pause and fall into the background when a call comes in.
Create a broadcast receiver to handle the incoming phone calls.
The following code demonstrates a BroadcastReceiver class that handles incoming phone calls:
Please refer to the source files for a full example.
When the application is started, it should now be paused when an incoming call event occurs.
If a Short Message Service (SMS) message is received, it will be displayed within the top menu bar while the application is running.
Your application is the most important piece of software running on an Android device.
Well, you may think that is the case, but unfortunately it is not.
The most important software running on the device may not have any interaction with your application at all.
Of course, we are talking about the capability for the Android device to communicate via phone or SMS services.
Ultimately, mobile devices are most useful for communication, and applications that do not pause or allow the user to exit and take action upon a received phone call or SMS message are usually frowned upon.
It is important to build your application so that it is aware of any incoming phone calls or messages and takes the appropriate action to allow users to act upon them.
They have no user interface; instead they act as a transparent gateway for other components to perform tasks.
For instance, the system may broadcast any number of announcements.
They may include an incoming phone call or SMS message, low battery, or a screen being turned off.
Any broadcast receivers will be notified of such announcements, and then they can perform a task such as pausing an application to allow the user to take a phone call.
There are two main types of broadcasts that can be received.
Each receiver can execute and then propagate a result or abort the broadcast.
Receivers can be run in a specified order by setting the android:priority attribute within the corresponding intent filter.
If two or more receivers contain the same priority number, they will be executed in any order.
Broadcasts are delivered as Intent objects, and a Broadcast Receiver acts as a listener for those Intents.
The onReceive(Context, Intent) method must be implemented within a BroadcastReceiver class.
Its purpose is to receive any broadcasts and act upon them accordingly.
In the solution to this recipe, the receiver’s main objective is to listen for incoming phone calls or SMS messages.
When a call comes in, the broadcast receiver’s onReceive() method is called and the Intent is passed into it.
The first line of the method gets the broadcasted announcement by calling the Intent’s getExtras() method, and a Bundle is obtained.
The Bundle can then be interrogated to determine the type of broadcast that has been made.
All this can be seen within the following code excerpt taken from the solution’s onReceive() method:
Note Although broadcasts to the system use Intent objects, they are separate from those Intent objects that are used for starting activities.
In the solution, the android:name attribute of the <receiver> tag specifies the name of the corresponding receiver class.
Two Intent actions are filtered with the receiver: phone calls and SMS.
The topic of broadcast receivers is immense, and entire chapters can be written on the topic.
This recipe only covers a small aspect of what broadcast receivers are capable of doing.
To learn more about broadcast receivers, please see the online documentation that can be found at http://developer.android.com/reference/android/content/BroadcastReceiver.html.
You would like to design a user interface that can make it easy to switch between two or more application screens.
Develop a tabbed user interface and designate a tab for each application screen.
This activity will be used to construct the tabbed user interface.
For this example, a tabbed interface will be developed for the application that has.
The next step is to provide a new drawable XML file for each of the activities for which you want to create a tab.
These drawable XML files must reside within the res/drawable/ directory in the application.
The following code shows what one of these XML files will look like.
One should be created for each activity that is going to be contained within a tab.
After creating a new drawable XML file for each tab, create the main tab layout XML file within the res/layout/ directory.
This file will be used to construct the XML layout for the tabbed user interface.
The following code is taken from a file named tabs.xml which resides within the res/layout/ directory:
After doing so, the complete manifest file should look as follows:
The resulting tabbed interface should resemble that shown in Figure 19-6
Tabbed user interfaces make it easy to navigate applications, especially on devices with smaller screens because the tabs do not take a lot of real estate.
Developing a tabbed user interface is an easy task, but it does require the manipulation of a few different files.
The tabbed interface itself must have its own Activity class and corresponding layout XML file.
Each activity that is going to reside within a tab must also have its own corresponding drawable XML file.
To begin implementing the tabbed user interface, create a drawable XML file for each activity that you want to load into a tab.
A state-list drawable is an object that is defined in XML, which uses different images to represent the same graphic, depending upon the state of the corresponding object.
In other words, these drawable files represent the tabs along with the images and text to load onto each tab.
Intricate applications load different images on tabs depending if they are the currently selected tab or not.
In the solution to this recipe, the drawable XML for the EnterInformation Activity class is shown, and you can see that different images are referenced depending upon the selection state of the tab.
The excerpt below shows the lines of XML that enable this functionality:
The android:drawable attributes of the <item> tags are set equal to a drawable element correlating to an image that is located in the res/drawable/ directory.
The resulting Activity class will contain the onCreate(Bundle) method just like every other activity.
Per the specification, the onCreate() method will be initiated prior to loading the user interface on the screen, and it is used to build the elements of the user interface.
In the solution to this recipe, another method named setupTabs() is called within the onCreate() method.
Taking a look at the code, the layout XML which corresponds to the tab view is loaded within the first line of the setupTabs() method.
Next, a Resources instance is obtained for working with the resource files that correspond to the different activities, which will be placed within the tabs.
A TabHost instance is also obtained for working with the tabs.
A couple of other variables are also declared for later use:
For the creation of each tab, a new Intent is created; passing the class of the corresponding activity that is to be loaded into the tab.
In this excerpt, an Intent is created for the EnterInformation activity that was developed in recipe 19-4:
The TabSpec is created to define the different properties for each tab.
When creating the TabSpec, pass a string value, which can be used to identify the tab.
Finally, set the content of the tab by passing the Intent that was created previously.
Once these steps have been taken, the TabSpec can be added to the TabHost.
Although this seems like a lot of steps to complete, it is done within two lines of code.
The following code excerpt sets up the TabSpec for the EnterInformation activity and adds it to the TabHost:
Follow these steps for each tab that you want to create.
The last line of the setupTabs() method sets the index for the tab that will be loaded first:
Similar to other activities, the TabActivity class must have a corresponding layout XML file.
This file should be placed within the res/layout/ directory and it is responsible for defining the layout structure of the tab interface.
In the solution to this recipe, a file named tabs.xml is created for this purpose.
After all the XML files and the TabActivity class have been created, the tabbed user interface is just about ready.
The last piece of the puzzle is to add the Activity class to the manifest.
The TabContainer activity has a couple of additional attributes specified within the <activity> tag.
This attribute allows you to override the default system configuration changes such as the screen orientation change.
This attribute allows for customization, and it can be used with any activity.
The other attribute that we have not yet discussed in this chapter is android:launchMode.
For the TabController activity, it is set to a value of “singleTop”
This attribute handles the way in which the activity is launched.
Specifying “singleTop”, which basically allows only one instance of the activity to be created.
This is important with the TabController activity because you do not want more than one set of tabs on the screen.
To see other useful attributes that can be used with the <activity> tag, please refer to the online documentation that can be found at: http://developer.android.com/guide/topics/manifest/activity-element.html.
After the tabbed interface has been configured and registered in the manifest, the application is ready to run.
There are more interfaces that can be useful for laying out application user interfaces, including the Grid Layout and Table Layout.
For a list of the others, as well as examples, please see the online documentation at: http://developer.android.com/resources/tutorials/views/index.html.
You would like to embed an active web page to your application.
Develop an activity that creates a WebView, and load the web page into it.
The following Java class contains an activity that instantiates a WebView:
A WebView is an Android view that displays web pages.
It uses WebKit for rendering and includes the functionality to navigate the web.
By default, the WebView does not enable any browser-like widgets, and functionality such as JavaScript is turned off.
When you use a vanilla WebView, it will load a web page and display it, and that is all.
However, the WebView is very customizable and can be adjusted to create a fully capable web browser if needed.
In the solution to this recipe, a standard WebView is created within an Activity class named ViewSite, which will include no browser-like widgets such as the back and forward buttons.
There are many other useful settings that can be set within the WebSettings class.
For complete documentation regarding the WebSettings class, please see the online documentation available at.
The code to enable JavaScript within the WebView is as follows:
A WebChromeClient subclass is used when an event occurs that may impact the browser UI.
In this case, when loading the specified web page, the progress bar is updated to reflect the progress:
Note Creating and setting a WebChromeClient can take care of providing specified functionality when browser specific events occur.
For more information on using the WebChromeClient class, please see the online documentation available at http://developer.android.com/reference/android/webkit/WebChromeClient.html.
The next code block creates and sets a WebViewClient, which is called when events occur that could impact the loading of a specified web page, such as JavaScript errors.
You can customize the functionality of a WebViewClient by implementing specific methods depending upon the events you are trying to handle.
After the text is created, it is displayed to the user within a Toast object.
A Toast is a view for displaying a message to a user.
For more information pertaining to using Toasts, please see the online documentation that can be found at http://developer.android.com/reference/android/widget/Toast.html.
Note Creating and setting a WebViewClient can take care of handling events that impact the loading of web pages.
There are a great number of events that can be handled using a WebViewClient such as a malformed URL or a failed SSL handshake.
For complete details on using a WebViewClient, please see the online documentation available at http://developer.android.com/reference/android/webkit/WebViewClient.html.
Finally, the activity loads the URL for the WebView to display and sets the content view.
The last thing that needs to be done to enable a WebView to access the Internet is to grant permissions to your application for doing so.
If you fail to grant permissions to your application for accessing the Internet, your WebView will be unable to display any web content.
For information regarding granting these permissions to your application, please see the next recipe, 19-11
Quite a bit is going on here that has not yet been discussed within the context of this chapter.
The WebView class is complex because it enables the developer to customize WebView instances in many different ways.
This recipe barely scratches the surface of what can be achieved by using a WebView within your Android application.
For complete documentation on using WebViews, please see the online documentation available at http://developer.android.com/reference/android/webkit/WebView.html.
For instance, you want to embed a web browser into your application and you need to provide the ability for your application to access the Internet.
For instance, if you want to allow your application the ability to access the Internet, add the following tag to the manifest:
Upon creation, a basic Android application has no permissions granted to it.
This is a safety feature so that the application will be unable to do anything that may adversely affect the user experience or the.
To specify permissions for an application, a series of one or more <uses-permission> tags can be added to the manifest declaring the permissions that the application requires.
The package installer then grants the requested permissions to the application at install time.
There are no security checks that will be displayed to the user at application runtime.
Either the application is granted the permissions at install time, or it is not.
Any number of permissions can be specified within the manifest in order to provide more functionality to an application.
However, it is important that only the permissions required for the application to run normally are specified.
Specifying more permissions than are needed can cause a device run in an unsecured state, allowing bad things to happen.
Note For a complete set of permissions that can be used within an Android application, please see the online documentation available at http://developer.android.com/reference/android/Manifest.permission.html.
The underlying web page–rendering engine in JavaFX is the popular open-source API called Webkit.
HTML5 is the new standard markup language for rendering content in web browsers.
The relationship between JavaFX and HTML5 is important because they complement one another by drawing from each of their individual strengths.
For instance, JavaFX’s rich client APIs coupled with HTML5’s rich web content create a user experience resembling a web application with the characteristics of desktop software.
Problem You hope to get promoted out of your cubicle into an office with windows by impressing your boss by creating a proof of concepts using JavaFX with your existing web development skills.
Solution Create a Hello World application using the NetBeans IDE 7.1 or later by using its new project wizard to create an application to run in a browser.
Shown following are steps to follow to create a Hello World JavaFX application that is embedded in an HTML web page:
Here are the steps to follow in running the new project wizard:
Select New Project in the File menu of the NetBeans IDE version 7.1 or later.
Figure 20-1 highlights the menu option in the NetBeans File menu.
Create a project by specifying a name and selecting the check box to allow the wizard to generate a main class called MyJavaFXApp.java.
Figure 20-3 shows a New JavaFX application wizard that specifies the project name and location.
Once your new project has been created, you modify project properties.
To modify the properties, right-click the project and select Properties via the popup menu.
Figure 20-4 shows the project created with a main JavaFX file named MyJavaFXApp.java.
Go into the project’s properties, as shown in Figure 20-5
Select the Run option in the Categories list shown in Figure 20-6
Run and test the project by clicking the Run button on the toolbar or the F6 key.
Figure 20-7 depicts the resulting Hello World application running in a browser.
Although there are different deployment strategies, such as Webstart and Standalone modes, here you use the NetBeans new project wizard to automatically deploy as a local web page containing your JavaFX application in your browser.
You will notice the JavaFX classes being used; for example, Stage, Group, and Scene classes.
Note You can drag the imports and body of code from another code file for this recipe into the body of your new main project class, changing the name on the class definition line, as appropriate.
Following is the source code when the NetBeans’ wizard generates a new project to create a JavaFX application embedded in a HTML web page:
In Step 2, you select the standard JavaFX application to be created.
After selecting the project type, you will be specifying the name of the project.
Make sure you click the Create Application Class check box to allow the wizard to generate the MyJavaFXApp Java file.
Once you have clicked Finish, your newly created application will appear in the projects tab.
Next, you will take Step 5 in changing project properties.
In Step 5 you will be changing two categories: Sources and Run.
In the Sources category, make sure the Source/Binary Format is set to JDK 1.6 or later.
After updating the Sources category, you will be changing how the project will run (Step 6) through the Run category.
In Step 6, after selecting the in Browser radio button option, you will notice the Width and Height below the working directory field.
To use your own custom web page, you click the browse button to select an existing HTML file, but in this recipe you can leave it blank to allow the wizard to generate a generic HTML page.
Assuming that you are done with your settings, click OK to close the Project Properties dialog window.
Last, you will run your embedded JavaFX web application (Step 7)
To run your application you will want to make sure this project is set as the main project by selecting in the menu Run -> Set Main.
Once you are initiating a run, your browser will launch, containing a generic web page with your JavaFX application.
You’ll also notice that a convenient link allows you to launch the application as a Webstart application (not embedded)
Problem You are so engrossed with a project for work that you often miss your kid’s soccer games.
What you need is a clock application to keep track of the time.
Solution Create a JavaFX based-application containing an analog clock that was created as HTML5 content.
The following source code is a JavaFX application displaying an animated analog clock.
The application will load an SVG file named clock3.svg and display the contents onto the JavaFX Scene graph:
Assuming that you have a designer who has provided content such as HTML5, it will be your job to render assets in JavaFX.
The following code represents an SVG file named clock3.svg that is predominantly generated by the powerful tool Inkscape, which is an illustrator tool capable of generating SVG.
In the following code, notice hand-coded JavaScript code (inside the CDATA tag) that will position the second, minute, and hour hands of the clock based on the current time of day.
Because all the logic (from setting the time to animating the hands) is inside this file, things are self contained, which means any HTML5 capable viewer can display the file’s contents.
So when debugging, you can easily render content in any HTML5-compliant browser.
Later in this chapter, we will demonstrate JavaFX code that can interact with HTML5 content.
Shown here is a pared-down version of the SVG analog clock.
To obtain the file’s source code, download the code from the book’s web site.
The rest of the Clock code: shiney glare, black button cover (center) on top of arms.
How It Works In this recipe, you will be creating an analog clock application that will take existing HTML5 content to be rendered onto the JavaFX Scene graph.
HTML5 allows the use of SVG content to be shown in browsers.
To manipulate SVG or any HTML5 elements, you will be using the JavaScript language.
Depicted in Figure 20-8 is a JavaFX application displaying an animated analog clock.
Before running this example, make sure the clock3.svg file is located in the build path.
In NetBeans you may need to perform a clean and build before running the application that will copy the resource (clock3.svg) to the build path.
In software development you will undoubtedly experience working with a designer where he/she will use popular tools to generate web content that will be wired up to an application’s functions.
To create an analog clock, I enlisted my daughter, who is quite proficient with the open-source tool Inkscape.
Although Inkscape was used to generate the content for this recipe, I will not go into details regarding the tool because it is beyond the scope of this book.
To learn more about Inkscape, please visit http://www.inkscape.org for tutorials and demos.
To model the Designer and Developer Workflow, she created a cool looking clock and I added JavaScript/SVG code to move the clock’s hour, minute, and second hands.
Inkscape allows you to create shapes, text, and effects to generate amazing illustrations.
In this scenario, you will be displaying the analog clock in JavaFX’s WebView node.
You can think of a WebView node as a mini browser capable of loading URLs to be displayed.
Shown here is the JavaFX’s WebEngine object loading a file clock3.svg:
You are probably wondering why the JavaFX source code is so small.
After that, the WebEngine object does all the work by rendering HTML5 content just like any browser.
When rendering the content, notice that the clock’s arms move or animate; for example, the second hand rotates clockwise.
Before animating the clock, you have to set the clock’s initial position by calling the JavaScript updateTime() function via the onload attribute on the entire SVG document (located on the root svg element)
Once the clock’s arms are set, you will add SVG code to draw and animate by using the line and animate transform elements, respectively.
Shown here is a SVG code snippet to animate the second hand indefinitely:
On a final note, if you want to create a clock like the one depicted in this recipe, visit.
Another impressive and beautiful display of custom controls that focuses on gauges and dials is the Steel Series by Gerrit Grunwald.
Problem You are an underpaid developer, and your boss refuses to let you relocate to the cube next to the window.
You must find a way to determine the weather without leaving your workspace.
Solution Create a weather application that fetches data from Yahoo’s weather service.
The following code implements a weather application that retrieves Yahoo’s weather information to be rendered as HTML in a JavaFX application:
Figure 20-9 depicts the weather application that fetches data from the Yahoo Weather service.
In the third line of displayed text, you’ll notice that Seconds till refresh: 31 is a countdown in seconds until the next retrieval of weather information.
The following is output to the console of the HTML that is rendered onto the WebView node:
How It Works In this recipe you will be creating a JavaFX application able to retrieve XML information from Yahoo’s weather service.
Once the XML is parsed, HTML content is assembled and rendered onto JavaFX’s WebView node.
The WebView object instance is a graph node capable of rendering and retrieving XML or.
The application will also display a countdown of the number of seconds until the next retrieval from the weather service.
When accessing weather information for your area through Yahoo’s weather service, you will need to obtain a location ID or the URL to the RSS feed associated with your city.
Before I explain the code line by line, I will list the steps to obtain the URL for the RSS feed of your local weather forecasts.
Click the small orange colored RSS button near the right side of the web page (under “Add weather to your website”)
Copy and paste the URL address line in your browser to be used in the code for your weather application.
For example, I used the following RSS URL web address: http://weather.yahooapis.com/forecastrss?p=USMD0033&u=f.
Now that you have obtained a valid RSS URL web address, let’s use it in our recipe example.
The refreshCountdown variable of type int is assigned 60 to denote the time in seconds until a refresh or another retrieval of the weather information takes place.
Like all our JavaFX examples inside of the start() method, we begin by creating the Scene object for the initial main content region.
The WebEngine object will asynchronously load the web content from Yahoo’s weather service.
Later we will discuss the callback method responsible for handling the content when the web content is done loading.
The following code line will create and load a URL web address using a WebEngine object:
After you create a WebEngine object, you will be creating an HTML document that will form as a.
Although the code contains HTML markup tags in Java code, which totally violates the principles of the separation of concerns, I inlined HTML by concatenating string values for brevity.
To have a proper MVC-style separation, you may want to create a separate file containing your HTML content with substitution sections for data that will change over time.
The code snippet that follows is the start of the creation of a template used to display weather information:
Once you have created your web page by concatenating strings, you will create a WebView object instance, which is a displayable graph node that will be responsible for rendering the web page.
Remember from recipe 20-2, in which we discussed that a WebView will have its own instance of a WebEngine.
Knowing this fact, we only use the WebView node to render the assembled HTML web page, not to retrieve the XML weather information via a URL.
In other words, the WebEngine object is responsible for retrieving the XML from Yahoo’s Weather service to be parsed and then fed into the WebView object to be displayed as HTML.
The following code snippet instantiates a WebView graph node that is responsible for rendering HTML5 content:
Next, you will create a countdown timer to refresh the weather information being displayed in the.
First, you will instantiate an IntegerProperty variable, countdown, to hold the number of seconds until the next refresh time.
Second, you will add a change listener (ChangeListener) to update the HTML content dynamically using JavaFX’s capability to execute JavaScript.
The change listener also will determine whether the countdown has reached zero.
If so, it will invoke the webEngine’s (WebEngine) reload() method to refresh or retrieve the weather information again.
The following is the code that creates an IntegerProperty value to update the countdown text within the HTML using the executeScript() method:
After implementing your ChangeListener, you can create a TimeLine object to cause change on the.
The follow code implements a TimeLine to update the countDown variable:
In summary, the rest of the code creates a ChangeListener that responds to a State.SUCCEEDED.
The following code parses and displays the weather data by calling the loadContent() method on the WebView’s WebEngine instance:
For convenience, I created a parse() method to walk the DOM to obtain weather data and return as a Weather object.
See Javadocs and Yahoo’s RSS XML Schema for more information on data elements returned from weather service.
Problem You begin to feel sorry for your other cube mates who are also oblivious to the outside world.
A storm is approaching and you want to let them know to take their umbrella before leaving the building.
Solution Add a Panic Button to your weather application that will simulate an e-mail notification.
A Calm Down button is also added to retract the warning message.
The following code implements the weather application with additional buttons to warn and disregard a warning of impending stormy weather:
This code will add HTML buttons with the onclick attributes set to invoke the JavaScript alert function:
The following code is added to the start() method to create the warning message with opacity set.
Continuing inside of the start() method, this code section is added to update the warning message after weather information was retrieved successfully:
This code sets the OnAlert property, which is an event handler to respond when a the Panic or Calm Down button is pressed:
Figure 20-10 shows our weather application displaying a warning message after the Panic Button.
To remove the warning message, you can press the Calm Down button.
How It Works In this recipe you will add additional features to the weather application (from recipe 20-3) that responds to HTML events.
The application you will be creating is similar to the previous recipe, except you will be adding HTML buttons on the web page to be rendered onto the WebView node.
The first button added is the Panic Button that, when pressed, displays a warning message stating the current weather condition and a simulated e-mail notification to your cube mates.
To retract the warning message you will also add a Calm Down button.
Note Because the code is so similar to the previous recipe, I will point out the additions to the source code without going into great detail.
Shown here are the two buttons added to the web page:
When the web page renders allowing you to press the buttons, the onclick attribute will call JavaScript’s alert() function that contains a string message.
When the alert() function is invoked, the web page’s owning parent (the webView’sWebEngine instance) will be notified of the alert via the WebEngine’s OnAlert attribute.
To respond to JavaScript’s alerts, you will add an event handler (EventHandler) to respond to WebEvent objects.
The following code snippet toggles the opacity of the warning message based on comparing the event’s data (evt.getData()) that contains the string passed in from the JavaScript’s alert() function.
Please see the Javadocs for additional HTML web events (WebEvent)
Problem You want to keep up on the latest news monitoring the local legislature and science regarding the detrimental effects of the lack of light in small cubical work areas.
The RSS feed location URLs will be stored in a database to be later retrieved.
Listed here are the main classes used in this recipe:
This recipe will be using an embedded database called Derby from the Apache group at http://www.apache.org.
As a requirement, you will need to download the Derby software.
To download the software, visit http://db.apache.org/derby/derby_downloads.html to download the latest version containing the libraries.
Once downloaded, you can unzip or untar into a directory.
To compile and run this recipe, you will need to update the classpath in your IDE or environment variable to point to Derby libraries (derby.jar and derbytools.jar)
When running the example code you can type into the text field a valid RSS URL and then hit the enter key to load your new RSS headlines.
After loading is complete the headline news is listed to the upper right frame region.
Next, you will have an opportunity to choose a headline news article to read fully by clicking on a view button beneath it.
The following code is an exerpt from DBUtils.java showing the saveRssFeed() method which is.
The left column shows a text field at the top to allow the user to enter new urls and RSS feed sources as hyperlinks underneath.
The upper-right frame contains the headline, an excerpt of the article, and a view button that renders the article’s web page in the bottom frame (lower-right region)
Shown here is an example of output of the HTML to be rendered in the new headlines region (upper-right frame)
You will also see the html view button responsible for notifying the application to load and render the entire article in the lower right frame region:
How It Works To create an RSS reader, you will need to store feed locations for later reading.
When adding a new RSS feed, you will want to locate the little orange iconic button and drag the URL address line into your JavaFX RSS reader application.
I find that the drag metaphor works on my FireFox browser.
However, if dragging doesn’t work I’ve provided a text field to allow you to cut-and-paste the URL.
Once the URL is entered you will hit the enter key to initiate the loading of the headline news.
For example you can visit Google’s technology news RSS at:
Figure 20-12 depicts the orange RSS icon in the upper left.
Once the URL is accepted via drag-n-drop or text field, the JavaFX RSS reader application will save the URL location to a database.
The RSS application consists of three frame regions: the RSS feed title column (left), headline news (upper right), and web site view (lower right)
To display the news headlines, click the hyperlinks to the left.
To show the entire article in the lower-right frame, click the View button below the headline in the upper-right frame.
Before running the code, the application will require the jar libraries derby.jar and derbytools.jar included into your project classpath.
These libraries allow you to save RSS URLs to an embedded JDBC database.
Similar to what you did in recipe 20-3, you retrieve news information from the Internet.
Now enough with the acronyms; let’s jump into the code, shall we?
Next, you will create a map (TreeMap) containing Hyperlink objects as values and keys representing the URL location (String) to the RSS feed.
As before when displaying HTML content, you will need to create WebViews.
The two WebViews will render HTML for the news headline frame region and the viewing of the entire article region (lower right)
The single WebEngine is responsible for retrieving the RSS feed when the user clicks the left frame region containing the RSS hyperlinks.
To support the feature that allows the user to enter an RSS feed you will need to create a text field that is able to save and render the headline news.
Below is the code snippet to save an RSS URL and to add an address as a new hyperlink to the list of feeds.
After a user has clicked on a hyperlink the news retrieval is initiated.
Once a successful retrieve has occurred on the webEngine (WebEngine) object, you will need to add a ChangeListener instance to respond when the state property changes to State.SUCCEEDED.
With a valid state of State.SUCCEEDED, you will begin to parse the XML DOM returned from the WebEngine’s getDocument() method.
Again, I provided a convenience method called parse()  to interrogate the Document object representing the RSS news information.
Next, you will create an HTML page that will list the channel tile and the number of total news.
After creating the HTML to display the RSS channel title and number of articles, you will iterate over all the news headlines to build record sets or rows.
Each row will contain an HTML button labeled View to notify the WebEngine object of an alert containing the URL of the article.
When the WebEngine object is notified, the OnAlert property will contain an event handler to render the entire article in the frame in the lower-right split region.
As a convenience, the saveRssFeed() method will check for duplicates and not save them.
The following code loads the web page to be rendered and saves the newly added rssFeed URL:
As in the previous recipes, you will be responding to HTML WebEvents when the new headline View button is pressed, which calls a JavaScript’s alert() function.
Shown following is the code snippet to handle a web event (WebEvent) containing a string of the URL that links to the entire article to be viewed in the frame to the lower right region:
When creating the headlines region (upper right) containing HTML buttons to render the article’s.
Shown following is an example of HTML generated for an headline news containing a View button that can notify the web engine’s OnAlert web event (WebEvent)
One last thing to point out is that the RSS application has missing features.
One feature that comes to my mind is the ability to delete individual RSS hyperlinks on the left column region.
A workaround is to remove all links by deleting the database on the file system.
Because Derby is an embedded database, you can delete the directory containing the database.
The JavaFX RSS application will re-create an empty database if one doesn’t exist.
Hopefully, you can add new features to enhance this fun and useful application.
Using this API you can send e-mail communications in response to an event (say a completed form or a finalized script)
You can also use the Email API to check an IMAP or POP3 mailbox.
In all, sending and receiving e-mail using the Email API has become pretty straightforward.
For the recipes in this chapter, please make sure that you have set up your firewall to allow e-mail communication; most of the time, firewalls will allow outbound communications to e-mail servers without an issue, but if you are running your own local SMTP (e-mail) server, you may need to configure your firewall to allow the e-mail server to operate correctly.
Note If you are using the J2EE JDK, the JavaMail API is included as part of the EE download.
If you are using the J2SE, you will need to download and install the JavaMail API.
Problem You want to install JavaMail for use by your application in sending e-mail notifications.
Once downloaded, unzip and add the JavaMail .jar files as dependencies from your project (both mail.jar and lib\*.jar)
By downloading and adding the dependencies, you get access to the robust Email API that allows you to send and receive e-mails.
Solution Using the Transport() methods, you can send an e-mail to specific recipients.
How It Works The JavaMail API starts by creating a Properties object that works as a standard Map object (in fact, it inherits from it), in which you put the different properties that might be needed by the JavaMail service.
When creating a Session, you can specify the login information if the service requires authentication.
This might be necessary when connecting to an SMTP service that is outside of your local area network.
The Message object represents an actual e-mail message and exposes e-mail properties such as From/To/Subject and Content properties.
After setting these properties, you call the Transport.send() static method to send the e-mail message.
Problem You need to attach a file to an e-mail message.
Solution Creating a message that contains different parts (a multipart message) is what allows you to send attachments such as files and images.
You can specify the body of the e-mail message and also specify an attachment.
Messages that contain different parts are referred to as Multipurpose Internet Mail Extensions (MIME) messages.
They are represented in the javax.mail API by the MimeMessage class.
This type of Message allows it to have different body parts.
In the example, you create a plain text part (which contains the text that the e-mail displays), and an attachment part, which holds the attachment you are trying to send.
Depending on the type of attachment, the Java API will choose an appropriate encoding for the attachment part.
Once these two parts are created, they are combined by creating a MultiPart object, and adding each individual part (the plain text and the attachment) to it.
Once the MultiPart object has all the parts, it is assigned as the content of the MimeMessage and sent (just like recipe 21-2)
Problem You want to send the same e-mail to multiple recipients.
Solution Use the setRecipients() method from the Mail API to send e-mail to multiple recipients.
The setRecipients() method allows for specifying more than one recipient at a time.
How It Works By using the setRecipients() method of the Message object, you can specify multiple recipients on the same message.
In this recipe, because you have a collection of Strings, you create the array as the size of the collection and create InternetAddress objects to fill the array with.
Sending e-mails using multiple e-mail addresses (as opposed to individual e-mails) is much more efficient because only one message is sent from your client to the target mail servers.
Each target mail server will then deliver to all recipients that it has mailboxes for.
For example, if sending to five different yahoo.com accounts, the yahoo.com mail server will only need to receive one copy of the message and it will deliver it to all the yahoo.com recipients specified in the message.
Tip  If you want to send bulk messages, you might want to specify the Recipient Type as BCC, so that the e-mail received doesn’t show everyone else that might have gotten the e-mail.
Problem You need to check if a new e-mail has arrived in an e-mail account.
For example, the following code connects to an IMAP account, retrieves the last five messages from that IMAP account, and marks those five messages as “read”
How It Works A Store object allows you to access e-mail mailbox information.
By creating a store and then requesting the “Inbox” folder, you have access to the messages in the main mailbox of your IMAP account.
With the folder object, you can request to download the messages from the inbox.
To do so, you use the getMessages (start, end) method.
The inbox also provides a getMessageCount() method, which allows you to know how many e-mails are in the inbox.
By parsing the SEEN flag, you can then process messages that haven’t been seen before.
This method allows you to set (or reset) e-mail flags.
Problem You want to monitor when e-mails arrive at a certain account and want to process them depending on their content.
Then add IMAP flag manipulation to create a robust e-mail monitor for your application.
The following example checks the subject of new messages and deals with them appropriately.
The example uses message flags to delete processed messages so they need not be read twice.
Messages that can’t be processed are marked as read but left in the server for troubleshooting by a human.
How It Works After connecting to the IMAP server, the example requests all messages received.
The code skips over the ones that are marked as SEEN.
To do so, the recipe uses the Arrays.AsList to convert the array of system message flags into an ArrayList.
Once the list is created, it is a matter of querying the list to see whether it contains the Flag.SEEN enum value.
If it’s present, the recipe skips to the next item.
When a message is found that has not been read, the message is then processed by the processMessage() method.
After determining the command to execute, the code proceeds to extract the sender’s e-mail from the message.
These Address objects are generic because the Address object can represent Internet or newsgroup addresses.
After checking that the Address object is indeed an InternetAddress, you cast the Address object as InternetAddress and call the getAddress() method, which contains the actual e-mail address.
However, in Java 7, you will find that the Java API for XML Processing (JAXP), Java API for XML Binding (JAXB), and even the Java API for XML Web Services (JAXWS) have been included in the core runtime libraries.
Please see the introductory chapters for instructions on how to find and download this book’s sample source code.
You want to create an XML document to store application data.
The following code iterates over an array of Patient objects and writes their data to an .xml file.
The newer, simpler, and more efficient model is the Streaming API for XML (StAX)
You can use a try-block to open and close this stream.
Once you have the writer, wrap the file stream object within the XML writer instance.
You will use the various write methods to create the XML document elements and attributes.
Finally, simply close the writer when you finish writing to the file.
Some of the more useful methods of the XMLStreamWriter instance are these:
You have the responsibility to call these in proper sequence to create well-formed documents.
Use the writeAttribute() method to place an attribute name and value into the current element.
Finally, signal the end of the document with the writeEndDocument() method and close the Writer instance.
One interesting point of using the XMLStreamWriter is that it does not format the document output.
Unless you specifically use the writeCharacters() method to output space and new-line characters, the output will stream to a single unformatted line.
Of course, this doesn’t invalidate the resulting XML file, but it does make it inconvenient and difficult for a human to read.
Therefore, you should consider using the writeCharacters() method to output spacing and new-line characters as needed to create a human readable document.
You can safely ignore this method of writing additional whitespace and line breaks if you do not need a document for human readability.
Regardless of the format, the XML document will be well formed in that it is adheres to correct XML syntax.
The command-line usage pattern for this example code is this:
Invoke this application to create a file named patients.xml in the following way:
You need to parse an XML document, retrieving known elements and attributes.
Using this API, your code will pull XML elements using a cursor-like interface similar to that in SQL to process each element in turn.
Use the XMLEventReader to read and process events using an event-oriented interface.
The following code is much like that of Solution 1, except that it uses the event-oriented API instead of the cursor-oriented API.
It is better than the older SAX API in that it allows you to both read and write XML documents.
Although StAX is not quite as powerful as a DOM API, it is an excellent and efficient API that is less taxing on memory resources.
StAX provides two methods for reading XML documents: a cursor-oriented API and an iteratorbased, event-oriented API.
The event-oriented, iterator API is preferred over the cursor API at this time because it provides XMLEvent objects with the following benefits:
The XMLEvent objects are immutable and can persist even though the StAX parser has moved on to subsequent events.
You can pass these XMLEvent objects to other processes or store them in lists, arrays, and maps.
You can subclass XMLEvent, creating your own specialized events as needed.
You can modify the incoming event stream by adding or removing events, which is more flexible than the cursor API.
To use StAX to read documents, create an XML event reader on your file input stream.
Check that events are still available with the hasNext() method, and read each event using the nextEvent() method.
The nextEvent() method will return a specific type of XMLEvent, which corresponds to the start and stop elements, attributes, and value data in the XML file.
Remember to close your readers and file streams when finished with those objects.
You can invoke the example application like this, using the patients.xml file as your <xmlFile> argument:
You want to convert an XML document to another format, for example HTML.
The following code demonstrates how to read a source document, apply an Extensible Stylesheet.
Language (XSL) transform file, and produce the transformed, new document.
The following snippet shows the important pieces of this class:
The most common use case is to convert data-oriented XML documents to user-readable HTML documents.
Transforming from one document type to another requires three files:
An XSL transformation document that maps XML elements to your new document elements.
The XML source document is, of course, your source data file.
It will most often contain dataoriented content that is easy to parse programmatically.
However, people don’t easily read XML files, especially complex, data-rich files.
Instead, people are much more comfortable reading properly rendered HTML documents.
The XSL transformation document specifies how an XML document should be transformed into a different format.
An XSL file will usually contain an HTML template that specifies dynamic fields that will hold the extracted contents of a source XML file.
In this example’s source code, you’ll find two source documents:
Patient identifier, provided as the id attribute of the patient element.
The transformation XSL document (patients.xsl) is quite small as well, and it simply maps the patient data to a more user-readable, HTML format using XSL:
Using this stylesheet, the sample code transforms the XMLinto an HTML table containing all the patients and their data.
Rendered in a browser, the HTML table should look like the one in Figure 22-1
The process for using this XSL file to convert the XML file to an HTML file is straightforward, but every step can be enhanced with additional error checking and processing.
For this example, refer to the previous code in the solution section.
Read the XSL document into your Java application as a Source object.
Create a Transformer instance and provide your XSL Source instance for it to use during its operation.
Create a StreamResult instance for your output document, which is an HTML file in this case.
Use the Transformer object’s transform() method to perform the conversion.
Close all the relevant streams and file instances as needed.
If you choose to execute the sample code, you should invoke it in the following way, using patients.xml, patients.xsl, and patients.html as arguments:
You want to confirm that your XML is valid, conforming to a known document definition or schema.
The most common schemas that you will use for XML validation are defined as constant URIs within the XMLConstants class:
Begin by creating a SchemaFactory for a specific type of schema definition.
A SchemaFactory knows how to parse a particular schema type and prepares it for validation.
The Schema object is an in-memory representation of the schema definition grammar.
You can use the Schema instance to retrieve a Validator instance that understands this grammar.
The method call will generate several different exceptions if anything goes wrong during the validation.
Otherwise, the validate() method returns quietly, and you can continue to use the XML file.
You would like to generate a set of Java classes (Java bindings) that represent the objects within an XML schema.
The JDK provides a tool that can turn schema documents into representative Java class files.
Use the <JDK_HOME>/bin/xjc command-line tool to generate Java bindings for your XML schemas.
To create the Java classes for the patients.xsd file from section 22-3, you could issue the following command from within a console:
This command will process the patients.xsd file and create all the classes needed to process an XML file that validates with this schema.
For this example, the patients.xsd file looks like the following:
The xjc utility is a command-line application that creates Java bindings from schema files.
The source schema files can be of several types, including XML Schemas, RELAX NG, and others.
The xjc command has several options for performing its work.
Some of the most common options specify the source schema file, the package of the generated Java binding files, and the output directory that will receive the Java binding files.
You can get detailed descriptions of all the command line options by using the tools’ –help option:
A Java binding contains annotated fields that correspond to the fields defined in the XML Schema file.
These annotations mark the root element of the schema file and all other subelements.
This is useful during the next step of XML processing, which is either unmarshalling or marshalling these bindings.
You want to unmarshall an XML file and create its corresponding Java object tree.
Note The previous output comes directly from instances of the Java Patient class that was created from XML representations.
The code does not print the contents of the XML file directly.
Instead, it is printing the contents of the Java bindings after the XML has been marshalled into appropriate Java binding instances.
Unmarshalling an XML file into its Java object representation has at least two criteria:
The Java bindings don’t have to be autogenerated from the xjc command.
Once you’ve gained some experience with Java bindings and the annotation features, you may prefer to create and control all aspects of Java binding by handcrafting your Java bindings.
Whatever your preference, Java’s unmarshalling service utilizes the bindings and their annotations to map XML objects to a target Java object and to map XML elements to target object fields.
You need to write an object’s data to an XML representation.
Assuming you have created Java binding files for your XML schema as described in recipe 22-4, use a JAXBContext instance to create a Marshaller object.
Use the Marshaller object to serialize your Java object tree to an XML document.
The previous code produces an unformatted but well-formed and valid XML document.
Note The getPatient() method in the previous code returns a List of Patient objects instead of a single patient.
This is a naming oddity of the JAXB code generation from the XSD schema in this example.
As it processes classes, it uses the JAXB annotations to provide it the context it needs for creating the object tree in XML.
The context argument refers to the package of the Java classes that you will marshal.
In the previous example, because the code marshals a Patients object tree, the correct context is the package name of the Patients class.
Today, writing an application that does not communicate over the Internet in some fashion is rare.
From sending data to another machine, to scraping information off remote web pages, networking plays an integral part in today’s computing world.
Java makes it easy to communicate over the network using the New I/O (NIO) and More New I/O Features for the Java Platform (NIO.2) APIs.
Java SE 7 brought forth a few new features, enabling easier multicasting among other things.
With the addition of these new features, the Java platform contains a plethora of programming interfaces to help accomplish network tasks.
This chapter will not attempt to cover every networking feature that is part of the Java language.
It will only provide a handful of recipes that were thought to be the most useful for a broad base of developers.
If you find this chapter interesting and would like to learn more about Java networking, a vast amount of resources can be found online.
Perhaps the best place to go for learning more about it is the Oracle documentation that can be found at http://download.oracle.com/javase/tutorial/networking/index.html.
Problem You need to establish a connection to a remote server.
Solution Create a Socket connection to the remote server using its name and port number where the server is listening for incoming client requests.
In the following example class, a Socket connection to a remote server is created.
The code then sends a textual message to the server and receives a response.
Tip To create a connection to a local program running on the client machine, set the “server-name” equal to "127.0.0.1"
This is done within the source listing for this recipe.
Usually local connections such as this are used for testing purposes only.
If testing this client against a server that successfully accepts the request, you will see the following result:
To create a server-side socket application that will accept this connection for a complete test, please see recipe 23-2
How It Works Every client/server connection occurs via a socket, which is an endpoint in a communication link between two different programs.
Sockets have port numbers assigned to them, which act as an identifier for the Transmission Control Protocol/Internet Protocol (TCP/IP) layer to use when attempting a connection.
A server program that accepts requests from client machines typically listens for new connections on a specified port number.
When a client wishes to make a request to the server, it creates a new socket utilizing the hostname of the server and the port on which the server is listening and attempts to establish a connection with that socket.
If the server accepts the socket, then the connection is successful.
This recipe discusses the client side of the socket connection, so we will not go into the details of what happens on the server side at this time.
However, more information regarding the server side of a connection will be covered in recipe 23-2
The example class in the solution to this recipe is representative of how a client-side program attempts and establishes connections to a server-side program.
In this recipe, a method named createConnection() is used to perform the actual connection.
It accepts a server hostname and port number, which will be used to create the socket.
Within the createConnection() method, the server hostname and port number are passed to the Socket class constructor, creating a new Socket object.
Next, a PrintWriter object is created using the Socket object’s output stream, and a BufferedReader object is created using the Socket object’s input stream.
After creating the socket and obtaining the socket’s output stream and input stream, the client can write to the PrintWriter in order to send data to the server.
Similarly, to receive a response from the server, the client reads from the BufferedReader object that was created.
The testConnection() method is used to simulate a conversation between the client and the server program using the newly created socket.
To do this, the socket, in, and out variables are checked to ensure that they are not equal to null.
A loop is then created to listen for a response from the server by calling the in.readLine() method until nothing else is received and printing out the messages that are received.
It abstracts the details of each platform from the developer, and provides a straightforward and consistent implementation for enabling client/server communications.
Problem You would like to create a server application that will listen for connections from a remote client.
When a request is received, the incoming message is printed to the command line and a response is sent back to the client.
Executing this program along with the client that was built in recipe 23-1 would result in the following output from the SocketServer:
Note To run the two recipes so that they work with each other, first start the SocketServer program so that the client can create a socket using the port that is opened in the server program.
After the SocketServer is started, initiate the SocketClient program to see the two work together.
Caution This SocketServer program opens a port on your machine (1234)
Be sure that you have a firewall set running on your machine, otherwise you will be opening port 1234 to everyone.
Open ports create vulnerabilities for attackers to break into machines, like leaving a door in your house open.
Note that the example in this recipe has a minimal attack profile because the server is run through only one pass and will print only a single message from the client before the session is closed.
How It Works In order for a client application to connect to a server application, the server application must be listening for connections and then processing them somehow.
You cannot simply run a client against any given host and port number combination because doing so would likely result in a refused connection.
The server-side application must do three things: open a port, accept and establish client connections, and then communicate with the client connections in some way.
In the solution to this recipe, the SocketServer class does all three of them.
This is done by creating a new instance of ServerSocket and passing a port number to it.
The port number used must not conflict with any other port that is currently in use on the server.
It is important to note that ports below 1024 are usually reserved for operating system usage, so port numbers should be chosen above that range.
If you attempt to open up a port that is already in use, the ServerSocket will not successfully be created, and the program will fail.
Next, the ServerSocket object’s accept() method is called, returning a new Socket object.
Calling the accept() method will do nothing until a client attempts to connect to the server program on the port that has been set up.
The accept() method will wait idly until a connection is requested and then it will return the new Socket object bound to the port that was set up on the ServerSocket.
This socket also contains the remote port and hostname of the client attempting the connection, so it contains the information on two endpoints and uniquely identifies the TCP connection.
At this point, the server program can communicate with the client program, and it does so using the PrintWriter and BufferedReader objects.
A new BufferedReader object can be created by generating a new InputStreamReader instance using the socket’s input stream.
Similarly, a new PrintWriter object can be created using the socket’s output stream.
Notice that this code must be wrapped in a try-catch block in case the creation of these objects is not successful.
Once these objects have been successfully created, the server can communicate with the client.
To do so, a loop is created, reading from the BufferedReader object (the client input stream), and then sending messages back to the client using the PrintWriter object.
In the solution to this recipe, the server closes the connection by issuing a break, which causes the loop to end and control returns to the main() method.
In a real-life server program, the server would most likely listen endlessly without using a break to end communication.
To handle multiple concurrent clients, each client connection would spawn a separate Thread to handle communication.
The server would do something useful with the client communication as well.
In the case of an HTML server, it would send back an HTML message to the client.
On an SMTP server, the client would send an e-mail message to the server, and the server would then process the e-mail and send it.
Socket communication is used for just about any TCP transmission, and both the client and servers create new sockets to perform a successful communication.
Problem Your application deployed on Linux or Solaris requires the ability to move data very quickly and efficiently, and you need to remove all bottlenecks that could slow things down.
Solution Make use of the Sockets Direct Protocol (SDP) to bypass TCP, a possible bottleneck in the process.
In order to do so, create an SDP configuration file and set the system property to specify the configuration file location.
Note The SDP was added to the Java SE 7 Release for applications deployed in the Solaris or Linux operating systems only.
This configuration file is an example of one that could be used to enable the use of SDP:
It is the execution of a Java application named SDPExample, specifying the SDP system property:
How It Works Sometimes it is essential that an application be as fast as possible while performing network communications.
Transfers over the TCP protocol can sometimes decrease performance, so bypassing TCP could be beneficial.
In JDK 7, support for the SDP is included for certain platforms.
The SDP is a protocol that supports stream connections over InfiniBand fabric.
Both Solaris and Linux include support for InfiniBand, so SDP can be useful on those platforms.
No programmatic changes need to be made to an application in order to support SDP.
The only two differences for using SDP are that you must create an SDP configuration file, and the JVM must be told to use the protocol by passing a flag when running the application.
Because the implementation is transparent, applications can be written for any platform, and those that support SDP can merely include the configuration file and bypass TCP.
The SDP configuration file is a text file that is composed of bind and connect rules.
A bind rule indicates that the SDP protocol transport should be used when a TCP socket binds to an address and port that match the given rule.
A connect rule indicates that the SDP protocol transport should be used when an unbound TCP socket attempts to connect to an address and port that match the given rule.The rule begins with either the bind or connect keyword indicating the rule type, followed by the hostname or IP address, and a single port number or range of port numbers.
Per the online documentation, a rule has the following form:
In the rule format shown here, 1*LWSP-char means that any number of tabs or spaces can separate the tokens.
Anything contained within square brackets indicates optional text, and quotes indicate literal text.
Each local address that is assigned to an InfiniBand adaptor should be specified with a bind rule within the configuration file.
This rule uses some special syntax that should be noted.
Although the SDP is only available under Solaris or Linux, it is a nice addition to the JDK for users of those platforms.
Any performance booster is always viewed as a bonus, and the solution to this recipe certainly falls into that category.
Problem You would like to broadcast datagrams to zero or more hosts identified by a single address.
Solution Make use of datagram multicasting using the DatagramChannel class.
The DatagramChannel class provides the ability for more than one client to connect to a group and listen for datagrams that have been broadcasted from a server.
The following sets of code demonstrate this technique using a client/server approach.
Note The following code may not function as expected using the OpenJDK platform on OS X.
Next, a server class can be used to broadcast datagrams to the address that multicast clients are connected to.
The server will have the ability to broadcast a message to each client that is a member of the group.
How It Works Multicasting is the ability to broadcast a message to a group of listeners in a single transmission.
Thousands of people can tune into a single broadcast event and listen to the same message.
Computers can do similar things when sending messages to listeners.
A group of client machines can tune into the same address and port number to receive a message that a server broadcasts to that address and port.
Datagrams are independent, nonguaranteed messages that can be delivered over the network to clients.
Being nonguaranteed means that the arrival, arrival time, and content are not predictable.
Unlike messages sent over TCP, sending a datagram is a nonblocking event, and the sender is not notified of the receipt of the message.
The ability to send multicast messages via UDP is one benefit over TCP, as long as the ordering, reliability, and data integrity of the message are not mission critical.
Classes that implement the MulticastChannel interface have multicasting enabled and can therefore broadcast to groups and receive group broadcasts.
One such class is the DatagramChannel, which is a selectable channel for datagram-oriented sockets.
In the solution to this recipe, both a client and a server program are used to communicate via multicast messaging, and the DatagramChannel class is used in both sides of the communication.
A DatagramChannel must be configured in a specific way if it is to be used for accepting multicast messages.
Specifically, there are options that need to be set on the DatagramClient that is opened.
The following steps are required for creating a client for receiving multicast messages.
Join the client to a multicast group and return a MembershipKey object.
In the solution to this recipe, the client application begins by obtaining a reference to the network interface that will be used for receiving the broadcast messages.
Next, a port number is chosen, as well as a multicasting IP address.
The group or registered listeners will use the IP address in order to listen for broadcasts.
The port number must not be in use, or an exception will be thrown.
This port and IP address will be the same that is used by a server to broadcast the message.
This indicates that multiple clients will be able to “reuse” the address or use it at the same time.
This needs to be set for a multicast to occur.
The client is then bound to the port using a new InetSocketAddress instance.
Change the code accordingly, depending upon which platform you are using.
Once these options have been set, and the port has been bound to the DatagramChannel, it is ready to join the group of listeners.
At this point, the client is ready to receive multicast messages and it waits for a message to be received.
The next lines of code within the client take care of receiving messages from the server.
In order to receive a broadcasted message, a ByteBuffer is created and then eventually passed to the DatagramChannel’s receive() method.
Once the receive() method is called, the client will pause until a message is received.
Note In the example to this recipe, a single pass is performed, and the client is then disconnected.
For extended listening, a loop with a timeout configured and tests for an ending state would be required.
This means that this server application could be run in a thread separate from other code within an application.
If there were another class that initiated the MulticastServer class’ run() method, it would run in a thread separate from the class that initiated it.
The run() method must exist within any class that extends Thread.
The bulk of the server code resides within the run() method.
A new InetAddress object is created using the same IP address that the client registered with in order to join the multicast group.
The same port number is also declared within the server code, and these two objects will be used later in the code block to send the message.
At this point, the client would receive the message that was sent by the server.
As for the client that is demonstrated in the solution to this recipe, it would then disconnect.
Normally in a real-world scenario, a different class would most likely initiate the server, and its run() method would contain a loop that would continue to execute until all messages have been broadcast or the loop was told to stop.
The client would probably not disconnect until after a user initiated a shutdown.
Problem You would like to generate URLs programmatically within your application.
Once the URLs have been created, you’d like to read data from them for use within your application.
Solution Make use of the java.net.URL class in order to create a URL.
There are a few different ways to generate a URL depending upon the address you are attempting to work with.
This solution demonstrates a few different ways to create URL objects, along with comments indicating the differences.
Once the URL objects have been created, one of the URLs is read into a BufferedReader and printed out to the command line.
Running this program will result in the printing of HTML from the URL resource identified as url1 to the command line.
How It Works The creation of URLs within Java code is fairly straightforward thanks to the java.net.URL class, which does all of the heavy lifting for you.
A URL is a character string that points to a resource on the Internet.
Sometimes it is useful to create URLs within Java code so that you can read content from, or push content to, the Internet resource that the URL is pointing to.
In the solution to this recipe, a few different URL objects are created, demonstrating the different constructors that are available for use.
The easiest route to use for creating a URL is to pass the standard readable URL String for a resource that is located on the Internet to the java.net.URL class to create a new instance of the URL.
In the solution, an absolute URL is passed to the constructor to create the url1 object.
Another useful way to create a URL is to pass two arguments to the URL constructor and create a relative URL.
Relative URLs are useful for basing upon the context of another URL.
Such is the case with the url2 object in the solution to this recipe.
There are a couple more constructors for creating URL objects that take more than two arguments.
In the solution, the second of the two constructors shown here is demonstrated.
The protocol, hostname, and path of the resource are passed to the constructor to create the url3 object.
These last two constructors are usually most useful when generating a URL dynamically.
Problem You would like to programmatically gather information from a URL within your application.
Solution Parse the URL using the built-in URL class methods.
In the following example class named ParseUrl, a URL object is created and then parsed using the built-in URL class methods to gather information regarding the URL.
After the information has been retrieved from the URL, it is printed to the command line and then used to create another URL.
When this code is executed, the following lines will be displayed:
How It Works When constructing and working with URLs within an application, it is sometimes beneficial to have the ability to extract information pertaining to a URL.
This can be easily done using the URL built-in class methods that can be called upon a given URL to return Strings of information.
Table 23-1 shows the different accessor methods available within the URL class for obtaining information.
Each of these accessor methods returns a String value that can be used for informational purposes.
If you take a look at the results from the solution to this recipe, you can see the information that was obtained regarding the URL via the accessor methods listed in Table 23-1
The getFile() method returns the file name of the URL.
The file name is the same as the result of concatenating the value returned from getPath() with the value returned from getQuery()
The reference component that is returned by calling the getRef() method refers to the “fragment” that may be appended to the end of a URL.
For instance, a “fragment” is indicated using the pound character (#), followed by a String that usually corresponds to a subsection on a particular web page.
Given the URL such as the following, recipe23_7 is what would be returned using the getRef() method.
Although not always needed, the ability to parse a URL to obtain information can come in very handy at times.
Because the Java language has helper methods built into the java.net.URL class, it makes gathering information pertaining to URLs a piece of cake.
All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed.
Exempted from this legal reservation are brief excerpts in connection with reviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work.
Duplication of this publication or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher's location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center.
Violations are liable to prosecution under the respective Copyright Law.
Trademarked names, logos, and images may appear in this book.
Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights.
While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made.
The publisher makes no warranty, express or implied, with respect to the material contained herein.
Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use.
Any source code or other supplementary materials referenced by the author in this text is available to readers at www.apress.com.
For detailed information about how to locate your book’s source code, go to http://www.apress.com/source-code/
This book is dedicated to the members of the Java community.
The Java platform would not be what it is today without the continued support and contributions from everyone in the community.
Josh Juneau has been developing software and database systems for several years.
Database application programming has been the focus of his career since the beginning.
He became an Oracle database administrator and adopted the PL/SQL language for performing administrative tasks and developing applications for Oracle database.
As Josh’s skills evolved, he began to incorporate Java into his PL/SQL applications and later began to develop standalone applications in Java.
He has extended his knowledge of the JVM by learning and developing applications with other JVM.
His interest in learning new languages that run on the JVM led to his interest in Jython.
Since 2006, Josh has been the editor and publisher for the Jython Monthly newsletter.
In late 2008, he began a podcast dedicated to the Jython programming language.
He works as an application developer and database administrator at Fermi National Accelerator Laboratory, and is the lead for the Django-Jython project (http://code.google.com/p/django-jython/)
Josh has a wonderful wife and four great children with whom he loves to spend time and teach about technology.
To hear more from Josh, follow his blog, which can be found at http://jjblogger.blogspot.com.
Dea is currently a software engineer working for BCT-LLC on projects with high performance computing (HPC) architectures.
He has written software ranging from mission-critical applications to web applications.
Carl has been using Java since the very beginning and he also is a huge JavaFX enthusiast, dating back to when it was called F3
His passion for software development started when his middle school science teacher showed him the TRS-80 computer.
Carl's current software development interests include rich client applications, game programming, Arduino, mobile phones, and tablet computers.
When he's not working, he and his wife love to watch their daughters perform at gymnastics meets.
Freddy Guime has been in the software industry for more than 12 years.
He has been working with Javafor more than 5 years and is a regular speaker at the JavaOne conference.
Freddy currently works for an options trading software company in Chicago, in which sub-millisecond response time in response to market events is paramount.
With his experience in multithreading and Java Swing he has managed to create Java clients that can consume tens of thousands of market events per second.
John O'Conner is a husband, father, and sleep-deprived technology enthusiast.
Currently the globalization architect at Adobe Systems, John uses a variety of technologies, strategies, and best practices to ensure that Adobe's Creative Media and Marketing products meet the demands of a global customer base.
The common thread running through John’s career is his interest in creating globalized, world-ready software platforms.
Mark Beaty has been developing in Java since 1998 when he went to work for Sun Microsystems.
During his years at Sun, Mark helped to develop and evolve Sun's web presence, in various roles ranging from architect to developer.
As a web application developer, Mark has spent a lot of time developing large-scale, multitiered web applications on the server side, but he also enjoys developing rich client applications in the browser.
Prior to becoming a Java developer, Mark worked as a software engineer in the defense industry, using a little-known programming language called Ada.
During his 10+ years in the defense industry, Mark had a huge amount of fun developing real-time embedded software for military training systems and flight simulators.
Mark is currently an independent software consultant focusing on developing mobile web and native applications on Android and iOS.
Mark lives in Colorado, where he enjoys cycling, hiking, skiing, and pretty much anything that involves being outdoors.
For more than 30 years, David's expertise has been in multiplatform network integration and systems programming.
Before coming to the Savannah River Site, he worked for several defense contractors and served as the technical lead for office and network computing at the National Aerospace Plane Joint Program Office at Wright-Patterson Air Force Base in Ohio.
As a perpetual student, David has one master's degree and many hours toward another.
Coffin is a triathlete and distance swimmer who competes in the middle of the pack.
He is also a classical guitar player, but he's not quitting his day job.
To my wife Angela: you have provided me with the love and support that I need to be successful in my career.
Thanks for being there for me always and talking to me about technology even though I know it bores you.
You have always been, and will continue to be, my inspiration for success.
I am so happy raising our children together; I hope they will turn out to be as kind and loving as you are.
To my children Kaitlyn, Jacob, Matthew, and Zachary: please stop growing up! I love you all so much and enjoy having such wonderful children.
We will read through this book together one day, and you, too, can learn the joy of developing successful software.
For now, I will enjoy all the time we have together as you continue to grow and learn more each day.
I want to thank my family for their continued support in my career.
You have always listened to my lectures on technology and programming, and I appreciate that.
I want to thank my co-workers at Fermilab for allowing me to guide the organization’s application development efforts and build successful solutions to keep us moving forward.
To my co-authors Carl Dea, Freddy Guime, John O’Conner, and Mark Beaty: you are excellent authors and experts in Java technology and I am honored to have had the opportunity to work with each of you.
I thank you all for working together to produce this excellent book; it would not have been possible without you.
To the folks at Apress, I thank you for providing me with the chance to share my knowledge with others.
I especially thank Jonathan Gennick for the continued support of my work and for providing the guidance to produce useful content for our readers.
You’ve become a good friend over the last couple of years and I really enjoy working with you.
I thank Annie Beck and Anita Castro for the ability to coordinate the efforts of each author who contributed to this book; you have both done an outstanding job.
I also would like to thank Steve Anglin for believing in my abilities to author books on the Java technology for Apress.
The technical reviewers, David Coffin and Mark Beaty, have done an excellent job of solidifying the book content.
Lastly, I’d like to thank everyone else at Apress who had a hand in this book.
To the Java community, I thank you all for helping the JVM to become a successful development platform.
We all have the privilege of working with a mature and robust platform, and it would not be successful today if it weren’t for everyone’s continued contributions to the technology.
I also thank all the Oracle Java experts: you hit a home run with Java 7 and the roadmap for the future is looking great.
I am looking forward to using Java technology for many years to come.
I would like to thank my wife,Tracey, and my daughters, Caitlin and Gillian, for their loving support and sacrifices.
A special thanks to my daughter Caitlin, who helped with illustrations and brainstorming fun examples.
A big thanks to Jim Weaver for recommending me for this project and being so encouraging.
I would also thank Josh Juneau for his leadership and guidance throughout this journey.
I also want to thank my co-authors, John O'Conner, Freddy Guime, and Mark Beaty for their excellent advice.
Thanks also to David Coffin for his uncanny ability to know my intentions and providing great feedback.
I want to thank the wonderful people at Apress for their professionalism.
Thanks to Annie Beck and Anita Castro for keeping me on track when things got rough.
Thanks to all who follow me on Twitter, especially the ones who relate to Java Swing and JavaFX.
Dedicated to the love of my life (and wife) Gabriela; my three awesome children Jolie, Natalie and Max; and my mom Julia and dad Alberto.
Thanks to my supportive, patient, and loving wife Robyn; and our five children Jackson, Nicholas, Matthew, Tressa, and Ruby.
