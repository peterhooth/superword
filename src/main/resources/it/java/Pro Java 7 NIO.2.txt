It covers the three primary elements that offer new input/output (I/O) APIs in Java 7, showing you how to:
Use the extensive file I/O API system that developers have long sought.
Work with the socket channel API to carry out multicasting and socket binding associated with channels.
Enhance scalability with the asynchronous I/O API: map to I/O facilities, completion ports, and various I/O event port mechanisms.
Each chapter contains extensive code examples that show the power and elegance of NIO.2, giving you the knowledge to apply the latest and greatest techniques in your own code.
For your convenience Apress has placed some of the front matter material after the index.
This class is a milestone of NIO.2, and every application that involves I/O operations will exploit the powerful facilities of this class.
Practically, it is the most commonly used class of NIO.2, since many I/O operations are based on a Path resource.
The Path class supports two types of operations: syntactic operations (almost any operation that involves manipulating paths without accessing the file system; these are logical manipulations done in memory) and operations over files referenced by paths.
This chapter covers the first type of operations and introduces you to the Path API.
In Chapter 4, I focus on  exploring the second type of operations.
The concepts presented in this chapter will be very useful in the rest of the book.
FileSystems contains the following two important methods, as well as a set of newFileSystem() methods, for constructing new file systems:
NIO.2 provides us with all file system functionalities that we may need to perform over a file, a directory, or a link.
The Path class is an upgraded version of the well-known java.io.File class, but the File class has kept a few specific operations, so it is not deprecated and cannot be considered obsolete.
Moreover, starting with Java 7, both classes are available, which means programmers can mix their powers to obtain the best of I/O APIs.
Java 7 provides a simple API for conversion between them.
Remember the days when you had to do the following?
Well, those days are gone, because with Java 7 you can do this:
At a closer look, a Path is a programmatic representation of a path in the file system.
The path string contains the file name, the directory list, and the OS-dependent file delimiter (e.g., backslash “\” on Microsoft Windows and forward slash “/” on Solaris and Linux), which means that a Path is not system independent since it is based on a system-dependent string path.
Because Path is basically a string, the referenced resource might not exist.
Defining a Path Once you identify the file system and the location of a file or directory, you can create a Path object for it.
Absolute paths, relative paths, paths defined with the notation “.” (indicates the current directory) or “..” (indicates the parent directory), and paths containing only a file/directory name are covered by the Path class.
The simplest solution for defining a Path is to call one of the get() methods of the Paths helper class.
Define an Absolute Path An absolute path (also known as a full path or file path) is a path that contains the root directory and all other subdirectories that contain a file or folder.
Note that if you define a chunk for each component of the path, you can omit the file separator delimiter.
Define a Path Relative to the File Store Root A relative path (also known as a nonabsolute path or partial path) is only a portion of the full path.
A relative path is often used in creating a web page.
Relative paths are used much more frequently than absolute paths.
Defining a path relative to the current file store root should start with the file delimiter.
Define a Path Relative to the Working Folder When you define a path relative to the current working folder, the path should not start with the file delimiter.
Define a Path Using Shortcuts Defining paths using the notation “.” (indicates the current directory) or “..” (indicates the parent directory) is a common practice.
These kinds of paths can be processed by NIO.2 to eliminate possible cases of redundancy if you call the Path.normalize() method (which removes any redundant elements, including any “.” or “directory/..” occurrences):
If you want to see the effect of the normalize() method, try to define the same Path with and without normalize(), as follows, and print the result to the console:
Define a Path from a URI In some cases, you may need to create a Path from a Uniform Resource Identifier (URI)
You can do so by using the URI.create() method to create a URI from a given string and by using the Paths.get() method that takes a URI object as an argument.
This is useful if you need to encapsulate a path string that can be entered into the address bar of a web browser:
Then, you can call the getPath() method as follows (the Paths.get() method in the preceding examples is just shorthand for this solution):
Get the Path of the Home Directory When you need a path that points to the home directory, you can proceed as shown in the following.
Getting Information About a Path After you have defined a Path object, you have access to a set of methods that provide useful information about the path elements.
Get the Path File/Directory Name The file/directory indicated by a path is returned by the getFileName() method, which is the farthest element from the root in the directory hierarchy:
Get the Path Root The root of the path can be obtained with the getRoot() method (if the Path does not have a root, it returns null):
Get the Path Parent The parent of this path (the path’s root component) is returned by the getParent() method (if the Path does not have a parent, it returns null):
Get Path Name Elements You can get the number of elements in a path with the getNameCount() method and get the name of each element with the getName() method:
Get a Path Subpath You can extract a relative path with the subpath() method, which gets two parameters, the start index and the end index, representing the subsequence of elements:
Converting a Path In this section, you will see how to convert a Path object into a string, a URI, an absolute path, a real path, and a File object.
The Path class contains a dedicated method for each of these conversions, as shown in the following subsections.
The following is the path we are going to work with:
Convert a Path to a String String conversion of a path can be achieved by the toString() method:
Convert a Path to a URI You can convert a Path to a web browser format string by applying the toURI() method, as shown in the following example.
The result is a URI object that encapsulates a path string that can be entered into the address bar of a web browser.
Convert a Relative Path to an Absolute Path Obtaining an absolute path from a relative one is a very common task.
NIO.2 can do that with the toAbsolutePath() method (notice that if you apply this method to an already absolute path, then the same path is returned):
Convert a Path to a Real Path The toRealPath() method returns the real path of an existing file—this means that the file must exist, which is not necessary if you use the toAbsolutePath() method.
If no argument is passed to this method and the file system supports symbolic links, this method resolves any symbolic links in the path.
Moreover, if the Path is relative, it returns an absolute path, and if the Path contains any redundant elements, it returns a path with those elements removed.
This method throws an IOException if the file does not exist or cannot be accessed.
The following snippet of code returns the real path of a file by not following symbolic links:
Convert a Path to a File A Path can also be converted to a File object using the toFile() method, as follows.
This a great bridge between Path and File since the File class also contains a method named toPath() for reconversion.
Combining Two Paths Combining two paths is a technique that allows you to define a fixed root path and append to it a partial path.
This is very useful for defining paths based on a common part.
There is also a method dedicated to sibling paths, named resolveSibling()
It resolves the passed path against the current path’s parent path.
Practically, this method replaces the file name of the current path with the file name of the given path.
Constructing a Path Between Two Locations When you need to construct a path from one location to another, you can call the relativize() method, which constructs a relative path between this path and a given path.
This method constructs a path originating from the original path and ending at the location specified by the passed-in path.
For a better understanding of this powerful facility, consider a simple example.
In this case, it is assumed that BNP.txt and AEGON.txt are siblings, which means that you can navigate from one to the other by going up one level and then down one level.
Another typical situation involves two paths that contain a root element.
In this case, both paths contain the same root element, /tournaments.
Note If only one of the paths includes a root element, then a relative path cannot be constructed.
Even then, the construction of the relative path is system dependent.
Comparing Two Paths The equality of two Paths can be tested in different ways for different purposes.
You can test whether two paths are equal by calling the Path.equals() method.
It does not access the file system, so the compared paths are not required to exist, and it does not check if the paths are the same file.
In some OS implementations, the paths are compared by ignoring the case, while in other implementations, the comparison is case sensitive—the implementation will specify whether case is considered.
Here I show a path relative to the current file store and an absolute path, both representing the same file, but not equals:
Sometimes you’ll want to check if two paths are the same file/folder.
If Path.equals() returns true, the paths are equal, and therefore no further comparisons are needed.
If it returns false, then the isSameFile() method enters into action to double-check.
Notice that this method requires that the compared files exist on the file system; otherwise, it throws an IOException.
Since the Path class implements the Comparable interface, you can compare paths by using the compareTo() method, which compares two abstract paths lexicographically.
The method returns zero if the argument is equal to this path, a value less than zero if this path is lexicographically less than the argument, or a value greater than zero if this path is lexicographically greater than the argument.
The following is an example of using the compareTo() method:
Partial comparison can be accomplished by using the startsWith() and endsWith() methods, as shown in the following example.
Using these methods, you can test if the current path starts or ends, respectively, with the given path.
Iterate over the Name Elements of a Path Since the Path class implements the Iterable interface, you can obtain an object that enables you to iterate over the elements in the path.
You can iterate either by using an explicit iterator or with a foreach loop that returns a Path object for each iteration.
This outputs the elements starting with the closest to the root, as follows:
Summary In this chapter you have taken your first step into the NIO.2 API.
Knowing how to obtain the default file system and how to define and manipulate file paths is important because the Path class will sustain the examples throughout the book and will usually be the entry point of applications.
If you have questions about a file or a directory, such as whether it is hidden, whether it is a directory, what its size is, and who owns it, you can get answers to those questions (and many others) from the metadata, which is data about other data.
Since different file systems have different notions about which attributes should be tracked, NIO.2 groups the attributes into views, each of which maps to a particular file system implementation.
Generally, views provide the attributes in bulk through a common method, readAttributes()
Depending on the view, other methods are available for additional tasks.
In this chapter you will learn how to use the views provided by NIO.2
You will see how to determine whether a file is read-only or hidden, when it was last accessed or modified, who owns it, and how to take ownership of it.
You will also discover how to view the access control list (ACL) of a file and how to set Unix permissions on a file.
Moreover, you will explore file store attributes and learn how to define your own attributes.
Determining Views Supported by a Particular File System Before you attempt to access a view's attributes, make sure that your file system supports the corresponding view.
NIO.2 lets you either view the entire list of supported views by name or check if a file store—represented by the FileStore class that maps any type of store, such as partitions, devices, volumes, and so on—supports a particular view.
For example, for Windows 7, the preceding code returned the following results:
Note All file systems support the basic view, so you should get at least the basic name in your output.
You can pass the desired view as a String or as a class name.
The following code checks whether the basic view is supported by all the available file stores:
Moreover, you can check if a file store in which a particular file resides supports a single view, as shown in this example:
Now that you can determine which views are supported on your file system, it is time to dig deeper and explore each view’s attributes, starting with the basic view.
Get a Single Attribute with getAttribute() If you need to extract a single attribute instead of all the attributes in bulk, use the getAttribute() method.
You need to pass the file path and the attribute name and specify whether or not you need to follow symbolic links.
The following code snippet shows how to extract the size attribute value.
Keep in mind that the getAttribute() method returns an Object, so you need an explicit conversion depending on the attribute’s value type.
Update a Basic Attribute Updating any or all of the file’s last modified time, last access time, and create time attributes can be accomplished with the setTimes() method, which takes three arguments representing the last modified time, last access time, and create time as instances of FileTime, which is a new class in Java 7 representing the value of a file’s timestamp attribute.
If any one of lastModifiedTime, lastAccessTime, or creationTime has the value null, then the corresponding timestamp is not changed.
Updating the file’s last modified time can also be accomplished with the setAttribute() method.
Actually, this method may be used to update the file’s last modified time, last access time, or create time attributes as if by invoking the setTimes() method:
Obviously, now you have to extract the three attributes’ values to see the changes.
There are four attributes, which are mapped by the following methods:
The following listing extracts in bulk the preceding four attributes for a given path:
Setting an attribute’s value and extracting a single attribute by name can be accomplished by the setAttribute() and getAttribute() methods, respectively, as follows (I randomly chose the hidden attribute):
File Owner View Most file systems accept the concept of file owner as an identity used to determine access rights to objects in a file system.
Actually, as you will see in the following code examples, NIO.2 has multiple ways for setting and getting the file owner.
Besides the file path, this method gets a UserPrincipal instance that maps a string representing the file owner.
Here is a simple example of setting a file owner:
The owner attribute is identified by the name owner, and the value of the attribute is a UserPrincipal object.
The following code snippet shows you how to set the owner using this interface:
The complete name of the attribute is owner:owner, as you can see here:
I believe that this method is pretty familiar to you from the above sections therefore here is the code snippet:
The file owner attribute can be required with the following name:
For example, you can extract the POSIX permissions of a file and create another file with the same attributes as follows (this example uses the attr object from the previous examples):
Moreover, you can set a file’s permissions as a hard-coded string by calling the fromString() method:
The setGroup() method gets the file path and a GroupPrincipal instance that maps a string representing the group owner—this class extends the UserPrincipal interface:
Note A group principal named “apressteam” is used in the preceding example, but this group will not be available on your machine.
In ACL controls the owners, permissions, and different kinds of flags for each object.
Read ACL Entries The previous two examples showed you how to extract the ACL for a specified path.
The result was a list of AclEntry—a class that maps an entry from an ACL.
Principal: The identity to which the entry grants or denies access.
Flags: A set of flags to indicate how entries are inherited and propagated.
You can iterate over the list and extract each entry’s components as follows—this is the list extracted in the previous sections:
The following is example output of this code (tested on Windows 7):
Grant a New Access in an ACL ACL entries are created using an associated AclEntry.Builder object by invoking its build() method.
For example, if you want to grant a new access to a principal, then you must follow this process:
Following these steps, you can write a code snippet for granting read data access and append data access to a principal named apress:
The preceding code adds a new entry in an ACL of an existing file.
In common cases, you will probably do that when you create a new file.
File Store Attributes If you think of a computer as a file storage container, then you can easily identify more types of stores, such as partitions, devices, volumes, and so on.
NIO.2 can obtain information about each type of store through the FileStore abstract class.
In the following subsections you will see how to obtain that information for all the stores in the default file system and for the store that contains a specified file.
Since each instance (name, type, total space, used space, and available free space) is a FileStore object, you can call the corresponding dedicated methods such as name(), type(), getTotalSpace(), and so on.
Note As you can see in the preceding example, if a store does not have a name, a blank string is returned.
In addition, the values returned for the amount of disk space are expressed in bytes, so you will probably want to convert those numbers to kilobytes, megabytes, or gigabytes to make them easier for humans to read.
Get Attributes of the File Store in Which a File Resides Based on the FileStore class, you can get attributes of a file store in which a particular file resides.
NIO.2 determines the file store for you and provides access to the information.
Note In addition, you can read the value of a file store attribute by using the getAttribute() method.
User-Defined File Attributes View If you find that there are not enough built-in attributes for your needs or if you have some unique metadata (meaningful to the file system) that you want to associate with a file, you can define your own attributes.
This facility allows you to associate to a file any attribute that you consider to be useful for your use cases.
For example, this may be useful if you develop a distributed file system.
For instance, you could add a boolean attribute that verifies whether or not the file is replicated or distributed to other locations.
Check User-Defined Attributes Supportability Before you attempt to create your own attributes, check whether your file system supports this facility.
Since this is checked over a file store, not over a file itself, first you need to obtain the desired file store.
It returns a boolean value, as you can see here:
Note You can do this check over all file stores, or a set of file stores, by getting them directly from the default file system.
It is not required to get the file store from where a file resides.
Operations on User-Defined Attributes If your file system supports user-defined attributes, then you are all set to create your own.
Next, you will see how to define an attribute, how to list the user-defined attributes, and how to delete a user-defined attribute.
Your focus in this section should be on the life cycle of user-defined attributes.
Define a User Attribute To start, you will define an attribute named file.description that has the value "This file contains private information!"
The write() method writes the value of the attribute from a given buffer as a sequence of bytes.
It receives two arguments: the attribute name and the buffer containing the attribute value.
If an attribute of the given name already exists, then its value is replaced.
As you can see, the method returns an int, which represents the number of bytes written, possibly zero.
Note In addition, you can write an attribute using the setAttribute() method.
You can write it from a buffer or byte array (byte[])
The returned list is a collection of strings that represents the attribute names.
You pass to it the attribute name and the destination buffer, and it returns the value in the specified buffer.
The following code snippet shows you how to do it:
Note You can also read an attribute by using the getAttribute() method.
You only need to supply the attribute’s name to the method and it will do the rest of the work for you.
The following shows how to delete the attribute defined earlier:
Summary In this chapter you have explored the views provided by NIO.2
You saw how to manipulate all kinds of attributes, how to query a file or a file store for different purposes, and how to define your own metadata.
After an introduction to the NIO.2 views and a description of how to determine which views are supported by a particular file system, the chapter introduced the basic and DOS attributes, which should be available for every file.
These attributes provide the main metadata, such as size, creation time, last modified time, read-only, and so forth.
The chapter next presented the file owner attributes, which provide support for setting and getting a file owner, followed by the POSIX attributes for Unix users and the ACL attributes, which provide access to the collection of permissions that control access to a file system’s objects.
The chapter wrapped up by discussing file store attributes and user-defined attributes.
Linux and Unix users (especially administrators) should be familiar with the concept of links.
There is two types of links: symbolic links and hard links.
Links commonly reach a file through several names, instead of navigating through a series of directories and subdirectories from the root – think of a link as an entity mapping a file/directory path and identified through a set of names.
If you are a dedicated Windows user, you might not be familiar with links, although Windows itself is perfectly aware of them, especially symbolic links, which most resemble Windows shortcuts.
NIO.2 provides support for both hard links and symbolic links.
Each method of the Path class knows how to detect a link and will behave in the default manner if no configuration of behavior is specified.
In this chapter, you will learn how to manipulate links through the java.nio.file API, including how to create a link and how to find the target of a link.
Each of these methods will be presented in detail in this chapter.
Introducing Links When you reach a file through a set of names (from command-line, an application, or other ways), you are dealing with a link.
A link can be set up either as a hard link (sometimes spelled hardlink) or as a symbolic link (also called symlink or softlink)
When a file has two names of equal weight and the inode table (Linux files don’t actually live in directories; they are assigned an inode number, which Linux uses to locate them) points directly to the blocks on the disk that contain the data, the link is a hard link.
Think of a hard link as a directory reference or pointer to a file.
When a file has one main name and an extra entry in the file name table that refers any accesses back to the main name, the link is a symbolic link.
Symbolic links are more flexible and used much more often than hard links.
Hard links can be created only for files, not for directories.
Symbolic links can link to a file or a directory.
Removing the original file that your hard link points to does not remove the hard link itself, and the hard link still provides the content of the underlying file.
Removing the original file that your symbolic link points to does not remove the attached symbolic link, but without the original file, the symbolic link is useless.
If you remove the hard link or the symbolic link itself, the original file stays intact.
A hard link is the same entity as the original file.
A hard link looks, and behaves, like a regular file, so hard links can be hard to find.
A symbolic link’s target may not even exist, therefore it is much flexible.
Creating Links from the Command Line Windows users can create symbolic and hard links from the command line by using the mklink command.
This command gets a set of options, depending on which kind of link you need to create.
Target  specifies the path (relative or absolute) that the new link refers to.
Unix (Linux) users can use the command named ln to achieve the same effect achieved in the preceding Windows example (notice that the target file is listed first and the link name is listed second in this case):
In addition, in Unix (Linux) you can delete a link using the rm command:
Creating a Symbolic Link Creating a symbolic link is very easy to accomplish in NIO.2
In addition, keep in mind that the target of the symbolic link can be absolute or relative (as described in Chapter 1) and might or might not exist.
The following code snippet creates a simple symbolic link with the default attributes.
This argument is an array of attributes of type FileAttribute—the class that encapsulates the value of a file attribute that can be set atomically when creating a new file, directory, or link.
The following code snippet reads the attributes of the target file and creates a link, assigning the attributes from the target to the link.
In addition, you can use the setAttribute() method to modify the link attributes after creation.
For example, the following code snippet reads the lastModifiedTime and lastAccessTime attributes of the target and sets them to the link.
Creating a Hard Link You can create a hard link by calling the createLink() method, which uses the link to create and a path to an existing file.
It returns the path to the link, which represents the new directory entry.
You then can access the file using the link as the path.
In addition, keep in mind that a hard link can be created only for existing files.
It receives a single argument, representing the Path to be tested, and returns a boolean value.
The following code snippet is a simple example of testing a Path for a symbolic link.
As you read in Chapter 2, you can test Path for a symbolic link by using the attribute views.
The basic view provides an attribute named isSymbolicLink, which returns true if the specified Path locates a file that is a symbolic link.
You can view the isSymbolicLink attribute through the readAttributes() method (not recommended in this case since it returns a bulk list of attributes) or, much more easily, through the getAttribute() method, which can be used as follows:
Locating the Target of a Link Starting from a link, you can locate its target (which may not exist) by calling the readSymbolicLink() method.
This method receives from the user the link, as a Path, and returns a Path object representing.
If the passed path is not a link, then a NotLinkException exception will be thrown.
Checking If a Link and a Target Point to the Same File Sometimes you may need to check if a link and a target point to the same file (location)
This method receives (from the user) the two Paths to be compared and returns a boolean value.
The following code snippet creates a target and a symbolic link for the target and then applies the isSameFile() method.
Summary In this chapter you saw how NIO.2 deals with symbolic and hard links.
After a short overview of these two concepts and some brief examples of how to create them in Windows and Unix (Linux), you saw the NIO.2 approach.
You learned how to create symbolic and hard links directly from Java, how to check if a path is a link, how to detect the target of a link, and how to check if a link and a target point to the same file.
Now that you know how to point to a file or directory using the Path class, you are ready to learn how to accomplish the most common tasks for managing files and directories, such as create, read, write, move, delete, and so on.
The chapter starts by exploring some methods dedicated to checking if a Path is readable, writable, executable, regular, or hidden.
These checks enable you to determine what kind of file or directory you are dealing with before you apply operations such as write or read.
The chapter then focuses on directory operations, showing you how to list, create, and read directories.
After you are familiar with directory operations, you will explore file operations, such as reading, writing, creating, and opening files.
As you will see, there is a wide array of file I/O methods to choose from.
In this chapter, you will see at work methods for buffered and unbuffered streams, leaving coverage of the methods for channels for the next chapters, in which you will see the real power of NIO.
The chapter ends with the well-known delete, copy, and move operations.
Each of these tasks is detailed presented and, as you will see, many aspects were “redesigned” from previous Java 6, but you will also recognize many of the presented methods from the java.io.File class.
Checking Methods for Files and Directories The Files class provides a set of isSomething methods that you can use to perform various kinds of checks before you actually manipulate a file or a directory.
Some of these methods were presented in the previous chapters, while the rest are presented here.
Taking advantage of these methods is recommended because they can be very useful in helping you to avoid exceptions or other strange behavior in your applications.
For example, it is a good idea to check if a file exists before you try to move it to another location.
Similarly, it is a good idea to check if a file is accessible to read before you try to read from it.
Checking for the Existence of a File or Directory As you know from previous chapters, a Path instance is perfectly valid even if the mapped file or directory does not physically exist.
Moreover, the syntactic Path methods can be applied with success in such cases because they do not operate on the file or directory itself.
Both methods receive two arguments, representing the path to the file to test and options indicating how symbolic links are handled.
The exists() method returns true if the file exists, and false otherwise (the file does not exist or the checking cannot be performed)
If you need to take action only if the file does not exist, then call the notExists() method, which returns true if the file does not exist and false otherwise (the file exists or the checking cannot be performed):
Note If both methods are applied to the same Path and both return false, then the checking cannot be performed.
For example, if the application does not have access to the file, then the status is unknown and both methods return false.
From here, it is easy to draw the conclusion that a file/directory’s existence status can be: exist, not exist, or unknown.
Immedately after checking this status, the result is outdated, since a file that exists can be deleted just after check, therefore the result must "expire" immediately.
If this method indicates the file exists then there is no guarantee that a subsequence access will succeed.
In addition, a SecurityException may be thrown if one of these methods does not have permissions to read the file.
Checking File Accessibility Another good practice before you access a file is to check its accessibility level, using the isReadable(), isWritable(), and isExecutable() methods.
After you pass the Path to be verified, these methods will.
In addition, you can check if the Path points to a regular file by calling the isRegularFile() method.
Note The preceding examples check the accessibility by applying all four methods to a Path, but you can combine these four methods in different ways depending on what level of accessibility you need to get.
For example, you may not care whether or not the Path is writable, in which case you can exclude this check.
Caution Even if these methods confirm the accessibility, there is no guarantee that the file can be accessed.
Unix fans are probably familiar with this concept, but it is applicable to any other system as well.
Checking If Two Paths Point to the Same File In the previous chapter, you saw how to check if a symbolic link and a target point to the same file.
Another common test that you can perform using the isSameFile() method is to check if two Paths expressed differently point to the same file.
For example, a relative Path and an absolute Path may point to the same file, even if it is not quite obvious.
Checking the File Visibility If you need to find out if a file is hidden, you can call the Files.isHidden() method.
Keeping in mind that the notion of “hidden” is platform/provider dependent, you just need to pass the Path to be checked and get a true or false response.
Creating and Reading Directories When it comes to creating and reading directories, NIO.2 provides a set of dedicated methods in the Files class.
In this section, you will discover how to list the file system roots, create directories (including temporary directories), list a directory’s content, and write and use filters for directories.
Listing File System Root Directories In Java 6, the file system root directories were extracted as an array of File objects.
You can easily get from Iterable into an array as follows:
If you need to extract the file system root directories as an array of File, use the Java 6 solution:
This method gets the directory to create (Path) and an optional list of file attributes (FileAttribute<?>) to set atomically at creation time.
You can add a set of attributes at creation time as shown in the following example code snippet, which creates a new directory on a POSIX file system that has specific permissions:
Note If the directory exists, then the createDirectory() method will throw an exception.
Sometimes you need to create more than just a single directory.
The sequence of directories is passed as a Path instance with or without a list of file attributes to set atomically when creating the directory.
The following code snippet shows how to create a sequence of hierarchical directories under the C:\rafaelnadal directory:
This method may fail after creation of some directories, but not all of them.
Listing a Directory’s Content Working with directories and files usually involves looping a directory’s content for different purposes.
NIO.2 provides this facility through an iterable stream named DirectoryStream, which is an interface that implements Iterable.
Listing the Content by Applying a Glob Pattern Sometimes, you may need to list only the content that meets certain criteria, which requires applying a filter to the directory’s content.
Commonly, you need to extract only files and subdirectories whose names match a particular pattern.
NIO.2 defines this particular pattern as a built-in glob filter.
Conforming to NIO.2 documentation, a glob pattern is just a string that is matched against other strings—in this case, directories and files names.
Since this is a pattern, it must respect some rules, as follows:
Convey a set of single characters or a range of characters if the hyphen character is present.
Listing the Content by Applying a User-Defined Filter If a glob pattern does not satisfy your needs, then is time to write your own filter.
A Path is accepted or rejected based on your implementation.
For example, the following code snippet accepts only directories in the final result:
The following list presents a set of commonly used filters:
Filter that accepts only files modified in the current day:
Creating, Reading, and Writing Files Probably the most common operations with files involve creating, reading, and/or writing actions.
NIO.2 comes with numerous dedicated methods for performing these actions at various levels of complexity and performance, from methods for commonly used small files (cases where it is convenient to read all bytes into a byte array) to methods for advanced features such as file locking and memory-mapped I/O.
This section starts with methods for small files and finishes with methods for buffered and unbuffered streams.
A stream represents an input source or an output destination (it can be anything from disk files to memory arrays)
Streams support different kinds of data, as strings, bytes, primitive data types, localized characters, and objects.
In an unbuffered stream, each read or write request is handled directly by the underlying operating system, while in a buffered stream, the data is read from a memory area known as a buffer; and the native input API is called only when the buffer is empty.
Similarly, buffered output streams write data to a buffer, and the native output API is called only when the buffer is full.
When a buffer is written out without waiting for it to fill, we say that the buffer is flushed.
Using Standard Open Options Starting with NIO.2, the methods dedicated to creating, reading and writing actions (or any other action that involves opening a file) support an optional parameter, OpenOption, which configures how to open or create a file.
Actually, the OpenOption is an interface from the java.nio.file package and it has two implementations: the LinkOption class (remember the well-known NOFOLLOW_LINKS enum constant) and the StandardOpenOption class, which defines the following enums:
CREATE_NEW Creates a new file, failing with an exception if the file already exists.
DELETE_ON_CLOSE Deletes the file when the stream is closed (used for deleting temporary files)
Some of these constants will be shown at work in the upcoming sections, after you take a look at.
This method gets the file to create (Path) and an optional list of file attributes (FileAttribute<?>) to set atomically at creation time.
You can add a set of attributes at creation time as shown in the following code snippet.
This code creates a new file on a POSIX file system that has specific permissions.
As you will see soon, this is not the only way to create a new file.
Writing a Small File NIO.2 comes with an elegant solution for writing small binary/text files.
Both of these methods open the file for writing (this can involve creating the file, if it doesn’t exist) or initially truncate an existing regular file to a size of 0 bytes.
In short, this method acts as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present—of course, this is applicable by default when no other options are specified.
Writing Bytes with the write() Method Writing bytes into a file can be accomplished with the Files.write() method.
This method gets the path to the file, the byte array with the bytes to write, and options specifying how the file is opened.
Now, if you check the corresponding path, you will find a small picture representing a tennis ball.
Moreover, if you need to write text (String) and you want to use this method, then convert the text.
Even if this works, it is much easier to use the write() method, described next, to write text to files.
Writing Lines with the write() Method Writing lines into a file can be accomplished by using the Files.write() method (a “line” is a char sequence)
After each line, this method appends the platform’s line separator (line.separator system property)
This method gets the path to the file, an iterable object over the char sequence, a charset to use for encoding, and options specifying how the file is opened.
The following code snippet writes some lines into a file (actually, it appends some lines to the end of the file wiki.txt created in the preceding section):
Reading a Small File NIO.2 provides a quick method to read small byte/text files in a single shot.
These methods read the entire file’s bytes or lines, respectively, into a single read and take care of opening and closing the stream for you after the file has been read or an I/O error or exception has occurred.
Focusing on the readAllBytes() method, the following code snippet reads the previously created ball.png binary file (the file must exist) into a byte array (the file path is passed as an argument):
This time the byte array should be converted to String, as in the following example (you can use any charset that is proper for your text files):
Caution If the file is too large (bigger than 2GB), then the size of the array cannot be allocated and a OutOfMemory error will be thrown.
For a 64-bit JVM, it can be much larger—tens of gigabytes potentially.
Reading with the readAllLines() Method In the preceding example you saw how to read a text file through the readAllBytes() method.
A more convenient solution is to use the readAllLines() method, since this method will read the entire file and return a List of String, which can be easily looped as follows (pass to this method the Path of the file to read and the charset to use for decoding):
Conforming to official documentation, this method recognizes the following as line terminators:
Working with Buffered Streams In most operating systems, a system call to read or write data is an expensive operation.
Buffers can fix this issue by providing a memory space between the buffered methods and the operating system.
Before calling the native API, these methods get or put the data from/into a buffer between the operating system and the application, which increases the application’s efficiency because it reduces the number of system calls—the disk is accessed only when the buffer is full or empty, depending on whether it is a write operation or a read operation.
Both of these methods get a Path instance and return an old JDK 1.1 BufferedReader or BufferedWriter instance.
It returns a new default buffered writer (this is a java.io-specific BufferedWriter)
The method opens the file for writing (this can involve creating the file, if it doesn’t exist) or initially truncates an existing regular file to a size of 0 bytes.
In short, this method acts as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present (which is applicable by default when no other options are specified)
The method gets the path to the file and a charset to use for decoding bytes into characters.
It returns a new default buffered reader (this is a java.io-specific BufferedReader)
The following code snippet reads the wiki.txt file using the UTF-8 charset:
If you followed along with the examples in the previous sections and created the entire wiki.txt file, then the preceding code will output the following content:
He is widely regarded as one of the greatest players of all time; his success on clay has earned him the nickname "The King of Clay", and has prompted many experts to regard him as the greatest clay court player of all time.
Working with Unbuffered Streams The unbuffered streams can be obtained through the new NIO.2 methods and either can be used verbatim or can be converted to buffered streams using the wrapping idiom provided by the java.io API.
Using the newOutputStream() Method The newOutputStream() method gets the path to the file and options specifying how the file is opened.
It returns a new default thread-safe unbuffered stream that may be used to write bytes to the file (this is a java.io-specific OutputStream)
The method opens the file for writing (this can involve creating the file, if it doesn’t exist) or initially truncates an existing regular file to a size of 0 bytes.
In short, this method acts as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present (which is applicable by default when no other options are specified)
Moreover, if you decide that it is a better idea to use a buffered stream instead of the preceding code, a conversion based on the java.io API is recommended, such as shown in the following code, which appends to the file racquet.txt (the file must exist) the text “String: Babolat RPM Blast 16”:
Using the newInputStream() Method The newInputStream() method gets the path to the file to open and options specifying how to open the file.
It returns a new default thread-safe unbuffered stream that may be used to read bytes from the file (this is a java.io-specific InputStream)
The method opens the file for read; if no options are present, then it is equivalent to opening the file with the READ option.
The following code snippet reads the content of the file racquet.txt (the file must exist):
As you probably already know from the java.io API, the InputStream class also provides a read() method that fills up a buffer array of type byte.
Therefore, you can modify the preceding code as follows (keep in mind that you are still dealing with an unbuffered stream):
Moreover, you can convert the unbuffered stream to a buffered stream by interoperating with the java.io API.
The following example has the same effect as the preceding example, but it is more efficient:
Creating Temporary Directories and Files A temporary directory is a directory that stores temporary files.
The location of the temporary directory depends on the operating system.
In Linux/Unix the global temporary directories are /tmp and /var/tmp.
The following code snippet creates two temporary directories, one with a prefix and one without a prefix:
Note If you don’t know what the default location for temporary directories is, you can use the following code:
Besides the temporary directory prefix and optional list of attributes, this method also gets a Path representing the default directory for temporary directories.
The following example creates a temporary directory in the C:\rafaelnadal\tmp directory:
Deleting a Temporary Directory with Shutdown-Hook Most operating systems will automatically delete the temporary directories (if not, you can use one of several kinds of cleaner software)
But, sometimes you may need to programmatically control the delete process.
For this you can attach a shutdown-hook mechanism, a runtime mechanism used to perform any resource cleanup or save that must take place before the JVM shuts down.
The run() method of the Thread will get executed when the hook is executed by the JVM at shutdown.
A nice and simple flow design of a shutdown-hook is shown in Figure 4-1
Putting the diagram shown in Figure 4-1 into code lines provide the following skeleton code:
Note Notice that adding a shutdown-hook as a Thread to the Runtime can be done as an anonymous inner class, as in the preceding code, or as a separate class that implements the Runnable or extends Thread.
A shutdown-hook is a nice solution to delete a temporary directory when the JVM shuts down, but, as you probably know, a directory cannot be deleted if it is not empty; therefore, you need to loop through the temporary directory content and delete each entry before deleting the temporary directory itself.
At this point, you know how to loop through a directory’s content only one level down, so suppose for now that your temporary directory contains only temporary files (as is true in many real-life cases) and other empty temporary directories.
Later in this book you will see how to implement recursive operations for navigating through all levels of a hierarchy structure.
The following example combines code from the preceding section for listing directory content with a shutdown-hook:
Note The preceding example uses a Thread.sleep() method to add a delay between the creation time of the temporary directory and the JVM shutdown.
Obviously, in place of that, you will provide the business logic that uses the temporary directory for the job for which it was created.
Deleting a Temporary Directory with the deleteOnExit() Method Another solution for deleting a temporary directory is to call the deleteOnExit() method.
This method is available in the java.io.File class (not specific to NIO.2) and it will delete the passed file or directory when the JVM shuts down.
Because this method must be called for each temporary file or directory, it is considered the least attractive choice because it will consume memory for each temporary entity.
Caution If your system is active for a long period of time or creates many temporary files or directories in a short period of time, then using deleteOnExit() is a bad idea! Before you choose to use deleteOnExit(), consider that it can use a lot of memory that will not be released until the JVM terminates.
The following code snippet shows you how to use deleteOnExit():
Note Since deleteOnExit() applies to File instances, not Path, you need to convert the Path to a File by calling the Path.toFile() method.
Creating Temporary Files This section takes a closer look at temporary files and the NIO.2 approach to them.
In real-world applications, temporary files often provide very useful help.
They work very well when you need files that are not indented to be used outside of the application or the application execution.
Known in Java as “work files,” they can be placed in any directory chosen from the application or in the default location returned by the Java property java.io.tmpdir.
In NIO.2 you can create a temporary file with the createTempFile() method.
Creating a temporary file in the default operating system location can be accomplished by calling the createTempFile() method with three parameters: a prefix string to be concatenated in front of the file’s name (it can be null), a suffix string to be concatenated at the end of the file’s name (it can be null; the default is .tmp), and an optional list of file attributes to set atomically when creating the file.
The following code snippet creates two temporary files, one without a prefix and suffix and one with a specified prefix and suffix:
The output will be two empty temporary files in the operating system default location:
Note If you don’t know what the default location for temporary files is, you can use the following code:
Going further, you can specify the default directory in which a temporary file is created by calling another createTempFile() method.
Besides the temporary file prefix and suffix and optional list of attributes, this method also gets a Path representing the default directory for temporary files.
The following is an example that creates a temporary file in the C:\rafaelnadal\tmp directory:
The output will be one empty temporary file in the C:\rafaelnadal\tmp directory:
Deleting a Temporary File with Shutdown-Hook A temporary file is just a simple file until you make sure that it is truly temporary, which means that an automatic mechanism must delete temporary files periodically or at a specified time.
The shutdownhook mechanism was presented earlier in the chapter in the section “Deleting a Temporary Directory with Shutdown-Hook.” The mechanism works in the same way for temporary files, so we will skip that presentation here and go straight to the code example.
Note The preceding code uses a Thread.sleep() method to add a delay between the creation time of the temporary file and the JVM shutdown.
Obviously, in place of that, you will provide the business logic that uses the temporary file for the job for which it was created.
Deleting a Temporary File with the deleteOnExit() Method Another solution for deleting a temporary file is to call the deleteOnExit() method.
This mechanism was detailed in the earlier section “Deleting a Temporary Directory with the deleteOnExit() Method” and works the same way for temporary files, so we will skip it here and to straight to the code example.
Note Since deleteOnExit() applies to File instances, not Path, you need to convert the Path to a File by calling the Path.toFile() method.
As its name suggests, this option deletes the file when the stream is closed.
Moreover, you can simulate a temporary file even without calling the createTempFile() method.
Simply define a file name, and use the DELETE_ON_CLOSE option in conjunction with the CREATE option, as shown in the following snippet (the effect is the same as in the preceding example):
Deleting, Copying, and Moving Directories and Files Delete, copy, and move are three of the most common operations used on files and directories.
NIO.2 provides dedicated methods to sustain different approaches to these operations.
Most of them come from the Files class, as you will see in this section.
This is useful when you have multiple threads deleting files and you don’t want to throw an exception just because one thread did so first.
Keeping in mind that the preceding code just deleted the rafa_1.jpg file, the following code will return false:
Caution If the deleted resource is a directory, then it must be empty.
Deleting the entire directory content (which may contain other directories, files, and so on) is a task usually implemented as a recursive operation.
Note If the file is a symbolic link, then the symbolic link itself, not the final target of the link, is deleted.
Copying Files and Directories Copying files and directories is a piece of cake in NIO.2
It provides three Files.copy() methods to accomplish this task and provides a set of options for controlling the copy process—the methods take a varargs argument represented by these options.
These options are provided under the StandardCopyOption and LinkOption enums and are listed here:
When dealing with a symbolic link, the target of the link it is not copied; only the link is copied.
COPY_ATTRIBUTES: Copy a file with its associated attributes (at least, the lastModifiedTime attribute is supported and copied)
If you are not familiar with enum types, then you should know that they can be imported into applications as follows.
Note By default, when copying a symbolic link, the target of that link is copied.
Caution Trying to copy a nonempty directory will result in an empty directory.
Moreover, copying a file is not an atomic operation, which means that an IOException exception can be thrown and the copy aborted even if the target file is incomplete or the attributes were not totally copied.
Usually, when you copy a file, you need a source path (copy from) and a target path (copy to)
Based on this simple case, NIO.2 provides a Files.copy() method that takes the path to the file to copy, the path to the target file, and a set of options for controlling the copy process.
If no options are specified, then the copy ends successfully only if the target file does not exist and it is not a symbolic link.
Otherwise, an exception will be thrown unless the source and the target are not the same (the isSameFile() method returns true)
It replaces an existing file, copies attributes of the source to the target, and does not follow links.
When you need to copy all bytes from an input stream to a file, you can call the Files.copy() method that gets the input stream to read from, the path to the file, and a set of options for controlling the copy process.
By default, the copy fails if the target file already exists or is a symbolic link.
Caution It is strongly recommended that you close the input stream immediately after an I/O error occurs.
When you need to copy all bytes from a file to an output stream, you can call the Files.copy() method that gets the path to the file and the output stream to write to.
It will return the number of bytes read or written.
The target file is represented as an output stream (the target will be replaced if exists)
Caution It is strongly recommended that you close the output stream immediately after an I/O error occurs.
Moving Files and Directories In this section, you will see how to move files and directories using the Files.move() method.
This method gets the path to the file to move, the path to the target file, and a set of options that controls the moving process.
These options are provided under the StandardCopyOption enum and are listed here:
REPLACE_EXISTING: If the target file already exists, then the move is still performed and the target is replaced.
When dealing with a symbolic link, the symbolic link is replaced but what it points to is not affected.
ATOMIC_MOVE: The file move will be performed as an atomic operation, which guarantees that any process that monitors the file’s directory will access a complete file.
Again, these enum types can be imported into an application like this:
Note By default, when moving a symbolic link, the symbolic link itself is moved, not the target of that link.
Caution The move() method can also be used to move empty directories.
Nevertheless, it is possible to move a directory that it is not empty if it does not require moving the entries in the directory.
In some cases a directory has entries for special files (such as links) that are created when the directory is created, and if the directory contains only those entries, it is considered empty.
If the target already exists, then it is replaced because the REPLACE_EXISITING option is specified.
You can skip to hard-code the name of the file in the moveto path by using the Path.resolve() method (for more details, see Chapter 1)
If you have tested the preceding code, then rafa_2.jpg should be present in this directory.
Summary This chapter started by exploring some methods dedicated to checking if a Path is readable, writable, regular, or hidden.
It then focused on directory operations and how to list, create, and read directories.
The chapter then explored files operations, such as reading, writing, creating, and opening files.
As you saw, there is a wide array of file I/O methods to choose from (for buffered and unbuffered streams)
The chapter ended with the well-known delete, copy, and move operations.
As you probably know, recursive programming is a debated technique because it usually needs a lot of memory but it simplifies some programming tasks.
Basically, a recursive programming is a situation in which a procedure calls itself, passing in a modified value of the parameter or parameters that were passed in to the current iteration of the procedure.
Programming tasks such as calculating factorial, Fibonacci numbers, anagrams, and Sierpinski carpet are just a few of the well-known tasks that can be accomplished through the recursive programming technique.
If you are already familiar with this programming technique, then proceed reading this chapter to see how NIO.2 takes advantage of it.
Many programming tasks that involve working with files require visiting all files in a file tree, which is a good opportunity for using the recursive programming mechanism because every file should be “touched” individually.
This is a very common approach when performing tasks such as deleting, copying, or moving a file tree.
Based on this mechanism, NIO.2 encapsulates the traversal process of a file tree in an interface, named FileVisitor, in the java.nio.file package.
This chapter starts by presenting the FileVisitor’s scope and methods.
Once you are familiar with FileVisitor, the chapter will help you to develop a set of applications you can use to perform tasks that involve traversing a file tree, such as finding, copying, deleting, and moving files.
The FileVisitor Interface As previously mentioned, the FileVisitor interface provides the support for recursively traversing a file tree.
The methods of this interface represent key points in the traversal process, enabling you to take control when a file is visited, before a directory is accessed, after a directory is accessed, and when a failure occurs; in other words, this interface has hooks for before, during, and after a file is visited, as well as for when failure occurs.
Once you have control (at any of these key points), you can choose how to process the visited file and decide what should happen to it next by indicating a visit result through the FileVisitResult enum, which contains four enum constants:
It can be translated into different actions depending on which FileVisitor method is returned.
For example, the traversal process may continue by visiting the next file, visiting a directory’s entries, or skipping a failure.
The constants of this enum type can be iterated as follows:
The following subsections discuss how you can control the traversal process by implementing the various FileVisitor methods.
Usually, this method returns a CONTINUE result or a TERMINATE result.
For example, when searching for a file, this method should return CONTINUE until the file is found (or the tree is completely traversed) and TERMINATE after the file is found.
When this method is invoked, it receives a reference to the file and the file’s basic attributes.
If an I/O error occurs, then it throws an IOException exception.
Also, you can skip visiting the siblings of this file or directory (and any descendants) by returning the SKIP_SIBLINGS result.
When this method is invoked, it gets a reference to the directory and the directory’s basic attributes.
If an I/O error occurs, then it throws an IOException exception.
When this method is invoked, it gets a reference to the directory and IOException object—it will be null if no error occurred during the visit or it will return the corresponding error if one occurred.
If an I/O error occurs, then it throws an IOException exception.
When this method is invoked, it gets a reference to the file and the exception that occurred while trying to visit that file.
If an I/O error occurs, then it throws an IOException exception.
The SimpleFileVisitor Class Implementing the FileVisitor interface requires implementing all of its methods, which may be undesirable if you need to implement only one or a few of those methods.
In that case, it is much simpler to extend the SimpleFileVisitor class, which implements the FileVisitor interface.
For example, you may want to traverse a file tree and list the names of all directories.
The simplest walkFileTree() method gets the starting file (this is usually the file tree root) and the file visitor to invoke for each file (this is an instance of the recursive mechanism class)
For example, you can start the code example in the preceding section by calling the walkFileTree() method as follows (the passed file tree is C:\rafaelnadal):
The accepted options are the constants of the FileVisitOption enum.
Actually, this enum contains a single constant, named FOLLOW_LINKS, indicating that the symbolic links are followed in the walk (by default, they are not followed)
Calling this method for the preceding walk may look like the following:
The following lines are the output of the preceding example:
Common Walks There is a set of common walks that you can easily implement through the FileVisitor interface.
This section shows you how to write and implement applications to perform a file search, a recursive copy, a recursive move, and a recursive delete.
Writing a File Search Application Most operating systems provide a dedicated tool for searching files (for example, Linux has the find command, while Windows has the File Search tool)
From simple searches to advanced searches, all of the tools generally work in the same way: you specify the search criteria and then wait for the tool to find the matching file(s)
But, if you need to accomplish the search programmatically, then FileVisitor can help you with the traversal process.
Whether you are looking for a file by name, by extension, or by a glob pattern or are looking inside files for some text or code, the approach is always to visit each file in the file store and perform some checks to determine whether the file conforms to your search criteria.
When you write your file search tool based on FileVisitor, you need to keep in mind the following:
The visitFile() method is the best place to perform the comparison between the current file and your search criteria.
At this point you can extract each file name, its extension, or its attributes or open the file for reading.
You can use the file name, extension, and so on for determining whether the visited file is the searched one.
Sometimes you will mix these information into complex search criteria.
The search process can follow symbolic links, which can be a good idea, since following symbolic links may locate the searched file before traversing the symbolic link’s target sub-tree.
Following symbolic links is not always a good idea; for example, for deleting files it is not advisable.
Searching for Files by Name The preceding list can be incorporated into the following single code snippet to produce an application that searches for a file by name.
This application will search for the file rafa_1.jpg in the entire default file system and will stop the search when it finds it.
A fragment of the output may look something like this:
Searching for Files by Glob Pattern Sometimes you may have only partial information about the file you want to search for, such as only its name or extension or perhaps even just a chuck of its name or extension.
Based on this small piece of information, you can write a glob pattern, as described in the Chapter 4 section “Listing the Content by Applying a Glob Pattern.” The search will locate all files in a file store that match the glob pattern, and from the results you’ll probably be able to find the file you needed to locate.
The process will stop only after the entire tree has been traversed.
If you have additional information about the file you are looking for, then you can create a more complex search.
For example, besides the small piece of information about the file name and type, perhaps you know that the file size is smaller than a certain number of kilobytes, or perhaps you know a detail such as when the file was created, when the file was last modified, whether the file is hidden or read-only, or who owns it.
The following is a fragment of the found files output:
Searching for Files by Content One of the advanced file searches involves finding files by their content.
You pass a sequence of words or sentences and the search returns only files that contain that text.
This is the most time-consuming file search task because it requires searching for text inside each visited file, which means opening the file, reading it, and finally closing it.
Moreover, there are many file formats that support text, such as PDF, Microsoft Word, Excel, and PowerPoint, simple text files, XML, HTML, XHTML, and so forth.
Each of these formats is read differently, which requires dedicated code that is capable of extracting text files from them.
In this section we will develop an application that searches for files by content.
Using the StringTokenizer class, and commas as separators, the following example extracts each word and sentence into an ArrayList:
The following code loops this ArrayList and compares each word and sentence with the text extracted from the visited file.
Notice in the searchText() method that the extracted text is passed as a parameter.
The following subsections focus on isolating a set of methods for extracting text from some of the most common file formats and performing the comparison.
We’ll then combine each of the methods we develop into a full search program.
For reading PDF files, we will use two of the most popular third-party open source libraries, iText and Apache PDFBox.
You can download the iText library from http://itextpdf.com/ and the PDFBox library from http://pdfbox.apache.org/
For purposes of this chapter, I used version 5.1.2 of iText and version PDF.
The first step consists of creating a PdfReader over the visited file.
Continue by extracting the PDF’s number of pages, extracting the text from each page, and passing the extracted text to the searchText() method.
If one of the tokens is found in the extracted text, then the search in the current file is stopped, the file is considered a valid search result, and its path and name are stored so we can print it out later when the entire search is over.
If you are more familiar with PDFBox than iText, then try the following method.
Start by creating a PDFParser over the PDF file, continue by extracting the number of pages, and finish by extracting the text of each page and passing it to the searchText() method.
The Microsoft Office suite’s files can be manipulated through the Apache POI library, which is the most commonly used Java API for Microsoft documents.
Based on the developer guide, I wrote the following method for extracting text from a Word document.
Apache POI extracts an array of String containing all the paragraphs of a Word document.
The array can be looped and each paragraph can be passed to the searchText() method.
We can extract text from Excel files as shown in the following example.
After creating an HSSFWorkbook for the Excel document, the basic idea is to iterate over the sheets, then over the rows, and finally over the cells.
The cell should contain the specific text that we are looking for.
Row row; Cell cell; String text; boolean flag = false; InputStream xls = null;
Finally, we can extract text from PowerPoint files as shown in the following example; each slide may contain text and notes:
Note I arbitrarily chose the third-party libraries used in the preceding examples.
There are many other open source and commercial libraries available for dealing with different kinds of documents.
Feel free to use anything that is convenient for your needs.
Our search example is not the most efficient way to do the searching.
In a worstcase scenario, we would have to walk through an entire array (half of an array in a typical scenario)
Perhaps using an indexing search such as the one that Apache Lucene (http://lucene.apache.org/java/docs/index.html) provides would be a better way to do it.
This as an exercise you can attempt on your own.
They can be read using pure NIO.2 code as follows:
Writing a Complete Search Program Yes! The pie is ready! Just throw it in the oven! We have the searched text, the text extracted from a set of common file formats, and a method that checks if the extracted text contains the searched text.
Put everything in the traversal process and the application is ready:
Row row; Cell cell; String text; boolean flag = false; InputStream xls = null;
Note that sometimes this is a pretty slow process that may take from several seconds to dozens of minutes—the running time will vary based on the file tree size, number of checked files, and the size of those files.
In the preceding example, the file tree contains all file stores in the default file system, so each file in any of the supported formats will be opened, read, and explored for our set of search words.
Depending on how large and numerous the matching files are, the process may appear to be jammed for a few seconds as the results are returned.
You can improve this application by adding more file formats, a progress bar or flag indicating process status, and multiple threads to speed up the process.
Moreover, displaying the name of the files as they are found may be a better idea than storing their names and path.
Writing a File Delete Application Deleting a single file is a simple operation, as you saw in the Chapter 4 section “Deleting Files and Directories.” After you call the delete() or deleteIfExists() method, the file is deleted from your file system.
Deleting an entire file tree is an operation based on calling the delete() or deleteIfExists() method recursively through a FileVisitor implementation.
Before you see an example, here are a few things you need to keep in mind:
Before you delete a directory, you must delete all files from it.
The visitFile() method is the best place to perform the deletion of each file.
The delete process can follow symbolic links, which may be not advisable, since symbolic links may point files outside the deletetion domain.
But if you are sure that this case can never happen, or a supplementary condition prevents undesirable deletions, then follow symbolic links.
Our aim in this section is to create an application that deletes an entire file tree.
The following code deletes the C:\rafaelnadal directory (for further use, make a backup of this directory before you run the following code):
Note Sending the deleted files to the recycle bin can be accomplished by using JNI to invoke Windows API SHFileOperation() method.
Writing a Copy Files Application Copying a file tree requires calling the Files.copy() method for each traversed file and directory.
Before you copy any files from a directory, you must copy the directory itself.
Copying a source directory (empty or not) will result in an empty target directory.
The visitFile() method is the perfect place to copy each file.
The copy process can follow symbolic links if you specify the FOLLOW_LINKS option.
Writing a Move Files Application Moving a file tree is a task that combines into a single application the steps of copying and deleting the file tree.
Depending on the approach you choose, FileVisitor should be implemented accordingly to accomplish the move file tree task.
Before you see an example, here are some items you need to keep in mind:
Before you move any files from a directory, you must move the directory itself.
Since nonempty directories cannot be moved (only empty directories can be moved), you need to use the Files.copy() method, which will copy an empty directory instead.
The visitFile() method is the perfect place to move each file.
For this you can use the Files.move() method, or Files.copy() combined with Files.delete()
After all files from a source directory are moved into the target directory, you need to call Files.delete() to delete the source directory, which, at this moment, should be empty.
Moreover, when you move a file or directory, you need to decide if ATOMIC_MOVE is needed.
The reason is that after you move a file from the source directory, the directory content has changed and the initial last modified time is overwritten by the new date.
The move process can follow symbolic links if you specify the FOLLOW_LINKS option.
Keep in mind that moving a symbolic link moves the link itself, not the target of that link.
In this case the directory and sub-directories are moved using Files.copy() and Files.delete(), and the files are moved using Files.move()
You can accomplish the same task without using Files.move(), since every move is just a pair of copy and delete operations.
For example, you can rewrite the moveSubTree() method to use Files.copy() and Files.delete() to move files also:
Summary This chapter focused on developing recursive operations over files and directories.
After a short intro to the recursive programming technique, you learned about the FileVisitor interface and SimpleFileVisitor implementation.
You then saw how to develop a set of applications that that you can use to perform tasks that involve traversing a file tree, such as finding, copying, deleting, and moving files.
The most common use is to monitor a directory for changes to its content through actions such as create, delete, and modify.
You’ve probably seen the effect of such a service many times.
This means the editor has detected a file change through a watch service and is reporting it accordingly.
This is known as the file change notification mechanism, and starting with NIO.2, it is available through the Watch Service API.
The Watch Service API is a low-level API that can be used as is or can be customized.
You can even write a high-level API on top of it.
By default, this API uses the underlying file system functionalities to watch the file system for changes.
It allows you to register a directory (or directories) to be monitored for different kinds of notification events that you specify during registration.
When one or more of the registered notification events are detected by the watch service, the watch service passes the notification events to the process that is registered to handles them through a separate thread or pool of threads.
Note Starting with NIO.2, you no longer need to poll the file system for changes or use other in-house solutions to monitor the file system changes.
In previous Java versions, you have to implement an agent running in a separate thread that keeps track of all the contents of the watched directories, constantly polling the file system to see if anything important has happened.
Now, regardless of whether you are running Mac OS X, Linux, Unix, Windows, or some other OS, you have the guarantee that the underlying operating system and file system provide the required functionalities to allow Java to register to receive notification of file system changes.
In this chapter you will see how to develop applications based on the provided Watch Service API.
Implementing a functional application isn’t easy, so we will start with the simplest case in which the application monitors a single directory for changes.
Afterward, you will see how to recursively monitor a directory tree that you have registered to be watched.
In addition, we will develop two more applications that are less generic and that encapsulate real-life cases.
To get you started, the chapter provides an overview of the main classes involved in writing a Watch Service API–based application.
It has multiple implementations for different file systems and operating systems.
You use this interface together with three classes to develop a system that has file system watch capability.
In our case, this is the most important class of NIO 2, the well-known Path class.
Event types: This is the list of events we are interested in monitoring.
Events trigger a notification only if they are specified in the register call.
Event modifier: This qualifies how a Watchable is registered with a WatchService.
As of the time of this writing, NIO.2 does not define any standard modifiers.
Watcher: The watcher watches watchables! In our examples, the watcher is WatchService and it monitors the file system changes (the file system is a FileSystem instance)
As you will see, the WatchService will be created through the FileSystem class.
It will work away silently in the background watching the registered Path.
Implementing a Watch Service Implementing a watch service is a task that requires accomplishing a set of steps.
In this section, you will see the main steps for developing a watch service that monitors a given directory for three notification events: delete, create, and modify.
Each step is supported by a chunk of code that demonstrates how to practically accomplish the step.
At the end, we will glue the chunks together into a complete functional example of a watch service.
Creating a WatchService We begin our journey by creating a WatchService for monitoring the file system.
Registering Objects with the Watch Service Every object that should be watched must be explicitly registered with the watch service.
We can register any object that implements the Watchable interface.
For our example, we will register directories that are instances of the Path class.
An ENTRY_CREATE event is also triggered when a file is renamed or moved into this directory.
An ENTRY_DELETE event is also triggered when a file is renamed or moved out of this directory.
Which events constitute a modification is somewhat platform-specific, but actually modifying the contents of a file always triggers a modify event.
On some platforms, changing attributes of files can also trigger this event.
You do not have to register for the OVERFLOW event to receive it.
There are two such methods dedicated for registering objects with the watch service.
One of them receives two arguments representing the watch service to which this object is to be registered and the events for which this object should be registered.
The second register method receives these two arguments also, and a third argument that specifies modifiers that qualify how the directory is registered.
At the time of this writing, NIO.2 does not provide any standard modifiers.
The following code snippet registers the Path C:\rafaelnadal with the watch service (the monitored events will be create, delete, and modify):
You receive a WatchKey instance for each directory that you register; this is a token representing the registration of a watchable object with a WatchService.
It is your choice whether or not to hang onto this reference, because the WatchService returns the relevant WatchKey to you when an event is triggered.
More details about watch keys are provided in the following section.
Waiting for the Incoming Events Waiting for the incoming events requires an infinite loop.
When an event occurs, the watch service is responsible for signaling the corresponding watch key and placing it into the watcher’s queue, from where we can retrieve it—we say that the watch key was queued.
Therefore, our infinite loop may be of the following type:
Getting a Watch Key Retrieving a queued key can be accomplished by calling one of the following three methods of the WatchService class.
All three methods retrieve the next key and remove it from the queue.
They differ in how they respond if no key is available, as described here:
If still no key is available, then it returns null.
The time period is indicated as a long number, while the TimeUnit argument determines whether the specified time is minutes, seconds, milliseconds, or some other unit of time.
The following three code snippets show you each of these methods called inside the infinite loop:
Keep in mind that a key always has a state, which can be either ready, signaled, or invalid:
Ready: When it is first created, a key is in the ready state, which means that it is ready to accept events.
Signaled: When a key is in the signaled state, it means that at least one event has occurred and the key was queued, so it is available to be retrieved by poll() or take() methods.
It is analogous to fishing: the key is the float, and the events are the fish.
When you have a fish on the hook, the float (key) signals you to pull the line out of the water.
Once signaled, the key remains in this state until its reset() method is invoked to return the key to the ready state.
If other events occur while the key is signaled, they are queued without requeuing the key itself (this never happens when fishing)
Invalid: When a key is in the invalid state, it means that it is no longer active.
A key remains valid until either it is cancelled by explicitly calling the cancel() method, the directory becomes inaccessible, or the watch service is closed.
Note Watch keys are safe for use by multiple concurrent threads.
Retrieving Pending Events for a Key When the key is signaled, we have one or more pending events waiting for us to take action.
It gets no arguments and returns a List containing the retrieved pending events.
We can iterate this List to extract and process each pending event individually.
The List type is WatchEvent<T>, which represents an event (or repeated event) for an object that is registered with a WatchService:
Note The pollEvents() method does not wait if there are no events pending, which sometimes may result in an empty List.
The following code snippet iterates the pending events for our key:
Retrieving the Event Type and Count The WatchEvent<T> interface maps event properties, such as type and count.
Note If you ignore the registered event types, it is possible to receive an OVERFLOW event.
This kind of event can be ignored or handled, the choice of which is up to you.
The following code snippet will list the type of each event provided by the pollEvents() method:
Besides the event type, we can also get the number of times that the event has been observed (repeated events)
Retrieving the File Name Associated with an Event When a delete, create, or modify event occurs on a file, we can find out its name by getting the event context (the file name is stored as the context of the event)
Putting the Key Back in Ready State Once signaled, the key remains in this state until its reset() method is invoked to return the key to the ready state.
The reset() method returns true if the watch key is valid and has been reset, and returns false if the watch key could not be reset because it is no longer valid.
In some cases, the infinite loop should be broken if the key is no longer valid; for example, if we have a single key, there is no reason to stay in the infinite loop.
Following is the code that is used to break the loop if the key in no longer valid:
Caution    If you forget or fail to call the reset() method, the key will not receive any further events!
Closing the Watch Service The watch service exits either when the thread exits or when the service is closed.
When the watch service is closed, any current operations are canceled and invalidated.
If this watch service is already closed, then invoking this method has no effect.
Gluing It All Together In this section, we glue together all the preceding chunks of code, with imports and spaghetti-code, into a single application that watches for create, delete, and modify events for the path C:\rafaelnadal and reports the type of event and the file where it occurred.
For purposes of testing, try manually to add, delete, or modify a file or directory under this path.
Since this application contains an infinite loop, be careful to manually stop the application, or implement a stop mechanism.
The application is provided as a NetBeans project, so you can easily stop it, with no supplementary code, from the Output window.
Other Examples of Using a Watch Service In this section, we will “play” with the preceding application for coding some scenarios meant to explore the possibilities of the watch service.
We will build new applications based on this one for accomplish more complicated tasks that involves a watch service.
As in the previous section, following the description of each step, a chunk of code supporting the step is provided.
After the steps are described in full, we will pull everything together into the complete application.
Note For purposes of keeping the code as clean as possible, we will skip the declaration of variables (their names are the same as in the previous application) and code that should just be repeated.
Watching a Directory Tree To get started, we’ll develop an application that extends the preceding example to watch the entire C:\rafaelnadal directory tree.
Moreover, if a CREATE event creates a new directory somewhere in this tree, it will get registered immediately as if it were there from the beginning.
Next, we need to register the directory tree for create, delete, and modify events.
This is trickier than it was in the original application because we need to register each subdirectory of C:\rafaelnadal, not only this directory.
Therefore, we need a walk (see Chapter 5) to traverse each subdirectory and register it individually in the watch service.
This case is perfect for implementing a walk by extending the SimpleFileVisitor class, since we only need to get involved when a directory is previsited (additionally, you may want to override the visitFileFailed() method for explicitly treating an unexpected traversal error)
To accomplish this, we will create a method, named registerTree(), as follows:
For each traversed directory, this code calls another method, named registerPath(), which will register the received path with the watch service as follows:
At this point, the initial C:\rafaelnadal directory and all subdirectories are registered for create, delete, and modify events.
Next, we will focus on the infinite loop that will “capture” these events.
When an event occurs, we are especially interested whether it is a CREATE event, since it may signal that a new subdirectory has been created, in which case it is our responsibility to add this subdirectory into the watch service process by calling the registerTree() method with the corresponding path.
The issue we need to resolve here is that we do not know which key has been queued, so we do not know which path should be passed for registration.
The solution may be to keep the keys and corresponding paths in a HashMap that is updated at every registration in the registerPath() method, as follows, after which, when an event occurs, we can just extract the associated key from the hash map:
Now, in the infinite loop, we can register any new subdirectory as follows:
The HashMap can also be used to stop the infinite loop when no more valid keys are available.
To accomplish this, when a key is invalid, it is removed from the HashMap, and when the HashMap is empty, the loop is broken:
That’s it! At this point, let’s put everything together into a single shot:
For testing purposes, try to create new subdirectories and files, modify them, and then delete them.
At the same time, keep an eye on the console output to see how events are reported.
Watching a Video Camera For this scenario, suppose that we have a surveillance video camera that captures at least one image every 10 seconds and sends it in JPG format to a computer directory.
Behind the scenes, a controller is responsible for checking if the camera sends the image captures on time and in the correct, JPG format.
It displays an alert message if the camera does not work properly.
This scenario can be easily reproduced in code lines thanks to the Watch Service API.
We are especially interested in writing the controller that watches the video camera.
Since the video camera sends the captures to a directory, our controller can watch that directory for the CREATE event.
The directory in this example is C:\security (which you should manually create) and it is mapped as a Path by the path variable:
Next, we know that the video camera sends images every 10 seconds, which means that the poll(long, TimeUnit) method should be perfect for monitoring this (remember that if an event occurs during the specified time period, this method exits, returning the relevant WatchKey)
We set it to wait exactly 11 seconds, and if in this time no new capture is created, then we report this through a message and stop the system:
Finally, if we have a new capture available, then all we need to do is check whether it is in the JPG image format.
We pass the file, and it returns null or the content type as a MIME.
For testing purposes, you may need to write a tester class or, much easier, play the role of the video camera.
Just start the application and copy and paste JPG images in C:\security before the critical time passes.
Try different cases, such as using a wrong file format, waiting more than 11 seconds before copying another image, and so on.
Watching a Printer Tray System In this section, we will develop an application that monitors a large-scale printer tray.
Suppose that we have a multithreading base class that receives documents to be printed and dispatches them to a suite of.
Now the printers are “fed” from a common public tray represented by a directory (C:\printertray, which you need to create manually)
Our job is to implement a watch service to manage this tray.
When a new document arrives into the tray, we have to pass it to the Print class, and after a document has been printed, we have to delete it from the tray.
We start by obtaining a watch service via the classical approach and registering the C:\printertray directory for CREATE and DELETE events:
Next, when a new document arrives into the tray, we have to create a new Print thread and store the thread and the document path for further tracking the thread state.
This will help us to know when a document has been printed and thus should be deleted from the tray and removed for storage (we use a HashMap for this task)
The following code snippet contains the block of code executed when a new document arrives into the tray (a CREATE event was queued):
After a document is deleted from the tray (a DELETE event is queued), we just print a message:
But when is the document deleted? To solve this task, we use a little trick.
Instead of using the take() method for waiting keys to be queued, we use the poll(long, TimeUnit) method, which will give us control in the infinite loop at the specified time interval—when we have control (no matter whether or not any key was queued), we can loop the HashMap of threads to see if any printing job has terminated (the associated thread state is TERMINATED)
Every TERMINATED state will be followed by deletion of the associated path and removal of the HashMap entry.
When the path is deleted, a DELETE event will be queued.
For testing purposes, start the application and copy a set of files into the C:\printertray directory.
For example, the following is output from testing with a set of files:
Summary In this chapter you have explored a great facility of NIO.2, the Watch Service API.
You learned how to watch a directory or directory tree for events such as create, delete, and modify.
After an overview of this API and an introductory application, you saw how to combine this API with NIO.2 walks, how to simulate video camera surveillance, and how to watch a large-scale printer tray.
These examples were simply meant to stimulate your curiosity to explore further the exciting world of this API.
Since it is very versatile, it can be applied in many other scenarios.
For example, you might use it to update a file listing in a GUI display or to detect the modification of configuration files that could then be reloaded.
Files that can be explored sequentially are known as sequential files.
In this chapter you will see the advantages of using nonsequential (random) access to a file’s contents.
Files that permit random access to their contents are known as random access files (RAFs)
Sequential files are used more often because they are easy to create, but RAFs are more flexible and their data can be located faster.
With a RAF, you can open the file, seek a particular location, and read from or write to that file.
After you open a RAF, you can read from it or write to it in a random manner just by using a record number, or you can add to the beginning or end of the file since you know how many records are in the file.
A RAF allows you to read a single character, read a chunk of bytes or a line, replace a portion of the file, append lines, delete lines, and so forth, and allows you to perform all of these actions in a random manner.
It extends the older ByteChannel interface and represents a byte channel that maintains a current position and allows that position to be modified.
Moreover, Java 7 improves the well-known FileChannel class by implementing this interface and providing RAF and FileChannel power in a single shot.
You will then see how to get a FileChannel with RAF capabilities and explore the main facilities provided by FileChannel, such as mapping a region of the file directly into memory for faster access, locking a region of the file, and reading and writing bytes from an absolute location without affecting the channel’s current position.
The chapter ends with a benchmarking application that will help you to determine the fastest way to copy a file using FileChannel capabilities versus other common approaches, like Files.copy(), buffered streams, and so on.
Brief Overview of ByteBuffer A buffer is essentially an array (usually of bytes, but other kinds of arrays can be used—the Buffer interface offers ByteBuffer, CharBuffer, IntBuffer, ShortBuffer, LongBuffer, FloatBuffer, and DoubleBuffer) that holds some data to be written or that was just read.
The two most important components of buffers in NIO are properties and ancestor methods, as discussed next in turn.
ByteBuffer Properties The following are the essential properties of a buffer:
Limit: When writing from a buffer, the limit specifies how much data remains to get.
When you are reading into a buffer, the limit specifies how much room remains to put data into.
Position: The position keeps track of how much data you have read or written.
It specifies into which or from which array element the next byte will go or come.
A buffer’s position is never negative and is never greater than its limit.
Capacity: The capacity specifies the maximum amount of data that can be stored in a buffer.
Note In some cases, the initial limit may be 0, or it may be some other value, depending on the type of the buffer and the manner in which it is constructed.
Next, suppose that we read 2 bytes of data into our buffer.
Continuing with a second read, another 3 bytes go into the buffer.
At this point, suppose that we are not reading into the buffer anymore and want to write from the buffer.
To do this, we first need to call the flip() method before we write any bytes.
After the flip, the buffer appears as shown in Figure 7-6
There are two additional operations we may want to accomplish.
Continuing with Figure 7-8 as a reference, we may want to rewind the buffer or clear the buffer.
This is the index to which its position will be reset when the reset() method is invoked.
The mark is not always defined, but it is never negative and is never greater than the position.
If the mark is defined, then it is discarded when the position or the limit is adjusted to a value smaller than the mark.
ByteBuffer Ancestor Methods ByteBuffer provides a set of get() and put() methods for accessing data.
Since they are pretty intuitive, I will simply list them here.
In addition to the get() and put() methods, ByteBuffer also has extra methods for reading and writing values of different types, as follows:
The JVM will perform native I/O operations on direct buffers.
Direct buffers are created by using the allocateDirect() method, while non-direct buffers are created by using the allocate() method.
At this point you have sufficient information about ByteBuffer to understand the following applications.
To get deeper into the bowels of ByteBuffer, access dedicated tutorials on the Web.
The next section will introduce you to channels and relate them with buffers.
By contrast, in a block-oriented I/O system, the input/output stream produces or consumes a block of data in one step.
Channels are analogous to streams, but with a few differences:
While streams are typically one-way (read or write), channels support read and write.
All data that is sent to a channel must first be placed in a buffer.
Any data that is read from a channel is read into a buffer.
We can read or write a ByteBuffer from or to a channel, get or set the current position, and truncate an entity connected to a channel to a specified dimension.
The following methods are associated with these features (more details are available in the official documentation at http://download.oracle.com/javase/7/docs/api/index.html):
Setting the position to a value that is greater than the current size is legal but does not change the size of the entity.
The first (simplest) newByteChannel() method receives the path to the file to open or create and a set of options specifying how the file is opened.
The StandardOpenOption enum constants were described in the Chapter 4 section “Using Standard Open Options,” but they are repeated here for easy reference:
CREATE_NEW Creates a new file, failing with an exception if the file already exists.
DELETE_ON_CLOSE Deletes the file when the stream is closed (used for deleting temporary files)
The second newByteChannel() method receives the path to the file to open or create, a set of options specifying how the file is opened, and, optionally, a list of file attributes to set atomically when the file is created.
As an example, the following application will read and display the content of story.txt using a ByteBuffer (the file must exist)
I chose a buffer of 12 bytes, but feel free to use any other size.
Rafa Nadal produced another masterclass of clay-court tennis to win his fifth French Open title ...
In addition, if we want to clean up the existing content before writing, we can add the TRUNCATE_EXISTING option as follows.
Here we truncate story.txt and prepare it for writing (the story.txt file must exist)
When you write a file, there a few common cases that involve combining the open options:
To write into a file that exists, at the beginning, use WRITE.
To write into a file that exists, at the end, use WRITE and APPEND.
To write into a file that exists and clean up its content before writing, use WRITE and TRUNCATE_EXISTING.
To write into a file that does not exist, use CREATE (or CREATE_NEW) and WRITE.
The email.txt file is created with read and write permissions for the owner and read-only permissions for the group.
As you can see, there is no need to specify the READ option.
The APPEND option is optional, and is specific to the preceding example.
For this, we will exploit the position() and position(long) methods in a suite of four examples meant to familiarize you with the RAF concept.
Keep in mind that the position() method without arguments returns the current channel (entity) position, while the position(long) method sets the current position in the channel (entity) by counting the number of bytes from the beginning of it.
The first position is 0 and the last valid position is the channel (entity) size.
Example 1: Read One Character from Different Positions We start with a simple example that reads exactly one character from a text file from the first, middle, and last positions.
Example 2: Write Characters at Different Positions Next, we will try to write to a specific position.
Suppose that the MovistarOpen.txt file has the following default content:
We want to accomplish two tasks: first, add some text at the end of the preceding text, and second, replace “Gonsales” with “Gonzalez” because Fernando’s last name was misspelled in the first instance.
If everything worked fine, the new MovistarOpen.txt content should be as follows:
Example 3: Copy a Portion of a File from the Beginning to the End Moving on to a new application, we next want to copy a portion of text from the beginning of a file to the end of the same file.
We want to copy the text “The Pride of New Zealand” at the end, like this:
Example 4: Replace a File Portion with Truncate Capability In this example we will truncate a file and append new text in place of the truncated text.
Brasil Open At Forefront Of Green Movement The Brasil Open, the second stop of the four-tournament Latin American swing, is held in an area renowned for its lush natural beauty and stunning beaches.
We want to truncate the file content to remove the text “From this point forward ...” and append new text in its place.
The effect of this application is the following modification of the BrasilOpen.txt file:
Brasil Open At Forefront Of Green Movement The Brasil Open, the second stop of the four-tournament Latin American swing, is held in an area renowned for its lush natural beauty and stunning beaches.
The tournament has taken a lead in environmental conservation efforts, with highlights including the planting of 500 trees to neutralise carbon emissions and providing recyclable materials to local children for use in craft work.
This suite of examples should help you to understand how to randomly access file content.
Both methods are able to open or create a file for the given Path and return a new channel.
The first (simplest) method receives the path of the file to open or create and a set of options specifying how the file is opened.
The second method receives the path of the file to open or create, a set of options specifying how the file is opened, and, optionally, a list of file attributes to set atomically when the file is created.
For example, the following code gets for the specified path a file channel with read/write capabilities:
Mapping a Channel’s File Region Directly into Memory One of the great FileChannel facilities is the capability to map a region of a channel’s file directly into memory.
Note Only channels opened for reading can be mapped as read-only, and only channels opened for reading and writing can be mapped as read/write or private.
The map() method will return a MappedByteBuffer that actually represents the extracted region.
This extends the ByteBuffer with the following three methods, more details of which you can find in the official documentation at http://download.oracle.com/javase/7/docs/api/index.html:
To test if the operation completes successfully, the following is a printout of the byte buffer content:
If everything worked fine, you should see the BrasilOpen.txt content output to the console.
Locking a Channel’s File File locking is a mechanism that restricts access to a file or other piece of data to ensure that two or more users can’t modify the same file simultaneously.
Usually the file is locked when the first user accesses it and stays locked (can be read, but not modified) until that user is finished with the file.
On some platforms, file locking is advisory (any application can access the file if the application does not check for a file lock), while on others it is mandatory (file locking prevents any application from accessing a file)
We can take advantage of file locking in Java applications through the NIO API.
However, there is no guarantee that the file locking mechanism will always work as you expect.
Underlying OS support or, sometimes, a faulty implementation may affect the expected behavior.
File locks are held on behalf of the entire Java virtual machine.
Windows takes care of locking directories and other structures for you, so a delete, rename, or write operation will fail if another process has the file open.
Therefore, creating a Java lock over a system lock will fail.
The Linux kernel manages a set of functions known as advisory locking mechanisms.
In addition, you can enforce locking at the kernel level with mandatory locks.
Therefore, when using Java locks, keep in mind this aspect.
The FileChannel class provides four methods for file locking: two lock() methods and two tryLock() methods.
The lock() methods block the application until the desired lock can be retrieved, while the tryLock() methods do not block the application and return null or throw an exception if the file is already locked.
There is one lock()/tryLock() method for retrieving an exclusive lock on this channel’s file and one for retrieving a lock over a region of the channel’s file—this method also allows a lock to be shared.
The second application will attempt to write to the same file during this time.
The process cannot access the file because another process has locked a portion of the file.
Run the preceding application and, within a maximum of 2 minutes, start the following application in parallel:
You should find that the second application can write into vamos.txt only after the lock is released, after 2 minutes.
Copying Files with FileChannel FileChannel provides a few ways to copy a file.
Copying Files with FileChannel and a Direct or Non-direct ByteBuffer To copy files with FileChannel and a direct or non-direct ByteBuffer, we need one channel for the source file, one channel for the target file, and a direct or non-direct ByteBuffer.
The following example transfers the entire content of Rafa Best Shots.mp4:
To do so, modify the preceding code by replacing the line.
In this section, we extrapolate that example to copy the Rafa Best Shots.mp4 content:
Benchmarking FileChannel Copy Capabilities In the previous three sections you saw different ways to copy a file using FileChannel capabilities.
Which one should you choose? This is a hard question, and its answer depends on many factors.
This section focuses on one factor, speed, because completing a copy task quickly increases productivity and, in some situations, is critical to success.
Thus, this section implements an application that compares how much time each of the following solutions takes for each copy:
Time was captured only after three ignored consecutive runs; the first three runs are ignored to achieve a trend.
The first-time run is always slower than the subsequent runs.
The application is listed next and is available in the Source Code Download section of this book’s page on Apress.com:
The output of this application is pretty hard to sort through since there are so many numbers involved, so I’ve plotted some of the data instead to give you a clearer image of the results of several.
The Y axis in these figures is the estimated time expressed in seconds, and the X axis is the size of the used buffer (or run number, after skipping the first three runs)
As shown in Figure 7-13, the fastest Files.copy() method is Path to Path, followed by Path to OutputStream, and finally InputStream to Path.
As you can see, Files.copy() with Path to Path seams to be the fastest solution for copying a file.
You then saw how to get a FileChannel with RAF capabilities and discovered the main facilities provided by FileChannel, including mapping a region of the file directly into memory for faster access, locking a region of the file, and reading and writing bytes from an absolute location without affecting the channel’s current position.
The chapter ended with a benchmarking application that tries to determine the fastest way to copy a file by comparing FileChannel capabilities against other common approaches, such as Files.copy(), using buffered streams and a byte array, and using unbuffered streams and a byte array.
Some years later, around the ’80s, the notion of the socket was introduced on BSD (Berkeley Software Distribution—a Unix variant) for communication between processes using Internet Protocol (IP)
Finally, programmers can now create network applications without years of study about network communications.
Java developers can write a simple network application just by scratching the surface of a few subjects, such as IP, IP addresses, ports, and Java networks.
On top of IP, we have other common protocols, such as TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) (this chapter’s applications exploit these protocols), and on top of these we have even more, including HTTP, TELNET, DNS, and so on.
Sockets make use of IP for communication between machines, so Java network applications can “talk” to existing servers using their predefined protocol.
On the Internet, each machine can be identified by a numerical label, known as an IP address.
Moreover, it is important to know that IP addresses are organized into classes A, B, C, D, and E.
In addition, remember that the address 127.0.0.1 is reserved for the localhost address.
Certain types of servers are typically found on certain ports: for example if you connect to port Telnet server, on 119 an NNTP server, and so on.
Therefore, be careful when choosing ports; make sure you don’t interfere with other processes and that you keep in range.
Each of these notions has entire books dedicated to it, but this is enough information for the purposes of creating Java client/server applications.
In a client/server model, a server runs on a host and listens to a port for connection requests from clients across the network, or even from the same machine.
Clients use the IP address (hostname) and port to locate the server, while the server serves each client according to its request.
On the connection process, the client identifies itself to the server through a local port number that can be explicitly set or assigned by the kernel—a socket is bound to this local port number to be used during this connection (we say that the client binds to a local port number)
Upon acceptance, the server gets a new socket bound to a new local port number and also has its remote endpoint set to the address and port of the client—it needs a new port number so that it can continue to listen for connection requests on the original port.
We can conclude that, for Java, a socket is a bidirectional software endpoint between a server program and its client programs, or more generally, between two programs running on the network that are involved in a two-way communication.
An endpoint is a combination of an IP address and a port number.
Java introduced support for sockets in JDK 1.0, but things have of course changed over time from version to version.
First of all, NIO.2 introduces an interface named NetworkChannel that provides methods commons to all network channel classes—any channel that implements this interface is a channel to a network socket.
This interface’s methods and the ones added directly into classes (for checking connection state, getting remote addresses, and shutdown) will prevent you from having to call the socket() method.
NIO.2 also introduces the MulticastChannel interface as a subinterface of NetworkChannel.
As its name suggests, the MulticastChannel interface maps a network channel that supports IP multicasting.
Keep in mind that MulticastChannel is implemented only by the datagram channel (the DatagramChannel class)
When joining a multicast group you get a membership key, which is a token that represents the membership of a multicast group.
Through the membership key, you can block/unblock datagrams from different addresses, drop membership, get the channel and/or multicast group for which this membership key was created, and more.
In addition, the “Short Overview of ByteBuffer” section may be taken in consideration to understand how Java buffers work.
NetworkChannel Overview In this section we will have a short overview of the NetworkChannel methods.
This interface represents a channel to a network socket and comes with a set of five common methods for all sockets.
We present them here since they will be very useful in the next sections.
We’ll start with the bind() method, which binds the channel’s socket to a local address.
More precisely, this method will establish an association between the socket and a local address, which is usually explicitly specified as an InetSocketAddress instance (this class represents a socket address with IP (or hostname) and port, and extends the abstract SocketAddress class)
The local address can also be automatically assigned if we pass null to the bind() method.
This method is used to bind server socket channels, socket channels, and datagram socket channels with the local machine.
NetworkChannel can extract the bound address by calling the getLocalAddress() method.
If the channel’s socket is not bound, then it returns null:
Socket Options The remaining three methods of NetworkChannel deal with socket options supported by the current channel.
A socket option associated with a socket is represented by the SocketOption<T> interface.
IP_MULTICAST_IF: This option is used to specify the network interface (NetworkInterface) used for multicast datagrams sent by the datagram-oriented socket; if it is null, then the OS will choose the outgoing interface (if one is available)
By default, it is null, but the option’s value can be set after the socket is bound.
When we talk about sending datagrams, you will see how to find out what multicast interfaces are available on your machine.
IP_MULTICAST_LOOP: This option’s value is a boolean that controls the loopback of multicast datagrams (this is OS dependent)
You have to decide, as the application writer, whether you want the data you send to be looped back to your host or not.
By default, this is TRUE, but the option’s value can be set after the socket is bound.
If not otherwise specified, multicast datagrams are sent with a default value of 1, to prevent them to be forwarded beyond the local network.
With this option we can control the scope of the multicast datagrams.
By default this is set to 1, but the option’s value can be set after the socket is bound.
IP_TOS: This option’s value is an integer representing the value of the Type of Service (ToS) octet in IP packets sent by sockets—the interpretation of this value is specific to the network.
The option’s value can be set any time after the socket is bound.
By default, it is FALSE, but the option’s value can be set any time.
SO_KEEPALIVE: This option’s value it is a boolean indicating if the connection should be kept alive or not.
By default, it is set to FALSE, but the option’s value can be set any time.
SO_LINGER: This option’s value is an integer that represents a timeout in seconds (the linger interval)
When attempting to close a blocking-mode socket via the close() method, it will wait for the duration of the linger interval before transmitting the unsent data (not defined for non-blocking mode)
By default, it is a negative value, which means that this option is disabled.
The option’s value can be set any time and the maximum value is OS dependent.
SO_RCVBUF: This option’s value is an integer that represents the size in bytes of the socket receive buffer—the input buffer used by the networking implementation.
By default, the value is OS dependent, but it can be set before the socket is bound or connected.
Depending on the OS, the value can be changed after the socket is bound.
SO_SNDBUF: This option’s value is an integer that represents the size in bytes of the socket send buffer—the output buffer used by the networking implementation.
By default, the value is OS dependent, but it can be set before the socket is bound or connected.
Depending on the OS, the value can be changed after the socket is bound.
SO_REUSEADDR: This option’s value is an integer that represents if an address can be reused or not.
This is very useful in datagram multicasting when we want multiple programs to be bound to the same address.
By default, the option’s value is OS dependent, but it can be set before the socket is bound or connected.
By default it is FALSE, but it can be set at any time.
Writing TCP Server/Client Applications It is far from our aim to write a TCP tutorial, since this is a very well-documented and large subject, and involves many technical notions and aspects, but we’ll give a quick overview.
The primary function of TCP is to provide a point-to-point communication mechanism.
One process on one machine communicates with another process on another machine or within the same machine.
The server listens to one single port and can talk to many clients at the same time.
Moreover, TCP supports sending data as byte arrays or using streams, which are very popular in Java.
Non-Blocking Mechanisms When you decide to write a Java TCP server/client application, you must consider whether you need to write a blocking or non-blocking application.
This decision is important because the implementations are different and the complexity may also be critical.
The main characteristic of a blocking mechanism presumes that a given thread cannot do anything more until the I/O is fully received, which may take a while in some cases—the application’s flow is blocked because the methods do not return right away.
Non-blocking mechanisms, on the other hand, immediately queue an I/O request and return the control to application flow (methods return right away)
From a Java developer perspective, you also must take into account the degree of complexity involved by these mechanisms.
Non-blocking mechanisms are much more complex to implement than blocking mechanisms, but they allow you more performance and scalability.
Note Non-blocking mechanisms are not the same as asynchronous mechanisms (although this is often debated depending on who you ask)
For example, in a non-blocking environment, if an answer can’t be returned rapidly, the API returns immediately with an error and does nothing else, while in an asynchronous environment, the API always returns immediately, having started a behind-the-scenes effort to serve your request.
In other words, with a non-blocking mechanism, a function won’t wait while on the stack, and with an asynchronous mechanism, work may continue on behalf of the function call after that call has left the stack.
Asynchronous is more familiar with parallel (as threading), while non-blocking often refers to polling.
Both blocking and non-blocking modes have been implemented since NIO, but we will try to spice up the code with the new NIO.2 features.
In the next sections, we will develop both types of application.
Let’s start with the easy one that uses the blocking mechanism.
Writing a Blocking TCP Server The easiest approach for a better understanding of how to accomplish this task is to follow a straightforward set of steps accompanied by chunks of codes that will be glued together at the end of the discussion.
We want to develop a single-thread blocking TCP server that will echo to the client everything that it gets from it.
Many of the steps to accomplish this are transferable to other blocking TCP servers as well.
Keep in mind that a newly created server socket channel is not bound or connected.
Binding and connecting will be accomplished in the next steps.
Configuring Blocking Mechanisms If the server socket channel has been successfully opened, it is time to specify the blocking mechanism.
If we pass true, then the blocking mechanism will be used; if we pass false, then the non-blocking mechanism will be used:
Notice that this method returns a SelectableChannel object, which represents a channel that can be multiplexed via a Selector.
This is useful when we are in non-blocking mode; therefore we will ignore it for the moment.
There is no required option (you can use the default values), but we’ll explicitly set a few options to show you how this can be done.
Binding the Server Socket Channel At this point we can bind the channel’s socket to a local address and configure the socket to listen for connections.
Another common approach consists of creating an InetSocketAddress object without specifying the IP address, only the port (there is a constructor for that)
The wildcard address is a special local IP address that can be used only for bind operations, and usually means “any”:
Caution    When you are using an IP wildcard address, take care to avoid any undesirable complications that may occur if you have multiple network interfaces with separate IP addresses.
In this case, if you are not sure how to accomplish this without issues, is it recommended to bind the socket to a specific network address, rather than use a wildcard.
In addition, there is one more bind() method that receives the address to bind the socket and the maximum number of pending connections:
The local address can also be automatically assigned if we pass null to the bind() method.
This returns null if the server socket channel has not been bound yet.
Accepting Connections After opening and binding, we finally reach the accepting milestone.
Since we are in blocking mode, accepting a connection will block the application until a new connection is available or an I/O error occurs.
When a new connection is available, this method returns the client socket channel (or simply, socket channel) for the new connection.
This is an instance of the SocketChannel class, which represents a selectable channel for stream-oriented connecting sockets.
Transmitting Data over a Connection At this point the server and client can transmit data over a connection.
They can send and receive different kinds of data packets mapped as byte arrays or using streams along with the standard Java file I/O mechanism.
For example, for our server we chose to use ByteBuffers and we kept in mind that this is an echo server—what it reads from the client is what it writes back.
The SocketChannel class provides a set of read()/write() methods for ByteBuffers.
Read a sequence of bytes from this channel into the given buffer.
These methods return the number of bytes read (it can be zero) or –1 if the channel has reached end-of-stream:
Write a sequence of bytes to this channel from the given buffer.
These methods return the number of bytes written; it can be zero:
As you know, channels are very good friends with buffers, but if you decide to use streams instead (InputStream and OutputStream), then you need to use the following code; once you have obtained an I/O stream you can further explore the standard Java file I/O mechanism.
Shutting down the connection for input (or reading) will reject any further read attempts by returning the end-of-stream indicator, –1
These methods are very useful if you want to reject read/write attempts without closing the channel.
Checking if a connection is currently shut down for I/O can be accomplished with the following code:
Closing the Channel When a channel becomes useless, it must be closed.
Using this feature will ensure that the resources are closed automatically.
If you are not familiar with try-with-resources feature, check out http://download.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html.
Putting it All Together into the Echo Server Now we have everything we need for creating our echo server.
Putting together the preceding chunks, adding the necessary imports and spaghetti code, and so on will provide us the following echo sever:
Writing a Blocking TCP Client What good is a server without a client? We do not want to find out the answer to this question, so let’s develop a client for our echo server.
When the number 50 is generated, the client stops sending and closes the channel.
The server will echo (write back) everything it reads from the client.
Now that we have a scenario, let’s see the steps for implementing it.
Creating a New Socket Channel The first step is to create a selectable channel for a stream-oriented connecting socket.
Keep in mind that a newly created socket channel is not connected.
It is also possible to do this in two steps, as we will discuss.
Configuring Blocking Mechanisms If the socket channel has been successfully opened, it is time to specify the blocking mechanism.
We will pass the true value, since we want to activate the blocking mechanism:
Connecting the Channel’s Socket After opening a socket channel (and optionally binding it), you should connect to the remote address (the server-side address)
Since we are in blocking mode, connecting to a remote address will block the application until a new connection is available or an I/O error occurs.
The method returns a boolean value representing a successful connection attempt.
You can use this boolean value to check the connection availability, until sending/receiving packets through this connection.
Note Obviously, in real-world cases it’s considered bad practice to hard-code IP addresses within the application.
In this case the client will only be able to run on the same machine with the server, which sort of defeats the purpose of remote communication.
In your case, the client may likely use the hostname of the server instead of the IP address (likely configured through DNS)
Transmitting Data over a Connection The connection has been established, so we can start transmitting data packets.
The following code sends the “Hello!” message, and then sends random numbers until the number 50 is generated.
We used ByteBuffer, CharBuffer, and the read()/write() methods of SocketChannel class (we listed these methods previously when we developed the server-side code, so you should be familiar with them already):
Closing the Channel When a channel becomes useless, it must be closed.
Again, the Java 7 try-with-resources feature may be used for automatic closing.
Putting It All Together into the Client Now we have everything we need for creating our client.
Putting together all the required elements will provide us the following client:
First, start the server and wait until you see the message “Waiting for connections ...”
Continue by starting the client and check out the output.
Writing a Non-Blocking TCP Client/Server Application Before we start developing, let’s have a short overview of the non-blocking API, which has been available since NIO, so it shouldn’t look totally new to you.
Keeping this in mind, we won’t go into too much detail about the things you likely already know.
Non-blocking socket mode is all about allowing I/O operation on a channel without blocking the processes using it.
The story begins exactly as in a blocking application: the server side is opened, is bound to a local address, and receives requests from the client side, which, obviously, is open, connected to the remote address, and sending requests to the server.
A Selector is created through a no-argument open() method (Selector was not modified in Java 7)
Basically, this class has the ability to recognize when one or more channels are available for data transfer and serializes the requests for helping the server to satisfy its clients (it monitors each recorded socket channel)
Moreover, the Selector processes multiple sockets’ I/O read/write operations in a single thread, thanks to a concept known as multiplexing—this solves the problem of dedicating one thread to each socket connection.
Using the SelectionKey Class If you are still on track, then let’s go deeper! Each time a channel is registered with a Selector, it is.
A selector is responsible for maintaining three sets of selection keys:
Note All three sets are empty in a newly created selector.
Selectors are themselves safe for use by multiple concurrent threads, but their key sets however are not.
When something happens on the battlefield, the selector wakes up and creates the corresponding keys (instances of the SelectionKey class)
The selector waits for incoming connections into an infinite loop (waits for events recorded on the selector)
In addition, a “select() with timeout” method is available, as is a non-blocking method called selectNow()
The Selector waits for a client to attempt a connection, and when that happens, the server application gets the keys created by the selector.
For each key, it checks the type (each processed key is removed from the set by explicitly calling the remove() method of an Iterator over keys—this will prevent the same key from coming up again)
At this point, the client socket channel is registered to the selector for reading/writing operations.
Note In non-blocking mode, an I/O operation may transfer fewer bytes than were requested (partial read or write), or possibly no bytes at all.
Using the Selector’s Methods Next, we’ll go over the methods invoked in this section, as well as a few more, are overviewed next (most of the following descriptions were taken from the official Java 7 Javadoc)
A key is invalid if it is cancelled, its channel is closed, or its selector is closed.
It gets the selector, the interest set for the resulting key, and the attachment for the resulting key (may be null)
Writing the Server Based on these methods and the preceding discussion, we have written the following non-blocking echo server (every step is commented to help give you a good understanding):
Writing the Client Focusing on the client side, the structure is almost the same, with a few differences:
When 50 is generated, the client stops sending and closes the channel.
The server will echo (write back) everything it reads from the client.
First, start the server and wait until you see the message “Waiting for connections ....” Continue by starting a set of clients and check out the output.
Figure 8-2 shows an example of running the server and three client instances.
Keep in mind that even if it looks like a multithreading application, this is a single-thread application based on the multiplexing technique.
Writing UDP Server/Client Applications Since TCP has had its moment of glory, it is time for UDP to get our attention.
Additionally, each packet is an individual, and is handled separately (no packet is aware of other packets)
Moreover, the packets can arrive in any order, and some of them can be lost without the sender being informed, or they can arrive.
Since the sender can’t track the packets’ routes, each packet encapsulates the remote IP address and the port.
If TCP is like a telephone, UDP is like a letter.
The sender writes the receiver address (remote IP and port) and sender address (local IP and port) on the envelope (UDP packet), puts the letter (data to be sent) into the envelope, and sends the letter.
He doesn’t know if the letter will arrive to the receiver or not.
Moreover, a more recent letter can arrive faster than and old one, and a letter might never arrive at all—the letters are not aware of one another.
Keep in mind that TCP is for high-reliability data transmissions while UDP is for low-overhead transmissions.
Typically, use UDP in applications in which reliability is not critical but speed is.
In the next sections, we will write a single-thread blocking client/server application based on UDP.
Writing a UDP Server To aid your understanding, we will split the developing process into discrete steps and bring to the front the features of NIO.2 meant to increase performance and ease of development.
Again, we will write an echo server and a client that sends some text to it and receives it back.
So, we can create a server datagram–oriented socket for IPv4 like this:
But in this case, the ProtocolFamily of the channel’s socket is platform (configuration) dependent and therefore unspecified.
A client datagram–oriented socket channel can be created and checked in the same manner.
As an example, we can set the input and output buffers used by the networking implementation as follows:
Binding the Datagram-Oriented Socket Channel At this point we can bind the channel’s socket to a local address and configure the socket to listen for connections.
The local address can also be automatically assigned if we pass null to the bind() method.
This returns null if the datagram-oriented socket channel has not been bound yet.
Transmitting Data Packets At this point our server is ready to receive and send packets.
Since UDP is a connectionless network protocol, you cannot just by default read and write to a DatagramChannel like you do from other channels—later, you will see how to set up a connection over UDP.
When you send a packet, you pass to the send() method a ByteBuffer that contains the precious data and the remote address (of the server or client, depending who is sending)
Here’s how this works according to the official documentation (see http://download.oracle.com/javase/7/docs/api/):
If this channel is in non-blocking mode and there is sufficient room in the underlying output buffer, or if this channel is in blocking mode and sufficient room becomes available, then the remaining bytes in the given buffer are transmitted as a single.
If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
If this channel’s socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if by invoking the bind() method with a parameter of null.
When you receive a packet, you pass to the receive() method the buffer (ByteBuffer) into which the.
Again, here’s how it works according to the documentation (see http://download.oracle.com/javase/7/docs/api/):
If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned.
If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns null.
If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete.
If this channel’s socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if by invoking the bind() method with a parameter of null.
The method will return the datagram’s source address, or null if this channel is in non-blocking mode and no datagram is immediately available.
The remote address can be used to find out where to send an answer packet.
Our datagram echo server will listen for incoming packets in an infinite loop, in blocking mode (by default), and when a packet arrives, it will extract from it the remote address and data.
The data is sent back based on the remote address:
Closing the Datagram Channel When a datagram channel becomes useless, it must be closed.
Again, the Java 7 try-with-resources features can be used for automatic closing.
Putting All Together into the Server Now we have everything we need for creating our server.
Putting all of the previous information together will provide us the following server:
After creating a new DatagramChannel in the same manner as shown previously, and setting whatever options you need, you can start sending and receiving data packets.
A client datagram–oriented socket channel doesn’t have to be bound to a local address, since the server will extract the IP address and port from each received data packet—in other words, it knows where the client lives.
Moreover, if this channel’s socket is not bound, then the send() and receive() methods will first cause the socket (client or server) to be bound to an address that is assigned automatically, as if by invoking the bind() method with a parameter of null.
But keep in mind that if the server side is automatically bound (not explicitly), then the client should be aware of the chosen address (or more precisely, of the chosen IP address and port)
The opposite is also true if the server sends the first data packet.
First, start the server and wait until you see the following message:
I have successfully sent 37 bytes to the Echo Server!
Caution    Don’t forget to manually stop the UDP server after finishing tests!
In a connected-client scenario, the channel’s socket is configured so that it only receives/sends datagrams from/to the given remote peer address.
After the connection is established, data packets may not be received/sent from/to any other address.
A datagram-oriented socket remains connected until it is explicitly disconnected or until it is closed.
This method may be invoked at any time, because it will not affect read/write operations that are already in progress at the moment that it is invoked.
If this channel’s socket is not bound, then this method will first cause the socket to be bound to an address that is assigned automatically, as if invoking the bind() method with a parameter of null.
A corresponding boolean value will be returned (true if this channel’s socket is open and connected):
The following application is a UDP connected client for our UDP echo server.
It connects to the remote address and uses read()/write() methods for transmitting data:
Reading sequence of bytes from this channel into the given buffer.
These methods return the number of bytes read (it can be zero) or –1 if the channel has reached the end of the stream:
Writing a sequence of bytes to this channel from the given buffer.
These methods return the number of bytes written; it can be zero:
First, start the server and wait until you see this message:
I have successfully sent 37 bytes to the Echo Server!
Multicasting You are probably already familiar with the term multicasting.
But, if you are not, let’s have a short overview of this concept.
Without academic descriptions and definitions, think of multicasting as the Internet’s version of broadcasting.
For example, a television station broadcasts its signal from one source, but the signal can reach everyone that lives in the signal area—only the ones that do not have the right equipment or refuse to catch the signal will fail to receive the transmission.
In the computer world, the TV station can be translated to a main node, or machine, that spreads datagrams to a group of destination hosts.
This is possible thanks to the multicast transport service, which sends datagrams from a source to multiple receivers in a single call—this opposed to the unicast transport service, which is specific to high-level network protocols that are based on point-to-point connections and requires a replicated unicast for sending the same data to multiple points (actually, it sends a copy of the data to each point)
Multicasting introduces the notion of a group for representing the receivers of the datagrams.
When a new receiver (client) wants to join a multicast group, it needs to connect to the group through the corresponding IP address and listen for the incoming datagrams.
Many real-life cases can be programmed based on multicasting, such as online conferencing, news distribution, advertising, e-mail groups, and data-sharing management.
MulticastChannel Overview NIO.2 comes with a new interface for mapping a network channel that supports IP multicasting.
At the API level, this is a subinterface of the NetworkChannel interface presented earlier in this chapter, and it is implemented by a single class: the DatagramChannel class.
Basically, it defines two join() methods and a close() method.
Focusing on the join() methods, here it is a short overview:
The first join() method is called by a client who wants to join a multicast group for receiving the incoming datagrams.
We need to pass the IP address of the group and the network interface on which to join the group (you will see shortly how to check if your machine has a network interface capable of multicasting)
If the indicated group is successfully joined, this method returns a MembershipKey instance.
This is new in NIO.2, and it is a token representing the membership of an IP multicast group (see the next section)
The second join() method is also used for joining a multicast group.
In this case, however, we indicate a source address from which group members can begin receiving datagrams.
Membership is cumulative, which means that this method may be invoked again with the same group and interface for receiving datagrams sent by other source addresses to the group.
Note A multicast channel may join several multicast groups, including the same group on more than one interface.
The close() method is used to drop the membership (if any group was joined) and close the channel.
MembershipKey Overview When you join a multicast group, you get a membership key that can be used to perform different kinds of actions inside that group.
Block/unblock: You can block the sent datagrams from a specific source by calling the block() method and passing the source address.
Moreover, you can unblock the blocked source by calling the unblock() method with the same address.
Get group: You can get the source address of the multicast group for which this membership key was created by calling the no-argument group() method.
Get channel: You can get the channel for which this membership key was created by calling the no-argument method channel()
Get source address: If the membership key is source specific (receives only datagrams from a specific source address), you can get the source address by calling the no-argument sourceAddress() method.
Get network interface: You can get the network interface for which this membership key was created by calling the no-argument networkInterface() method.
Check validity: You can check if a membership is valid by calling the isValid() method.
Drop: You can drop membership (the channel will no longer receive any datagrams sent to the group) by calling the no-argument drop() method.
A membership key is valid when you create it and remains valid until the membership is dropped by using the drop() method or the channel is closed.
NetworkInterface Overview The NetworkInterface class represents a network interface, which is made up of a name and a list of IP addresses assigned to this interface.
It is used to identify the local interface to which a multicast group is joined.
For example, the following code will return information about all the network interfaces found on your machine:
This application will return all the network interfaces found on your machine, and for each one will render its display name (a human-readable String describing the network device) and name (the real name used to identify a network interface)
Moreover, each network interface is checked to see if it supports multicast, if it is virtual (a subinterface), and if it is up and running.
Figure 8-4 shows a fragment of output on my machine.
The framed interface is the one used for testing multicast applications—its name is eth3 and will be used later in the client/server multicast application for indicating this interface.
Writing a UDP Multicast Server In this section, we will write a UDP multicast server that sends to the group datagrams containing the current date and time on the server.
Now that we have some experience with writing UDP client/server applications, there is no need to repeat the entire process step by step.
We’ll just point out the main differences that transform a usual UDP client/server application into a UDP multicast client/server application.
We start the developing process by creating a new DatagramChannel object by calling the open() method.
The first one will indicate the network interface for IP multicast datagrams used in this case, and the second one should be enabled prior to binding the socket—this is required to allow multiple members of the group to bind to the same address:
Next, we bind the channel’s socket to the local address by calling the bind() method:
The multicast group IP address was arbitrarily chosen as 225.4.5.6, and it is mapped by an InetAddress object:
Writing a UDP Multicast Client The code for a UDP multicast client is almost the same as for a server, with a few differences.
And second, since this is a client, it must join the group by calling one of the two join() methods.
Blocking and Unblocking Datagrams Sometimes joining multicast groups can bring to you undesired datagrams (the reasons are not relevant here)
Usually, you’ll be in one of the following two scenarios:
You have a list of senders’ addresses that you’d like to join.
Supposing that the addresses are stored in a List, you can loop it and join each address separately, as shown here:
You have a list of senders’ addresses that you don’t want to join.
Supposing that the addresses are stored in a List, then you can loop it and block each address separately, as shown here:
First, start the multicast server and wait until you see this message:
Here is some example output for the UDP multicast server:
Here is the UDP client output (the client is started after a few minutes):
Performing some tests on this example will reveal some issues.
When the server is started, it sends datagrams without being aware of whether any client is listening for those datagrams.
Also, it is not aware of when clients join or leave the group.
On the opposite side, the client starts receiving datagrams when it joins the group, but is not aware of whether the server stops sending because of any causes.
If the server goes offline, the client is still waiting, and it will receive again when the server is online again and begins sending.
It can be an interesting exercise to try solving these issues if your case requires more control.
Summary This chapter covered the NIO.2 features for creating TCP/UDP client/server applications.
As discussed, NIO.2 has improved this support by updating existing classes with new methods and adding new interfaces/classes for writing such applications.
The chapter began with the NetworkChannel interface, which provides methods commons to all network channel classes.
It also discussed the MulticastChannel interface—a subinterface of NetworkChannel that maps a network channel that supports IP multicasting.
We’ve finally reached the most powerful feature introduced in NIO.2, the asynchronous channel API.
These classes are similar in style to the NIO.2 channel APIs.
These threads receive instructions to perform I/O events and they dispatch the results to the completion handlers.
All the effort is for the purpose of handling the completion of initiated asynchronous I/O operations.
In this chapter, you will see the asynchronous mechanism from the Java perspective.
You will see the big picture of how Java implements asynchronous I/O, after which you will develop related applications for files and sockets.
But, before we jump into the features of the API, a short overview of the difference between synchronous I/O and asynchronous I/O is in order.
Asynchronous I/O The difference between synchronous and asynchronous execution may seem a bit confusing at first, so let’s clear it up.
Basically, there are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O (also referred to as overlapped I/O)
In a synchronous I/O operation, a thread enters into action and waits until the I/O request is completed (the program is “stuck” waiting for the process to end, with no way out)
When the same action occurs in an asynchronous environment, a thread performs the I/O operation with more kernel help.
Actually, it immediately passes the request to the kernel and continues on to process another job.
The kernel signals to the thread when the operation has completed, and the thread “respects” the signal by interrupting its current job and processing the data from the I/O operation as necessary.
In the Java spirit of platform independence, asynchronous I/O can be tied to multiple threads—basically, allowing something to be processed on a separate thread.
You can use synchronous I/O if you simply want to make a request and receive a response.
Synchronous I/O limits performance and scalability since it is one thread per I/O connection, and running thousands of threads significantly increases overhead on the operating system.
Asynchronous I/O is a different programming model, because you don’t necessarily wait for a response, but rather submit your work for execution and then come back for a response either almost immediately or sometime later.
Therefore, asynchronous I/O seems to be better than synchronous I/O, since performance and scalability are keywords of the I/O system.
Various important operating systems, such as Windows and Linux, support fast, scalable I/O based on the use of asynchronous notifications of I/O operations taking place in the OS layers.
In summary, I/O processing that is expected to take a large amount of time can be optimized by using asynchronous I/O.
For relatively fast I/O operations, synchronous I/O would be better because the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial.
Asynchronous I/O Big Picture When talking about asynchronous I/O in Java, we are talking about the asynchronous channels.
An asynchronous channel is a connection that supports multiple I/O operations in parallel through separate threads (connecting, reading, and writing, for example) and provides mechanisms for controlling the operations after they’ve been initiated.
This section discusses a few important aspects that are common to all asynchronous channels.
Foremost, note that all asynchronous channels initiate I/O operations (does not block the application to perform other tasks) and provide notifications when I/O completes.
This rule is the foundation of asynchronous channels, and from it derives the entire asynchronous channel API.
To begin our discussion of the asynchronous I/O big picture, we’ll look at forms.
Through Future’s methods we can check if the operation is complete, wait for its completion (if it’s not already complete), and retrieve the result of the operation.
You can explicitly cancel an operation by calling the Future.cancel() method, which will return a boolean representing the success of the cancellation—if the thread executing this task should be interrupted, then pass true to this method; otherwise, in-progress tasks are allowed to complete.
This attempt will fail if the task has already completed, has already been canceled, or could not be canceled for some other reason.
If successful, and this task had not started when cancel() was called, the task should never run.
Tip Make sure that the I/O buffers involved in a canceled read/write operation are not further accessed while the channel remains open.
The result of the operation can only be retrieved using the methods Future.get() and Future.get(long timeout, TimeUnit unit) after the operation has completed, waiting if necessary until it is ready or the specified timeout has expired.
The V represents the result type returned by this Future’s get() method, which means that this is the result type of the operation.
Complete Result and the CompletionHandler Interface The second form, complete result, is reminiscent of the well-known callback mechanism (such as AJAX callbacks)
A handler should override two methods: the completed() method, which is invoked when the I/O operation completes successfully, and the failed() method, which is invoked if the I/O operation fails.
If the operation completes successfully, then the result is passed as a parameter to the completed() method, and if the operation fails, a Throwable is passed to the failed() method.
Ignoring the operation status, both methods receive an attachment parameter representing an object that is passed in to the asynchronous operation.
It can be used to track which operation finished first if the same CompletionHandler object is used for multiple operations, but, of course, you may find it useful in other situations.
Tip Per the official Java Platform SE 7 documentation for CompletionHandler, “The implementations of these methods should complete in a timely manner so as to avoid keeping the invoking thread from dispatching to other completion handlers.” The following sections will explain the reason.
Types of Asynchronous Channels As of this writing, Java 7 comes with the following three types of asynchronous channels.
This class provides methods for reading and writing a file based on ByteBuffers.
In addition, it provides methods for locking files, truncating files, and getting file sizes, but keep in mind that, unlike a synchronous FileChannel channel, this type of channel does not maintain a global file position (current position) or offset.
Even if no global position or offset is available, each read or write operation should specify the position in the file from which to read or write.
This allows accessing of different parts of the file concurrently.
Opening such a channel type allows us to bind it to a group that has an associated thread pool to which tasks are submitted to handle I/O operations (there is also a default group when none is specified)
After opening, the channel has the capability to accept incoming connections in an asynchronous manner, which means that we can choose between a Future and a CompletionHandler for tracking the connection status.
Important tasks such as binding and setting channel options are provided through the implemented NetworkChannel interface.
Opening such a channel type allows us to bind it to a group that has an associated thread pool to which tasks are submitted to handle I/O operations (there is also a default group when none is specified)
After opening, the channel has the capability to connect to the remote addresses in an asynchronous manner, which means that we can choose between a Future and a CompletionHandler for tracking the connection status.
For a successful connection, this channel can read and write buffers of bytes (sequences of bytes, ByteBuffers) through a set of read() and write() asynchronous methodsagain, we can choose between a Future and a CompletionHandler for tracking the reading or writing status.
Important tasks such as binding and setting channel options are provided through the implemented NetworkChannel interface.
A timeout may leave the channel, or the underlying connection, in an inconsistent state.
A subsequent attempt to initiate a read or write operation causes an unspecified runtime exception to be thrown.
These threads receive instructions to perform I/O events and they dispatch the results to the completion handlers.
The asynchronous channel group encapsulates thread pool and the resources shared by all the threads working for the channels.
Also, the channel is in effect owned by the group, so if the group is closed, the channel is closed too.
Asynchronous channels are safe for use by multiple concurrent threads.
Some channel implementations may support concurrent reading and writing but may not allow more than one read and one write operation to be outstanding at any given time.
Default Group Besides the developer’s created groups, JVM maintains a system-wide default group that is constructed automatically, useful for simple applications.
When a group is not specified, or a null is passed instead, the asynchronous channels are bound, at construction time, to the default group.
The default group may be configured by means of two system properties, the first of which follows:
The value of this property is taken to be the fully-qualified name of a concrete ThreadFactory class.
The class is loaded using the system class loader and instantiated.
The factory’s newThread method is invoked to create each thread for the default group’s thread pool.
If the process to load and instantiate the value of the property fails then an unspecified error is thrown during the construction of the default group.
The value of the initialSize parameter for the default group.
The value of the property is taken to be the String representation of an Integer that is the initial size parameter.
If the value cannot be parsed as an Integer it causes an unspecified error to be thrown during the construction of the default group.
In short, this system property specifies the thread pool’s initial size.
Now, let’s see what the advantages and disadvantages of each supported thread pool are; these characteristics will help you to decide which one is proper in your case.
This method creates a channel group with a fixed thread pool.
You must specify the factory to use when creating new threads and the number of threads.
Caution    The life cycle in a fixed thread pool follows a simple scenario: a thread waits for an I/O event, completes I/O for the event, invokes a completion handler, and goes back to wait for more I/O events (the kernel dispatches events directly to these threads)
When the completion handler terminates normally, the thread returns to the thread pool and waits for the next event.
But if the completion handler does not complete in a timely manner, then it is possible to enter into an indefinitely blocking.
If all threads “deadlock” inside a completion handler, then the application is blocked until a thread is available to execute again, and any new event will be queued until a thread is available.
In the worst-case scenario, no thread can get free and the kernel can no longer execute anything.
This issue may be avoided if you don’t use blocking or long operations inside a completion handler.
Also, you may use a cached thread pool or timeouts for avoiding this issue.
This method creates an asynchronous channel group with a given thread pool that creates new threads as needed.
You just need to specify the initial number of threads and an ExecutorService that creates new threads as needed.
It may reuse previously constructed threads when they are available.
In this case the asynchronous channel group will submit events to the thread pool that simply invoke completion handlers.
But if the thread pool simply invokes the completion handlers, then who does the hard work and performs the I/O operations? The answer is the hidden thread pool.
This is a set of separate threads that waits for incoming I/O events.
More precisely, the kernel I/O operations are handled by one or more invisible internal threads that dispatch events to a cached pool, which in turn invokes completion handlers.
The hidden thread pool is important because it greatly reduces the probability that the application will be blocked (it solves the fixed thread pool issue) and guarantees that the kernel will be able to complete its I/O operations.
Avoiding the use of blocking or long operations inside completion handlers is still a good idea.
This method creates an asynchronous channel group with a designated thread pool.
The ExecutorService executes tasks submitted to dispatch completion results for operations initiated on asynchronous channels in the group.
Using this approach requires extra care when configuring ExecutorService—do at least two things here: provide support for direct handoff or.
Shutting down a group can be accomplished by calling the shutdown() method or the shutdownNow() method.
Calling the shutdown() method initiates the procedure of shutting down the group by marking the group as shutdown.
Once it is marked for shutdown, the group begins the termination process, which involves waiting for all the bound asynchronous channels to be closed (i.e., the completion handlers have run and the resources have been released)
You can block until the group terminates by calling the awaitTermination() method with a specified timeout—the blocking is in charge until the group terminates, the timeout occurs, or the current thread is interrupted, whichever happens first.
You can check if a group has terminated by calling the isTerminated() method and you can check if it is shut down by calling the isShutdown() method.
Keep in mind that the shutdown() method will not force to stop or interrupt threads that are executing completion handlers.
When a ServiceExecutor is specified, it is intended to be used exclusively by the resulting asynchronous channel group.
Termination of the group results in the orderly shutdown of the executor service; if the executor service shuts down for some other reason, an unspecified behavior will occur.
Therefore, you must make sure that you do not access a byte buffer that is currently involved in an I/O operation.
A nice solution for avoiding this issue is to use a ByteBuffer pool.
When an I/O operation is oncoming, you get a byte buffer from the pool, perform the I/O operation, and then return the byte buffer to the pool.
Fixing this issue also fixes another issue regarding the out of memory errors.
Memory requirements for buffers depend on the number of outstanding I/O operations, but using a pool will help you to reuse a set of buffers and avoid out of memory issues.
If you are not familiar with this API, you should consult the official documentation, available at.
This API is an important component of the Java concept of concurrency and multithreading, and it is beyond our aim to present it here since it is a large and complex API.
Each of these methods creates a number (specified by developer or deduced by default implementation) of worker threads.
The result is computed inside the Callable.call() method, which should be overridden accordingly—this throws an Exception if the result cannot be computed.
Each Callable task is submitted to the Executor (the submit() method) and it returns a Future representing the pending result; use this to check the result status and retrieve the result by calling the get() method.
Developing Asynchronous Applications There are so many examples to develop and so many tests to perform to accomplish best scalability with the asynchronous channel API that an entire dedicated book would be required to cover all the details.
Since we are covering the topic in a single chapter, we will cut straight to the stub applications, which should provide you with a source of inspiration to develop others.
We start this developing spree with the asynchronous file channel for reading, writing, and manipulating a file.
You will see how to perform these I/O operations over a file based on both Future and CompletionHander forms.
We’ll then move on to the asynchronous channel for stream-oriented listening sockets and the asynchronous channel for stream-oriented connecting sockets.
The easiest to use will receive the path of the file to open or create and, optionally, a set of options specifying how the file is opened, as shown next.
This open() method will associate the channel with a system-dependent default thread pool that may be shared with other channels (the default group)
The file is prepared for reading, so we can start reading.
This task is accomplished by the read() methods (there are two of them)
Since we are interested in using the Future mode, we will use the following read() method:
This method reads a sequence of bytes from this channel into the given buffer, starting at the given file position, and returns an object representing the pending result.
Since we are in an asynchronous environment, this method just initiates the read and does not block the application.
The following code shows you how to use it to read the first 100 bytes:
The pending result allows us to track the reading process status through the Future.isDone() method, which will return false until the read operation completes.
Placing this call in a loop allows us to complete other tasks until the read completes:
When the read operation completes, the application flow exits the loop and the result can be retrieved by calling the get() method, which waits if necessary for the operation to complete.
The result is an integer representing the number of read bytes, while the bytes are in the destination buffer:
Rafa Nadal produced another masterclass of clay-court tennis to win his fifth French Open title ...
The file is prepared for writing, so we can start writing.
This task is accomplished by the write() methods (there are two of them)
Since we are interesting in using the Future mode, we will use the following write() method:
This method writes a sequence of bytes to this channel from the given buffer, starting at the given file position, and returns an object representing the pending result.
Since we are in an asynchronous environment, this method just initiates the write and does not block the application.
The following code shows you how to use it to write some bytes starting from position 100:
This time the get() method returns the number of written bytes.
The bytes are written starting with position 100 in the file.
As an exercise, try combining both applications into a single one for reading and writing asynchronously.
File Read and Future Timeout As previously stated, the get() method waits if necessary for the operation to complete, after which it retrieves the result.
This method also has a timeout version, in which we can specify precisely how long we can afford to wait.
For this, we pass to the get() method a timeout and unit time.
If the time expires, this method throws a TimeoutException and we can interrupt the thread to finish this task by calling the cancel() method with a true parameter.
The following application reads the content of story.txt with a very short timeout:
First, if the time expires and the I/O operation does not complete, the output will be as follows:
If the I/O operation completes before the time expires, the output will be as follows:
File Read and CompletionHandler Now that you’ve seen a few examples of how the Future form works, it’s time to see how a CompletionHandler can be written to read the story.txt content.
This method reads a sequence of bytes from this channel into the given buffer, starting at the given file position.
Besides the destination buffer and the file position, this method gets the object to attach to the I/O operation (can be null) and the completion handler for consuming the result.
Since we are in an asynchronous environment, this method just initiates the read and does not block the application.
The following code shows you how to use it to read the first 100 bytes—you can locate the CompletionHandler as an anonymous inner class:
The current thread was used just to discover when we should stop the application; in some cases, the flow may end the application before the completion handler consumes the result.
In other cases, you may see the waiting message after the CompletionHandler output, depending on how fast it consumes the result of the I/O operation.
The destination ByteBuffer may “arrive” into the CompletionHandler as the object attached to the I/O operation (when you do not have any attachments, just pass null)
The following application decodes and displays the content of the destination ByteBuffer into the completed() method of CompletionHandler:
Rafa Nadal produced another masterclass of clay-court tennis to win his fifth French Open title ...
File Lock Sometimes you need to acquire an exclusive lock on a channel’s file before performing another I/O operation, such as reading or writing.
The following application uses the lock() method with the Future form for locking a file.
We will wait to acquire the lock by calling the Future.get() method, and, afterward, we will write some bytes into our file.
Again, we call the get() method that will wait until the new bytes are written and, finally, release the lock.
Moreover, an implementation of the lock() method with CompletionHandler may look like the following:
It is time to see the second open() method at work, which allows us to specify a custom thread pool through an ExecutorService object.
As you can see, this open() method gets the path of the file to open or create, a set of options specifying how the file is opened (optional), a thread pool (or null) as an ExecutorService (see “Introducing the ExecutorService API” above), and a list of file attributes to set atomically when creating the file (optional)
In our scenario, we want to develop an application that asynchronously fills up 50 ByteBuffers with bytes from random positions of the story.txt file.
Moreover, we want to use a custom group with a fixed thread pool of five threads.
We start by creating the thread pool through an ExecutorService:
We continue by passing the thread pool to the open() method, next to the file path and options:
Next, in a loop, we create 50 Callable workers (value-returning tasks) and override the call() method to create random-capacity byte buffers and fill them up with bytes from from random positions in the file—this is our computation.
We submit each “worker” to the executor and store its Future into an ArrayList.
Later, we will loop this list and call the get() method to retrieve the result from each byte buffer.
Since we passed to the executor all the necessary tasks, we can shut it down so that it doesn’t accept new tasks.
It finishes all existing threads in the queue and terminates—in the meantime, we can count some sheep:
After counting sheep for awhile, the isTerminate() method returns true, and the results are just “out of the oven.” Iterate the Future list and call the get() method to retrieve each result:
Done! Gluing everything together and adding boilerplate code and imports produces the following:
Developing an asynchronous client/server application is an interesting project for any Java developer who is focused on the networking applications field.
The easiest approach for a better understanding of how to accomplish this task is to follow a straightforward set of steps accompanied by chunks of codes that will be glued together at the end of the discussion.
We’ll start with an asynchronous server based on the Future form.
Writing an Asynchronous Server (Based on Future) We want to develop an asynchronous server that will echo to the client everything that it gets from it.
During execution, the Future mode will be responsible for tracking the status of tasks such as accepting connections, reading bytes from the client, and writing bytes to the client.
Keep in mind that a newly created asynchronous server socket channel is not bound to the local address.
There is no required option (you can use the default values), but we’ll explicitly set a few options to show you how this can be done.
At this point we can bind the asynchronous server socket channel to a local address and configure the socket to listen for connections.
Another common approach is to create an InetSocketAddress object without specifying the IP address, only the port (there is a constructor for that)
In this case, the IP address is the wildcard address, and the port number is a specified value.
The wildcard address is a special local IP address that can be used only for bind operations.
In addition, there is one more bind() method that gets, in addition to the address to bind the socket to, the maximum number of pending connections:
The local address can also be automatically assigned if we pass null to the bind() method.
This returns null if the asynchronous server socket channel has not been bound yet.
After opening and binding, we finally reach the accepting milestone.
We call the Future.get() method, which returns the new connection on successful completion.
In addition, you may want to use the isDone() method to check periodically the operation completion status.
At this point the server and client can transmit data over a connection.
They can send and receive different kinds of data packets mapped as byte arrays.
Implementing the transmission (send/receive) is a flexible and specific process since it involves many options.
For example, for our server we’ll use ByteBuffers, keeping in mind that this is an echo server—what it reads from the client is what it writes back.
The preceding read() and write() methods get a destination/source ByteBuffer, initiate a read/write operation, and return a Future<Integer> object for tracking the read/write operation status.
Calling the get() method forces the application to wait until the operation is complete before returning the number of read/written bytes.
First, we wait for incoming bytes to be read (this is what the server echoes)
Since the application is “captured” inside read/write operations with the first client, it is unprepared to accept other connections until it has completely served the current client, which means that only one client can be served at a time.
Alternatively, we can close these resources by placing the code into the Java 7 try-with-resources feature.
Using this feature will ensure that the resources are closed automatically.
Now we have everything we need to create our echo server.
Putting together the preceding chunks of code and adding the necessary imports, spaghetti code, and so forth produces the following echo sever:
You’re likely still wondering about how to accept multiple clients.
A simple solution is to wrap the preceding code into an ExecutorService.
Afterward, the worker is submitted to the executor and a new connection is prepared to be accepted.
If an unexpected error occurs, then we shut down the executor and wait to.
The following application modifies the preceding one so that it accepts multiple clients at the same time:
Writing an Asynchronous Client (Based on Future) Now let’s develop a client for our echo server.
When the number 50 is generated, the client stops sending and closes the channel.
The server will echo (write back) everything it reads from the client.
The steps for implementing the client for this scenario are discussed next.
The first step is to create an asynchronous channel for stream-oriented connecting sockets bound to the default group.
Keep in mind that a newly created asynchronous socket channel is not connected.
After opening an asynchronous socket channel (and optionally binding it), you should connect to the remote address (the server-side address)
This method initiates an operation to connect to this channel.
The method returns a Future<Void> object representing the pending result.
The connection has been established, so we can start transmitting data packets.
The following code sends the “Hello!” message, and then sends random numbers until the number 50 is generated.
The following read() and write() methods get a destination/source ByteBuffer, initiate a read/write operation, and return a Future<Integer> object for tracking the read/write operation status.
Calling the get() method will wait until the operation is complete and returns the number of read/written bytes.
Again, the Java 7 try-with-resources feature may be used for automatically closing.
Now we have everything we need to create our client.
Putting together the preceding code chunks and adding the necessary imports, spaghetti code, and so on will provide us the following client:
Testing the Echo Application (Based on Future) Testing the application is a simple task.
First, start the server and wait until you see the message “Waiting for connections ...”
Continue by starting the client and check out the output.
Writing an Asynchronous Server (Based on CompletionHandler) Next, we want to develop the same echo asynchronous server using the CompletionHandler mode instead of the Future mode.
Actually, we will mix them together, by letting the CompletionHandler mode deal with the connection’s acceptance operation and letting the Future mode deal with read/write operations.
We open the asynchronous server socket channel, set its options, and bind it in the exact same manner as we did earlier.
Next we focus on signaling the desire to accept connections.
This method gets the object to attach to the I/O operation (which can be null) and the completion handler that is invoked when a connection is accepted (or the operation fails)
We implement the CompletionHandler as an anonymous inner class and override its methods.
Now, the completed() method of the completion handler is responsible for maintaining and closing the “conversation” with the connected client.
For this we use the same read() and write() methods as earlier and use the same approach.
The failed() method of the completion handler should be called only if the operation of accepting connections fails—we just throw an exception and get ready to accept another connection.
Once a connection is accepted, we immediately get ready for a new one by invoking the accept() method from the completed() and failed() methods, as follows (this is the first line of code):
Finally, there is one more aspect to take care off.
Since this is an asynchronous application, the flow will “traverse” the entire application and exit so fast that not even a single connection can be established or served, which is not good, because we want the server to wait and serve clients for a long time.
Writing an Asynchronous Client (Based on CompletionHandler) The client for our server can also be implemented with a CompletionHandler for dealing with the connection request operations.
This method gets the remote address to which this channel is to be connected, the object to attach to the I/O operation (can be null), and the completion handler that is invoked when the connection is successfully established or not.
We implement the CompletionHandler as an anonymous inner class and override its methods.
Now, the completed() method of the completion handler is responsible for maintaining and closing the “conversation” with the server.
For this we use the same read() and write() methods as earlier and use the same approach.
The failed() method of the completion handler should be called only if the operation of connecting fails—in this case, the channel is closed.
Testing the Echo Application (Based on CompletionHandler) Testing the application is a simple task.
First, start the server and wait until you see the message “Waiting for connections ....” Continue by starting the client and checking out the output.
Using Read/Write Operations and CompletionHandler In the previous examples, we have managed the read/write operations through the Future mode.
The first read() method initiates an operation that reads a sequence of bytes from this channel into a subsequence of the given buffers (known as an asynchronous scattering read)
This method initiates an operation that reads a sequence of bytes from this channel into the given buffer:
This method initiates an operation that reads a sequence of bytes from this channel into the given buffer.
Analogue to these methods, but for writing operations, we have one method for asynchronous gathering write:
And we have two more methods for writing a sequence of bytes to this channel from the given buffer:
Writing an Asynchronous Client/Server Based on Custom Group The previous client/server applications were developed by using the default group.
This example creates a cached thread pool with the initial size of one thread:
The following example creates a fixed thread pool with exactly five threads:
Now you can modify the preceding applications for using custom groups.
Tips The applications presented in this chapter are fine for educational purposes but not for a production environment.
If you need to write applications for a production environment, then it is a good idea to keep in mind the following tips.
The method is able to read from a large number of slow clients for a while, but eventually it is overwhelmed by the huge number of clients arriving.
You can avoid this by applying a trick: use a byte buffer pool and throttle read operations.
In addition, there may be a danger here of running out of memory if your byte buffer grows too large, so you must be mindful of memory consumption (perhaps adjust Java heap parameters such as Xms and Xmx)
In this scenario, you must make sure you do not lock your thread pool, especially if you are using a fixed thread pool.
You can avoid this scenario by using blocking only for short reading operations.
But, moving on to other tasks may cause the thread to invoke the write() method again, and the completion handler has not yet been invoked by the previous write call.
You can fix this issue by making sure that the completion handler complete() method is invoked before a new write operation is initiated.
For this, use a first-in first out queue (FIFO-Q) for the byte buffers and write only when the previous write() has completed.
Refer to the “ByteBuffers Considerations” section, earlier in this chapter, also.
It will also have dedicated methods for read/write operations: a set of send()/receive() methods for connectionless case, and a set of read()/write() methods for connection case.
All read/write operations will be asynchronous and will provide support for Future and CompletionHandler modes.
There is a chance it will show up in later releases, so some guidelines for its main features are presented here.
This channel supports asynchronous opening and read/write operations (through send()/receive() methods for unconnected channels, and read()/write() methods for connected channels)
That means that these operations can be tracked by Future and CompletionHandler mechanisms.
On the other hand, this channel implements NetworkChannel for binding and setting/getting socket options and implements MulticastChannel for joining multicast groups.
If you work with an asynchronous datagram channel in the future, you must be careful to take into account the following aspects:
Summary In this chapter, you learned how to work with the NIO.2 asynchronous channel API.
After a brief introduction to the differences between synchronous I/O and asynchronous I/O, you received a detailed overview of this API structure.
The chapter wrapped up with a few tips regarding developing asynchronous-based applications.
The first parts of this chapter offer some information that is good to know, or at least hear about.
This information didn’t fit neatly into any of the previous chapters, and you probably won’t use it very soon, but it may be helpful someday.
We finish this chapter (and the book also) with a set of NIO.2 milestone methods that were presented and used in the book.
Every time you need a quick reminder or overview of these methods, you can easily leaf through the last pages of the book for them.
Refactoring java.io.File Code If you have developed a few applications based on java.io.File, then you should be familiar with the most common methods of this class.
But, if you’ve developed more than a few applications based on java.io.File, then you should be familiar with not only its methods, but also its methods’ drawbacks.
For example, many of these methods don’t throw exceptions when they fail, there is no real support for symbolic links, metadata access is inefficient, file-renaming across platforms is inconsistent, some methods don’t scale, and so on—all of which should sound pretty familiar to many senior Java developers, and pretty scary for juniors.
However, while this is the easiest solution, it may not always satisfy your needs.
Tests this abstract pathname for equality with the given object.
Tests whether the file denoted by this abstract pathname is a normal file.
Tests whether the file denoted by this abstract pathname is a directory.
Tests whether the file named by this abstract pathname is a hidden file.
Tests whether the application can read the file denoted by this abstract pathname.
Tests whether the application can modify the file denoted by this abstract pathname.
Tests whether the application can execute the file denoted by this abstract pathname.
Tests whether the file or directory denoted by this abstract pathname exists File.exists()
Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories.
Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist.
Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname.
Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter.
The length of the file denoted by this abstract pathname.
Deletes the file or directory denoted by this abstract pathname.
Sets the owner or everybody’s execute permission for this abstract pathname.
Sets the owner or everybody’s read permission for this abstract pathname.
Marks the file or directory named by this abstract pathname so that only read operations are allowed.
Sets the owner or everybody’s write permission for this abstract pathname.
Returns the time that the file denoted by this abstract pathname was last modified.
Sets the last-modified time of the file or directory named by this abstract pathname.
Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name.
Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate its name.
Returns the size of the partition named by this abstract pathname.
Returns the number of unallocated bytes in the partition named by this abstract path name.
Returns the number of bytes available to this virtual machine on the partition named by this abstract pathname.
Requests that the file or directory denoted by this abstract pathname be deleted when the virtual machine terminates.
Working with the ZIP File System Provider Conforming to NIO.2, a file system concerns the generic notion of a container that’s capable of managing and accessing the file system objects.
A file system object is typically a file store (e.g., on Windows we usually have C:, D:, and E: file stores, and we refer to them as partitions), but it can be a directory or a file as well.
Moreover, it provides an implementation of a custom file system provider—the ZIP File System Provider (ZFSP)—that can be used as-is, and/or can be the inspiration point to develop other custom file system providers.
The ZFSP treats a ZIP/JAR file as a file system and provides the ability to manipulate the contents of the file.
The ZFSP creates one file system for each ZIP/JAR file.
First, we create a simple HashMap that contains the configurable properties of a ZIP file system created by the ZFSP.
If the value is true, the ZFSP creates a new ZIP file if it does not exist.
Therefore, we can indicate that the ZIP file exists and the needed encoding is ISO-8859-1 like so:
Create a ZIP file system by specifying the path of the ZIP/JAR file.
In addition, there are two more newFileSystem() methods for accomplishing this step:
We want to copy the AEGONTickets.png entry out of the archive.
Considerations on Developing a Custom File System Provider In the preceding section, you saw how to use a custom file system provider.
If you decide to try to write your own custom file system provider, then it is a good idea to take into account the considerations listed in this section.
A file system provider is identified by a URI scheme such as file, jar, memory, or cd, and a file system’s URI has a URI scheme that matches the file system provider’s URI scheme.
Therefore, implementing a custom file system provider requires writing at least two classes and keeping in mind a set of mandatory steps.
Define a URI scheme for the provider (the getScheme() method should return this URI scheme)
Create an internal cache for managing the provider’s created file systems.
Implement the newFileSystem() and getFileSystem() methods for creating a file system and for retrieving a reference to an existing file system.
For more details, you may want to take a closer look at official documentation, at http://download.oracle.com/javase/7/docs/technotes/guides/io/fsp/filesystemprovider.html.
This last section covers some useful methods that are ready to help you in any NIO.2 application.
Default File System You’ve seen how to get the default file system many times in this book, but we’re putting this so you can easily access this information if you forget.
File Stores Getting the file system file stores is another well-covered subject in the book, but for a quick reminder, come here.
Path of a File Here’s how to get the path of a file:
Path String Separator As you know, a path string separator is OS dependent.
To retrieve the Path string separator for the default file system, you can use one of the following approaches:
Summary In this chapter you learned how to convert code based on the java.io.File class into code based on.
Also, you learned how to use the ZIP file system provider and some information on creating a custom file system provider.
The chapter (and the book) ends with the most used snippets of codes from the book.
All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed.
Exempted from this legal reservation are brief excerpts in connection with reviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work.
Duplication of this publication or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher's location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center.
Violations are liable to prosecution under the respective Copyright Law.
Trademarked names, logos, and images may appear in this book.
Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights.
While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made.
The publisher makes no warranty, express or implied, with respect to the material contained herein.
Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use.
Any source code or other supplementary materials referenced by the author in this text is available to readers at www.apress.com.
Anghel Leonard is a senior Java developer with more than 12 years of experience in Java SE, Java EE, and related frameworks.
In the past two years, he has focused on developing rich Internet applications for geographic information systems.
He has more than 20 years of experience working in various areas of information technology and financial services.
His professional interests are in Internet technology, service-oriented architecture, enterprise application architecture, multiplatform distributed applications, cloud, distributed caching, Java, grid, and high performance computing.
Thank you to the Apress team for trust in me to write this book and for the hard work you put in this project.
And thank you, Octavia, my dear wife, for your love, patience, and for being next to me all the time.
This book covers all the important aspects involved in developing NIO.2-based applications.
You will learn to develop NIO.2 applications, beginning with simple but essential stuff and gradually moving on to complex features such as sockets and asynchronous channels.
For the opening chapters (Chapters 1-5), it is enough to be familiar with Java syntax and to know how to open and run NetBeans projects.
What This Book Covers This section contains a brief summary of what is covered in each chapter.
In this chapter I cover such important topics as declaring Path instances and syntactic operations.
Attributes are divided into categories, and now they cover POSIX systems as well.
This chapter shows you how to create, follow, and manipulate symbolic and hard links.
You learn how to check file status and loop file stores, how to work with temporary files, and how to delete, copy, and move files and directories.
Use the FileVisitor API to develop recursive file operations Chapter 5: Need to copy, move, or delete an entire directory? You’ve come to the right place.
Chapter 5 shows you how to do all that through the brand new FileVisitor API.
You also find out how to develop a Search File tool.
Explore the Watch Service API and file changed notification Chapter 6: Want to monitor a file/directory for changes such as entries created, deleted, or modified? This is what the Watch Service does best.
I also cover watching a print tray and surveying a video camera in this chapter.
This is where you discover how flexible and versatile the new Watch Service API is.
Practice, practice, practice, and go beyond being a RAF apprentice!
I cover both TCP and UDP in detail and sprinkle important aspects of sockets programming throughout the chapter.
It was a pleasure to write, and I hope you find it as useful as I found it fun.
With the Asynchronous Channel API, you can develop asynchronous networkbased Java applications with a suite of classes and options.
Work with the Zip File System Provider and write a custom file system provider Chapter 10: This last chapter finishes the book with an example of using the new Zip File System Provider.
I address a few considerations about writing a custom file system provider as well.
