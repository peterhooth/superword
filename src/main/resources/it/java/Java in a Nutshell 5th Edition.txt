OnJava.com is a one-stop resource for enterprise Java developers, featuring news, code recipes, interviews, weblogs, and more.
Conferences O’Reilly Media brings diverse innovators together to nurture the ideas that spark revolutionary industries.
We specialize in documenting the latest tools and systems, translating the innovator’s knowledge into useful skills for those in the trenches.
Subscribers can zero in on answers to time-critical questions in a matter of seconds.
Read the books on your Bookshelf from cover to cover or simply flip to the page you need.
O’Reilly books may be purchased for educational, business, or sales promotional use.
The In a Nutshell series designations, Java in a Nutshell, the image of the Javan tiger, and related trade dress are trademarks of O’Reilly Media, Inc.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc.
While every precaution has been taken in the preparation of this book, the publisher and author assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.
Changes in the Fifth Edition The fifth edition of this book covers Java 5.0
As its incremented version number attests, this new version of Java has a lot of new features.
The three most significant new language features are generic types, enumerated types, and annotations, which are covered in a new chapter of their own.
The for/in statement for easily iterating through arrays and collections (this statement is sometimes called “foreach”)
Autoboxing and autounboxing conversions to automatically convert back and forth between primitive values and their corresponding wrapper objects (such as int values and Integer objects) as needed.
Varargs methods to define and invoke methods that accept an arbitrary number of arguments.
Covariant returns to allow a subclass to override a superclass method and narrow the return type of the method.
The import static declaration to import the static members of a type into the namespace.
Although each of these features is new in Java 5.0, none of them is large enough to merit a chapter of its own.
In addition to these language changes, Java 5.0 also includes changes to the Java platform.
The java.util collections classes have been converted to be generic types, providing support for typesafe collections.
This class enables C-style formatted text output with printf( ) and format( ) methods.
These packages support Java 5.0 annotations and the instrumentation, management, and monitoring of a running Java interpreter.
Although their position in the java.lang hierarchy marks these packages as very important, they are not commonly used.
In a mostly futile attempt to make room for this new material, I’ve had to make some cuts.
JavaBeans standards have not caught on in core Java APIs and now appear to be relevant only for Swing and related graphical APIs.
As such, they are no longer relevant in this book.
And the org.ietf.jgss package is of interest to only a very narrow subset of readers.
Along with removing coverage of java.beans from the quick reference section, I’ve also cut the chapter on JavaBeans from Part I of this book.
Contents of This Book The first eight chapters of this book document the Java language, the Java platform, and the Java development tools that are supplied with Sun’s Java Development Kit (JDK)
The first five chapters are essential; the next three cover topics of interest to some, but not all, Java programmers.
Chapter 1: Introduction This chapter is an overview of the Java language and the Java platform that explains the important features and benefits of Java.
It concludes with an example Java program and walks the new Java programmer through it line by line.
It is a long and detailed chapter that does not assume substantial programming experience.
Experienced Java programmers can use it as a language reference.
Programmers with substantial experience with languages such as C and C++ should be able to pick up Java syntax quickly by reading this chapter; beginning programmers with only a modest amount of experience should be able to learn Java programming by studying this chapter carefully.
It can be used as a tutorial by new programmers or as a reference by experienced Java programmers.
If you read previous editions of this book, you might want to skip directly to this chapter.
Chapter 5: The Java Platform This chapter is an overview of the essential Java APIs covered in this book.
It contains numerous short examples that demonstrate how to perform common tasks with the classes and interfaces that comprise the Java platform.
Programmers who are new to Java (and especially those who learn best by example) should find this a valuable chapter.
Chapter 6: Java Security This chapter explains the Java security architecture that allows untrusted code to run in a secure environment from which it cannot do any malicious damage to the host system.
It is important for all Java programmers to have at least a passing familiarity with Java security mechanisms.
Chapter 7: Programming and Documentation Conventions This chapter documents important and widely adopted Java programming conventions, including JavaBeans naming conventions.
It also explains how you can make your Java code self-documenting by including specially formatted documentation comments.
Chapter 8: Java Development Tools Sun’s JDK includes a number of useful Java development tools, most notably the Java interpreter and the Java compiler.
These first eight chapters teach you the Java language and get you up and running with the Java APIs.
Part II of the book is a succinct but detailed API reference formatted for optimum ease of use.
Reference in Part II; it explains how to get the most out of the quick reference section.
Also, please note that the quick reference chapters are followed by one final chapter called “Class, Method, and Field Index.” This special index allows you to look up the name of a type and find the package in which it is defined or to look up the name of a method or field and find the type in which it it is defined.
Related Books O’Reilly publishes an entire series of books on Java programming, including several companion books to this one.
Java Examples in a Nutshell This book contains hundreds of complete, working examples illustrating many common Java programming tasks using the core, enterprise, and desktop APIs.
Java Examples in a Nutshell is like Chapter 4 of this book, but greatly expanded in breadth and depth, and with all the code snippets fully fleshed out into working examples.
This is a particularly valuable book for readers who learn well by experimenting with existing code.
You can find a complete list of Java books from O’Reilly at http://java.oreilly.com/
Books that focus on the core Java APIs, as this one does, include:
Learning Java, by Pat Niemeyer and Jonathan Knudsen This book is a comprehensive tutorial introduction to Java, with an emphasis on client-side Java programming.
Java Threads, by Scott Oaks and Henry Wong Java makes multithreaded programming easy, but doing it right can still be tricky.
Java I/O, by Elliotte Rusty Harold Java’s stream-based input/output architecture is a thing of beauty.
Java Security, by Scott Oaks This book explains the Java access-control mechanisms in detail and also documents the authentication mechanisms of digital signatures and message digests.
Examples Online The examples in this book are available online and can be downloaded from the home page for the book at http://www.oreilly.com/catalog/javanut5
You may also want to visit this site for any important notes or errata that have been published there.
Conventions Used in This Book We use the following formatting conventions in this book:
Italic Used for emphasis and to signify the first use of a term.
Italic is also used for commands, email addresses, web sites, FTP sites, and file and directory names.
Bold Occasionally used to refer to particular keys on a computer keyboard or to portions of a user interface, such as the Back button or the Options menu.
Constant Width Used for all Java code as well as for anything that you would type literally when programming, including keywords, data types, constants, method names, variables, class names, and interface names.
Constant Width Italic Used for the names of function arguments and generally as a placeholder to indicate an item that should be replaced with an actual value in your program.
Sometimes used to refer to a conceptual section or line of code as in statement.
Franklin Gothic Book Condensed Used for the Java class synopses in the quick reference section.
This very narrow font allows us to fit a lot of information on the page without a lot of distracting line breaks.
This font is also used for code entities in the descriptions in the quick reference section.
Franklin Gothic Demi Condensed Used for highlighting class, method, field, property, and constructor names in the quick reference section, which makes it easier to scan the class synopses.
Franklin Gothic Book Condensed Italic Used for method parameter names and comments in the quick reference section.
Request for Comments Please address comments and questions concerning this book to the publisher:
There is a web page for this book, which lists errata, examples, and any additional information.
To ask technical questions or comment on this book, send email to:
For more information about books, conferences, Resource Centers, and the O’Reilly Network, see the O’Reilly web site at:
How the Quick Reference Is Generated For the curious reader, this section explains a bit about how the quick reference material in Java in a Nutshell and related books is created.
As Java has evolved, so has my system for generating Java quick reference material.
The current system is part of a larger commercial documentation browser system I’m developing (visit http://www.davidflanagan.com/Jude for more information about it)
The program works in two passes: the first pass collects and organizes the API information, and the second pass outputs that information in the form of quick reference chapters.
The first pass begins by reading the class files for all of the classes and interfaces to be documented.
Almost all of the API information in the quick reference is available in these class files.
The notable exception is the names of method arguments, which are not stored in class files.
These argument names are obtained by parsing the Java source file for each class and interface.
Where source files are not available, I obtain method argument names by parsing the API documentation generated by javadoc.
The parsers I use to extract API information from the source files and javadoc files are created using the Antlr parser generator developed by Terence Parr.
See http://www.antlr.org for details on this very powerful programming tool.
Once the API information has been obtained by reading class files, source files, and javadoc files, the program spends some time sorting and cross-referencing everything.
Then it stores all the API information into a single large data file.
The second pass reads API information from that data file and outputs quick reference chapters using a custom XML doctype.
Once I’ve generated the XML output, I hand it off to the production team at O’Reilly.
In this edition, the chapters were converted from XML to Framemaker instead, using in-house production tools.
It’s a virtual library that lets you easily search thousands of top tech books, cut and paste code samples, download chapters, and find quick answers when you need the most accurate, current information.
Acknowledgments Many people helped in the creation of this book, and I am grateful to them all.
I am indebted to the many, many readers of the first four editions who wrote in with comments, suggestions, bug reports, and praise.
Also, my apologies to those who made many good suggestions that could not be incorporated into this edition.
Deb edited not only the material that was new in this edition but also made the time to carefully read over the old material, giving it a much-needed updating.
Deb was patient when my work on this book veered off in an unexpected direction and provided steady guidance to help get me back on track.
The fourth edition was edited by Bob Eckstein, a careful editor with a great sense of humor.
Paula Ferguson, a friend and colleague, was the editor of the first three editions of this book.
Her careful reading and practical suggestions made the book stronger, clearer, and more useful.
As usual, I’ve had a crack team of technical reviewers for this edition of the book.
Gilad Bracha of Sun reviewed the material on generic types.
Josh Bloch, a former Sun employee who is now at Google, reviewed the material on enumerated types and annotations.
Josh was also a reviewer for the third and fourth editions of the book, and his helpful input has been an invaluable resource for me.
Neal Gafter, who, like Josh, left Sun for Google, answered many questions about annotations and generics.
Any mistakes that remain in the book are, of course, my own.
The fourth edition was also reviewed by a number of engineers from Sun and elsewhere.
Josh Bloch reviewed material on assertions and the Preferences API.
Philip Milne, a former Sun employee, now at Dresdner Kleinwort Wasserstein, reviewed the material on the JavaBeans persistence mechanism.
Mark deserves special thanks for having been a reviewer for the second, third, and fourth editions of this book.
The third edition also benefited greatly from the contributions of reviewers who are intimately familiar with the Java platform.
Joshua Bloch, one of the primary authors of the Java collections framework, reviewed my descriptions of the collections classes and interfaces.
Josh was also helpful in discussing the Timer and TimerTask classes of Java 1.3 with me.
Mark Reinhold, creator of the java.lang.ref package, explained the package to me and reviewed my documentation of it.
Scott Oaks reviewed my descriptions of the Java security and cryptography classes and interfaces.
The documentation of the javax.crypto package and its subpackages was also reviewed by Jon Eaves.
Finally, Chapter 1 was improved by the comments of reviewers who were not already familiar with the Java platform: Christina Byrne reviewed it from the standpoint of a novice programmer, and Judita Byrne of Virginia Power offered her comments as a professional COBOL programmer.
For the second edition, John Zukowski reviewed my Java 1.1 AWT quick reference material, and George Reese reviewed most of the remaining new material.
The second edition was also blessed with a “dream team” of technical reviewers from Sun.
John Rose, the author of the Java inner class specification, reviewed the chapter on inner classes.
Mark Reinhold, author of the new character stream classes in java.io, reviewed my documentation of these classes.
Nakul Saraiya, the designer of the Java Reflection API, reviewed my documentation of the java.
Mike Loukides provided high-level direction and guidance for the first edition of the book.
Eric Raymond and Troy Downing reviewed that first edition—they helped spot my errors and omissions and offered good advice on making the book more useful to Java programmers.
The O’Reilly production team has done its usual fine work of creating a book out of the electronic files I submit.
Part I is an introduction to the Java language and the Java platform.
These chapters provide enough information for you to get started using Java right away.
This chapter begins by explaining what Java is and describing some of the features that distinguish it from other programming languages.
Next, it outlines the structure of this book, with special emphasis on what is new in Java 5.0
Finally, as a quick tutorial introduction to the language, it walks you through a simple Java program you can type, compile, and run.
The Java programming language is the language in which Java applications, applets, servlets, and components are written.
When a Java program is compiled, it is converted to byte codes that are the portable machine language of a CPU architecture known as the Java Virtual Machine (also called the Java VM or JVM)
The JVM can be implemented directly in hardware, but it is usually implemented in the form of a software program that interprets and executes byte codes.
The Java platform is distinct from both the Java language and Java VM.
The Java platform is the predefined set of Java classes that exist on every Java installation; these classes are available for use by all Java programs.
The Java platform is also sometimes referred to as the Java runtime environment or the core Java APIs (application programming interfaces)
The Java platform can be extended with optional packages (formerly called standard extensions)
These APIs exist in some Java installations but are not guaranteed to exist in all installations.
The Java programming language is a state-of-the-art, object-oriented language that has a syntax similar to that of C.
The language designers strove to make the Java language powerful, but, at the same time, they tried to avoid the overly.
By keeping the language simple, the designers also made it easier for programmers to write robust, bug-free code.
As a result of its elegant design and next-generation features, the Java language has proved popular with programmers, who typically find it a pleasure to work with Java after struggling with more difficult, less powerful languages.
Most experienced Java programmers have welcomed the new features, despite the added complexity they bring.
The Java Virtual Machine, or Java interpreter, is the crucial piece of every Java installation.
By design, Java programs are portable, but they are only portable to platforms to which a Java interpreter has been ported.
Sun ships VM implementations for its own Solaris operating system and for Microsoft Windows and Linux platforms.
Many other vendors, including Apple and various commercial Unix vendors, provide Java interpreters for their platforms.
The Java VM is not only for desktop systems, however.
It has been ported to set-top boxes and handheld devices that run Windows CE and PalmOS.
Although interpreters are not typically considered high-performance systems, Java VM performance has improved dramatically since the first versions of the language.
Of particular note is a VM technology called just-in-time (JIT) compilation whereby Java byte codes are converted on the fly into native platform machine language, boosting execution speed for code that is run repeatedly.
The Java platform is just as important as the Java programming language and the Java Virtual Machine.
All programs written in the Java language rely on the set of predefined classes† that comprise the Java platform.
Java classes are organized into related groups known as packages.
The Java platform defines packages for functionality such as input/output, networking, graphics, user-interface creation, security, and much more.
It is important to understand what is meant by the term platform.
To a computer programmer, a platform is defined by the APIs he can rely on when writing programs.
These APIs are usually defined by the operating system of the target computer.
Thus, a programmer writing a program to run under Microsoft Windows must use a different set of APIs than a programmer writing the same program for a Unix-based system.
Java 5.0 represents a significant change in version numbering for Sun.
A class is a module of Java code that defines a data structure and a set of methods (also called procedures, functions, or subroutines) that operate on that data.
Nevertheless, the Java platform provides APIs with a comparable breadth and depth to those defined by an operating system.
With the Java platform, you can write applications in Java without sacrificing the advanced features available to programmers writing native applications targeted at a particular underlying operating system.
An application written on the Java platform runs on any operating system that supports the Java platform.
This means you do not have to create distinct Windows, Macintosh, and Unix versions of your programs, for example.
A single Java program runs on all these operating systems, which explains why “Write once, run anywhere” is Sun’s motto for Java.
The Java platform is not an operating system, but for programmers, it is an alternative development target and a very popular one at that.
The Java platform reduces programmers’ reliance on the underlying operating system, and, by allowing programs to run on top of any operating system, it increases end users’ freedom to choose an operating system.
As of this writing, there have been six major versions of Java.
Java 1.0 This was the first public version of Java.
It was simple and elegant but is now completely outdated.
It introduced nested types (or “inner classes”), an important change to the Java language itself, and included significant performance improvements in the Java VM.
Important additions included the Collections API for working with sets, lists, and maps of objects and the Swing API for creating graphical user interfaces.
Java 1.3 This was primarily a maintenance release, focused on bug fixes, stability, and performance improvements (including the high-performance “HotSpot” virtual machine)
Additions to the platform included the Java Naming and Directory Interface (JNDI) and the Java Sound APIs, which were previously available as extensions to the platform.
In addition to these platform changes, the 1.4 release introduced an assert statement to the Java language.
Java 5.0 The most recent release of Java introduces a number of changes to the core language itself including generic types, enumerated types, annotations, varargs methods, autoboxing, and a new for/in statement.
Because of the major language changes, the version number was incremented.
In addition to the language changes, Java 5.0 includes a number of additions to the Java platform as well.
Notable additions include utilities for concurrent programming, a remote management framework, and classes for the remote management and instrumentation of the Java VM itself.
See the Preface for a list of changes in this edition of the book, including pointers to coverage of the new language and platform features.
To write programs in Java, you must obtain the Java Development Kit (JDK)
Sun releases a new version of the JDK for each new version of Java.
The JRE contains everything you need to run Java programs, but it does not contain the tools you need to develop Java programs (primarily the compiler)
See Java Enterprise in a Nutshell and Java Micro Edition in a Nutshell (both by O’Reilly) for more information on these other editions.
Key Benefits of Java Why use Java at all? Is it worth learning a new language and a new platform? This section explores some of the key benefits of Java.
Sun identifies “Write once, run anywhere” as the core value proposition of the Java platform.
It is built into the popular web browsers, which places it on virtually every Internet-connected PC in the world.
It is even being built into consumer electronic devices such as television set-top boxes, PDAs, and cell phones.
Both the language and the platform were designed from the ground up with security in mind.
The Java platform allows users to download untrusted code over a network and run it in a secure environment in which it cannot do any harm: untrusted code cannot infect the host system with a virus, cannot read or write files from the hard drive, and so forth.
It made security levels and restrictions highly configurable and extended them beyond applets.
As of Java 1.2, any Java code, whether it is an applet, a servlet, a JavaBeans component, or a complete Java application, can be run with restricted permissions that prevent it from doing harm to the host system.
The security features of the Java language and platform have been subjected to intense scrutiny by security experts around the world.
In the earlier days of Java, security-related bugs, some of them potentially serious, were found and promptly fixed.
Because of the strong security promises Java makes, it is big news when a new security bug is found.
No other mainstream platform can make security guarantees nearly as strong as those Java makes.
No one can say that Java security holes will not be found in the future, but if Java’s security is not yet perfect, it has been proven strong enough for practical day-to-day use and is certainly better than any of the alternatives.
Sun’s corporate motto has always been “The network is the computer.” The designers of the Java platform believed in the importance of networking and designed the Java platform to be network-centric.
From a programmer’s point of view, Java makes it easy to work with resources across a network and to create network-based applications using client/server or multitier architectures.
Java code is organized in modular objectoriented units called classes.
Classes are stored in separate files and are loaded into the Java interpreter only when needed.
This means that an application can decide as it is running what classes it needs and can load them when it needs them.
It also means that a program can dynamically extend itself by loading the classes it needs to expand its functionality.
The network-centric design of the Java platform means that a Java application can dynamically extend itself by loading new classes over a network.
An application that takes advantage of these features ceases to be a monolithic block of code.
Instead, it becomes an interacting collection of independent software components.
Thus, Java enables a powerful new metaphor of application design and development.
The Java language and the Java platform were designed from the start with the rest of the world in mind.
The features permeate the Java platform, making it easier to write internationalized programs with Java than it is with any other environment.
As described earlier, Java programs are compiled to a portable intermediate form known as byte codes, rather than to native machine-language instructions.
The Java Virtual Machine runs a Java program by interpreting these portable bytecode instructions.
This architecture means that Java programs are faster than programs or scripts written in purely interpreted languages, but Java programs are typically slower than C and C++ programs compiled to native machine language.
Keep in mind, however, that although Java programs are compiled to byte code, not all of the Java platform is implemented with interpreted byte codes.
Although early releases of Java suffered from performance problems, the speed of the Java VM has improved dramatically with each new release.
The VM has been highly tuned and optimized in many significant ways.
Furthermore, most current implementations include a just-in-time (JIT) compiler, which converts Java byte codes to native machine instructions on the fly.
Using sophisticated JIT compilers, Java programs can execute at speeds comparable to the speeds of native C and C++ applications.
Java is a portable, interpreted language; Java programs run almost as fast as native, nonportable C and C++ programs.
Performance used to be an issue that made some programmers avoid using Java.
The final, and perhaps most important, reason to use Java is that programmers like it.
Java is an elegant language combined with a powerful and (usually) well-designed set of APIs.
Programmers enjoy programming in Java and are often amazed at how.
Because Java is a simple and elegant language with a well-designed, intuitive set of APIs, programmers write better code with fewer bugs than for other platforms, thus reducing development time.
Before we look at how the program works, we must first discuss how to run it.
In order to compile and run the program, you need a Java development kit (JDK) of some sort.
Sun Microsystems created the Java language and ships a free JDK for its Solaris operating system and also for Linux and Microsoft Windows platforms.† At the time of this writing, the current version of Sun’s JDK is available for download from http://java.sun.com.
The JRE enables you to run existing Java programs, but not to write and compile your own.
The factorial of an integer is the product of the number and all positive integers less than the number.
Other companies, such as Apple, have licensed and ported the JDK to their operating systems.
In Apple’s case, this arrangement leads to a delay in the latest JDK being available on that platform.
The Sun JDK is not the only Java programming environment you can use.
A number of companies sell Java IDEs (integrated development environments), and high-quality open-source IDEs are also available.
This book assumes that you are using Sun’s JDK and its accompanying command-line tools.
If you are using a product from some other vendor, be sure to read that vendor’s documentation to learn how to compile and run a simple program, like that shown in Example 1-1
Once you have a Java programming environment installed, the first step towards running our program is to type it in.
Using your favorite text editor, enter the program as it is shown in Example 1-1.* Omit the line numbers, which are just for reference.
Note that Java is a case-sensitive language, so you must type lowercase letters in lowercase and uppercase letters in uppercase.
You’ll notice that many of the lines of this program end with semicolons.
It is a common mistake to forget these characters, but the program won’t work without them, so be careful! You can omit everything from // to the end of a line: those are comments that are there for your benefit and are ignored by Java.
When writing Java programs, you should use a text editor that saves files in plaintext format, not a word processor that supports fonts and formatting and saves files in a proprietary format.
If you use a Windows system, you might use Notepad or WordPad, if you don’t have a more specialized programmer’s editor (versions of GNU Emacs, for example, are available for Windows)
If you are using an IDE, it should include an appropriate text editor; read the documentation that came with the product.
When you are done entering the program, save it in a file named Factorial.java.
This is important; the program will not work if you save it by any other name.
After writing a program like this one, the next step is to compile it.
With Sun’s JDK, the Java compiler is known as javac.
If this command prints any error messages, you probably got something wrong when you typed in the program.
If it does not print any error messages, however, the compilation has succeeded, and javac creates a file called Factorial.class.
Once you have compiled a Java program, you must still run it.
Java programs are not compiled into native machine language, so they cannot be executed directly by the system.
Instead, they are run by another program known as the Java interpreter.
In Sun’s JDK, the interpreter is a command-line program named, appropriately enough, java.
I recommend that you type this example in by hand, to get a feel for the language.
If you really don’t want to, however, you can download this, and all examples in the book, from http://www.
Congratulations! You’ve just written, compiled, and run your first Java program.
Try running it again to compute the factorials of some other numbers.
Now that you have run the factorial program, let’s analyze it line by line to see what makes a Java program tick.
The first three lines of the program are a comment.
Java ignores them, but they tell a human programmer what the program does.
Any amount of text, including multiple lines of text, may appear between these characters.
If the characters // appear in a Java program, Java ignores those characters and any other text that appears between those characters and the end of the line.
A class is the fundamental unit of program structure in Java, so it is not surprising that the first line of our program declares a class.
All Java programs are classes, although some programs use many classes instead of just one.
Java is an object-oriented programming language, and classes are a fundamental part of the object-oriented paradigm.
Example 1-1 is not really an object-oriented program, however, so I’m not going to go into detail about classes and objects here.
For now, all you need to understand is that a class defines a set of interacting members.
The Factorial class contains two members, both of which are methods.
Line 5 begins the definition of a method of our Factorial class.
A Java program can call, or invoke, a method to execute the code in it.
If you have programmed in other languages, you have probably seen methods before, but they may have been called functions, procedures, or subroutines.
The interesting thing about methods is that they have parameters and return values.
When you call a method, you pass it some data you want it to operate on, and it returns a result to you.
Here, the mathematical function f performs some computation on the value represented by x and returns a value, which we represent by y.
To return to line 5, the public and static keywords are modifiers.
The void keyword specifies the return value of the method.
In this case, it specifies that this method does not have a return value.
When the main() method finishes, the program is done, and the Java interpreter exits.
In other words, the main() method is the main entry point into a Java program.
It is not actually sufficient for a method to be named main( ), however.
In fact, the only part of line 5 you can change is the word args, which you can replace with any word you want.
You’ll be using this line in all of your Java programs, so go ahead and commit it to memory now!
Following the name of the main() method is a list of method parameters in parentheses.
String[] specifies the type of the parameter, which is an array of strings (i.e., a numbered list of strings of text)
In the algebraic equation f(x), x is simply a way of referring to an unknown value.
As we’ll see, the name args is used in the body of the method to refer to the unknown value that is passed to the method.
All Java programs that are run directly by the Java interpreter must have a main() method.
It is possible to write programs that are not run directly by the interpreter, but are dynamically loaded into some other already running Java program.
Examples are applets, which are programs run by a web browser, and servlets, which are programs run by a web server.
Applets are discussed in Java Foundation Classes in a Nutshell (O’Reilly) while servlets are discussed in Java Enterprise in a Nutshell (O’Reilly)
By convention, when this book refers to a method, it follows the name of the method by a pair of parentheses.
As you’ll see, parentheses are an important part of method syntax, and they serve here to keep method names distinct from the names of classes, fields, variables, and so on.
As I’ve just explained, the main() method is a special one that is called by the Java interpreter when it starts running a Java class (program)
More precisely, an array of strings containing only one entry, 4, is passed to main()
Our program looks only at the first string in the array, so the other strings are ignored.
Finally, the last thing on line 5 is an open curly brace.
Methods are composed of statements, which the Java interpreter executes in sequential order.
Each statement ends with a semicolon to separate it from the next.
This is an important part of Java syntax; beginning programmers often forget the semicolons.
The first statement of the main() method, line 6, declares a variable and assigns a value to it.
In any programming language, a variable is simply a symbolic name for a value.
We’ve already seen that, in this program, the name args refers to the parameter value passed to the main() method.
It is also possible for methods to declare additional “local” variables.
Methods can use local variables to store and reference the intermediate values they use while performing their computations.
That line begins with the words int input, which declare a variable named input and specify that the variable has the type int; that is, it is an integer.
Java can work with several different types of values, including integers, real or floating-point numbers, characters (e.g., letters and digits), and strings of text.
Java is a strongly typed language, which means that all variables must have a type specified and can refer only to values of that type.
Our input variable always refers to an integer, so it cannot refer to a floating-point number or a string.
Recall that the args parameter had a type of String[ ]
Continuing with line 6, the variable declaration int input is followed by the = character.
This is the assignment operator in Java; it sets the value of a variable.
When reading Java code, don’t read = as “equals,” but instead read it as “is assigned the value.” As we’ll see in Chapter 2, there is a different operator for “equals.”
As you might guess, this method “parses” an integer; that is, it converts a string representation of an integer, such.
Every Java program can use the powerful set of classes and methods defined by this core API.
The second half of this book is a quick reference that documents that core API.
It declares a variable and assigns a value to it.
The value assigned to the variable is computed by invoking a method.
The variable is named result, and it has a type of double.
The variable is assigned a value that is computed by the factorial( ) method.
The factorial() method, however, is not part of the standard Java API.
We’ll consider the body of the factorial() method shortly, but you can surmise from its name that this method takes an input value, computes the factorial of that value, and returns the result.
This commonly used method is part of the core Java API; it causes the Java interpreter to print out a value.
In this case, the value that it prints is the value referred to by the variable named result.
There is no variable declaration or = assignment operator in this statement since there is no value to assign to anything.
These variable and parameter names have meaning only within the main( ) method and cannot be used elsewhere in the program unless other parts of the program declare different variables or parameters that happen to have the same name.
You can insert blank lines and spaces anywhere in a program, and you should use them liberally to make the program readable.
You’ll notice that the program also uses whitespace to indent the various lines of code.
This kind of indentation is optional; it emphasizes the structure of the program and greatly enhances the readability of the code.
Line 11 begins the definition of the factorial() method that was used by the main( ) method.
Compare this line to line 5 to note its similarities and differences.
The factorial( ) method has the same public and static modifiers.
It takes a single integer parameter, which we call x.
Unlike the main( ) method, which had no return value (void), factorial( ) returns a value of type double.
In the main() method, we saw variable declarations, assignments, and method invocations.
It is an if statement, which executes another statement conditionally.
We saw earlier that the Java interpreter executes the three statements of the main() method one after another.
It always executes them in exactly that way, in exactly that order.
An if statement is a flowcontrol statement; it can affect the way the interpreter runs a program.
The if keyword is followed by a parenthesized expression and a statement.
If the expression is false, however, the interpreter skips the statement and goes to the next one.
It checks whether the value passed to the factorial() method is less than zero.
If it is, this expression is true, and the statement on line 13 is executed.
Semicolons are required only at the end of a statement.
It says that the return value of the factorial( ) method is 0.0
When the Java interpreter sees a return, it stops executing the current method and returns the specified value immediately.
Java ignores this indentation, but it is very helpful for humans who read Java code.
It is an error to try to compute a factorial for a negative number, so these lines make sure that the input value x is valid.
If it is not valid, they cause factorial( ) to return a consistent invalid result, 0.0
This variable holds the value of the factorial as we compute it in the statements that follow.
In Java, variables can be declared anywhere; they are not restricted to the beginning of a method or block of code.
Line 15 introduces another type of statement: the while loop.
Like an if statement, a while statement consists of a parenthesized expression and a statement.
When the Java interpreter sees a while statement, it evaluates the associated expression.
If that expression is true, the interpreter executes the statement.
The interpreter repeats this process, evaluating the expression and executing the statement if the expression is true, until the expression evaluates to false.
We can assume from this expression that if the loop is ever going to terminate, the value of x must somehow be modified by the statement that the loop executes.
A compound statement is zero or more statements grouped between curly braces.
The while keyword on line 15 is followed by an expression in parentheses and then by an open curly brace.
Earlier in the chapter, I said that all Java statements end with semicolons.
Line 16 multiplies the value of fact by the value of x and stores the result back into fact.
It subtracts 1 from the value of x and stores the result back into x.
And, as you can probably guess, the – on line 17 is the subtraction operator.
An operator is a key part of Java syntax: it performs a computation on one or two operands to produce a new value.
The value of this expression is a boolean truth value—either true or false, depending on the result of the comparison.
To understand this while loop, it is helpful to think like the Java interpreter.
This one does not return a constant value like 0.0, but instead returns the value of the fact variable.
Recall that the factorial() method was invoked on line 7 of the program.
When this return statement is executed, control returns to line 7, where the return value is assigned to the variable named result.
There is one more important feature of Java programming I want to introduce, but it is one that does not appear in the program listing itself.
Recall that the program computes the factorial of the number you specify on the command line.
What happens if you run the program without specifying a number?
And what happens if you specify a value that is not a number?
If you didn’t understand all the details of this factorial program, don’t worry.
We’ll cover the details of the Java language a lot more thoroughly in subsequent chapters.
However, if you feel like you didn’t understand any of the line-by-line analysis, you may also find that the upcoming chapters are over your head.
In that case, you should probably go elsewhere to learn the basics of the Java language and return to this book to solidify your understanding, and, of course, to use as a reference.
One resource you may find useful in learning the language is Sun’s online Java tutorial, available at http://java.sun.com/docs/books/tutorial.
In both cases, an error occurs or, in Java terminology, an exception is thrown.
When an exception is thrown, the Java interpreter prints a message that explains what type of exception it was and where it occurred (both exceptions above occurred on line 6)
In the first case, the exception is thrown because there are no strings in the args list, meaning we asked for a nonexistent string with args[0]
We’ll see more about exceptions in Chapter 2 and learn how to handle them gracefully as they occur.
This chapter is a terse but comprehensive introduction to Java syntax.
It is written primarily for readers who are new to the language but have at least some previous programming experience.
Determined novices with no prior programming experience may also find it useful.
If you already know Java, you should find it a useful language reference.
The chapter includes comparisons of Java to C and C++ for the benefit of programmers coming from those languages.
This chapter documents the syntax of Java programs by starting at the very lowest level of Java syntax and building from there, covering increasingly higher orders of structure.
The characters used to write Java programs and the encoding of those characters.
Literal values, identifiers, and other tokens that comprise a Java program.
The operators used in Java to group individual tokens into larger expressions.
Statements, which group expressions and other statements to form logical chunks of Java code.
Methods (also called functions, procedures, or subroutines), which are named collections of Java statements that can be invoked by other Java code.
Classes are the central program element in Java and form the basis for object-oriented programming.
Chapter 3 is devoted entirely to a discussion of classes and objects.
Java programs, which consist of one or more interacting classes that may be drawn from one or more packages.
The syntax of most programming languages is complex, and Java is no exception.
In general, it is not possible to document all elements of a language without referring to other elements that have not yet been discussed.
But it is also not possible to document objects thoroughly without referring to the operators and statements of the language.
The process of learning Java, or any language, is therefore an iterative one.
If you are new to Java (or a Java-style programming language), you may find that you benefit greatly from working through this chapter and the next twice, so that you can grasp the interrelated concepts.
Java Programs from the Top Down Before we begin our bottom-up exploration of Java syntax, let’s take a moment for a top-down overview of a Java program.
Java programs consist of one or more files, or compilation units, of Java source code.
Near the end of the chapter, we describe the structure of a Java file and explain how to compile and run a Java program.
Each compilation unit begins with an optional package declaration followed by zero or more import declarations.
These declarations specify the namespace within which the compilation unit will define names, and the namespaces from which the compilation unit imports names.
We’ll see package and import again in “Packages and the Java Namespace” later in this chapter.
The optional package and import declarations are followed by zero or more reference type definitions.
These are typically class or interface definitions, but in Java 5.0 and later, they can also be enum definitions or annotation definitions.
Type definitions include members such as fields, methods, and constructors.
Most statements include expressions, which are built using operators and values known as primitive data types.
Finally, the keywords used to write statements, the punctuation characters that represent operators, and the literals values that appear in a program are all tokens, which are described next.
As the name of this section implies, this chapter moves from describing the smallest units, tokens, to progressively larger units.
Since the concepts build upon one another, we recommend reading this chapter sequentially.
Lexical Structure This section explains the lexical structure of a Java program.
It starts with a discussion of the Unicode character set in which Java programs are written.
It then covers the tokens that comprise a Java program, explaining comments, identifiers, reserved words, literals, and so on.
You can use Unicode characters anywhere in a Java program, including comments and identifiers such as variable names.
Thus, you can simply write plain ASCII programs, and they will work as valid Unicode.
If you ever need to include one of these (rarely used) supplementary characters in Java source code, use two \u sequences to represent the surrogate pair.
Details of surrogate pair encoding are beyond the scope of this book, however.
Its keywords are written in lowercase and must always be used that way.
That is, While and WHILE are not the same as the while keyword.
Similarly, if you declare a variable named i in your program, you may not refer to it as I.
Java ignores spaces, tabs, newlines, and other whitespace, except when it appears within quoted characters and string literals.
Programmers typically use whitespace to format and indent their code for easy readability, and you will see common indentation conventions in the code examples of this book.
Comments are natural-language text intended for human readers of a program.
The first type is a single-line comment, which begins with the characters // and continues until the end of the current line.
Although this style of comment is typically used for multiline comments, it can also be used for single-line comments.
When writing multiline comments, programmers often use extra * characters to make the comments stand out.
The third type of comment is a special case of the second.
If a comment begins with /**, it is regarded as a special doc comment.
Like regular multiline comments, doc comments end with */ and cannot be nested.
When you write a Java class you expect other programmers to use, use doc comments to embed documentation about the class and each of its methods directly into the source code.
A program named javadoc extracts these comments and processes them to create online documentation for your class.
A doc comment can contain HTML tags and can use additional syntax understood by javadoc.
Comments may appear between any tokens of a Java program, but may not appear within a token.
In particular, comments may not appear within doublequoted string literals.
A comment within a string literal simply becomes a literal part of that string.
The following words are reserved in Java: they are part of the syntax of the language and may not be used to name variables, classes, and so forth.
We’ll meet each of these reserved words again later in this book.
Some of them are the names of primitive types and others are the names of Java statements, both of which are discussed later in this chapter.
Still others are used to define classes and their members (see Chapter 3)
Note that const and goto are reserved but aren’t actually used in the language.
An identifier is simply a name given to some part of a Java program, such as a class, a method within a class, or a variable declared within a method.
An identifier may not begin with a digit, however, because the compiler would then think it was a numeric literal rather than an identifier.
Literals are values that appear directly in Java source code.
They include integer and floating-point numbers, characters within single quotes, strings of characters within double quotes, and the reserved words true, false and null.
The syntax for expressing numeric, character, and string literals is detailed in “Primitive Data Types” later in this chapter.
Java also uses a number of punctuation characters as tokens.
The Java Language Specification divides these characters (somewhat arbitrarily) into two categories, separators and operators.
We’ll see separators throughout the book, and will cover each operator individually in “Expressions and Operators” later in this chapter.
Primitive Data Types Java supports eight basic data types known as primitive types as described in Table 2-1
The primitive types include a boolean type, a character type, four integer types, and two floating-point types.
The four integer types and the two floatingpoint types differ in the number of bits that represent them and therefore in the.
In addition to these primitive types, Java supports nonprimitive data types such as classes, interfaces, and arrays.
These composite types are known as reference types, which are introduced in “Reference Types” later in this chapter.
This type has only two possible values, representing the two boolean states: on or off, yes or no, true or false.
Java reserves the words true and false to represent these two boolean values.
In particular, a boolean is not an integral type, and integer values cannot be used in place of a boolean.
In other words, you cannot take shortcuts such as the following in Java:
Instead, Java forces you to write cleaner code by explicitly stating the comparisons you want:
It surprises many experienced programmers to learn that Java char values are 16 bits long, but in practice this fact is totally transparent.
To include a character literal in a Java program, simply place it between single quotes (apostrophes):
You can, of course, use any Unicode character as a character literal, and you can use the \u Unicode escape sequence.
In addition, Java supports a number of other escape sequences that make it easy both to represent commonly used nonprinting ASCII characters such as newline and to escape certain punctuation characters that have special meaning in Java.
Table 2-2 lists the escape characters that can be used in char literals.
These characters can also be used in string literals, which are covered in the next section.
Unlike byte, short, int, and long, however, char is an unsigned type.
The Character class defines a number of useful static methods for working with characters, including isDigit( ), isJavaLetter( ), isLowerCase( ), and toUpperCase( )
The Java language and its char type were designed with Unicode in mind.
The Unicode standard is evolving, however, and each new version of Java adopts the latest version of Unicode.
These supplementary characters, which are mostly infrequently used Han (Chinese) ideographs, occupy 21 bits and cannot be represented in a single char value.
Instead, you must use an int value to hold the codepoint of a supplementary character, or you must encode it into a so-called “surrogate pair” of two char values.
Unless you commonly write programs that use Asian languages, you are unlikely to encounter any supplementary characters.
If you do anticipate having to process characters that do not fit into a char, Java 5.0 has added methods to the Character, String, and related classes for working with text using int codepoints.
Unicode escapes can appear anywhere in a Java program, not only in character and string literals.
In addition to the char type, Java also has a data type for working with strings of text (usually simply called strings)
The String type is a class, however, and is not one of the primitive types of the language.
Because strings are so commonly used, though, Java does have a syntax for including string values literally in a program.
A String literal consists of arbitrary text within double quotes.
String literals can contain any of the escape sequences that can appear as char literals (see Table 2-2)
Since String is a reference type, string literals are described in more detail in “Object Literals” later in this chapter.
Chapter 5 demonstrates some of the ways you can work with String objects in Java.
The integer types in Java are byte, short, int, and long.
As shown in Table 2-1, these four types differ only in the number of bits and, therefore, in the range of numbers each type can represent.
All integral types represent signed numbers; there is no unsigned keyword as there is in C and C++
Literals for each of these types are written exactly as you would expect: as a string of decimal digits, optionally preceded by a minus sign.* Here are some legal integer literals:
Integer literals can also be expressed in hexadecimal or octal notation.
Java does not allow integer literals to be expressed in binary (base-2) notation.
Technically, the minus sign is an operator that operates on the literal, but is not part of the literal itself.
There is no special syntax for byte and short literals, but int literals are usually converted to these shorter types as needed.
Integer arithmetic in Java is modular, which means that it never produces an overflow or an underflow when you exceed the range of a given integer type.
Neither the Java compiler nor the Java interpreter warns you in any way when this occurs.
When doing integer arithmetic, you simply must ensure that the type you are using has a sufficient range for the purposes you intend.
Each integer type has a corresponding wrapper class: Byte, Short, Integer, and Long.
The classes also define useful static methods, such as Byte.
Real numbers in Java are represented by the float and double data types.
Both types adhere to the IEEE 754-1985 standard, which specifies both the format of the numbers and the behavior of arithmetic for the numbers.
Floating-point values can be included literally in a Java program as an optional string of digits, followed by a decimal point and another string of digits.
Floating-point literals can also use exponential, or scientific, notation, in which a number is followed by the letter e or E (for exponent) and another number.
This second number represents the power of ten by which the first number is multiplied.
To include a float value literally in a program, follow the number with f or F:
Floating-point literals cannot be expressed in hexadecimal or octal notation.
Most real numbers, by their very nature, cannot be represented exactly in any finite number of bits.
Thus, it is important to remember that float and double values are only approximations of the numbers they are meant to represent.
In practice, these data types are suitable for most real-number computations.
In addition to representing ordinary numbers, the float and double types can also represent four special values: positive and negative infinity, zero, and NaN.
The infinity values result when a floating-point computation produces a value that overflows the representable range of a float or double.
When a floating-point computation underflows the representable range of a float or a double, a zero value results.
The Java floating-point types make a distinction between positive zero and negative zero, depending on the direction from which the underflow occurred.
In practice, positive and negative zero behave pretty much the same.
Finally, the last special floating-point value is NaN, which stands for “not-a-number.” The NaN value results when an illegal floating-point operation, such as 0.0/0.0, is performed.
Here are examples of statements that result in these special values:
Because the Java floating-point types can handle overflow to infinity and underflow to zero and have a special NaN value, floating-point arithmetic never throws exceptions, even when performing illegal operations, like dividing zero by zero or taking the square root of a negative number.
The float and double primitive types have corresponding classes, named Float and Double.
Adding or subtracting any finite value to or from infinity, for example, yields infinity.
Negative zero behaves almost identically to positive zero, and, in fact, the = = equality operator reports that negative zero is equal to positive zero.
One way to distinguish negative zero from positive, or regular, zero is to divide by it.
Finally, since NaN is not-a-number, the = = operator says that it is not equal to any other number, including itself! To check whether a float or double value is NaN, you must use the Float.isNaN( ) and Double.isNaN( ) methods.
In addition, because every character corresponds to a number in the Unicode encoding, char values can be converted to and from the integer and floating-point types.
In fact, boolean is the only primitive type that cannot be converted to or from another primitive type in Java.
A widening conversion occurs when a value of one type is converted to a wider type—one that has a larger range of legal.
Java performs widening conversions automatically when, for example, you assign an int literal to a double variable or a char literal to an int variable.
A narrowing conversion occurs when a value is converted to a type that is not wider than it is.
Because you can lose data in a narrowing conversion, the Java compiler complains when you attempt any narrowing conversion, even if the value being converted would in fact fit in the narrower range of the specified type:
The one exception to this rule is that you can assign an integer literal (an int value) to a byte or short variable if the literal falls within the range of the variable.
If you need to perform a narrowing conversion and are confident you can do so without losing data or precision, you can force Java to perform the conversion using a language construct known as a cast.
Perform a cast by placing the name of the desired type in parentheses before the value to be converted.
Casts of primitive types are most often used to convert floating-point values to integers.
When you do this, the fractional part of the floating-point value is simply truncated (i.e., the floating-point value is rounded towards zero, not towards the nearest integer)
The methods Math.round( ), Math.floor( ), and Math.ceil( ) perform other types of rounding.
The char type acts like an integer type in most ways, so a char value can be used anywhere an int or long value is required.
Recall, however, that the char type is unsigned, so it behaves differently than the short type, even though both are 16 bits wide:
Table 2-3 shows which primitive types can be converted to which other types and how the conversion is performed.
The letter N in the table means that the conversion cannot be performed.
The letter Y means that the conversion is a widening conversion and is therefore performed automatically and implicitly by Java.
The letter C means that the conversion is a narrowing conversion and requires an explicit cast.
Finally, the notation Y* means that the conversion is an automatic widening conversion, but that some of the least significant digits of the value may be lost in the conversion.
This can happen when converting an int or long to a float or double.
The floating-point types have a larger range than the integer types, so any int or long can be represented by a float or double.
However, the floating-point types are approximations of numbers and cannot always hold as many significant digits as the integer types.
Expressions and Operators So far in this chapter, we’ve learned about the primitive types that Java programs can manipulate and seen how to include primitive values as literals in a Java program.
We’ve also used variables as symbolic names that represent, or hold, values.
These literals and variables are the tokens out of which Java programs are built.
An expression is the next higher level of structure in a Java program.
The Java interpreter evaluates an expression to compute its value.
The very simplest expressions are called primary expressions and consist of literals and variables.
When the Java interpreter evaluates a literal expression, the resulting value is the literal itself.
When the interpreter evaluates a variable expression, the resulting value is the value stored in the variable.
More complex expressions are made by using operators to combine primary expressions.
For example, the following expression uses the assignment operator to combine two primary expressions—a variable and a floating-point literal—into an assignment expression:
But operators are used not only with primary expressions; they can also be used with expressions at any level of complexity.
The kinds of expressions you can write in a programming language depend entirely on the set of operators available to you.
The P and A columns of the table specify the precedence and associativity of each group of related operators, respectively.
These concepts—and the operators themselves—are explained in more detail in the following sections.
The P column of Table 2-4 specifies the precedence of each operator.
The multiplication operator has higher precedence than the addition operator, so a is added to the product of b and c.
Operator precedence can be thought of as a measure of how tightly operators bind to their operands.
Default operator precedence can be overridden through the use of parentheses that explicitly specify the order of operations.
The previous expression can be rewritten as follows to specify that the addition should be performed before the multiplication:
The default operator precedence in Java was chosen for compatibility with C; the designers of C chose this precedence so that most expressions can be written naturally without parentheses.
There are only a few common Java idioms for which parentheses are required.
When an expression involves several operators that have the same precedence, the operator associativity governs the order in which the operations are performed.
Most operators are left-to-right associative, which means that the operations are performed from left to right.
The A column of Table 2-4 specifies the associativity of each operator or group of operators.
The value L means left to right, and R means right to left.
The additive operators are all left-to-right associative, so the expression a+b-c is evaluated from left to right: (a+b)-c.
Unary operators and assignment operators are evaluated from right to left.
As with operator precedence, operator associativity establishes a default order of evaluation for an expression.
This default order can be overridden through the use of parentheses.
However, the default operator associativity in Java has been chosen to yield a natural expression syntax, and you rarely need to alter it.
The fourth column of Table 2-4 specifies the number and type of the operands expected by each operator.
Some operators operate on only one operand; these are called unary operators.
For example, the unary minus operator changes the sign of a single number:
Most operators, however, are binary operators that operate on two operand values.
Java also defines one ternary operator, often called the conditional operator.
Its three operands are separated by a question mark and a colon; the second and third operands must be convertible to the same type:
In addition to expecting a certain number of operands, each operator also expects particular types of operands.
Some of the codes used in that column require further explanation:
In Java 5.0 and later, autounboxing (see “Boxing and Unboxing Conversions” later in this chapter) means that the wrapper classes (such as Character, Integer, and Double) for these types can be be used in this context as well.
Just as every operator expects its operands to be of specific types, each operator produces a value of a specific type.
The arithmetic, increment and decrement, bitwise, and shift operators return a double if at least one of the operands is a double.
They return a float if at least one of the operands is a float.
They return a long if at least one of the operands is a long.
Otherwise, they return an int, even if both operands are byte, short, or char types that are narrower than int.
The comparison, equality, and boolean operators always return boolean values.
Each assignment operator returns whatever value it assigned, which is of a type compatible with the variable on the left side of the expression.
Every operator computes a value based on one or more operand values.
Some operators, however, have side effects in addition to their basic evaluation.
If an expression contains side effects, evaluating it changes the state of a Java program in such a way that evaluating the expression again may yield a different result.
For example, the ++ increment operator has the side effect of incrementing a variable.
The expression ++a increments the variable a and returns the newly incremented value.
If this expression is evaluated again, the value will be different.
The value of the expression is the value of a multiplied by 2, but the expression also has the side effect of storing that value back into a.
The method invocation operator ( ) has side effects if the invoked method has side effects.
Some methods, such as Math.sqrt( ), simply compute and return a value without side effects of any kind.
Finally, the new operator has the profound side effect of creating a new object.
When the Java interpreter evaluates an expression, it performs the various operations in an order specified by the parentheses in the expression, the precedence of the operators, and the associativity of the operators.
Before any operation is performed, however, the interpreter first evaluates the operands of the operator.
The interpreter always evaluates operands in order from left to right.
This matters if any of the operands are expressions that contain side effects.
Although the multiplication is performed before the addition, the operands of the + operator are evaluated first.
Since most programs operate primarily on numbers, the most commonly used operators are often those that perform arithmetic operations.
The arithmetic operators can be used with integers, floating-point numbers, and even characters (i.e., they can be used with any primitive type other than boolean)
If either of the operands is a floating-point number, floating-point arithmetic is used; otherwise, integer arithmetic is used.
This matters because integer arithmetic and floatingpoint arithmetic differ in the way division is performed and in the way underflows and overflows are handled, for example.
As we’ll see shortly, the + operator can also be used to concatenate strings.
If either operand of + is a string, the other.
Be sure to use parentheses when you want to combine addition with concatenation.
Subtraction (-) When the - operator is used as a binary operator, it subtracts its second operand from its first.
Division (/) The / operator divides its first operand by its second.
If both operands are integers, the result is an integer, and any remainder is lost.
If either operand is a floating-point value, however, the result is a floating-point value.
For floating-point calculations, however, division by zero simply yields an infinite result or NaN:
Modulo (%) The % operator computes the first operand modulo the second operand (i.e., it returns the remainder when the first operand is divided by the second operand an integral number of times)
The sign of the result is the same as the sign of the first operand.
While the modulo operator is typically used with integer operands, it also works for floating-point values.
When working with floating-point values, anything modulo 0.0 evaluates to NaN, as does infinity modulo anything.
Unary minus (-) When the - operator is used as a unary operator—that is, before a single operand—it performs unary negation.
In other words, it converts a positive value to an equivalently negative value, and vice versa.
In addition to adding numbers, the + operator (and the related += operator) also concatenates, or joins, strings.
If either of the operands to + is a string, the operator converts the other operand to a string.
As a result, you must be careful to put any addition expressions in parentheses when combining them with string concatenation.
If you do not, the addition operator is interpreted as a concatenation operator.
The Java interpreter has built-in string conversions for all primitive types.
An object is converted to a string by invoking its toString( ) method.
Some classes define custom toString( ) methods so that objects of that class can easily be converted to strings in this way.
An array is converted to a string by invoking the built-in toString( ) method, which, unfortunately, does not return a useful string representation of the array contents.
The ++ operator increments its single operand, which must be a variable, an element of an array, or a field of an object, by one.
The behavior of this operator depends on its position relative to the operand.
When used before the operand, where it is known as the pre-increment operator, it increments the operand and evaluates to the incremented value of that operand.
When used after the operand, where it is known as the post-increment operator, it increments its operand, but evaluates to the value of that operand before it was incremented.
For example, the following code sets both i and j to 2:
Similarly, the -- operator decrements its single numeric operand, which must be a variable, an element of an array, or a field of an object, by one.
Like the ++ operator, the behavior of -- depends on its position relative to the operand.
When used before the operand, it decrements the operand and returns the decremented value.
When used after the operand, it decrements the operand, but returns the undecremented value.
If x is itself an expression with side effects, this makes a big difference.
These operators, in both prefix and postfix forms, are most commonly used to increment or decrement the counter that controls a loop.
The comparison operators consist of the equality operators that test values for equality or inequality and the relational operators used with ordered types (numbers and characters) to test for greater than and less than relationships.
Both types of operators yield a boolean result, so they are typically used with if statements and while and for loops to make branching and looping decisions.
Equals (= =) The = = operator evaluates to true if its two operands are equal and false otherwise.
With primitive operands, it tests whether the operand values themselves are identical.
For operands of reference types, however, it tests whether the operands refer to the same object or array.
In other words, it does not test the equality of two distinct objects or arrays.
In particular, note that you cannot test two distinct strings for equality with this operator.
If = = is used to compare two numeric or character operands that are not of the same type, the narrower operand is converted to the type of the wider operand before the comparison is done.
For example, when comparing a short to a float, the short is first converted to a float before the comparison is performed.
For floating-point numbers, the special negative zero value tests equal to the regular, positive zero value.
Also, the special NaN (not-a-number) value is not equal to any other number, including itself.
To test whether a floating-point value is NaN, use the Float.isNan( ) or Double.isNan( ) method.
Not equals (!=) The != operator is exactly the opposite of the = = operator.
It evaluates to true if its two primitive operands have different values or if its two reference operands refer to different objects or arrays.
The relational operators can be used with numbers and characters, but not with boolean values, objects, or arrays because those types are not ordered.
Less than (<) Evaluates to true if the first operand is less than the second.
Less than or equal (<=) Evaluates to true if the first operand is less than or equal to the second.
Greater than (>) Evaluates to true if the first operand is greater than the second.
Greater than or equal (>=) Evaluates to true if the first operand is greater than or equal to the second.
As we’ve just seen, the comparison operators compare their operands and yield a boolean result, which is often used in branching and looping statements.
In order to make branching and looping decisions based on conditions more interesting than a single comparison, you can use the boolean (or logical) operators to combine multiple comparison expressions into a single, more complex expression.
The boolean operators require their operands to be boolean values and they evaluate to boolean values.
Conditional AND (&&) This operator performs a boolean AND operation on its operands.
It evaluates to true if and only if both its operands are true.
If either or both operands are false, it evaluates to false.
This operator (and all the boolean operators except the unary ! operator) have a lower precedence than the comparison operators.
Thus, it is perfectly legal to write a line of code like the one above.
However, some programmers prefer to use parentheses to make the order of evaluation explicit:
You should use whichever style you find easier to read.
This operator is called a conditional AND because it conditionally evaluates its second operand.
If the first operand evaluates to false, the value of the expression is false, regardless of the value of the second operand.
Therefore, to increase efficiency, the Java interpreter takes a shortcut and skips the second operand.
Since the second operand is not guaranteed to be evaluated, you must use caution when using this operator with expressions that have side effects.
On the other hand, the conditional nature of this operator allows us to write Java expressions such as the following:
The second and third comparisons in this expression would cause errors if the first or second comparisons evaluated to false.
Fortunately, we don’t have to worry about this because of the conditional behavior of the && operator.
Conditional OR (||) This operator performs a boolean OR operation on its two boolean operands.
It evaluates to true if either or both of its operands are true.
If the first operand evaluates to true, the value of the expression is true, regardless of the value of the second operand.
Thus, the operator simply skips the second operand in that case.
This unary operator changes the boolean value of its operand.
If applied to a true value, it evaluates to false, and if applied to a false value, it evaluates to true.
Because ! is a unary operator, it has a high precedence and often must be used with parentheses:
This operator is almost always used as a bitwise operator with integer operands, however, and many Java programmers would not even recognize its use with boolean operands as legal Java code.
Boolean OR (|) This operator performs a boolean OR operation on its two boolean operands.
It is like the || operator, except that it always evaluates both operands, even if the first one is true.
The | operator is almost always used as a bitwise operator on integer operands; its use with boolean operands is very rare.
Boolean XOR (^) When used with boolean operands, this operator computes the Exclusive OR (XOR) of its operands.
It evaluates to true if exactly one of the two operands is true.
In other words, it evaluates to false if both operands are false or if both operands are true.
The ^ operator is much more commonly used as a bitwise operator on integer operands.
With boolean operands, this operator is equivalent to the != operator.
The bitwise and shift operators are low-level operators that manipulate the individual bits that make up an integer value.
The bitwise operators are most commonly used for testing and setting individual flag bits in a value.
In order to understand their behavior, you must understand binary (base-2) numbers and the twos-complement format used to represent negative integers.
You cannot use these operators with floating-point, boolean, array, or object operands.
If either of the arguments to a bitwise operator is a long, the result is a long.
If the left operand of a shift operator is a long, the result is a long; otherwise, the result is an int.
It inverts each bit of its single operand, converting ones to zeros and zeros to ones.
Bitwise AND (&) This operator combines its two integer operands by performing a boolean AND operation on their individual bits.
The result has a bit set only if the corresponding bit is set in both operands.
When used with boolean operands, & is the infrequently used boolean AND operator described earlier.
Bitwise OR (|) This operator combines its two integer operands by performing a boolean OR operation on their individual bits.
The result has a bit set if the corresponding bit is set in either or both of the operands.
It has a zero bit only where both corresponding operand bits are zero.
When used with boolean operands, | is the infrequently used boolean OR operator described earlier.
Bitwise XOR (^) This operator combines its two integer operands by performing a boolean XOR (Exclusive OR) operation on their individual bits.
The result has a bit set if the corresponding bits in the two operands are different.
If the corresponding operand bits are both ones or both zeros, the result bit is a zero.
When used with boolean operands, ^ is the infrequently used boolean XOR operator.
High-order bits of the left operand are lost, and zero bits are shifted in from the right.
Shifting an integer left by n places is equivalent to multiplying that number by 2n.
The low-order bits of the left operand are shifted away and are lost.
The high-order bits shifted in are the same as the original high-order bit of the left operand.
In other words, if the left operand is positive, zeros are shifted into the high-order bits.
If the left operand is negative, ones are shifted in instead.
This technique is known as sign extension; it is used to preserve the sign of the left operand.
This technique is called zero extension; it is appropriate when the left operand is being treated as an unsigned value (despite the fact that Java integer types are all signed)
The assignment operators store, or assign, a value into some kind of variable.
The left operand must evaluate to an appropriate local variable, array element, or object field.
The right side can be any value of a type compatible with the variable.
An assignment expression evaluates to the value that is assigned to the variable.
More importantly, however, the expression has the side effect of actually performing the assignment.
Unlike all other binary operators, the assignment operators are right-associative, which means that the assignments in a=b=c are performed right-to-left, as follows: a=(b=c)
Do not confuse it with the equality operator, = =
In order to keep these two operators distinct, I recommend that you read = as “is assigned the value.”
For example, the += operator reads the value of the left variable, adds the value of the right operand to it, stores the sum back into the left variable as a side effect, and returns the sum as the value of the expression.
The difference between these two expressions is that when you use the += operator, the left operand is evaluated only once.
This makes a difference when that operand has a side effect.
This is equivalent (unless there are side effects in var) to:
The conditional operator ?: is a somewhat obscure ternary (three-operand) operator inherited from C.
It allows you to embed a conditional within an expression.
You can think of it as the operator version of the if/else statement.
The first and second operands of the conditional operator are separated by a question mark (?)
The second and third operands can be of any type, but they must be convertible to the same type.
If it is true, the operator evaluates its second operand and uses that as the value of the expression.
On the other hand, if the first operand is false, the conditional operator evaluates and returns its third operand.
The conditional operator never evaluates both its second and third operand, so be careful when using expressions with side effects with this operator.
Note that the ?: operator has lower precedence than all other operators except the assignment operators, so parentheses are not usually necessary around the operands of this operator.
Many programmers find conditional expressions easier to read if the first operand is placed within parentheses, however.
This is especially true because the conditional if statement always has its conditional expression written within parentheses.
The instanceof operator requires an object or array value as its left operand and the name of a reference type as its right operand.
It evaluates to true if the object or array is an instance of the specified type; it returns false otherwise.
If the left operand is null, instanceof always evaluates to false.
If an instanceof expression evaluates to true, it means that you can safely cast and assign the left operand to a variable of the type of the right operand.
The instanceof operator can be used only with reference types and objects, not primitive types and values.
Java has five language constructs that are sometimes considered operators and sometimes considered simply part of the basic language syntax.
These “operators” were included in Table 2-4 in order to show their precedence relative to the other.
The use of these language constructs is detailed elsewhere in this book but is described briefly here so that you can recognize them in code examples.
An object is a collection of data and methods that operate on that data; the data fields and methods of an object are called its members.
If o is an expression that evaluates to an object reference, and f is the name of a field of the object, o.f evaluates to the value contained in that field.
If m is the name of a method, o.m refers to that method and allows it to be invoked using the ( ) operator shown later.
Array element access ([ ]) An array is a numbered list of values.
Each element of an array can be referred to by its number, or index.
The [ ] operator allows you to refer to the individual elements of an array.
If a is an array, and i is an expression that evaluates to an int, a[i] refers to one of the elements of a.
Unlike other operators that work with integer values, this operator restricts array index values to be of type int or narrower.
Method invocation (( )) A method is a named collection of Java code that can be run, or invoked, by following the name of the method with zero or more comma-separated expressions contained within parentheses.
The values of these expressions are the arguments to the method.
The method processes the arguments and optionally returns a value that becomes the value of the method invocation expression.
If o.m is a method that expects no arguments, the method can be invoked with o.m( )
If the method expects three arguments, for example, it can be invoked with an expression such as o.m(x,y,z)
Before the Java interpreter invokes a method, it evaluates each of the arguments to be passed to the method.
These expressions are guaranteed to be evaluated in order from left to right (which matters if any of the arguments have side effects)
Object creation (new) In Java, objects (and arrays) are created with the new operator, which is followed by the type of the object to be created and a parenthesized list of arguments to be passed to the object constructor.
A constructor is a special method that initializes a newly created object, so the object creation syntax is similar to the Java method invocation syntax.
Type conversion or casting (( )) As we’ve already seen, parentheses can also be used as an operator to perform narrowing type conversions, or casts.
The first operand of this operator is the type to be converted to; it is placed between the parentheses.
The second operand is the value to be converted; it follows the parentheses.
Statements A statement is a single command executed by the Java interpreter.
By default, the Java interpreter runs one statement after another, in the order they are written.
Many of the statements defined by Java, however, are flow-control statements, such as conditionals and loops, that alter this default order of execution in welldefined ways.
As we saw earlier in the chapter, certain types of Java expressions have side effects.
In other words, they do not simply evaluate to some value; they also change the program state in some way.
Any expression with side effects can be used as a statement simply by following it with a semicolon.
The legal types of expression statements are assignments, increments and decrements, method calls, and object creation.
A compound statement is any number and kind of statements grouped together within curly braces.
You can use a compound statement anywhere a statement is required by Java syntax:
An empty statement in Java is written as a single semicolon.
The empty statement doesn’t do anything, but the syntax is occasionally useful.
For example, you can use it to indicate an empty loop body in a for loop:
A labeled statement is simply a statement that has been given a name by prepending an identifier and a colon to it.
A local variable, often simply called a variable, is a symbolic name for a location to store a value that is defined within a method or compound statement.
All variables must be declared before they can be used; this is done with a variable declaration statement.
Because Java is a strongly typed language, a variable declaration specifies the type of the variable, and only values of that type can be stored in the variable.
In its simplest form, a variable declaration specifies a variable’s type and name:
A variable declaration can also include an initializer: an expression that specifies an initial value for the variable.
The initializer expression need not be a literal value or a constant expression that can be evaluated by the compiler; it can be an arbitrarily complex expression whose value is computed when the program is run.
A single variable declaration statement can declare and initialize more than one variable, but all variables must be of the same type.
Variable names and optional initializers are separated from each other with commas:
In Java 1.1 and later, variable declaration statements can begin with the final keyword.
This modifier specifies that once an initial value is specified for the variable, that value is never allowed to change:
Local variable declarations can also be integrated with the initialize portion of a for loop, as we’ll discuss shortly.
Local variables can be used only within the method or block of code in which they are defined.
The if statement is the fundamental control statement that allows Java to make decisions or, more precisely, to execute statements conditionally.
If the expression evaluates to true, the interpreter executes the statement.
If the expression evaluates to false the interpreter skips the statement.
In Java 5.0, the expression may be of the wrapper type Boolean instead of the primitive type boolean.
Although they look extraneous, the parentheses around the expression are a required part of the syntax for the if statement.
As I already mentioned, a block of statements enclosed in curly braces is itself a statement, so we can also write if statements that look like this:
An if statement can include an optional else keyword that is followed by a second statement.
In this form of the statement, the expression is evaluated, and, if it is true, the first statement is executed.
When you use nested if/else statements, some caution is required to ensure that the else clause goes with the appropriate if statement.
In this example, the inner if statement forms the single statement allowed by the syntax of the outer if statement.
Unfortunately, it is not clear (except from the hint given by the indentation) which if the else goes with.
The rule is that an else clause like this is associated with the nearest if statement.
This is legal code, but it is clearly not what the programmer had in mind.
When working with nested if statements, you should use curly braces to make your code easier to read.
The if/else statement is useful for testing a condition and choosing between two statements or blocks of code to execute.
But what about when you need to choose between several blocks of code? This is typically done with an else if clause, which is not really new syntax, but a common idiomatic usage of the standard if/ else statement.
It is just a series of if statements, where each if is part of the else clause of the previous statement.
Using the else if idiom is preferable to, and more legible than, writing these statements out in their fully nested form:
An if statement causes a branch in the flow of a program’s execution.
You can use multiple if statements, as shown in the previous section, to perform a multiway branch.
This is not always the best solution, however, especially when all of the branches depend on the value of a single variable.
In this case, it is inefficient to repeatedly check the value of the same variable in multiple if statements.
A better solution is to use a switch statement, which is inherited from the C programming language.
Although the syntax of this statement is not nearly as elegant as other parts of Java, the brute practicality of the construct makes it worthwhile.
If you are not familiar with the switch statement itself, you may at least be familiar with the basic concept, under the name computed goto or jump table.
A switch statement starts with an expression whose type is an int, short, char, or byte.
In Java 5.0 Integer, Short, Character and Byte wrapper types are allowed, as are enumerated types.
For example, the following switch statement is equivalent to the repeated if and else/if statements shown in the previous section:
As you can see from the example, the various entry points into a switch statement are labeled either with the keyword case, followed by an integer value and a colon, or with the special default keyword, followed by a colon.
When a switch statement executes, the interpreter computes the value of the expression in parentheses and then looks for a case label that matches that value.
If it finds one, the interpreter starts executing the block of code at the first statement following the case label.
If it does not find a case label with a matching value, the interpreter starts execution at the first statement following a special-case default: label.
Or, if there is no default: label, the interpreter skips the body of the switch statement altogether.
Note the use of the break keyword at the end of each case in the previous code.
The break statement is described later in this chapter, but, in this case, it causes the interpreter to exit the body of the switch statement.
The case clauses in a switch statement specify only the starting point of the desired code.
The individual cases are not independent blocks of code, and they do not have any implicit ending point.
Therefore, you must explicitly specify the end of each case with a break or related statement.
In the absence of break statements, a switch statement begins executing code at the first statement after the matching case label and continues executing statements until it reaches the end of the block.
On rare occasions, it is useful to write code like this that falls through from one case label to the next, but 99% of the time you should be careful to end every case and default section with a statement that causes the switch statement to stop executing.
Normally you use a break statement, but return and throw also work.
A switch statement can have more than one case clause labeling the same statement.
The switch statement and its case labels have some important restrictions.
First, the expression associated with a switch statement must have a byte, char, short, or int value.
The floating-point and boolean types are not supported, and neither is long, even though long is an integer type.
Second, the value associated with each case label must be a constant value or a constant expression the compiler can evaluate.
A case label cannot contain a runtime expression involving variables or method calls, for example.
Third, the case label values must be within the range of the data type used for the switch expression.
And finally, it is obviously not legal to have two or more case labels with the same value or more than one default label.
Just as the if statement is the basic control statement that allows Java to make decisions, the while statement is the basic statement that allows Java to perform repetitive actions.
The while statement works by first evaluating the expression, which must result in a boolean (or, in Java 5.0, a Boolean) value.
If the value is false, the interpreter skips the statement associated with the loop and moves to the next statement in the program.
If it is true, however, the statement that forms the body of the loop is executed, and the expression is reevaluated.
Again, if the value of expression is false, the interpreter moves on to the next statement in the program; otherwise it executes the statement again.
This cycle continues while the expression remains true (i.e., until it evaluates to false), at which point the while statement ends, and the interpreter moves on to the next statement.
You can create an infinite loop with the syntax while(true)
As you can see, the variable count starts off at 0 in this example and is incremented each time the body of the loop runs.
The variable names i, j, and k are commonly used as loop counters, although you should use more descriptive names if it makes your code easier to understand.
A do loop is much like a while loop, except that the loop expression is tested at the bottom of the loop rather than at the top.
This means that the body of the loop is always executed at least once.
Notice a couple of differences between the do loop and the more ordinary while loop.
First, the do loop requires both the do keyword to mark the beginning of the loop and the while keyword to mark the end and introduce the loop condition.
Also, unlike the while loop, the do loop is terminated with a semicolon.
This is because the do loop ends with the loop condition rather than simply ending with a curly brace that marks the end of the loop body.
The following do loop prints the same output as the while loop just discussed:
The do loop is much less commonly used than its while cousin because, in practice, it is unusual to encounter a situation where you are sure you always want a loop to execute at least once.
The for statement provides a looping construct that is often more convenient than the while and do loops.
The for statement takes advantage of a common looping pattern.
Most loops have a counter, or state variable of some kind, that is initialized before the loop starts, tested to determine whether to execute the loop body, and then incremented or updated somehow at the end of the loop body before the test expression is evaluated again.
The initialization, test, and update steps are the three crucial manipulations of a loop variable, and the for statement makes these three steps an explicit part of the loop syntax:
This for loop is basically equivalent to the following while loop:*
As you’ll see when we consider the continue statement, this while loop is not exactly equivalent to the for loop.
Placing the initialize, test, and update expressions at the top of a for loop makes it especially easy to understand what the loop is doing, and it prevents mistakes such as forgetting to initialize or update the loop variable.
The interpreter discards the values of the initialize and update expressions, so in order to be useful, these expressions must have side effects.
Notice how this syntax places all the important information about the loop variable on a single line, making it very clear how the loop executes.
Placing the update expression in the for statement itself also simplifies the body of the loop to a single statement; we don’t even need to use curly braces to produce a statement block.
The for loop supports some additional syntax that makes it even more convenient to use.
Because many loops use their loop variables only within the loop, the for loop allows the initialize expression to be a full variable declaration, so that the variable is scoped to the body of the loop and is not visible outside of it.
Furthermore, the for loop syntax does not restrict you to writing loops that use only a single variable.
Both the initialize and update expressions of a for loop can use a comma to separate multiple initializations and update expressions.
Even though all the examples so far have counted numbers, for loops are not restricted to loops that count numbers.
For example, you might use a for loop to iterate through the elements of a linked list:
The initialize, test, and update expressions of a for loop are all optional; only the semicolons that separate the expressions are required.
If the test expression is omitted, it is assumed to be true.
The for/in statement is a powerful new loop that was added to the language in Java 5.0
On each iteration it assigns an element of the array or Iterable object.
No loop counter or Iterator object is involved; the for/in loop performs the iteration automatically, and you need not concern yourself with correct initialization or termination of the loop.
A for/in loop is written as the keyword for followed by an open parenthesis, a variable declaration (without initializer), a colon, an expression, a close parenthesis, and finally the statement (or block) that forms the body of the loop.
Despite its name, the for/in loop does not use the keyword in.
It is common to read the colon as “in,” however.
Because this statement does not have a keyword of its own, it does not have an unambiguous name.
You may also see it called “enhanced for” or “foreach.”
For the while, do, and for loops, we’ve shown an example that prints ten numbers.
The for/in loop can do this too, but not on its own.
It is a specialized loop that executes its body once for each element in an array or collection.
So, in order to loop ten times (to print out ten numbers), we need an array or other collection with ten elements.
Here are some more things you should know about the syntax of the for/in loop:
This type must be known at compiletime so that the compiler can generate appropriate looping code.
For example, you can’t use this loop with an array or List that you have cast to an Object.
If you use an Iterable object that is not parameterized with an element type, the variable must be declared as an Object.
The declaration usually consists of just a type and a variable name, but it may include a final modifier and any appropriate annotations (see Chapter 4)
Using final prevents the loop variable from taking on any value other than the array or collection element the loop assigns it and serves to emphasize that the array or collection cannot be altered through the loop variable.
The loop variable of the for/in loop must be declared as part of the loop, with both a type and a variable name.
You cannot use a variable declared outside the loop as you can with the for loop.
The following class further illustrates the use of the for/in statement.
It relies on parameterized types, which are covered in Chapter 4, and you may want to return to this section after reading that chapter.
Iterator defines a way to iterate through the elements of a collection or other data structure.
It works like this: while there are more elements in the collection (hasNext( ) returns true), call next( ) to obtain the next element of the collection.
Ordered collections, such as lists, typically have iterators that guarantee that they’ll return elements in order.
Unordered collections like Set simply guarantee that repeated calls to next( ) return all elements of the set without omissions or duplications but do not specify an ordering.
The Iterable interface was introduced to make the for/in loop work.
A class implements this interface in order to advertise that it is able to provide an Iterator to anyone interested.
If you implement Iterable and provide an Iterator for your own classes, you’ll be able to iterate over those classes with the for/in loop.
Remember that if you use the for/in loop with an Iterable<E>, the loop variable must be of type E or a superclass or interface.
For example, to iterate through the elements of a List<String>, the variable must be declared String or its superclass Object, or one of its interfaces CharSequence, Comparable, or Serializable.
If you use for/in to iterate through the elements of a raw List with no type parameter, the Iterable and Iterator also have no type parameter, and the type returned by the next( ) method of the raw Iterator is Object.
In this case, you have no choice but to declare the loop variable to be an Object.
It is not a general replacement for the while, for, or do loops, however, because it hides the loop counter or Iterator from you.
This means that some algorithms simply cannot be expressed with a for/in loop.
Suppose you want to print the elements of an array as a comma-separated list.
To do this, you need to print a comma after every element of the array except the last, or equivalently, before every element of the array except the first.
With a traditional for loop, the code might look like this:
This is a very straightforward task, but you simply cannot do it with for/in.
The problem is that the for/in loop doesn’t give you a loop counter or any other way to tell if you’re on the first iteration, the last iteration, or somewhere in between.
Here are two other simple loops that can’t be converted to use for/in, for the same basic reason:
A similar issue exists when using for/in to iterate through the elements of the collection.
Just as a for/in loop over an array has no way to obtain the array index of the current element, a for/in loop over a collection has no way to obtain the.
Iterator object that is being used to itemize the elements of the collection.
Here are some other things you cannot do with for/in:
Iterate backwards through the elements of an array or List.
Use a single loop counter to access the same-numbered elements of two distinct arrays.
Iterate through the elements of a List using calls to its get( ) method rather than calls to its iterator.
A break statement causes the Java interpreter to skip immediately to the end of a containing statement.
We have already seen the break statement used with the switch statement.
The break statement is most often written as simply the keyword break followed by a semicolon:
When used in this form, it causes the Java interpreter to immediately exit the innermost containing while, do, for, or switch statement.
The break statement can also be followed by the name of a containing labeled statement.
When used in this form, break causes the Java interpreter to immediately exit the named block, which can be any kind of statement, not just a loop or switch.
While a break statement exits a loop, a continue statement quits the current iteration of a loop and starts the next one.
When used without a label, continue causes the innermost loop to start a new iteration.
When used with a label that is the name of a containing loop, it causes the named loop to start a new iteration.
With a while loop, the Java interpreter simply returns to the top of the loop, tests the loop condition again, and, if it evaluates to true, executes the body of the loop again.
With a do loop, the interpreter jumps to the bottom of the loop, where it tests the loop condition to decide whether to perform another iteration of the loop.
With a for loop, the interpreter jumps to the top of the loop, where it first evaluates the update expression and then evaluates the test expression to decide whether to loop again.
As you can see, the behavior of a for loop with a continue statement is different from the behavior of the “basically equivalent” while loop presented earlier; update gets evaluated in the for loop but not in the equivalent while loop.
A return statement tells the Java interpreter to stop executing the current method.
If the method is declared to return a value, the return statement is followed by an expression.
The value of the expression becomes the return value of the method.
For example, the following method computes and returns the square of a number:
Some methods are declared void to indicate that they do not return any value.
The Java interpreter runs methods like this by executing their statements one by one until it reaches the end of the method.
Sometimes, however, a void method has to return explicitly before reaching the last statement.
In this case, it can use the return statement by itself, without any expression.
For example, the following method prints, but does not return, the square root of its argument.
If the argument is a negative number, it returns without printing anything:
Java makes it easy to write multithreaded programs (see Chapter 5 for examples)
When working with multiple threads, you must often take care to prevent multiple threads from modifying an object simultaneously in a way that might.
Sections of code that must not be executed simultaneously are known as critical sections.
Java provides the synchronized statement to protect these critical sections.
The statements constitute the code of the critical section and must be enclosed in curly braces.
Before executing the critical section, the Java interpreter first obtains an exclusive lock on the object or array specified by expression.
It holds the lock until it is finished running the critical section, then releases it.
While a thread holds the lock on an object, no other thread can obtain that lock.
Therefore, no other thread can execute this or any other critical sections that require a lock on the same object.
If a thread cannot immediately obtain the lock required to execute a critical section, it simply waits until the lock becomes available.
Note that you do not have to use the synchronized statement unless your program creates multiple threads that share data.
If only one thread ever accesses a data structure, there is no need to protect it with synchronized.
When you do have to use synchronized, it might be in code like the following:
The synchronized keyword is also available as a modifier in Java and is more commonly used in this form than as a statement.
When applied to a method, the synchronized keyword indicates that the entire method is a critical section.
For a synchronized class method (a static method), Java obtains an exclusive lock on the class before executing the method.
For a synchronized instance method, Java obtains an exclusive lock on the class instance.
An exception is a signal that indicates some sort of exceptional condition or error has occurred.
To throw an exception is to signal an exceptional condition.
To catch an exception is to handle it—to take whatever actions are necessary to recover from it.
In Java, the throw statement is used to throw an exception:
The expression must evaluate to an exception object that describes the exception or error that has occurred.
When the Java interpreter executes a throw statement, it immediately stops normal program execution and starts looking for an exception handler that can catch, or handle, the exception.
Exception handlers are written with the try/ catch/finally statement, which is described in the next section.
The Java interpreter first looks at the enclosing block of code to see if it has an associated exception handler.
If so, it exits that block of code and starts running the exception-handling code associated with the block.
After running the exception handler, the interpreter continues execution at the statement immediately following the handler code.
If the enclosing block of code does not have an appropriate exception handler, the interpreter checks the next higher enclosing block of code in the method.
If the method does not contain an exception handler that can handle the exception thrown by the throw statement, the interpreter stops running the current method and returns to the caller.
Now the interpreter starts looking for an exception handler in the blocks of code of the calling method.
In this way, exceptions propagate up through the lexical structure of Java methods, up the call stack of the Java interpreter.
If the exception is never caught, it propagates all the way up to the main( ) method of the program.
If it is not handled in that method, the Java interpreter prints an error message, prints a stack trace to indicate where the exception occurred, and then exits.
Exceptions that are subclasses of Error generally indicate unrecoverable problems: the virtual machine has run out of memory, or a class file is corrupted and cannot be read, for example.
Exceptions of this sort can be caught and handled, but it is rare to do so.
Exceptions that are subclasses of Exception, on the other hand, indicate less severe conditions.
Since an exception is an object, it can contain data, and its class can define methods that operate on that data.
The Throwable class and all its subclasses include a String field that stores a human-readable error message that describes the exceptional condition.
It’s set when the exception object is created and can be read from the exception with the getMessage( ) method.
Most exceptions contain only this single message, but a few add other data.
The try clause of this statement establishes a block of code for exception handling.
This try block is followed by zero or more catch clauses, each of which is a block of statements designed to handle a specific type of exception.
The catch clauses are followed by an optional finally block that contains cleanup code guaranteed to be executed regardless of what happens in the try block.
Both the catch and finally clauses are optional, but every try block must be accompanied by at least one or the other.
The try, catch, and finally blocks all begin and end with curly braces.
These are a required part of the syntax and cannot be omitted, even if the clause contains only a single statement.
The following code illustrates the syntax and purpose of the try/catch/finally statement:
The try clause simply establishes a block of code that either has its exceptions handled or needs special cleanup code to be run when it terminates for any reason.
The try clause by itself doesn’t do anything interesting; it is the catch and finally clauses that do the exception-handling and cleanup operations.
A try block can be followed by zero or more catch clauses that specify code to handle various types of exceptions.
Each catch clause is declared with a single argument that specifies the type of exceptions the clause can handle and also provides a name the clause can use to refer to the exception object it is currently handling.
The type and name of an exception handled by a catch clause are exactly like the type and name of an argument passed to a method, except that for a catch clause, the argument type must be Throwable or one of its subclasses.
When an exception is thrown, the Java interpreter looks for a catch clause with an argument of the same type as the exception object or a superclass of that type.
The interpreter invokes the first such catch clause it finds.
The code within a catch block should take whatever action is necessary to cope with the exceptional condition.
It is not required to have a catch clause for every possible exception; in some cases the correct response is to allow the exception to propagate up and be caught by the invoking method.
The finally clause is generally used to clean up after the code in the try clause (e.g., close files and shut down network connections)
What is useful about the finally clause is that it is guaranteed to be executed if any portion of the try block is executed, regardless of how the code in the try block completes.
In fact, the only way a try clause can exit without allowing the finally clause to be executed is by invoking the System.exit( ) method, which causes the Java interpreter to stop running.
In the normal case, control reaches the end of the try block and then proceeds to the finally block, which performs any necessary cleanup.
If control leaves the try block because of a return, continue, or break statement, the finally block is executed before control transfers to its new destination.
If an exception occurs in the try block and there is an associated catch block to handle the exception, control transfers first to the catch block and then to the finally block.
If there is no local catch block to handle the exception, control transfers first to the finally block, and then propagates up to the nearest containing catch clause that can handle the exception.
If a finally block itself transfers control with a return, continue, break, or throw statement or by calling a method that throws an exception, the pending control.
For example, if a finally clause throws an exception, that exception replaces any exception that was in the process of being thrown.
If a finally clause issues a return statement, the method returns normally, even if an exception has been thrown and has not yet been handled.
In this case, the finally block is simply cleanup code that is guaranteed to be executed, regardless of any break, continue, or return statements within the try clause.
In previous discussions of the for and continue statements, we’ve seen that a for loop cannot be naively translated into a while loop because the continue statement behaves slightly differently when used in a for loop than it does when used in a while loop.
The finally clause gives us a way to write a while loop that handles the continue statement in the same way that a for loop does.
The following while loop behaves the same, even if the statement block contains a continue statement:
Note, however, that placing the update statement within a finally block causes this while loop to respond to break statements differently than the for loop does.
An assert statement is used to document and verify design assumptions in Java code.
This statement was added in Java 1.4 and cannot be used with previous versions of the language.
An assertion consists of the assert keyword followed by a boolean expression that the programmer believes should always evaluate to true.
By default, assertions are not enabled, and the assert statement does not actually do anything.
It is possible to enable assertions as a debugging and testing tool, however; when this is done, the assert statement evaluates the expression.
The assert statement may include an optional second expression, separated from the first by a colon.
When assertions are enabled and the first expression evaluates to false, the value of the second expression is taken as an error code or error message and is passed to the AssertionError( ) constructor.
It is important to remember that the assertion must be a boolean expression, which typically means that it contains a comparison operator or invokes a boolean-valued method.
For this reason, the javac compiler does not recognize the assert statement by default.
To compile Java code that uses the assert statement, you must use the command-line argument -source 1.4
If it finds assert used as an identifier, it issues an incompatibility warning to encourage you to modify your code.
If you have legacy code that still uses assert as an identifier, it will no longer compile by default in Java 5.0
For efficiency, it does not make sense to test assertions each time code is executed.
Thus, by default, assertions are disabled, and assert statements have no effect.
The assertion code remains compiled in the class files, however, so it can always be enabled for testing, diagnostic, and debugging purposes.
You can enable assertions, either across the board or selectively, with command-line arguments to the Java interpreter.
To enable assertions in all classes except for system classes, use the -ea argument.
To enable assertions within a specific class, use -ea followed by a colon and the classname:
To enable assertions for all classes in a package and in all of its subpackages, follow the -ea argument with a colon, the package name, and three dots:
You can disable assertions in the same way, using the -da argument.
For example, to enable assertions throughout a package and then disable them in a specific class or subpackage, use:
If you use a custom class loader in your program and want to turn on assertions, you may be interested in these methods.
Because assertions are disabled by default and impose no performance penalty on your code, you can use them liberally to document any assumptions you make while programming.
It may take some time to get used to this, but as you do, you’ll find more and more uses for the assert statement.
Without assertions, you might code an if statement that looks like this:
The comment and the assumption that go along with it are no longer valid, and this may cause a bug that is not immediately apparent or is difficult to localize.
The solution in this situation is to convert your comment into an assert statement.
Now, if x somehow ends up holding an unexpected value, an AssertionError is thrown, which makes the bug immediately apparent and easy to pinpoint.
Furthermore, the second expression (following the colon) in the assert statement includes the unexpected value of x as the “error message” of the AssertionError.
This message is not intended to mean anything to an end user, but to provide enough information so that you know not just that an assertion failed but also what caused it to fail.
If you write a switch statement without a default clause, you make an assumption about the set of possible values for the switch expression.
If you believe that no other value is possible, you can add an assert statement to document and validate that fact.
It is a useful “dead-end” statement when you believe that the statement can never be reached.
Another common use of the assert statement is to test whether the arguments passed to a method all have values that are legal for that method; this is also known as enforcing method preconditions.
The programmer has used an assert statement to document a precondition of the subArray( ) method and state that she believes that all methods that invoke this private method do in fact honor that precondition.
She can state this because she has control over all the methods that invoke subArray( )
She can verify her belief by enabling assertions while testing the code.
But once the code is tested, if assertions are left disabled, the method does not suffer the overhead of testing its arguments each time it is called.
Note that the programmer did not use an assert statement to test that argument a is non-null and that the x and y arguments were legal indexes into that array.
It is important to understand that the assert statement is not suitable for enforcing preconditions on public methods.
A public method can be called from anywhere, and the programmer cannot assert in advance that it will be invoked correctly.
To be robust, a public API must explicitly test its arguments and enforce its preconditions each time it is called, whether or not assertions are enabled.
A related use of the assert statement is to verify a class invariant.
Suppose you are creating a class that represents a list of objects and allows objects to be inserted and deleted but always maintains the list in sorted order.
You believe that your implementation is correct and that the insertion methods always leave the list in sorted order, but you want to test this to be sure.
You might write a method that tests whether the list is actually sorted, then use an assert statement to invoke the method at the end of each method that modifies the list.
When writing code that must be threadsafe, you must obtain locks (using a synchronized method or statement) when required.
One common use of the assert statement in this situation is to verify that the current thread holds the lock it requires:
To use assertions effectively, you must be aware of a couple of fine points.
First, remember that your programs will sometimes run with assertions enabled and.
This means that you should be careful not to write assertion expressions that contain side effects.
If you do, your code will run differently when assertions are enabled than it will when they are disabled.
There are a few exceptions to this rule, of course.
For example, if a method contains two assert statements, the first can include a side effect that affects only the second assertion.
Another use of side effects in assertions is the following idiom that determines whether assertions are enabled (which is not something that your code should ever really need to do):
Note that the expression in the assert statement is an assignment, not a comparison.
The value of an assignment expression is always the value assigned, so this expression always evaluates to true, and the assertion never fails.
Because this assignment expression is part of an assert statement, the assertions variable is set to true only if assertions are enabled.
In addition to avoiding side effects in your assertions, another rule for working with the assert statement is that you should never try to catch an AssertionError (unless you catch it at the top level simply so that you can display the error in a more user-friendly fashion)
If an AssertionError is thrown, it indicates that one of the programmer’s assumptions has not held up.
This means that the code is being used outside of the parameters for which it was designed, and it cannot be expected to work correctly.
In short, there is no plausible way to recover from an AssertionError, and you should not attempt to catch it.
Methods A method is a named sequence of Java statements that can be invoked by other Java code.
When a method is invoked, it is passed zero or more values known as arguments.
The method performs some computations and, optionally, returns a value.
As described in “Expressions and Operators” earlier in this chapter, a method invocation is an expression that is evaluated by the Java interpreter.
Because method invocations can have side effects, however, they can also be used as expression statements.
This section does not discuss method invocation, but instead describes how to define methods.
You already know how to define the body of a method; it is simply an arbitrary sequence of statements enclosed within curly braces.
What is more interesting about a method is its signature.* The signature specifies the following:
The number, order, type, and name of the parameters used by the method.
In the Java Language Specification, the term “signature” has a technical meaning that is slightly different than that used here.
This book uses a less formal definition of method signature.
The checked exceptions that the method can throw (the signature may also list unchecked exceptions, but these are not required)
Various method modifiers that provide additional information about the method.
A method signature defines everything you need to know about a method before calling it.
It is the method specification and defines the API for the method.
The reference section of this book is essentially a list of method signatures for all publicly accessible methods of all publicly accessible classes of the Java platform.
In order to use the reference section of this book, you need to know how to read a method signature.
And, in order to write Java programs, you need to know how to define your own methods, each of which begins with a method signature.
The signature (the method specification) is followed by the method body (the method implementation), which is simply a sequence of Java statements enclosed in curly braces.
If the method is abstract (see Chapter 3), the implementation is omitted, and the method body is replaced with a single semicolon.
In Java 5.0 and later, the signature of a generic method may also include type variable declarations.
Here are some example method definitions, which begin with the signature and are followed by the method body:
This method is abstract which means it has no body.
A method might be declared with the public and static modifiers, for example.
The allowed modifiers and their meanings are described in the next section.
The type in a method signature specifies the return type of the method.
If the method does not return a value, type must be void.
If a method is declared with a non-void return type, it must include a return statement that returns a value of (or convertible to) the declared type.
A constructor is a special kind of method used to initialize newly created objects.
As we’ll see in Chapter 3, constructors are defined just like methods, except that their signatures do not include this type specification.
The name of a method follows the specification of its modifiers and type.
Method names, like variable names, are Java identifiers and, like all Java identifiers, may contain letters in any language represented by the Unicode character set.
It is legal, and often quite useful, to define more than one method with the same name, as long as each version of the method has a different parameter list.
Defining multiple methods with the same name is called method overloading.
One method by this name prints a string and other methods by the same name print the values of the various primitive types.
The Java compiler decides which method to call based on the type of the argument passed to the method.
When you are defining a method, the name of the method is always followed by the method’s parameter list, which must be enclosed in parentheses.
The parameter list defines zero or more arguments that are passed to the method.
The parameter specifications, if there are any, each consist of a type and a name and are separated from each other by commas (if there are multiple parameters)
When a method is invoked, the argument values it is passed must match the number, type, and order of the parameters specified in this method signature line.
The values passed need not have exactly the same type as specified in the signature, but they must be convertible to those types without casting.
In Java 5.0 and later, it is possible to define and invoke methods that accept a variable number of arguments, using a syntax known colloquially as varargs.
The final part of a method signature is the throws clause, which is used to list the checked exceptions that a method can throw.
Checked exceptions are a category of exception classes that must be listed in the throws clauses of methods that can throw them.
If a method uses the throw statement to throw a checked exception, or if it calls some other method that throws a checked exception and does not catch or handle that exception, the method must declare that it can throw that exception.
If a method can throw one or more checked exceptions, it specifies this by placing the throws keyword after the argument list and following it by the name of the exception class or classes it can throw.
If a method does not throw any exceptions, it does not use the throws keyword.
If a method throws more than one type of exception, separate the names of the exception classes from each other with commas.
The modifiers of a method consist of zero or more modifier keywords such as public, static, or abstract.
Here is a list of allowed modifiers and their meanings.
Anyone can define new annotation types, so it is not possible to list all possible method annotations.
The curly braces and Java statements that would normally comprise the body of the method are replaced with a single semicolon.
A class that includes an abstract method must itself be declared abstract.
Such a class is incomplete and cannot be instantiated (see Chapter 3)
All private methods are implicitly final, as are all methods of any class that is declared final.
Like abstract methods, native methods have no body: the curly braces are replaced with a semicolon.
When Java was first released, native methods were sometimes used for efficiency reasons.
Instead, native methods are used to interface Java code to existing libraries written in C or C++
The “fp” in this awkwardly named, rarely used modifier stands for “floating point.”
Before a thread can invoke a synchronized method, it must obtain a lock on the method’s class (for static methods) or on the relevant instance of the class (for non-static methods)
This prevents two threads from executing the method at the same time.
The synchronized modifier is an implementation detail (because methods can make themselves threadsafe in other ways) and is not formally part of the.
Good documentation specifies explicitly whether a method is threadsafe; you should not rely on the presence or absence of the synchronized keyword when working with multithreaded programs.
In the discussion of the throw statement, we said that exceptions are Throwable objects and that exceptions fall into two main categories, specified by the Error and Exception subclasses.
In addition to making a distinction between Error and Exception classes, the Java exception-handling scheme also distinguishes between checked and unchecked exceptions.
The distinction between checked and unchecked exceptions has to do with the circumstances under which the exceptions are thrown.
Practically any method can throw an unchecked exception at essentially any time.
Checked exceptions, on the other hand, arise only in specific, well-defined circumstances.
Java has different rules for working with checked and unchecked exceptions.
If you write a method that throws a checked exception, you must use a throws clause to declare the exception in the method signature.
The reason these types of exceptions are called checked exceptions is that the Java compiler checks to make sure you have declared them in method signatures and produces a compilation error if you have not.
Even if you never throw an exception yourself, sometimes you must use a throws clause to declare an exception.
If your method calls a method that can throw a checked exception, you must either include exception-handling code to handle that exception or use throws to declare that your method can also throw that exception.
For example, the following method reads the first line of text from a named file.
How do you know if the method you are calling can throw a checked exception? You can look at its method signature to find out.
Or, failing that, the Java compiler will tell you (by reporting a compilation error) if you’ve called a method whose exceptions you must handle or declare.
In Java 5.0 and later, methods may be declared to accept, and may be invoked with, variable numbers of arguments.
The second, however may be repeated zero or more times.
All of the following are legal invocations of max( ):
As you can tell from the for/in statement in the body of max( ), the second argument is treated as an array of int values.
To the Java interpreter, the max( ) method is indistinguishable from this one:
To convert a varargs signature to the “real” signature, simply replace ...
Remember that only one ellipsis can appear in a parameter list, and it may only appear on the last parameter in the list.
Since varargs methods are compiled into methods that expect an array of arguments, invocations of those methods are compiled to include code that creates and initializes such an array.
If you already have method arguments stored in an array, it is perfectly legal for you to pass them to the method that way, instead of writing them out individually.
The converse is not true, however: you can only use varargs method invocation syntax when the method is actually declared as a varargs method using an ellipsis.
Varargs methods interact particularly well with the new autoboxing feature of Java 5.0 (see “Boxing and Unboxing Conversions” later in this chapter)
Furthermore, autoboxing allows you to invoke the method using primitive values as well: the compiler boxes these up into wrapper objects as it builds the Object[ ] that is the true argument to the method.
The printf( ) and format( ) methods mentioned at the beginning of this section are all declared with an Object...
It does not arise very often in practice, but studying the quirk will solidify your understanding of varargs.
Recall that varargs methods can be invoked with an argument of array type or any number of arguments of the element type.
What do you do if you want to pass an Object[ ] as the single object argument to the method? Consider the following code that uses the printf( ) method:
As part of the addition of generic types, Java 5.0 now also supports covariant returns.
This means that an overriding method may narrow the return type of the method it overrides.* The following example makes this clearer:
Method overriding is not the same as method overloading discussed earlier in this section.
If you are not already familiar with these concepts, you should skip this section for now and return to it later.
This code defines four classes: a two-dimensional point, a three-dimensional point, and event objects that represent an event in two-dimensional space and in three-dimensional space.
In Java 1.4 and earlier, the return type of an overriding method must be identical to the type of the method it overrides.
This one is a compile-time assertion that the method overrides something.
The compiler would have produced a compilation error if the assertion failed.
Classes and Objects Introduced Now that we have introduced operators, expressions, statements, and methods, we can finally talk about classes.
A class is a named collection of fields that hold data values and methods that operate on those values.
Classes are just one of five reference types supported by Java, but they are the most important type.
We introduce them here, however, because they are the next higher level of syntax after methods, and because the rest of this chapter requires a basic familiarity with the concept of class and the basic syntax for defining a class, instantiating it, and using the resulting object.
The most important thing about classes is that they define new data types.
For example, you might define a class named Point to represent a data point in the two-dimensional Cartesian coordinate system.
This class would define fields (each of type double) to hold the X and Y coordinates of a point and methods to manipulate and operate on the point.
When discussing data types, it is important to distinguish between the data type itself and the values the data type represents.
A class is a data type; a class value is called an object.
We use the name class because each class defines a type (or kind, or species, or class) of objects.
The Point class is a data type that represents X,Y points, while a Point object represents a single specific X,Y point.
As you might imagine, classes and their objects are closely linked.
Here is a possible definition of the Point class we have been discussing:
This class definition is stored in a file named Point.java and compiled to a file named Point.class, where it is available for use by Java programs and other classes.
This class definition is provided here for completeness and to provide context, but don’t expect to understand all the details just yet; most of Chapter 3 is devoted to the topic of defining classes.
Keep in mind that you don’t have to define every class you want to use in a Java program.
The Java platform includes thousands of predefined classes that are guaranteed to be available on every computer that runs Java.
Now that we have defined the Point class as a new data type, we can use the following line to declare a variable that holds a Point object:
Declaring a variable to hold a Point object does not create the object itself, however.
To actually create an object, you must use the new operator.
This keyword is followed by the object’s class (i.e., its type) and an optional argument list in parentheses.
These arguments are passed to the constructor method for the class, which initializes internal fields in the new object:
The new keyword is by far the most common way to create objects in Java.
First, a couple of classes are so important that Java defines special literal syntax for creating objects of those types (as we discuss later in this section)
Second, Java supports a dynamic loading mechanism that allows programs to load classes and create instances of those classes dynamically.
In other words, an object that has had its state saved, or serialized, usually to a file, can be recreated using the java.io.
Now that we’ve seen how to define classes and instantiate them by creating objects, we need to look at the Java syntax that allows us to use those objects.
Recall that a class defines a collection of fields and methods.
Each object has its own copies of those fields and has access to those methods.
This syntax is central to object-oriented programming in Java, so you’ll see it a lot.
In our discussion of primitive types, we saw that each primitive type has a literal syntax for including values of the type literally into the text of a program.
Java also defines a literal syntax for a few special reference types, as described next.
The String class represents text as a string of characters.
Since programs usually communicate with their users through the written word, the ability to manipulate strings of text is quite important in any programming language.
In some languages, strings are a primitive type, on a par with integers and characters.
In Java, however, strings are objects; the data type used to represent text is the String class.
Don’t confuse the double-quote characters that surround string literals with the single-quote (or apostrophe) characters that surround char literals.
String literals can contain any of the escape sequences char literals can (see Table 2-2)
Escape sequences are particularly useful for embedding double-quote characters within double-quoted string literals.
String literals cannot contain comments and may consist of only a single line.
If you need to represent a long string of text that does not fit on a single line, break it into independent string literals and use the + operator to concatenate the literals.
String s = "This is a test of the         // This is illegal; string  literals emergency broadcast system";  // cannot be broken across lines.
String s = "This is a test of the " +     // Do this instead "emergency broadcast system";
This concatenation of literals is done when your program is compiled, not when it is run, so you do not need to worry about any kind of performance penalty.
The second type that supports its own special object literal syntax is the class named Class.
Instances of the Class class represent a Java data type.
To include a Class object literally in a Java program, follow the name of any data type with .class.
Class typeInt = int.class; Class typeIntArray = int[].class; Class typePoint = Point.class;
The null keyword is a special literal value that is a reference to nothing, or an absence of a reference.
The null value is unique because it is a member of every reference type.
You can assign null to variables of any reference type.
Arrays An array is a special kind of object that holds zero or more primitive values or references.
These values are held in the elements of the array, which are unnamed variables referred to by their position or index.
The type of an array is characterized by its element type, and all elements of the array must be of that type.
Array elements are numbered starting with zero, and valid indexes range from zero to the number of elements minus one.
The array element with index 1, for example, is the second element in the array.
The number of elements in an array is its length.
The length of an array is specified when the array is created, and it never changes.
The element type of an array may be any valid Java type, including array types.
This means that Java supports arrays of arrays, which provide a kind of multidimensional array capability.
Java does not support the matrix-style multidimensional arrays found in some languages.
Instances of arrays are objects, just as the instances of a class are.* Unlike classes, array types do not have to be defined.
For example, the following code declares three variables of array type:
The length of an array is not part of the array type.
It is not possible, for example, to declare a method that expects an array of exactly four int values, for example.
If a method parameter is of type int[ ], a caller can pass an array with any number (including zero) of elements.
Array types are not classes, but array instances are objects.
Arrays also implement Serializable so that any array can be serialized if its element type can be serialized.
Finally, all arrays have a public final int field named length that specifies the number of elements in the array.
Since arrays extend Object and implement the Cloneable and Serializable interfaces, any array type can be widened to any of these three types.
But certain array types can also be widened to other array types.
If the element type of an array is a reference type T, and T is assignable to a type S, the array type T[ ] is assignable to the array type S[ ]
Note that there are no widening conversions of this sort for arrays of a given primitive type.
As examples, the following lines of code show legal array widening conversions:
Unlike with classes and their instances, we use the term “array” for both the array type and the array instance.
In practice, it is usually clear from context whether a type or a value is being discussed.
This ability to widen an array type to another array type means that the compiletime type of an array is not always the same as its runtime type.
The compiler must usually insert runtime checks before any operation that stores a reference value into an array element to ensure that the runtime type of the value matches the runtime type of the array element.
As we’ve seen, an array type is written simply by placing brackets after the element type.
For compatibility with C and C++, however, Java supports an alternative syntax in variable declarations: brackets may be placed after the name of the variable instead of, or in addition to, the element type.
This line declares local variables of type int, int[] and int[][] int justOne, arrayOfThem[], arrayOfArrays[][];
This compatibility syntax is uncommon, and its use is strongly discouraged.
To create an array value in Java, you use the new keyword, just as you do to create an object.
Array types don’t have constructors, but you are required to specify a length whenever you create an array.
Specify the desired size of your array as a nonnegative integer between square brackets:
Array creation expressions can also be used to create and initialize a multidimensional rectangular array of arrays.
This syntax is somewhat more complicated and is explained later in this section.
To create an array and initialize its elements in a single expression, omit the array length and follow the square brackets with a comma-separated list of expressions within curly braces.
The type of each expression must be assignable to the element type of the array, of course.
The length of the array that is created is equal.
It is legal, but not necessary, to include a trailing comma following the last expression in the list.
Note that this syntax allows arrays to be created, initialized, and used without ever being assigned to a variable.
In a sense these array creation expressions are anonymous array literals.
When an array initializer is part of a variable declaration, you may omit the new keyword and element type and  list the desired array elements within curly braces:
The Java Virtual Machine architecture does not support any kind of efficient array initialization.
In other words, array literals are created and initialized when the program is run, not when the program is compiled.
This is compiled into Java byte codes that are equivalent to:
If you want to initialize a large array, you should think twice before including the values literally in the program, since the Java compiler has to emit lots of Java byte codes to initialize the array.
It may be more space-efficient to store your data in an external file and read it into the program at runtime.
The fact that Java does all array initialization at runtime has an important corollary, however.
It means that the expressions in an array initializer may be computed at runtime and need not be compile-time constants.
Once an array has been created, you are ready to start using it.
The following sections explain basic access to the elements of an array and cover common idioms of array usage such as iterating through the elements of an array and copying an array or part of an array.
When an array element appears in an expression, it evaluates to the value held in the element.
And when an array element appears on the left-hand side of an assignment operator, a new value is stored into that element.
Unlike a normal variable, however, an array element has no name, only a number.
If a is an expression that evaluates to an array reference, you index that array and refer to a specific element with a[i], where i is an integer literal or an expression that evaluates to an int.
The array index expression must be of type int, or a type that can be widened to an int: byte, short, or even char.
It is obviously not legal to index an array with a boolean, float, or double value.
Indexing an array with an expression of type long generates a compile-time error, even if the value of that expression at runtime would be within the range of an int.
A common bug involving arrays is use of an index that is too small (a negative index) or too large (greater than or equal to the array length)
In languages like C or C++, accessing elements before the beginning or after the end of an array yields unpredictable behavior that can vary from invocation to invocation and platform to platform.
Such bugs may not always be caught, and if a failure occurs, it may be at some later time.
While it is just as easy to write faulty array indexing code in Java, Java guarantees predictable results by checking every array access at runtime.
It is common to write loops that iterate through each of the elements of an array in order to perform some operation on it.
The following code, for example, computes the sum of an array of integers:
The structure of this for loop is idiomatic, and you’ll see it frequently.
In Java 5.0 and later, arrays can also be iterated with the for/in loop.
All array types implement the Cloneable interface, and any array can be copied by invoking its clone( ) method.
If the element type of the array is a reference type, only the references are copied, not the referenced objects themselves.
Because the copy is shallow, any array can be cloned, even if the element type is not itself Cloneable.
Sometimes you simply want to copy elements from one existing array to another existing array.
First pass the source array from which elements are to be copied.
Second, pass the index of the start element in that array.
Pass the destination array and the destination index as the third and fourth arguments.
Finally, as the fifth argument, specify the number of elements to be copied.
Most of these methods are heavily overloaded, with versions for arrays of each primitive type and another version for arrays of objects.
The sort( ) and binarySearch( ) methods are particularly useful for sorting and searching arrays.
The equals( ) method allows you to compare the content of two arrays.
The Arrays.toString( ) method is useful when you want to convert array content to a string, such as for debugging or logging output.
As of Java 5.0, the Arrays class includes deepEquals( ), deepHashCode( ), and deepToString( ) methods that work correctly for multidimensional arrays.
As we’ve seen, an array type is written as the element type followed by a pair of square brackets.
An array of char is char[ ], and an array of arrays of char is char[ ][ ]
When the elements of an array are themselves arrays, we say that the array is multidimensional.
In order to work with multidimensional arrays, you need to understand a few additional details.
Imagine that you want to use a multidimensional array to represent a multiplication table:
Each of the pairs of square brackets represents one dimension, so this is a twodimensional array.
To access a single int element of this two-dimensional array, you must specify two index values, one for each dimension.
Assuming that this array was actually initialized as a multiplication table, the int value stored at any given element would be the product of the two indexes.
To create a new multidimensional array, use the new keyword and specify the size of both dimensions of the array.
In some languages, an array like this would be created as a single block of 100 int values.
Declares a variable named products to hold an array of arrays of int.
It assigns each of these 10 new arrays to the elements of the initial array.
To put this another way, the previous single line of code is equivalent to the following code:
The new keyword performs this additional initialization automatically for you.
It works with arrays with more than two dimensions as well:
When using new with multidimensional arrays, you do not have to specify a size for all dimensions of the array, only the leftmost dimension or dimensions.
The first line creates a single-dimensional array, where each element of the array can hold a float[ ][ ]
The second line creates a two-dimensional array, where each element of the array is a float[ ]
If you specify a size for only some of the.
Or, if you want to use a multidimensional array without declaring a variable, you can use the anonymous initializer syntax:
When you create a multidimensional array using the new keyword, you always get a rectangular array: one in which all the array values for a given dimension have the same size.
This is perfect for rectangular data structures, such as matrices.
However, because multidimensional arrays are implemented as arrays of arrays in Java, instead of as a single rectangular block of elements, you are in no way constrained to use rectangular arrays.
For example, since our multiplication table is symmetrical diagonally from top left to bottom right, we can represent the same information in a nonrectangular array with fewer elements:
When working with multidimensional arrays, you’ll often find yourself using nested loops to create or initialize them.
For example, you can create and initialize a large triangular multiplication table as follows:
Reference Types Now that we’ve covered arrays and introduced classes and objects, we can turn to a more general description of reference types.
Classes and arrays are two of Java’s five kinds of reference types.
This section does not cover specific syntax for any particular reference type, but instead explains the general behavior of reference types and illustrates how they differ from Java’s primitive types.
In this section, the term object refers to a value or instance of any reference type, including arrays.
Reference types and objects differ substantially from primitive types and their primitive values:
Reference types are user-defined, so there is an unlimited number of them.
For example, a program might define a class named Point and use objects of this newly defined type to store and manipulate X,Y points in a Cartesian coordinate system.
The same program might use an array of characters—of type char[ ]—to store text and might use an array of Point objects—of type Point[ ]—to store a sequence of points.
Reference types are aggregate types that hold zero or more primitive values or objects.
Our hypothetical Point class, for example, might hold two double values to represent the X and Y coordinates of the points.
The char[ ] and Point[ ] array types are obviously aggregate types because they hold a sequence of primitive char values or Point objects.
Primitive types require between one and eight bytes of memory.
When a primitive value is stored in a variable or passed to a method, the computer makes a copy of the bytes that hold the value.
Objects, on the other hand, may require substantially more memory.
When an object is assigned to a variable or passed to a method, the memory that represents the object is not copied.
Instead, only a reference to that memory is stored in the variable or passed to the method.
This last difference between primitive and reference types explains why reference types are so named.
The sections that follow are devoted to exploring the substantial differences between types that are manipulated by value and types that are manipulated by reference.
Before moving on, however, it is worth briefly considering the nature of references.
A reference is simply some kind of reference to an object.
References are completely opaque in Java and the representation of a reference is an implementation detail of the Java interpreter.
If you are a C programmer, however, you can safely imagine a reference as a pointer or a memory address.
Remember, though, that Java programs cannot manipulate references in any way.
Unlike pointers in C and C++, references cannot be converted to or from integers, and they cannot be incremented or decremented.
In Java, primitive types are always handled exclusively by value, and objects are always handled exclusively by reference: the.
After these lines execute, the variable y contains a copy of the value held in the variable x.
Now think about what happens if we run the same basic code but use a reference type instead of a primitive type:
After this code runs, the variable q holds a copy of the reference held in the variable p.
There is still only one copy of the Point object in the VM, but there are now two copies of the reference to that object.
Suppose the two previous lines of code are followed by this code:
Since the variables p and q hold references to the same object, either variable can be used to make changes to the object, and those changes are visible through the other variable as well.
This behavior is not specific to objects; the same thing happens with arrays, as illustrated by the following code:
A similar difference in behavior between primitive types and reference types occurs when arguments are passed to methods.
When this method is invoked, the method is given a copy of the argument used to invoke the method in the parameter x.
The code in the method uses x as a loop counter and decrements it to zero.
Since x is a primitive type, the method has its own private copy of this value, so this is a perfectly reasonable thing to do.
On the other hand, consider what happens if we modify the method so that the parameter is a reference type:
When this method is invoked, it is passed a private copy of a reference to a Point object and can use this reference to change the Point object.
When the changeReference( ) method is invoked, it is passed a copy of the reference held in variable q.
Now both the variable q and the method parameter p hold references to the same object.
The method can use its reference to change the contents of the object.
Note, however, that it cannot change the contents of the variable q.
In other words, the method can change the Point object beyond recognition, but it cannot change the fact that the variable q refers to that object.
The title of this section is “Copying Objects,” but, so far, we’ve only seen copies of references to objects, not copies of the objects and arrays themselves.
Note that a cast is necessary to coerce the return value of the clone( ) method to the correct type.
There are a couple of points you should be aware of when using clone( )
Java only allows an object to be cloned if the object’s class has explicitly declared itself to be cloneable by implementing the Cloneable interface.
The definition of Point that we showed earlier does not actually implement this interface, so our Point type, as implemented, is not cloneable.
When you use the clone( ) method, you may want to use it within a try block to catch this exception.
The second thing you need to understand about clone( ) is that, by default, it creates a shallow copy of an object.
The copied object contains copies of all the primitive values and references in the original object.
In other words, any references in the object are copied, not cloned; clone( ) does not recursively make copies of the objects referred to by those references.
A class may need to override this shallow copy behavior by defining its own version of the clone( ) method that explicitly performs a deeper copy where needed.
To understand the shallow copy behavior of clone( ), consider cloning a two-dimensional array of arrays:
If you want to make a deep copy of this multidimensional array, you have to copy each dimension explicitly:
We’ve seen that primitive types and reference types differ significantly in the way they are assigned to variables, passed to methods, and copied.
The types also differ in the way they are compared for equality.
When used with primitive values, the equality operator (= =) simply tests whether two values are identical (i.e., whether they have exactly the same bits)
With reference types, however, = = compares references, not actual objects.
In other words, = = tests whether two references refer to the same object; it does not test whether two objects have the same content.
When working with reference types, there are two kinds of equality: equality of reference and equality of object.
It is important to distinguish between these two kinds of equality.
One way to do this is to use the word “identical” when talking about equality of references and the word “equal” when talking about two distinct objects that have the same content.
To test two nonidentical objects for equality, pass one of them to the equals( ) method of the other:
All objects inherit an equals( ) method (from Object), but the default implementation simply uses = = to test for identity of references, not equality of content.
A class that wants to allow objects to be compared for equality can define its own version of the equals( ) method.
Our Point class does not do this, but the String class does, as indicated in the code example.
You can call the equals( ) method on an array, but it is the same as using the = = operator, because arrays always inherit the default equals( ) method that compares references rather than array content.
I’ve said that Java handles objects “by reference.” Don’t confuse this with the phrase “pass by reference.” “Pass by reference” is a term used to describe the methodcalling conventions of some programming languages.
In a pass-by-reference language, values—even primitive values—are not passed directly to methods.
Thus, if the method modifies its parameters, those modifications are visible when the method returns, even for primitive types.
Java does not do this; it is a “pass by value” language.
However, when a reference type is involved, the value that is passed is a reference.
If Java were a pass-by-reference language, when a reference type is passed to a method, it would be passed as a reference to the reference.
As we’ve already noted, objects are composite values that can contain a number of other values and may require a substantial amount of memory.
When you use the new keyword to create a new object or use an object literal in your program, Java automatically creates the object for you, allocating whatever amount of memory is necessary.
You don’t need to do anything to make this happen.
In addition, Java also automatically reclaims that memory for reuse when it is no longer needed.
An object is considered garbage when no references to it are stored in any variables, the fields of any objects, or the elements of any arrays.
After the Java interpreter executes the third line, a reference to the new Point object has replaced the reference to the first one.
No references to the first object remain, so it is garbage.
At some point, the garbage collector discovers this and reclaims the memory used by the object.
Even though it seems like magic, it really works! There is a slight, but usually negligible, performance penalty due to the use of garbage collection.
However, having garbage collection built into the language dramatically reduces the occurrence of memory leaks and related bugs and almost always improves programmer productivity.
In order to understand reference type conversions, you need to understand that reference types form a hierarchy, usually called the class hierarchy.
Every Java reference type extends some other type, known as its superclass.
A type inherits the fields and methods of its superclass and then defines its own additional fields and methods.
A special class named Object serves as the root of the class hierarchy in Java.
The Object class defines a number of special methods that are inherited (or overridden) by all objects.
The predefined String class and the Point class we discussed earlier in this chapter both extend Object.
Thus, we can say that all String objects are also Object objects.
We can also say that all Point objects are Object objects.
We cannot say that every Object is a String because, as we’ve just seen, some Object objects are Point objects.
With this simple understanding of the class hierarchy, we can return to the rules of reference type conversion:
The Java compiler does not allow you to convert a String to a Point, for example, even if you use a cast operator.
An object can be converted to the type of its superclass or of any ancestor class.
This is a widening conversion, so no cast is required.
For example, a String value can be assigned to a variable of type Object or passed to a method where an Object parameter is expected.
Note that no conversion is actually performed; the object is simply treated as if it were an instance of the superclass.
An object can be converted to the type of a subclass, but this is a narrowing conversion and requires a cast.
The Java compiler provisionally allows this kind of conversion, but the Java interpreter checks at runtime to make sure it is valid.
Only cast an object to the type of a subclass if you are sure, based on the logic of your program, that the object is actually an instance of the subclass.
For example, if we assign a String object to a variable of type Object, we can later cast the value of that variable back to type String:
Object o = "string";    // Widening conversion from String to Object // Later in the program...
String s = (String) o;  // Narrowing conversion from Object to String.
Arrays are objects and follow some conversion rules of their own.
First, any array can be converted to an Object value through a widening conversion.
A narrowing conversion with a cast can convert such an object value back to an array.
In addition to converting an array to an object, an array can be converted to another type of array if the “base types” of the two arrays are reference types that can themselves be converted.
Note that these array conversion rules apply only to arrays of objects and arrays of arrays.
An array of primitive type cannot be converted to any other array type, even if the primitive base types can be converted:
It is sometimes useful to treat primitive values as objects, and for this reason, the Java platform includes wrapper classes for each of the primitive types.
Boolean, Byte, Short, Character, Integer, Long, Float, and Double are immutable classes whose instances each hold a single primitive value.
Prior to Java 5.0, no conversions between primitive types and reference types were allowed.
This code explicitly calls the Integer( ) constructor to wrap a primitive int in an object and explicitly calls the intValue( ) method to extract a primitive value from the wrapper object.
Java 5.0 introduces two new types of conversions known as boxing and unboxing conversions.
Boxing conversions convert a primitive value to its corresponding wrapper object and unboxing conversions do the opposite.
You may explicitly specify a boxing or unboxing conversion with a cast, but this is unnecessary since these conversions are automatically performed when you assign a value to a variable or pass a value to a method.
Because Java 5.0 performs boxing and unboxing automatically, this new language feature is often known as autoboxing.
Here are some examples of automatic boxing and unboxing conversions:
Automatic boxing and unboxing conversions make it much simpler to use primitive values with collection classes.
The list-of-numbers code earlier in this section can be translated as follows in Java 5.0
Packages and the Java Namespace A package is a named collection of classes, interfaces, and other reference types.
Packages serve to group related classes and define a namespace for the classes they contain.
The core classes of the Java platform are in packages whose names begin with java.
For example, the most fundamental classes of the language are in the package java.lang.
Classes for input and output are in java.io, and classes for networking are in java.net.
Extensions to the Java platform that have been standardized by Sun typically have package names that begin with javax.
Some of these extensions, such as javax.swing and its myriad subpackages, were later adopted into the core platform itself.
Finally, the Java platform also includes several “endorsed standards,” which have packages named after the standards body that created them, such as org.w3c and org.omg.
Every class has both a simple name, which is the name given to it in its definition, and a fully qualified name, which includes the name of the package of which it is a part.
This section explains how to place your own classes and interfaces into a package and how to choose a package name that won’t conflict with anyone else’s package name.
Next, it explains how to selectively import type names into the namespace so that you don’t have to type the package name of every class or interface you use.
Finally, the section explains a feature that is new in Java 5.0: the ability to import static members of types into the namespace so that you don’t need to prefix these with a package name or a class name.
To specify the package a class is to be part of, you use a package declaration.
The package keyword, if it appears, must be the first token of Java code (i.e., the first thing other than comments and space) in the Java file.
The keyword should be followed by the name of the desired package and a semicolon.
If no package directive appears in a Java file, all classes defined in that file are part of an unnamed default package.
In this case, the qualified and unqualified names of a class are the same.
The possibility of naming conflicts means that you should use this default package only for very simple code or early on in the development process of a larger project.
One of the important functions of packages is to partition the Java namespace and prevent name collisions between classes.
It is only their package names that keep the java.util.List and java.awt.List classes distinct, for example.
In order for this to work, however, package names must themselves be distinct.
As the developer of Java, Sun controls all package names that begin with java, javax, and sun.
For the rest of us, Sun proposes a package-naming scheme, which, if followed correctly, guarantees globally unique package names.
The scheme is to use your Internet domain name, with its elements reversed, as the prefix for all your package names.
Note that these package-naming rules apply primarily to API developers.
If other programmers will be using classes that you develop along with unknown other classes, it is important that your package name be globally unique.
On the other hand, if you are developing a Java application and will not be releasing any of the classes for reuse by others, you know the complete set of classes that your application will be deployed with and do not have to worry about unforeseen naming conflicts.
In this case, you can choose a package naming scheme for your own convenience rather than for global uniqueness.
One common approach is to use the application name as the main package name (it may have subpackages beneath it)
When referring to a class or interface in your Java code, you must, by default, use the fully qualified name of the type, including the package name.
If you’re writing code to manipulate a file and need to use the File class of the java.io package, you must type java.io.File.
Types from the package java.lang are so important and so commonly used that they can always be referred to by their simple names.
The code in a type p.T may refer to other types defined in the package p by their simple names.
Types that have been imported into the namespace with an import declaration may be referred to by their simple names.
The first two exceptions are known as “automatic imports.” The types from java.
Typing the package name of commonly used types that are not in java.lang or the current package quickly becomes tedious, and so it is also possible to explicitly import types from other packages into the namespace.
To import a single type into the namespace, follow the import keyword with the name of the type and a semicolon:
The other form of import is the “on-demand type import.” In this form, you specify the name of a package followed the characters .* to indicate that any type from that package may be used without its package name.
Thus, if you want to use several other classes from the java.io package in addition to the File class, you can simply import the entire package:
Using an on-demand type import declaration is not the same as explicitly writing out a single type import declaration for every type in the package.
It is more like an explicit single type import for every type in the package that you actually use in your code.
This is the reason it’s called “on demand”; types are imported as you use them.
It is illegal to import both java.util.List and java.awt.List in the same Java file.
The following single type import declarations produce a compilation error:
Using on-demand type imports for the two packages is legal:
Difficulty arises, however, if you actually try to use the type List.
This type can be imported “on demand” from either package, and any attempt to use List as an unqualified type name produces a compilation error.
The workaround, in this case, is to explicitly specify the package name you want.
Because java.util.List is much more commonly used than java.awt.List, it is useful to combine the two on-demand type import declarations with a single-type import declaration that serves to disambiguate what we mean when we say List:
With these import declarations in place, we can use List to mean the java.util.List interface.
If we actually need to use the java.awt.List class, we can still do so as long as we include its package name.
In Java 5.0 and later, you can import the static members of types as well as types themselves using the keywords import static.
If you are not already familiar with them, you may want to come back to this section later.
Like type import declarations, these static import declarations come in two forms: single static member import and on-demand static member import.
Suppose, for example, that you are writing a text-based program that sends a lot of output to System.out.
In this case, you might use this single static member import to save yourself typing:
With this import in place, you can then use out.print( ) instead of System.out.
Or suppose you are writing a program that uses many of the the trigonometric and other functions of the Math class.
In a program that is clearly focused on numerical methods like this, having to repeatedly type the class name “Math” does not add clarity to your code; it just gets in the way.
In this case, an ondemand static member import may be appropriate:
With this import declaration, you are free to write concise expressions like sqrt(abs(sin(x))) without having to prefix the name of each static method with the class name Math.
Another important use of import static declarations is to import the names of constants into your code.
This works particularly well with enumerated types (see Chapter 4)
Suppose, for example that you want to use the values of this enumerated type in code you are writing:
For more concise code, you could import the enumerated values themselves:
Using static member import declarations for constants is generally a better technique than implementing an interface that defines the constants.
A static import declaration imports a name, not any one specific member with that name.
Since Java allows method overloading and allows a type to have fields and methods with the same name, a single static member import declaration may actually import more than one member.
If you use the imported name sort to invoke a method, the compiler will look at the types of the method arguments to determine which method you mean.
It is even legal to import static methods with the same name from two or more different types as long as the methods all have different signatures.
You might expect that this code would cause a syntax error.
In fact, it does not because the sort( ) methods defined by the Collections class have different signatures than all of the sort( ) methods defined by the Arrays class.
When you use the name “sort” in your code, the compiler looks at the types of the arguments to determine which of the 21 possible imported methods you mean.
Java File Structure This chapter has taken us from the smallest to the largest elements of Java syntax, from individual characters and tokens to operators, expressions, statements, and methods, and on up to classes and packages.
From a practical standpoint, the unit of Java program structure you will be dealing with most often is the Java file.
Java file is the smallest unit of Java code that can be compiled by the Java compiler.
These elements can be interspersed with comments, of course, but they must appear in this order.
All Java statements (except the package and import directives, which are not true statements) must appear within methods, and all methods must appear within a type definition.
First, each file can contain at most one class that is declared public.
A public class is one that is designed for use by other classes in other packages.
This restriction on public classes only applies to top-level classes; a class can contain any number of nested or inner classes that are declared public.
The second restriction concerns the filename of a Java file.
If a Java file contains a public class, the name of the file must be the same as the name of the class, with the extension .java appended.
Thus, if Point is defined as a public class, its source code must appear in a file named Point.java.
Regardless of whether your classes are public or not, it is good programming practice to define only one per file and to give the file the same name as the class.
When a Java file is compiled, each of the classes it defines is compiled into a separate class file that contains Java byte codes to be interpreted by the Java Virtual Machine.
A class file has the same name as the class it defines, with the extension .class appended.
Thus, if the file Point.java defines a class named Point, a Java compiler compiles it to a file named Point.class.
On most systems, class files are stored in directories that correspond to their package names.
The Java interpreter knows where the class files for the standard system classes are located and can load them as needed.
In order to tell the interpreter to look in locations other than the current directory, you must use the -classpath option when invoking the interpreter or set the CLASSPATH environment variable.
Defining and Running Java Programs A Java program consists of a set of interacting class definitions.
But not every Java class or Java file defines a program.
To create a program, you must define a class that has a special method with the following signature:
This main( ) method is the main entry point for your program.
This method is passed an array of strings and returns no value.
When main( ) returns, the Java interpreter exits (unless main( ) has created separate threads, in which case the interpreter waits for all those threads to exit)
To run a Java program, you run the Java interpreter, java, specifying the fully qualified name of the class that contains the main( ) method.
Note that you specify the name of the class, not the name of the class file that contains the class.
Any additional arguments you specify on the command line are passed to the main( ) method as its String[ ] parameter.
You may also need to specify the -classpath option (or -cp) to tell the interpreter where to look for the classes needed by the program.
Finally, datafile.jude is a string that is passed to that main( ) method as the single element of an array of String objects.
If a program and all its auxiliary classes (except those that are part of the Java platform) have been properly bundled in a Java archive (JAR) file, you can run the program simply by specifying the name of the JAR file:
Differences Between C and Java If you are a C or C++ programmer, you should have found much of the syntax of Java—particularly at the level of operators and statements—to be familiar.
Because Java and C are so similar in some ways, it is important for C and C++ programmers to understand where the similarities end.
Constant definitions are replaced with static final fields in Java.
Macro definitions are not available in Java, but advanced compiler technology and inlining has made them less useful.
Java does not require an #include directive because Java has no header files.
Java class files contain both the class API and the class implementation, and the compiler reads API information from class files as necessary.
Java lacks any form of conditional compilation, but its cross-platform portability means that this feature is rarely needed.
Packages contain classes, classes contain fields and methods, and methods contain local variables.
But Java has no global variables, and thus there is no possibility of namespace collisions among those variables.
Well-defined primitive type sizes All the primitive types in Java have well-defined sizes.
No pointers Java classes and arrays are reference types, and references to objects and arrays are akin to pointers in C.
Unlike C pointers, however, references in Java are entirely opaque.
There is no way to convert a reference to a primitive type, and a reference cannot be incremented or decremented.
Eliminating them simplifies the language and makes Java programs more robust and secure.
Garbage collection The Java Virtual Machine performs garbage collection so that Java programmers do not have to explicitly manage the memory used by all objects and arrays.
This feature eliminates another entire category of common bugs and all but eliminates memory leaks from Java programs.
Use of goto except in certain welldefined circumstances is regarded as poor programming practice.
Java adds exception handling and labeled break and continue statements to the flowcontrol statements offered by C.
Variable declarations anywhere C requires local variable declarations to be made at the beginning of a method or block, while Java allows them anywhere in a method or block.
Many programmers prefer to keep all their variable declarations grouped together at the top of a method, however.
Forward references The Java compiler is smarter than the C compiler in that it allows methods to be invoked before they are defined.
This eliminates the need to declare functions in a header file before defining them in a program file, as is done in C.
Method overloading Java programs can define multiple methods with the same name, as long as the methods have different parameter lists.
No struct and union types Java doesn’t support C struct and union types.
A Java class can be thought of as an enhanced struct, however.
No bitfields Java doesn’t support the (infrequently used) ability of C to specify the number of individual bits occupied by fields of a struct.
No typedef Java doesn’t support the typedef keyword used in C to define aliases for type names.
Java’s lack of pointers makes its type-naming scheme simpler and more consistent than C’s, however, so many of the common uses of typedef are not really necessary in Java.
No method pointers C allows you to store the address of a function in a variable and pass this function pointer to other functions.
You cannot do this with Java methods, but you can often achieve similar results by passing an object that implements a particular interface.
Now that we’ve covered fundamental Java syntax, we are ready to begin objectoriented programming in Java.
All Java programs use objects, and the type of an object is defined by its class or interface.
Every Java program is defined as a class, and nontrivial programs usually include a number of classes and interface definitions.
This chapter explains how to define new classes and interfaces and how to do object-oriented programming with them.*
This is a relatively long and detailed chapter, so we begin with an overview and some definitions.
A class is a collection of fields that hold values and methods that operate on those values.
Classes are the most fundamental structural element of all Java programs.
All Java statements appear within methods, and all methods are implemented within classes.
The Point class defines a type that is the set of all possible two-dimensional points.
A Point object is a value of that type: it represents a single two-dimensional point.
Objects are usually created by instantiating a class with the new keyword and a constructor invocation, as shown here:
Constructors are covered in “Creating and Initializing Objects” later in this chapter.
If you do not have object-oriented (OO) programming background, don’t worry; this chapter does not assume any prior experience.
If you do have experience with OO programming, however, be careful.
Don’t assume that Java works the same way as your favorite OO language.
Although Java and C++ borrow much syntax from C, the similarities between the two languages do not go far beyond the level of syntax.
Don’t let your experience with C++ lull you into a false familiarity with Java.
A class definition consists of a signature and a body.
The class signature defines the name of the class and may also specify other important information.
The body of a class is a set of members enclosed in curly braces.
The members of a class may include fields and methods, constructors and initializers, and nested types.
A static member belongs to the class itself while a nonstatic member is associated with the instances of a class (see “Fields and Methods” later in this chapter)
The signature of a class may declare that the class extends another class.
The extended class is known as the superclass and the extension is known as the subclass.
A subclass inherits the members of its superclass and may declare new members or override inherited methods with new implementations.
The signature of a class may also declare that the class implements one or more interfaces.
An interface is a reference type that defines method signatures but does not include method bodies to implement the methods.
A class that implements an interface is required to provide bodies for the interface’s methods.
Instances of such a class are also instances of the interface type that it implements.
The members of a class may have access modifiers public, protected, or private, which specify their visibility and accessibility to clients and to subclasses.
This allows classes to hide members that are not part of their public API.
When applied to fields, this ability to hide members enables an object-oriented design technique known as data encapsulation.
Classes and interfaces are the most important of the five fundamental reference types defined by Java.
Arrays, enumerated types (or “enums”) and annotation types are the other three.
Enums are a specialized kind of class and annotation types are a specialized kind of interface.
Class Definition Syntax At its simplest level, a class definition consists of the keyword class followed by the name of the class and a set of class members within curly braces.
The class keyword may be preceded by modifier keywords and annotations (see Chapter 4)
If the class extends another class, the class name is followed by the extends keyword and the name of the class being extended.
If the class implements one or more interfaces then the class name or the extends clause is followed by the implements keyword and a comma-separated list of interface names.
Class declarations may include zero or more of the following modifiers:
Any class with one or more abstract methods must be declared abstract.
Declaring a class final may enable the Java VM to optimize its methods.
By convention, if a class has more than one modifier, they appear in the order shown.
Fields and Methods A class can be viewed as a collection of data and code to operate on that data.
The data is stored in fields, and the code is organized into methods.
This section covers fields and methods, the two most important kinds of class members.
Fields and methods come in two distinct types: class members (also known as static members) are associated with the class itself, while instance members are associated with individual instances of the class (i.e., with objects)
The simple class definition for the class Circle, shown in Example 3-1, contains all four types of members.
An instance field public double r;                  // The radius of the circle.
Method declaration syntax is covered in “Methods” later in this chapter.
Field declaration syntax is much like the syntax for declaring local variables (see Chapter 2) except that field definitions may also include modifiers.
The simplest field declaration consists of the field type followed by the field name.
The type may be preceded by zero or more modifier keywords or annotations (see Chapter 4), and the name may be followed by an equals sign and initializer expression that provides the initial value of the field.
If two or more fields share the same type and modifiers, the type may be followed by a comma-separated list of field names and initializers.
Field modifiers are comprised of zero or more of the following keywords:
Fields that are both static and final are compile-time constants that the compiler can inline.
A class field is associated with the class in which it is defined rather than with an instance of the class.
This line declares a field of type double named PI and assigns it a value of 3.14159
As you can see, a field declaration looks quite a bit like a local variable declaration.
The difference, of course, is that variables are defined within methods while fields are members of classes.
The static modifier says that the field is a class field.
Class fields are sometimes called static fields because of this static modifier.
The final modifier says that the value of the field does not change.
Since the field PI represents a constant, we declare it final so that it cannot be changed.
It is a convention in Java (and many other languages) that constants are named with capital letters, which is why our field is named PI, not pi.
Defining constants like this is a common use for class fields, meaning that the static and final modifiers are often used together.
In other words, a field can be declared static without being declared final.
Finally, the public modifier says that anyone can use the field.
This is a visibility modifier, and we’ll discuss it and related modifiers in more detail later in this chapter.
The key point to understand about a static field is that there is only a single copy of it.
This field is associated with the class itself, not with instances of the class.
If you look at the various methods of the Circle class, you’ll see that they use this field.
From inside the Circle class, the field can be referred to simply as PI.
Outside the class, however, both class and field names are required to uniquely specify the field.
Methods that are not part of Circle access this field as Circle.PI.
The names of class fields are qualified by the unique names of the classes that contain them, however.
Thus, Java does not suffer from the name collisions that can affect other languages when different modules of code define global variables with the same name.
As with class fields, class methods are declared with the static modifier:
It has a single parameter of type double and returns a double value.
The body of the method is quite short; it performs a simple computation and returns the result.
Like class fields, class methods are associated with a class, rather than with an object.
When invoking a class method from code that exists outside the class, you must specify both the name of the class and the method.
If you want to invoke a class method from inside the class in which it is defined, you don’t have to specify the class name.
However, it is often good style to specify the class name anyway, to make it clear that a class method is being invoked.
A class method can use any class fields and class methods of its own class (or of any other class)
But it cannot use any instance fields or instance methods because class methods are not associated with an instance of the class.
In other words, although the radiansToDegrees() method is defined in the Circle class, it does not use any Circle objects.
The instance fields and instance methods of the class are associated with Circle objects, not with the class itself.
Since a class method is not associated with an instance of its class, it cannot use any instance methods or fields.
As we discussed earlier, a class field is essentially a global variable.
In a similar way, a class method is a global method, or global function.
Although radiansToDegrees() does not operate on Circle objects, it is defined within the Circle class because it is a utility method that is sometimes useful when working with circles.
In many nonobject-oriented programming languages, all methods, or functions, are global.
You can write complex Java programs using only class methods.
This is not object-oriented programming, however, and does not take advantage of the power of the Java language.
To do true object-oriented programming, we need to add instance fields and instance methods to our repertoire.
Any field declared without the static modifier is an instance field:
Instance fields are associated with instances of the class, rather than with the class itself.
Thus, every Circle object we create has its own copy of the double field r.
In our example, r represents the radius of a circle.
Thus, each Circle object can have a radius independent of all other Circle objects.
Inside a class definition, instance fields are referred to by name alone.
You can see an example of this if you look at the method body of the circumference() instance method.
In code outside the class, the name of an instance method must be prefixed with a reference to the object that contains it.
For example, if the variable c holds a reference to a Circle object, we use the expression c.r to refer to the radius of that circle:
Instance fields hold the state of an object; the values of those fields make one object distinct from another.
Any method not declared with the static keyword is an instance method.
An instance method operates on an instance of a class (an object) instead of operating on the class itself.
It is with instance methods that object-oriented programming starts to get interesting.
The Circle class defined in Example 3-1 contains two instance methods, area( ) and circumference(), that compute and return the area and circumference of the circle represented by a given Circle object.
To use an instance method from outside the class in which it is defined, we must prefix it with a reference to the instance that is to be operated on.
If you’re new to object-oriented programming, that last line of code may look a little strange.
This is why it is called object-oriented programming; the object is the focus here, not the function call.
This small syntactic difference is perhaps the single most important feature of the object-oriented paradigm.
The point here is that we don’t have to pass an argument to c.area()
The object we are operating on, c, is implicit in the syntax.
You’ll notice the same thing in the signature of the area( ) method: it doesn’t have a parameter.
Now look at the body of the area( ) method: it uses the instance field r.
Because the area() method is part of the same class that defines this instance field, the method can use the unqualified name r.
It is understood that this refers to the radius of whatever Circle instance invokes the method.
Another important thing to notice about the bodies of the area( ) and circumference() methods is that they both use the class field PI.
We saw earlier that class methods can use only class fields and class methods, not instance fields or methods.
Instance methods are not restricted in this way: they can use any member of a class, whether it is declared static or not.
What’s going on here? How can a method that has no parameters know what data to operate on? In fact, the area( ) method does have a parameter.
All instance methods are implemented with an implicit parameter not shown in the method signature.
The implicit argument is named this; it holds a reference to the object through which the method is invoked.
The implicit this parameter is not shown in method signatures because it is usually not needed; whenever a Java method accesses the instance fields in its class, it is implicit that it is accessing fields in the object referred to by the this parameter.
The same is true when an instance method invokes another instance method in the same class.
I said earlier that to invoke an instance method you must prepend a reference to the object to be operated on.
When an instance method is invoked within another instance method in the same class, however, you don’t need to specify an object.
In this case, it is implicit that the method is being invoked on the this object.
You can use the this keyword explicitly when you want to make it clear that a method is accessing its own fields and/or methods.
For example, we can rewrite the area() method to use this explicitly to refer to instance fields:
This code also uses the class name explicitly to refer to class field PI.
In a method this simple, it is not necessary to be explicit.
In more complicated cases, however, you may find that it increases the clarity of your code to use an explicit this where it is not strictly required.
For example, when a method parameter or local variable in a method has the same name as one of the fields of the class, you must use this to refer to the field since the field name used alone refers to the method parameter or local variable.
For example, we can add the following method to the Circle class:
Finally, note that while instance methods can use the this keyword, class methods cannot.
This is because class methods are not associated with objects.
Instance methods are one of the key features of object-oriented programming.
That doesn’t mean, however, that you should shun class methods.
In many cases, it is perfectly reasonable to define class methods.
When working with the Circle class, for example, you might find that you often want to compute the area of a circle with a given radius but don’t want to bother creating a Circle object to represent that circle.
It is perfectly legal for a class to define more than one method with the same name, as long as the methods have different parameters.
Since this version of the area() method is a class method, it does not have an implicit this parameter and must have a parameter that specifies the radius of the circle.
This parameter keeps it distinct from the instance method of the same name.
As another example of the choice between instance methods and class methods, consider defining a method named bigger( ) that examines two Circle objects.
We can write bigger( ) as an instance method as follows:
We can also implement bigger( ) as a class method as follows:
Given two Circle objects, x and y, we can use either the instance method or the class method to determine which is bigger.
The invocation syntax differs significantly for the two methods, however:
Both methods work well, and, from an object-oriented design standpoint, neither of these methods is “more correct” than the other.
The instance method is more formally object-oriented, but its invocation syntax suffers from a kind of asymmetry.
In a case like this, the choice between an instance method and a class method is simply a design decision.
Depending on the circumstances, one or the other will likely be the more natural choice.
We’ve never explained why this method has such an long, awkward name or what those two periods are doing in it.
Now that you understand class and instance fields and class and instance methods, it is easier to understand what is going on: System is a class.
The object System.out has an instance method named println( )
Creating and Initializing Objects Now that we’ve covered fields and methods, we move on to other important members of a class.
Constructors and initializers are class members whose job is to initialize the fields of a class.
Take another look at how we’ve been creating Circle objects:
What are those parentheses doing there? They make it look like we’re calling a method.
Every class in Java has at least one constructor, which is a method that has the same name as the class and whose purpose is to perform any necessary initialization for a new object.
Since we didn’t explicitly define a constructor for our Circle class in Example 3-1, Java gave us a default constructor that takes no arguments and performs no special initialization.
The new operator creates a new, but uninitialized, instance of the class.
The constructor method is then called, with the new object passed implicitly (a this reference, as we saw earlier) as well as whatever arguments that are specified between parentheses passed explicitly.
The constructor can use these arguments to do whatever initialization is necessary.
There is some obvious initialization we could do for our circle objects, so let’s define a constructor.
Example 3-2 shows a new definition for Circle that contains a constructor that lets us specify the radius of a new Circle object.
The constructor also uses the this reference to distinguish between a method parameter and an instance field of the same name.
When we relied on the default constructor supplied by the compiler, we had to write code like this to initialize the radius explicitly:
With this new constructor, the initialization becomes part of the object creation step:
Here are some important notes about naming, declaring, and writing constructors:
The constructor name is always the same as the class name.
Unlike all other methods, a constructor is declared without a return type, not even void.
The body of a constructor should initialize the this object.
A constructor may not return this or any other value.
A constructor may include a return statement, but only one that does not include a return value.
Sometimes you want to initialize an object in a number of different ways, depending on what is most convenient in a particular circumstance.
For example, we might want to initialize the radius of a circle to a specified value or a reasonable default value.
Since our Circle class has only a single instance field, we can’t initialize it too many ways, of course.
But in more complex classes, it is often convenient to define a variety of constructors.
It is perfectly legal to define multiple constructors for a class, as long as each constructor has a different parameter list.
The compiler determines which constructor you wish to use based on the number and type of arguments you supply.
A specialized use of the this keyword arises when a class has multiple constructors; it can be used from a constructor to invoke one of the other constructors of the same class.
In other words, we can rewrite the two previous Circle constructors as follows:
The this( ) syntax is a method invocation that calls one of the other constructors of the class.
The particular constructor that is invoked is determined by the number and type of arguments, of course.
This is a useful technique when a number of constructors share a significant amount of initialization code, as it avoids repetition of that code.
This would be a more impressive example, of course, if the one-parameter version of the Circle( ) constructor did more initialization than it does.
There is an important restriction on using this(): it can appear only as the first statement in a constructor.
It may, of course, be followed by any additional initialization a particular version of the constructor needs to do.
The reason for this restriction involves the automatic invocation of superclass constructor methods, which we’ll explore later in this chapter.
These default values are guaranteed by Java and apply to both instance fields and class fields.
If the default field value is not appropriate for your field, you can explicitly provide a different initial value.
Field declarations and local variable declarations have similar syntax, but there is an important difference in how their initializer expressions are handled.
As described in Chapter 2, a local variable declaration is a statement that appears within a Java method; the variable initialization is performed when the statement is executed.
Field declarations, however, are not part of any method, so they cannot be executed as statements are.
Instead, the Java compiler generates instance-field initialization code automatically and puts it in the constructor or constructors for the class.
The initialization code is inserted into a constructor in the order in which it appears in the source code, which means that a field initializer can use the initial values of any fields declared before it.
Consider the following code excerpt, which shows a constructor and two instance fields of a hypothetical class:
In this case, the code generated for the constructor is actually equivalent to the following:
If a constructor begins with a this( ) call to another constructor, the field initialization code does not appear in the first constructor.
Instead, the initialization is handled in the constructor invoked by the this( ) call.
So, if instance fields are initialized in constructor methods, where are class fields initialized? These fields are associated with the class, even if no instances of the class are ever created, so they need to be initialized even before a constructor is called.
To support this, the Java compiler generates a class initialization method.
As with instance field initialization, class field initialization expressions are inserted into the class initialization method in the order in which they appear in the source code.
This means that the initialization expression for a class field can use the class fields declared before it.
The class initialization method is an internal method that is hidden from Java programmers.
So far, we’ve seen that objects can be initialized through the initialization expressions for their fields and by arbitrary code in their constructor methods.
A class has a class initialization method, which is like a constructor, but we cannot explicitly define the body of this method as we can for a constructor.
Java does allow us to write arbitrary code for the initialization of class fields, however, with a construct known as a static initializer.
A static initializer is simply the keyword static followed by a block of code in curly braces.
A static initializer can appear in a class definition anywhere a field or method definition can appear.
For example, consider the following code that performs some nontrivial initialization for two class fields:
The body of each initializer block is incorporated into the class initialization method, along with any static field initialization expressions.
A static initializer is like a class method in that it cannot use the this keyword or any instance fields or instance methods of the class.
It is actually possible to write a class initializer for a class C that calls a method of another class that creates an instance of C.
In this contrived recursive case, an instance of C is created before the class C is fully initialized.
In Java 1.1 and later, classes are also allowed to have instance initializers.
An instance initializer is like a static initializer, except that it initializes an object, not a class.
A class can have any number of instance initializers, and they can appear anywhere a field or method definition can appear.
The body of each instance initializer is inserted at the beginning of every constructor for the class, along with any field initialization expressions.
An instance initializer looks just like a static initializer, except that it doesn’t use the static keyword.
In other words, an instance initializer is just a block of arbitrary Java code that appears within curly braces.
Instance initializers can initialize arrays or other fields that require complex initialization.
They are sometimes useful because they locate the initialization code right next to the field, instead of separating into a constructor method.
In practice, however, this use of instance initializers is fairly rare.
Instance initializers were introduced in Java 1.1 to support anonymous inner classes, which are not allowed to define constructors.
Anonymous inner classes are covered in “Nested Types” later in this chapter.
Destroying and Finalizing Objects Now that we’ve seen how new objects are created and initialized in Java, we need to study the other end of the object life cycle and examine how objects are finalized and destroyed.
In Java, the memory occupied by an object is automatically reclaimed when the object is no longer needed.
This is done through a process known as garbage collection.
Garbage collection is a technique that has been around for years in languages such as Lisp.
It takes some getting used to for programmers accustomed to such languages as C and C++, in which you must call the free() function or the delete operator to reclaim memory.
The fact that you don’t need to remember to destroy every object you create is one of the features that makes Java a pleasant language to work with.
It is also one of the features that makes programs written in Java less prone to bugs than those written in languages that don’t support automatic garbage collection.
The Java interpreter knows exactly what objects and arrays it has allocated.
It can also figure out which local variables refer to which objects and arrays and which objects and arrays refer to which other objects and arrays.
Thus, the interpreter is able to determine when an allocated object is no longer referred to by any other active object or variable.
When the interpreter finds such an object, it knows it can safely reclaim the object’s memory and does so.
The garbage collector can also detect and destroy cycles of objects that refer to each other, but are not referenced by any other active objects.
It is reasonable, however, to imagine the garbage collector running as a low-priority.
The only time the garbage collector must run while something high-priority is going on (i.e., the only time it actually slows down the system) is when available memory has become dangerously low.
This doesn’t happen very often because the low-priority thread cleans things up in the background.
The fact that Java supports garbage collection dramatically reduces the incidence of a class of bugs known as memory leaks.
A memory leak occurs when memory is allocated and never reclaimed.
At first glance, it might seem that garbage collection prevents all memory leaks because it reclaims all unused objects.
A memory leak can still occur in Java, however, if a valid (but unused) reference to an unused object is left hanging around.
For example, when a method runs for a long time (or forever), the local variables in that method can retain object references much longer than they are actually required.
It will get garbage collected when there // are no more references to it.
Since big_array is a local variable, // it refers to the array until this method returns.
So we've got to explicitly get rid of the reference // ourselves, so the garbage collector knows it can reclaim the array.
Memory leaks can also occur when you use a hash table or similar data structure to associate one object with another.
Even when neither object is required anymore, the association remains in the hash table, preventing the objects from being reclaimed until the hash table itself is reclaimed.
If the hash table has a substantially longer lifetime than the objects it holds, this can cause memory leaks.
The key to avoiding memory leaks is to set object references to null when they are no longer needed if the object that contains those references is going to continue to exist.
One common source of leaks is in data structures in which an Object array is used to represent a collection of objects.
It is common to use a separate size field to keep track of which elements of the array are currently valid.
When removing an object from the collection, it is not sufficient to simply decrement this size field: you must also set the appropriate array element to null so that the obsolete object reference does not live on.
A finalizer in Java is the opposite of a constructor.
While a constructor method performs initialization for an object, a finalizer method can be used to perform cleanup or “finalization” for the object.
Garbage collection automatically frees up the memory resources used by objects, but objects can hold other kinds of resources, such as open files and network connections.
The garbage collector cannot free these resources for you, so you may occasionally want to write a finalizer method for any object that needs to perform such tasks as closing files, terminating network connections, deleting temporary files, and so on.
This is particularly true for classes that use native methods: these classes may need a native finalizer to release native resources (including memory) that are not under the control of the Java garbage collector.
A finalizer is an instance method that takes no arguments and returns no value.
There can be only one finalizer per class, and it must be named finalize().* A finalizer can throw any kind of exception or error, but when a finalizer is automatically invoked by the garbage collector, any exception or error it throws is ignored and serves only to cause the finalizer method to return.
Finalizer methods are typically declared protected (which we have not discussed yet) but can also be declared public.
If an object has a finalizer, the finalizer method is invoked sometime after the object becomes unused (or unreachable), but before the garbage collector reclaims the object.
Java makes no guarantees about when garbage collection will occur or in what order objects will be collected.
Therefore, Java can make no guarantees about when (or even whether) a finalizer will be invoked, in what order finalizers will be invoked, or what thread will execute finalizers.
The Java interpreter can exit without garbage collecting all outstanding objects, so some finalizers may never be invoked.
In this case, resources such as network connections are closed and reclaimed by the operating system.
Note, however, that if a finalizer that deletes a file does not run, that file will not be deleted by the operating system.
C++ programmers should note that although Java constructor methods are named like C++ constructors, Java finalization methods are not named like C++ destructor methods.
As we will see, they do not behave quite like C++ destructor methods either.
Unfortunately, however, this method can cause deadlock and is inherently unsafe; it was deprecated in 1.2
In Java 1.3 and later, the Runtime method addShutdownHook() can safely execute arbitrary code before the Java interpreter exits.
After a finalizer is invoked, objects are not freed right away.
This is because a finalizer method can resurrect an object by storing the this pointer somewhere so that the object once again has references.
Thus, after finalize() is called, the garbage collector must once again determine that the object is unreferenced before it can garbage-collect it.
However, even if an object is resurrected, the finalizer method is never invoked more than once.
Resurrecting an object is never a useful thing to do—just a strange quirk of object finalization.
The finalize( ) method is an instance method, and finalizers act on instances.
In practice, it is quite rare for an application-level class to require a finalize( ) method.
Finalizer methods are more useful, however, when writing Java classes that interface to native platform code with native methods.
In this case, the native implementation can allocate memory or other resources that are not under the control of the Java garbage collector and need to be reclaimed explicitly by a native finalize() method.
Furthermore, because of the uncertainty about when and whether a finalizer runs, it is best to avoid dependence on finalizers.
For example, a class that includes a reference to a network socket should define a public close() method, which calls the close( ) method of the socket.
This way, when the user of your class is done with it, she can call close( ) and be sure that the network connection is closed.
You might, however, define a finalize( ) method as backup in case the user of your class forgets to call close( ) and allows an unclosed instance to be garbage-collected.
Subclasses and Inheritance The Circle defined earlier is a simple class that distinguishes circle objects only by their radii.
Suppose, instead, that we want to represent circles that have both a size and a position.
To do this, we need a new class, which we’ll call PlaneCircle.
We’d like to add the ability to represent the position of a circle without losing any of the existing functionality of the Circle class.
This is done by defining PlaneCircle as a subclass of Circle so that PlaneCircle inherits the fields and methods of its superclass, Circle.
The ability to add functionality to a class by subclassing, or extending, is central to the object-oriented programming paradigm.
Example 3-3 shows how we can implement PlaneCircle as a subclass of the Circle class.
Note the use of the keyword extends in the first line of Example 3-3
This keyword tells Java that PlaneCircle extends, or subclasses, Circle, meaning that it inherits the fields and methods of that class.* The definition of the isInside() method shows field inheritance; this method uses the field r (defined by the Circle class) as if it were defined right in PlaneCircle itself.
Thus, if we have a PlaneCircle object referenced by variable pc, we can say:
This works just as if the area( ) and circumference() methods were defined in PlaneCircle itself.
Another feature of subclassing is that every PlaneCircle object is also a perfectly legal Circle object.
If pc refers to a PlaneCircle object, we can assign it to a Circle variable and forget all about its extra positioning capabilities:
This assignment of a PlaneCircle object to a Circle variable can be done without a cast.
As we discussed in “Reference Type Conversions” in Chapter 2 a widening conversion like this is always legal.
The value held in the Circle variable c is still a valid PlaneCircle object, but the compiler cannot know this for sure, so it doesn’t allow us to do the opposite (narrowing) conversion without a cast:
C++ programmers should note that extends is the Java equivalent of : in C++; both are used to indicate the superclass of a class.
When a class is declared with the final modifier, it means that it cannot be extended or subclassed.
Declaring a class final prevents unwanted extensions to the class: if you invoke a method on a String object, you know that the method is the one defined by the String class itself, even if the String is passed to you from some unknown outside source.
Because String is final, no one can create a subclass of it and change the meaning or behavior of its methods.
Declaring a class final also allows the compiler to make certain optimizations when invoking the methods of a class.
We’ll explore this when we talk about method overriding later in this chapter.
We can also say that Circle is the superclass of PlaneCircle.
The superclass of a class is specified in its extends clause:
Object is a special class for a couple of reasons:
It is the only class in Java that does not have a superclass.
Because every class has a superclass, classes in Java form a class hierarchy, which can be represented as a tree with Object at its root.
Figure 3-1 shows a partial class hierarchy diagram that includes our Circle and PlaneCircle classes, as well as some of the standard classes from the Java API.
Look again at the PlaneCircle() constructor method of Example 3-3:
This constructor explicitly initializes the cx and cy fields newly defined by PlaneCircle, but it relies on the superclass Circle( ) constructor to initialize the inherited fields of the class.
One of its uses is to invoke the constructor method of a superclass from within the constructor method of a subclass.
This use is analogous to the use of this( ) to invoke one constructor.
Invoking a constructor using super() is subject to the same restrictions as is using this( ) :
The call to the superclass constructor must appear as the first statement within the constructor method, even before local variable declarations.
The arguments passed to super( ) must match the parameters of the superclass constructor.
If the superclass defines more than one constructor, super( ) can be used to invoke any one of them, depending on the arguments passed.
Java guarantees that the constructor method of a class is called whenever an instance of that class is created.
It also guarantees that the constructor is called whenever an instance of any subclass is created.
In order to guarantee this second point, Java must ensure that every constructor method calls its superclass constructor method.
Thus, if the first statement in a constructor does not explicitly invoke another constructor with this() or super( ), Java implicitly inserts the call super( ), that is, it calls the superclass constructor with no arguments.
If the superclass does not have a constructor that takes no arguments, this implicit invocation causes a compilation error.
Consider what happens when we create a new instance of the PlaneCircle class.
This constructor explicitly calls super(r) to invoke a Circle constructor, and that Circle() constructor implicitly calls super() to invoke the constructor of its superclass, Object.
When it returns, the body of the Circle( ) constructor runs.
Finally, when the call to super(r) returns, the remaining statements of the PlaneCircle( ) constructor are executed.
What all this means is that constructor calls are chained; any time an object is created, a sequence of constructor methods is invoked, from subclass to superFigure 3-1
Because a superclass constructor is always invoked as the first statement of its subclass constructor, the body of the Object constructor always runs first, followed by the constructor of its subclass and on down the class hierarchy to the class that is being instantiated.
There is an important implication here; when a constructor is invoked, it can count on the fields of its superclass to be initialized.
There is one missing piece in the previous description of constructor chaining.
If a constructor does not invoke a superclass constructor, Java does so implicitly.
But what if a class is declared without a constructor? In this case, Java implicitly adds a constructor to the class.
This default constructor does nothing but invoke the superclass constructor.
For example, if we don’t declare a constructor for the PlaneCircle class, Java implicitly inserts this constructor:
If the superclass, Circle, doesn’t declare a no-argument constructor, the super( ) call in this automatically inserted default constructor for PlaneCircle( ) causes a compilation error.
In general, if a class does not define a no-argument constructor, all its subclasses must define constructors that explicitly invoke the superclass constructor with the necessary arguments.
If a class does not declare any constructors, it is given a no-argument constructor by default.
All other classes are given a default constructor that is declared without any visibility modifier: such a constructor has default visibility.
The notion of visibility is explained later in this chapter.
If you are creating a public class that should not be publicly instantiated, you should declare at least one non-public constructor to prevent the insertion of a default public constructor.
Such a constructor can never be invoked from outside of the class, but it prevents the automatic insertion of the default constructor.
You might assume that since Java chains constructor methods, it also automatically chains the finalizer methods for an object.
In other words, you might assume that the finalizer method of a class automatically invokes the finalizer of its superclass, and so on.
When you write a finalize() method, you must explicitly invoke the superclass finalizer.
You should do this even if you know that the superclass does not have a finalizer because a future implementation of the superclass might add a finalizer.
As we saw in our example finalizer earlier in the chapter, you can invoke a superclass method with a special syntax that uses the super keyword:
We’ll discuss this syntax in more detail when we consider method overriding.
In practice, the need for finalizer methods, and thus finalizer chaining, rarely arises.
For the sake of example, imagine that our PlaneCircle class needs to know the distance between the center of the circle and the origin (0,0)
We can add another instance field to hold this value:
Adding the following line to the constructor computes the value of the field:
But wait; this new field r has the same name as the radius field r in the Circle superclass.
When this happens, we say that the field r of PlaneCircle hides the field r of Circle.
This is a contrived example, of course: the new field should really be called distanceFromOrigin.
Although you should attempt to avoid it, subclass fields do sometimes hide fields of their superclass.
With this new definition of PlaneCircle, the expressions r and this.r both refer to the field of PlaneCircle.
How, then, can we refer to the field r of Circle that holds the radius of the circle? A special syntax for this uses the super keyword:
Another way to refer to a hidden field is to cast this (or any instance of the class) to the appropriate superclass and then access the field:
This casting technique is particularly useful when you need to refer to a hidden field defined in a class that is not the immediate superclass.
Suppose, for example, that classes A, B, and C all define a field named x and that C is a subclass of B, which is a subclass of A.
Then, in the methods of class C, you can refer to these different fields as follows:
You cannot refer to a hidden field x in the superclass of a superclass with super.super.x.
Similarly, if you have an instance c of class C, you can refer to the three fields named x like this:
You can use the same super syntax to refer to the hidden value of the field, but this is never necessary since you can always refer to a class field by prepending the name of the desired class.
Now, code in PlaneCircle can use this more accurate value with the expressions PI or PlaneCircle.PI.
It can also refer to the old, less accurate value with the expressions super.PI and Circle.PI.
Note, however, that the area( ) and circumference() methods inherited by PlaneCircle are defined in the Circle class, so they use the value Circle.PI, even though that value is hidden now by PlaneCircle.PI.
When a class defines an instance method using the same name, return type, and parameters as a method in its superclass, that method overrides the method of the superclass.
When the method is invoked for an object of the class, it is the new definition of the method that is called, not the superclass’s old definition.
In Java 5.0 and later, the return type of the overriding method may be a subclass of return type of the overridden method instead of being exactly the same type.
Method overriding is an important and useful technique in object-oriented programming.
PlaneCircle does not override either of the methods defined by Circle, but suppose we define another subclass of Circle, named Ellipse.* In this case, it is important for Ellipse to override the area( ) and circumference() methods of Circle since the formulas used to compute the area and circumference of a circle do not work for ellipses.
The upcoming discussion of method overriding considers only instance methods.
Class methods behave quite differently, and there isn’t much to say.
Like fields, class methods can be hidden by a subclass but not overridden.
As noted earlier in this chapter, it is good programming style to always prefix a class method invocation with the name of the class in which it is defined.
If you consider the class name part of the class method name, the two methods have different names, so nothing is actually hidden at all.
It is, however, illegal for a class method to hide an instance method.
Before we go any further with the discussion of method overriding, you should understand the difference between method overriding and method overloading.
As we discussed in Chapter 2, method overloading refers to the practice of defining multiple methods (in the same class) that have the same name but different parameter lists.
This is very different from method overriding, so don’t get them confused.
Mathematical purists may argue that since all circles are ellipses, Ellipse should be the superclass and Circle the subclass.
A pragmatic engineer might counter that circles can be represented with fewer instance fields, so Circle objects should not be burdened by inheriting unnecessary fields from Ellipse.
Although Java treats the fields and methods of a class analogously in many ways, method overriding is not like field hiding at all.
You can refer to hidden fields simply by casting an object to an instance of the appropriate superclass, but you cannot invoke overridden instance methods with this technique.
While this difference between method overriding and field hiding may seem surprising at first, a little thought makes the purpose clear.
Suppose we are manipulating a bunch of Circle and Ellipse objects.
To keep track of the circles and ellipses, we store them in an array of type Circle[]
We can do this because Ellipse is a subclass of Circle, so all Ellipse objects are legal Circle objects.
When we loop through the elements of this array, we don’t have to know or care whether the element is actually a Circle or an Ellipse.
What we do care about very much, however, is that the correct value is computed when we invoke the area() method of any element of the array.
In other words, we don’t want to use the formula for the area of a circle when the object is actually an ellipse! Seen in this context, it is not surprising at all that method overriding is handled differently by Java than is field hiding.
If we have a Circle[ ] array that holds Circle and Ellipse objects, how does the compiler know whether to call the area( ) method of the Circle class or the.
Ellipse class for any given item in the array? In fact, the compiler does not know this because it cannot know it.
The compiler knows that it does not know, however, and produces code that uses dynamic method lookup at runtime.
When the interpreter runs the code, it looks up the appropriate area( ) method to call for each of the objects in the array.
That is, when the interpreter interprets the expression o.area(), it checks the actual type of the object referred to by the variable o and then finds the area( ) method that is appropriate for that type.
It does not simply use the area( ) method that is statically associated with the type of the variable o.
This process of dynamic method lookup is sometimes also called virtual method invocation.*
Virtual method invocation is fast, but method invocation is faster when no dynamic lookup is necessary at runtime.
Fortunately, Java does not always need to use dynamic method lookup.
In particular, if a method is declared with the final modifier, it means that the method definition is the final one; it cannot be overridden by any subclasses.
If a method cannot be overridden, the compiler knows that there is only one version of the method, and dynamic method lookup is not necessary.† In addition, all methods of a final class are themselves implicitly final and cannot be overridden.
As we’ll discuss later in this chapter, private methods are not inherited by subclasses and, therefore, cannot be overridden (i.e., all private methods are implicitly final)
Finally, class methods behave like fields (i.e., they can be hidden by subclasses but not overridden)
Taken together, this means that all methods of a class that is declared final, as well as all methods that are final, private, or static, are invoked without dynamic method lookup.
These methods are also candidates for inlining at runtime by a just-in-time compiler ( JIT) or similar optimization tool.
We’ve seen the important differences between method overriding and field hiding.
Nevertheless, the Java syntax for invoking an overridden method is quite similar to the syntax for accessing a hidden field: both use the super keyword.
C++ programmers should note that dynamic method lookup is what C++ does for virtual functions.
An important difference between Java and C++ is that Java does not have a virtual keyword.
In this sense, the final modifier is the opposite of the virtual modifier in C++
Recall that when you use super to refer to a hidden field, it is the same as casting this to the superclass type and accessing the field through that.
Using super to invoke an overridden method, however, is not the same as casting this.
In other words, in the previous code, the expression super.f() is not the same as ((A)this).f( )
When the interpreter invokes an instance method with this super syntax, a modified form of dynamic method lookup is performed.
The first step, as in regular dynamic method lookup, is to determine the actual class of the object through which the method is invoked.
Normally, the dynamic search for an appropriate method definition would begin with this class.
When a method is invoked with the super syntax, however, the search begins at the superclass of the class.
If the superclass implements the method directly, that version of the method is invoked.
If the superclass inherits the method, the inherited version of the method is invoked.
Note that the super keyword invokes the most immediately overridden version of a method.
Suppose class A has a subclass B that has a subclass C and that all three classes define the same method f( )
The method C.f() can invoke the method B.f( ), which it overrides directly, with super.f( )
But there is no way for C.f() to invoke A.f( ) directly: super.super.f( ) is not legal Java syntax.
Of course, if C.f() invokes B.f( ), it is reasonable to suppose that B.f( ) might also invoke A.f()
This kind of chaining is relatively common when working with overridden methods: it is a way of augmenting the behavior of a method without replacing the method entirely.
We saw this technique in the the example finalize() method shown earlier in the chapter: that method invoked super.finalize() to run its superclass finalization method.
Don’t confuse the use of super to invoke an overridden method with the super() method call used in constructor methods to invoke a superclass constructor.
Although they both use the same keyword, these are two entirely different syntaxes.
In particular, you can use super to invoke an overridden method anywhere in the overriding class while you can use super() only to invoke a superclass constructor as the very first statement of a constructor.
It is also important to remember that super can be used only to invoke an overridden method from within the class that overrides it.
Given an Ellipse object e, there is no way for a program that uses an object (with or without the super syntax) to invoke the area() method defined by the Circle class on this object.
Data Hiding and Encapsulation We started this chapter by describing a class as a collection of data and methods.
One of the important object-oriented techniques we haven’t discussed so far is hiding the data within the class and making it available only through the methods.
Why would you want to do this? The most important reason is to hide the internal implementation details of your class.
If you prevent programmers from relying on those details, you can safely modify the implementation without worrying that you will break existing code that uses the class.
Another reason for encapsulation is to protect your class against accidental or willful stupidity.
A class often contains a number of interdependent fields that must be in a consistent state.
If you allow a programmer (including yourself) to manipulate those fields directly, he may change one field without changing important related fields, leaving the class in an inconsistent state.
If instead he has to call a method to change the field, that method can be sure to do everything necessary to keep the state consistent.
Similarly, if a class defines certain methods for internal use only, hiding these methods prevents users of the class from calling them.
Here’s another way to think about encapsulation: when all the data for a class is hidden, the methods define the only possible operations that can be performed on objects of that class.
Once you have carefully tested and debugged your methods, you can be confident that the class will work as expected.
On the other hand, if all the fields of the class can be directly manipulated, the number of possibilities you have to test becomes unmanageable.
Other reasons to hide fields and methods of a class include:
Internal fields and methods that are visible outside the class just clutter up the API.
Keeping visible fields to a minimum keeps your class tidy and therefore easier to use and understand.
If a field or method is visible to the users of your class, you have to document it.
All the fields and methods of a class can always be used within the body of the class itself.
Java defines access control rules that restrict members of a class from being used outside the class.
In a number of examples in this chapter, you’ve seen the public modifier used in field and method declarations.
This public keyword, along with protected and private, are access control modifiers; they specify the access rules for the field or method.
A package is always accessible to code defined within the package.
Whether it is accessible to code from other packages depends on the way the package is deployed on the host system.
When the class files that comprise a package are stored in a directory, for example, a user must have read access to the directory and the files within it in order to have access to the package.
Package access is not part of the Java language itself.
Access control is usually done at the level of classes and members of classes instead.
By default, top-level classes are accessible within the package in which they are defined.
However, if a top-level class is declared public, it is accessible everywhere (or everywhere that the package itself is accessible)
The reason that we’ve restricted these statements to top-level classes is that, as we’ll see later in this chapter, classes can also be defined as members of other classes.
Because these inner classes are members of a class, they obey the member access-control rules.
The members of a class are always accessible within the body of the class.
By default, members are also accessible throughout the package in which the class is defined.
This implies that classes placed in the same package should trust each other with their internal implementation details.
This default level of access is often called package access.
It is only one of four possible levels of access.
The other three levels of access are defined by the public, protected, and private modifiers.
If a member of a class is declared with the public modifier, it means that the member is accessible anywhere the containing class is accessible.
If a member of a class is declared private, the member is never accessible, except within the class itself.
If a member of a class is declared protected, it is accessible to all classes within the package (the same as the default package accessibility) and also accessible within the body of any subclass of the class, regardless of the package in which that subclass is defined.
This is more restrictive than public access, but less restrictive than package access.
If a member of a class is not declared with any of these modifiers, it has the default package access: it is accessible to code within all classes that are defined in the same package but inaccessible outside of the package.
Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important)
Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to.
This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them.
The Java specification states that a subclass inherits all the instance fields and instance methods of its superclass accessible to it.
If the subclass is defined in the same package as the superclass, it inherits all non-private instance fields and methods.
If the subclass is defined in a different package, however, it inherits all protected and public instance fields and methods.
Finally, constructors are not inherited; they are chained, as described earlier in this chapter.
The statement that a subclass does not inherit the inaccessible fields and methods of its superclass can be a confusing one.
It would seem to imply that when you create an instance of a subclass, no memory is allocated for any private fields defined by the superclass.
Every instance of a subclass does, in fact, include a complete instance of the superclass within it, including all inaccessible fields and methods.
Because the inaccessible fields cannot be used in the subclass, we say they are not inherited.
Earlier in this section we said that the members of a class are always accessible within the body of the class.
If this statement is to apply to all members of the class, including inherited members, we must define “inherited members” to include only those members that are accessible.
If you don’t care for this definition, you can think of it this way instead:
A class inherits all instance fields and instance methods (but not constructors) of its superclass.
The body of a class can always access all the fields and methods it declares itself.
It can also access the accessible fields and members it inherits from its superclass.
Here are some simple rules of thumb for using visibility modifiers:
Use public only for methods and constants that form part of the public API of the class.
Certain important or frequently used fields can also be public, but it is common practice to make fields non-public and encapsulate them with public accessor methods.
Use protected for fields and methods that aren’t required by most programmers using the class but that may be of interest to anyone creating a subclass.
Note that protected members are technically part of the exported API of a class.
They should be documented and cannot be changed without potentially breaking code that relies on them.
Use the default package visibility for fields and methods that are internal implementation details but are used by cooperating classes in the same package.
You cannot take real advantage of package visibility unless you use the package directive to group your cooperating classes into a package.
Use private for fields and methods that are used only inside the class and should be hidden everywhere else.
If you are not sure whether to use protected, package, or private accessibility, it is better to start with overly restrictive member access.
You can always relax the access restrictions in future versions of your class, if necessary.
Doing the reverse is not a good idea because increasing access restrictions is not a backwardcompatible change and can break code that relies on access to those members.
In the Circle example, we declared the circle radius to be a public field.
The Circle class is one in which it may well be reasonable to keep that field publicly accessible; it is a simple enough class, with no dependencies between its fields.
On the other hand, our current implementation of the class allows a Circle object to have a negative radius, and circles with negative radii should simply not exist.
As long as the radius is stored in a public field, however, any programmer can set the field to any value she wants, no matter how unreasonable.
The only solution is to restrict the programmer’s direct access to the field and define public methods that provide indirect access to the field.
Providing public methods to read and write a field is not the same as making the field itself public.
The crucial difference is that methods can perform error checking.
Example 3-4 shows how we might reimplement Circle to prevent circles with negative radii.
This version of Circle declares the r field to be protected and defines accessor methods named getRadius( ) and setRadius() to read and write the field value while enforcing the restriction on negative radius values.
Because the r field is protected, it is directly (and more efficiently) accessible to subclasses.
We have defined the Circle class within a package named shapes.
Since r is protected, any other classes in the shapes package have direct access to that field and can set it however they like.
The assumption here is that all classes within the shapes package were written by the same author or a closely cooperating group of authors and that the classes all trust each other not to abuse their privileged level of access to each other’s implementation details.
Finally, the code that enforces the restriction against negative radius values is itself placed within a protected method, checkRadius()
Although users of the Circle class cannot call this method, subclasses of the class can call it and even override it if they want to change the restrictions on the radius.
Note particularly the getRadius() and setRadius( ) methods of Example 3-4
It is a common convention in Java that data accessor methods begin with the prefixes “get” and “set.” If the field being accessed is of type boolean, however, the get() method may be replaced with an equivalent method that begins with “is.” For example, the accessor method for a boolean field named readable is typically called isReadable( ) instead of getReadable()
In the programming conventions of the JavaBeans component model (covered in Chapter 7), a hidden field with one or more data accessor methods whose names begin with “get,” “is,” or “set” is called a property.
An interesting way to study a complex class is to look at the set of properties it defines.
Properties are particularly common in the AWT and Swing APIs, which are covered in Java Foundation Classes in a Nutshell (O’Reilly)
Abstract Classes and Methods In Example 3-4, we declared our Circle class to be part of a package named shapes.
Suppose we plan to implement a number of shape classes: Rectangle, Square, Ellipse, Triangle, and so on.
We can give these shape classes our two basic area( ) and circumference() methods.
If we structure our class hierarchy this way, every shape object, regardless of the actual type of shape it represents, can be assigned to variables, fields, or array elements of type Shape.
We want the Shape class to encapsulate whatever features all our shapes have in common (e.g., the area() and circumference( ) methods)
But our generic Shape class doesn’t represent any real kind of shape, so it cannot define useful implementations of the methods.
Java lets us define a method without implementing it by declaring the method with the abstract modifier.
An abstract method has no body; it simply has a signature definition followed by a semicolon.* Here are the rules about abstract methods and the abstract classes that contain them:
Any class with an abstract method is automatically abstract itself and must be declared as such.
A subclass of an abstract class can be instantiated only if it overrides each of the abstract methods of its superclass and provides an implementation (i.e., a method body) for all of them.
Such a class is often called a concrete subclass, to emphasize the fact that it is not abstract.
If a subclass of an abstract class does not implement all the abstract methods it inherits, that subclass is itself abstract and must be declared as such.
A class can be declared abstract even if it does not actually have any abstract methods.
Declaring such a class abstract indicates that the implementation is somehow incomplete and is meant to serve as a superclass for one or more subclasses that complete the implementation.
There is an important feature of the rules of abstract methods.
If we define the Shape class to have abstract area() and circumference( ) methods, any subclass of Shape is required to provide implementations of these methods so that it can be instantiated.
In other words, every Shape object is guaranteed to have implementations of these methods defined.
It defines an abstract Shape class and two concrete subclasses of it.
An abstract method in Java is something like a pure virtual function in C++ (i.e., a virtual function that is declared = 0)
In C++, a class that contains a pure virtual function is called an abstract class and cannot be instantiated.
The same is true of Java classes that contain abstract methods.
Each abstract method in Shape has a semicolon right after its parentheses.
They have no curly braces, and no method body is defined.
Using the classes defined in Example 3-5, we can now write code such as:
Subclasses of Shape can be assigned to elements of an array of Shape.
This is another example of a widening reference type conversion (discussed in Chapter 2)
You can invoke the area( ) and circumference() methods for any Shape object, even though the Shape class does not define a body for these methods.
When you do this, the method to be invoked is found using dynamic method lookup, so the area of a circle is computed using the method defined by Circle, and the area of a rectangle is computed using the method defined by Rectangle.
This class defines several important methods that you should consider overriding in every class you write.
The sections that follow the example document the default implementation of.
You may also find it helpful to look up Object in the reference section for an API listing.
Some of the syntax in Example 3-6 may be unfamiliar to you.
First, it implements a parameterized, or generic, version of the Comparable interface.
Second, the example uses the @Override annotation to emphasize (and have the compiler verify) that certain methods override Object.
A hash code allows an object to be used in a hash table.
The purpose of the toString( ) method is to return a textual representation of an object.
Giving objects a textual representation can be quite helpful for debugging or logging output, and a wellcrafted toString() method can even help with tasks such as report generation.
The version of toString() inherited from Object returns a string that includes the name of the class of the object as well as a hexadecimal representation of the hashCode() value of the object (discussed later in this chapter)
This default implementation provides basic type and identity information for an object but is not usually very useful.
The toString( ) method in Example 3-6 instead returns a human-readable string that includes the value of each of the fields of the Circle class.
The = = operator tests two references to see if they refer to the same object.
If you want to test whether two distinct objects are equal to one another, you must use the equals() method instead.
Any class can define its own notion of equality by overriding equals()
The Object.equals( ) method simply uses the == operator: this default method considers two objects equal only if they are actually the very same object.
The equals( ) method in Example 3-6 considers two distinct Circle objects to be equal if their fields are all equal.
Note that it first does a quick identity test with = = as an optimization and then checks the type of the other object with instanceof: a Circle can be equal only to another Circle, and it is not acceptable for an equals() method to throw a ClassCastException.
Note that the instanceof test also rules out null arguments: instanceof always evaluates to false if its left-hand operand is null.
Whenever you override equals( ), you must also override hashCode( )
This method returns an integer for use by hash table data structures.
It is critical that two objects have the same hash code if they are equal according to the equals() method.
It is important (for efficient operation of hash tables) but not required that unequal objects have unequal hash codes, or at least that unequal objects are unlikely to share a hash code.
This second criterion can lead to hashCode() methods that involve mildly tricky arithmetic or bit-manipulation.
When you override equals( ), you must always override hashCode() to guarantee that equal objects have equal hash codes.
Since the equals( ) method in Example 3-6 bases object equality on the values of the three fields, the hashCode( ) method computes its hash code based on these three fields as well.
It is clear from the code that if two Circle objects have the same field values, they will have the same hash code.
Note that the hashCode( ) method in Example 3-6 does not simply add the three fields and return their sum.
Such an implementation would be legal but not efficient because two circles with the same radius but whose X and Y coordinates were reversed would then have the same hash code.
The repeated multiplication and addition steps “spread out” the range of hash codes and dramatically reduce the likelihood that two unequal Circle objects have the same code.
Effective Java Programming Guide by Joshua Bloch (Addison Wesley) includes a helpful recipe for constructing efficient hashCode() methods like this one.
If a class implements Comparable, we can say that one instance is less than, greater than, or equal to another instance.
Since compareTo( ) is defined by an interface, the Object class does not provide any default implementation.
It is up to each individual class to determine whether and how its instances should be ordered and to include a compareTo() method that implements that ordering.
The ordering defined by Example 3-6 compares Circle objects as if they were words on a page.
Circles are first ordered from top to bottom: circles with larger Y coordinates are less than circles with smaller Y coordinates.
If two circles have the same Y coordinate, they are ordered from left to right.
A circle with a smaller X coordinate is less than a circle with a larger X coordinate.
Finally, if two circles have the same X and Y coordinates, they are compared by radius.
Notice that under this ordering, two circles are equal only if all three of their fields are equal.
This means that the ordering defined by compareTo() is consistent with the equality defined by equals()
The compareTo( ) method returns an int value that requires further explanation.
It should return 0 if the two objects are equal.
And compareTo() should return a positive number if this is greater than the method argument.
Object defines a method named clone() whose purpose is to return an object with fields set identically to those of the current object.
Cloneable does not define any methods, so implementing it is simply a matter of listing it in the implements clause of the class signature.
The other unusual feature of clone() is that it is declared protected (see “Data Hiding and Encapsulation” earlier in this chapter)
This means that subclasses of Object can call and override Object.clone(), but other code cannot call it.
Therefore, if you want your object to be cloneable, you must implement Cloneable and override the clone() method, making it public.
The Circle class of Example 3-6 does not implement Cloneable; instead it provides a copy constructor for making copies of Circle objects:
It can be difficult to implement clone( ) correctly, and it is usually easier and safer to provide a copy constructor.
To make the Circle class cloneable, you would add Cloneable to the implements clause and add the following method to the class body:
See Effective Java Programming Guide by Joshua Bloch for a detailed discussion of the ins and outs of clone() and Cloneable.
Interfaces Like a class, an interface defines a new reference type.
Unlike classes, however, interfaces provide no implementation for the types they define.
As its name implies, an interface specifies only an API: all of its methods are abstract and have no bodies.
It is not possible to directly instantiate an interface and create a member of the interface type.
Instead, a class must implement the interface to provide the necessary method bodies.
Any instances of that class are members of both the type defined by the class and the type defined by the interface.
Interfaces provide a limited but very powerful alternative to multiple inheritance.* Classes in Java can inherit members from only a single superclass, but they can implement any number of interfaces.
Objects that do not share the same class or superclass may still be members of the same type by virtue of implementing the same interface.
An interface definition is much like a class definition in which all the methods are abstract and the keyword class has been replaced with interface.
For example, the following code shows the definition of an interface named Centered.
A Shape class, such as those defined earlier in the chapter, might implement this interface if it wants to allow the coordinates of its center to be set and queried:
A number of restrictions apply to the members of an interface:
All methods of an interface are implicitly abstract and must have a semicolon in place of a method body.
The abstract modifier is allowed but, by convention, is usually omitted.
Since static methods may not be abstract, the methods of an interface may not be declared static.
All members of an interface are implicitly public, and it is conventional to omit the unnecessary public modifier.
It is an error to define a protected or private method in an interface.
Fields are an implementation detail, and an interface is a pure specification without any implementation.
The only fields allowed in an interface definition are constants that are declared both static and final.
An interface cannot be instantiated, so it does not define a constructor.
C++ supports multiple inheritance, but the ability of a class to have more than one superclass adds a lot of complexity to the language.
Interfaces may extend other interfaces, and, like a class definition, an interface definition may include an extends clause.
When one interface extends another, it inherits all the abstract methods and constants of its superinterface and can define new abstract methods and constants.
Unlike classes, however, the extends clause of an interface definition may include more than one superinterface.
For example, here are some interfaces that extend other interfaces:
An interface that extends more than one interface inherits all the abstract methods and constants from each of those interfaces and can define its own additional abstract methods and constants.
A class that implements such an interface must implement the abstract methods defined directly by the interface, as well as all the abstract methods inherited from all the superinterfaces.
Just as a class uses extends to specify its superclass, it can use implements to name one or more interfaces it supports.
When a class declares an interface in its implements clause, it is saying that it provides an implementation (i.e., a body) for each method of that interface.
If a class implements an interface but does not provide an implementation for every interface method, it inherits those unimplemented abstract methods from the interface and must itself be declared abstract.
If a class implements more than one interface, it must implement every method of each interface it implements (or be declared abstract)
The following code shows how we can define a CenteredRectangle class that extends the Rectangle class from earlier in the chapter and implements our Centered interface.
Suppose we implement CenteredCircle and CenteredSquare just as we have implemented this CenteredRectangle class.
Since each class extends Shape, instances of the classes can be treated as instances of the Shape class, as we saw earlier.
Since each class implements the Centered interface, instances can also be treated as instances of that type.
The following code demonstrates how objects can be members of both a class type and an interface type:
Shape[] shapes = new Shape[3];          // Create an array to hold shapes.
This example demonstrates that interfaces are data types in Java, just like classes.
When a class implements an interface, instances of that class can be assigned to variables of the interface type.
Don’t interpret this example to imply that you must assign a CenteredRectangle object to a Centered variable before you can invoke the setCenter( ) method or to a Shape variable before you can invoke the area() method.
CenteredRectangle defines setCenter( ) and inherits area() from its Rectangle superclass, so you can always invoke these methods.
Suppose we want shape objects that can be positioned in terms of not only their center points but also their upper-right corners.
And suppose we also want shapes that can be scaled larger and smaller.
Remember that although a class can extend only a single superclass, it can implement any number of interfaces.
When a class implements more than one interface, it simply means that it must provide implementations for all abstract methods in all its interfaces.
When defining an abstract type (e.g., Shape) that you expect to have many subtypes (e.g., Circle, Rectangle, Square), you are often faced with a choice between interfaces and abstract classes.
Since they have similar features, it is not always clear which to use.
An interface is useful because any class can implement it, even if that class extends some entirely unrelated superclass.
But an interface is a pure API specification and contains no implementation.
If an interface has numerous methods, it can become tedious to implement the methods over and over, especially when much of the implementation is duplicated by each implementing class.
An abstract class does not need to be entirely abstract; it can contain a partial implementation that subclasses can take advantage of.
In some cases, numerous subclasses can rely on default method implementations provided by an abstract class.
But a class that extends an abstract class cannot extend any other class, which can cause design difficulties in some situations.
Another important difference between interfaces and abstract classes has to do with compatibility.
If you define an interface as part of a public API and then later add a new method to the interface, you break any classes that implemented the previous version of the interface.
If you use an abstract class, however, you can safely add nonabstract methods to that class without requiring modifications to existing classes that extend the abstract class.
In some situations, it is clear that an interface or an abstract class is the right design choice.
In other cases, a common design pattern is to use both.
Define the type as a totally abstract interface, then create an abstract class that implements the interface and provides useful default implementations that subclasses can take advantage of.
Sometimes it is useful to define an interface that is entirely empty.
A class can implement this interface simply by naming it in its implements clause without having to implement any methods.
In this case, any instances of the class become valid instances of the interface.
Java code can check whether an object is an instance of the interface using the instanceof operator, so this technique is a useful way to provide additional information about an object.
A class implements Serializable interface to tell ObjectOutputStream that its instances may safely be serialized.
Algorithms that care about the performance of randomaccess operations can test for RandomAccess like this:
As noted earlier, constants can appear in an interface definition.
Any class that implements an interface inherits the constants it defines and can use them as if they were defined directly in the class itself.
Importantly, there is no need to prefix the constants with the name of the interface or provide any kind of implementation of the constants.
When a set of constants is used by more than one class, it is tempting to define the constants once in an interface and then have any classes that require the constants implement the interface.
This situation might arise, for example, when client and server classes implement a network protocol whose details (such as the port number to connect to and listen on) are captured in a set of symbolic constants.
The primary benefit of inheriting constant definitions from an interface is that it saves typing: you don’t need to specify the type that defines the constants.
The use of constants is an implementation detail that is not appropriate to declare in the implements clause of a class signature.
A better approach is to define constants in a class and use the constants by typing the full class name and the constant name.
In Java 5.0 and later, you can save typing by importing the constants from their defining class with the import static declaration.
See “Packages and the Java Namespace” in Chapter 2 for details.
Nested Types The classes, interfaces, and enumerated types we have seen so far in this book have all been defined as top-level classes.
This means that they are direct members of packages, defined independently of other types.
However, type definitions can also be nested within other type definitions.
These nested types, commonly known as “inner classes,” are a powerful and elegant feature of the Java language.
A type can be nested within another type in four ways:
Static member types A static member type is any type defined as a static member of another type.
A static method is called a class method, so, by analogy, we could call this type of nested type a “class type,” but this terminology would obviously be confusing.
A static member type behaves much like an ordinary top-level type, but its name is part of the namespace, rather than the package, of the containing type.
Also, a static member type can access the static members of the class that contains it.
Nested interfaces, enumerated types, and annotation types are implicitly static, whether or not the static keyword appears.
Any type nested within an interface or annotation is also implicitly static.
Static member types may be defined within top-level types or nested to any depth within other static member types.
A static member type may not be defined within any other kind of nested type, however.
Nonstatic member classes A “nonstatic member type” is simply a member type that is not declared static.
Since interfaces, enumerated types, and annotations are always implicitly static, however, we usually use the term “nonstatic member class” instead.
Nonstatic member classes may be defined within other classes or enumerated types and are analogous to instance methods or fields.
An instance of a nonstatic member class is always associated with an instance of the enclosing type, and the code of a nonstatic member class has access to all the fields and methods (both static and non-static) of its enclosing type.
Several features of Java syntax exist specifically to work with the enclosing instance of a nonstatic member class.
Local classes A local class is a class defined within a block of Java code.
Interfaces, enumerated types, and annotation types may not be defined locally.
Like a local variable, a local class is visible only within the block in which it is defined.
Although local classes are not member classes, they are still defined within an enclosing class, so they share many of the features of member classes.
Additionally, however, a local class can access any final local variables or parameters that are accessible in the scope of the block that defines the class.
Anonymous classes An anonymous class is a kind of local class that has no name; it combines the syntax for class definition with the syntax for object instantiation.
While a local class definition is a Java statement, an anonymous class definition (and instantiation) is a Java expression, so it can appear as part of a larger expression, such as method invocation.
Interfaces, enumerated types, and annotation types cannot be defined anonymously.
Sometimes, however, inner class is used to refer to a nonstatic member class, local class, or anonymous class, but not a static member type.
Although the terminology for describing nested types is not always clear, the syntax for working with them is, and it is usually clear from context which kind of nested type is being discussed.
Now we’ll describe each of the four kinds of nested types in greater detail.
Each section describes the features of the nested type, the restrictions on its use, and any special Java syntax used with the type.
These four sections are followed by an implementation note that explains how nested types work under the hood.
A static member type is much like a regular top-level type.
For convenience, however, it is nested within the namespace of another type.
Example 3-7 shows a helper interface defined as a static member of a containing class.
The example also shows how this interface is used both within the class that contains it and by external classes.
Note the use of its hierarchical name in the external class.
The head of the list is a Linkable object Linkable head;
A static member type is defined as a static member of a containing type.
Any type (class, interface, enumerated type, or annotation type) may be defined as a static member of any other type.
Interfaces, enumerated types, and annotation types are implicitly static, whether or not the static keyword appears in their definition.
A static member type is like the other static members of a class: static fields and static methods.
Like a class method, a static member type is not associated with any instance of the containing class (i.e., there is no this object)
A static member type does, however, have access to all the static members (including any other static member types) of its containing type.
A static member type can use any other static member without qualifying its name with the name of the containing type.
A static member type has access to all static members of its containing type, including private members.
The reverse is true as well: the methods of the containing type have access to all members of a static member type, including the private members.
A static member type even has access to all the members of any other static member types, including the private members of those types.
Top-level types can be declared with or without the public modifier, but they cannot use the private and protected modifiers.
Static member types, however, are members and can use any access control modifiers that other members of the containing type can.
These modifiers have the same meanings for static member types as they do for other members of a type.
In Example 3-7, the Linkable interface is declared public, so it can be implemented by any class that is interested in being stored on a LinkedStack.
Recall that all members of interfaces (and annotation types) are implicitly public, so static member types nested within interfaces or annotation types cannot be protected or private.
A static member type cannot have the same name as any of its enclosing classes.
In addition, static member types can be defined only within top-level types and other static member types.
This is actually part of a larger prohibition against static members of any sort within member, local, and anonymous classes.
You can use the import directive to import a static member type:
In Java 5.0 and later, you can also use the import static directive to import a static member type.
See “Packages and the Java Namespace” in Chapter 2 for details on import and import static.
Note that importing a nested type obscures the fact that that type is closely associated with its containing type, and it is not commonly done.
A nonstatic member class is a class that is declared as a member of a containing class or enumerated type without the static keyword.
If a static member type is analogous to a class field or class method, a nonstatic member class is analogous to an instance field or instance method.
Example 3-8 shows how a member class can be defined and used.
The implementation of this interface is defined as a member class.
The example uses Java 5.0 generic type syntax in a couple of places, but this should not prevent you from understanding it.
Notice how the LinkedIterator class is nested within the LinkedStack class.
Since LinkedIterator is a helper class used only within LinkedStack, there is real elegance to having it defined so close to where it is used by the containing class.
Like instance fields and instance methods, every instance of a nonstatic member class is associated with an instance of the class in which it is defined.
This means that the code of a member class has access to all the instance fields and instance methods (as well as the static members) of the containing class, including any that are declared private.
This single line of code sets the current field of the inner class to the value of the head field of the containing class.
The code works as shown, even though head is declared as a private field in the containing class.
A nonstatic member class, like any member of a class, can be assigned one of three visibility levels: public, protected, or private.
If none of these visibility modifiers is specified, the default package visibility is used.
In Example 3-8, the LinkedIterator class is declared protected, so it is inaccessible to code (in a different package) that uses the LinkedStack class but is accessible to any class that subclasses LinkedStack.
A nonstatic member class cannot have the same name as any containing class or package.
This is an important rule, one not shared by fields and methods.
Nonstatic member classes cannot contain any static fields, methods, or types, except for constant fields declared both static and final.
Defining a static top-level member within a member class that is not at the top level would cause confusion, so it is not allowed.
Interfaces, enumerated types, and annotation types are all implicitly static, even if the static keyword is omitted.
The most important feature of a member class is that it can access the instance fields and methods in its containing object.
In this example, head is a field of the LinkedStack class, and we assign it to the current field of the LinkedIterator class.
What if we want to make these references explicit? We could try code like this:
It is the this.head expression that causes the problem; it refers to a field named head in the LinkedIterator object.
Since there is no such field, the compiler generates an error.
To solve this problem, Java defines a special syntax for explicitly referring to the containing instance of the this object.
Thus, if we want to be explicit in our constructor, we can use the following syntax:
The general syntax is classname.this, where classname is the name of a containing class.
Note that member classes can themselves contain member classes, nested to any depth.
Since no member class can have the same name as any containing class, however, the use of the enclosing class name prepended to this is a perfectly general way to refer to any containing instance.
This syntax is needed only when referring to a member of a containing class that is hidden by a member of the same name in the member class.
When a class shadows or overrides a member of its superclass, you can use the keyword super to refer to the hidden member.
This super syntax can be extended to work with member classes as well.
As we’ve seen, every instance of a member class is associated with an instance of its containing class.
Look again at our definition of the iterator() method in Example 3-8:
When a member class constructor is invoked like this, the new instance of the member class is automatically associated with the this object.
This is what you would expect to happen and exactly what you want to occur in most cases.
Occasionally, however, you may want to specify the containing instance explicitly when instantiating a member class.
You can do this by preceding the new operator with a reference to the containing instance.
Thus, the iterator() method shown earlier is shorthand for the following:
Let’s pretend we didn’t define an iterator( ) method for LinkedStack.
In this case, the code to obtain an LinkedIterator object for a given LinkedStack object might look like this:
The containing instance implicitly specifies the containing class; it is a syntax error to explicitly specify the containing class name:
One other special piece of Java syntax specifies an enclosing instance for a member class explicitly.
Before we consider it, however, let me point out that you should rarely, if ever, need to use this syntax.
It is one of the pathological cases that snuck into the language along with all the elegant features of nested types.
As strange as it may seem, it is possible for a top-level class to extend a member class.
This means that the subclass does not have a containing instance, but its superclass does.
When the subclass constructor invokes the superclass constructor, it must specify the containing instance.
It does this by prepending the containing instance and a period to the super keyword.
If we had not declared our LinkedIterator class to be a protected member of LinkedStack, we could subclass it.
Although it is not clear why we would want to do so, we could write code like the following:
We’ve just noted that a top-level class can extend a member class.
With the introduction of nonstatic member classes, two separate hierarchies must be considered for any class.
The first is the inheritance hierarchy, from superclass to subclass, that defines the fields and methods a member class inherits.
The second is the containment hierarchy, from containing class to contained class, that defines a set of fields and methods that are in the scope of (and are therefore accessible to) the member class.
The two hierarchies are entirely distinct from each other; it is important that you do not confuse them.
This should not be a problem if you refrain from creating naming conflicts, where a field or method in a superclass has the same name as a field or method in a containing class.
If such a naming conflict does arise, however, the inherited field or method takes precedence over the field or method of the same name in the containing class.
This behavior is logical: when a class inherits a field or method, that field or method effectively becomes part of that class.
Therefore, inherited fields and methods are in the scope of the class that inherits them and take precedence over fields and methods by the same name in enclosing scopes.
A good way to prevent confusion between the class hierarchy and the containment hierarchy is to avoid deep containment hierarchies.
If a class is nested more than two levels deep, it is probably going to cause more confusion than it is worth.
Furthermore, if a class has a deep class hierarchy (i.e., it has many ancestors), consider defining it as a top-level class rather than as a nonstatic member class.
A local class is declared locally within a block of Java code rather than as a member of a class.
Only classes may be defined locally: interfaces, enumerated types and annotation types must be top-level or static member types.
Typically, a local class is defined within a method, but it can also be defined within a static initializer or instance initializer of a class.
Because all blocks of Java code appear within class definitions, all local classes are nested within containing classes.
For this reason, local classes share many of the features of member classes.
It is usually more appropriate, however, to think of them as an entirely separate kind of nested type.
A local class has approximately the same relationship to a member class as a local variable has to an instance variable of a class.
The defining characteristic of a local class is that it is local to a block of code.
Like a local variable, a local class is valid only within the scope defined by its enclosing block.
If a member class is used only within a single method of its containing class, for example, there is usually no reason it cannot be coded as a local class rather than a member class.
Example 3-9 shows how we can modify the iterator() method of the LinkedStack class so it defines LinkedIterator as a local class instead of a member class.
By doing this, we move the definition of the class even closer to where it is used and hopefully improve the clarity of the code even further.
For brevity, Example 3-9 shows only the iterator( ) method, not the entire LinkedStack class that contains it.
Like member classes, local classes are associated with a containing instance and can access any members, including private members, of the containing class.
In addition to accessing fields defined by the containing class, local classes can access any local variables, method parameters, or exception parameters that are in the scope of the local method definition and are declared final.
The name of a local class is defined only within the block that defines it; it can never be used outside that block.
Note however that instances of a local class created within the scope of the class can continue to exist outside of that scope.
This situation is described in more detail later in this section.
Local classes cannot be declared public, protected, private, or static.
These modifiers are for members of classes; they are not allowed with local variable declarations or local class declarations.
Like member classes, and for the same reasons, local classes cannot contain static fields, methods, or classes.
The only exception is for constants that are declared both static and final.
Interfaces, enumerated types, and annotation types cannot be defined locally.
A local class, like a member class, cannot have the same name as any of its enclosing classes.
As noted earlier, a local class can use the local variables, method parameters, and even exception parameters that are in its scope but only if those variables or parameters are declared final.
This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined.
For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler)
The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final.
In Java 1.0, only fields, methods, and classes could be declared final.
The addition of local classes in Java 1.1 required a liberalization in the use of the final modifier.
As of Java 1.1, final can be applied to local variables, method parameters, and even the exception parameter of a catch statement.
The meaning of the final modifier remains the same in these new uses: once the local variable or parameter has been assigned a value, that value cannot be changed.
Instances of local classes, like instances of nonstatic member classes, have an enclosing instance that is implicitly passed to all constructors of the local class.
Local classes can use the same this syntax as nonstatic member classes to refer explicitly to members of enclosing classes.
Because local classes are never visible outside the blocks that define them, however, there is never a need to use the new and super syntax used by member classes to specify the enclosing instance explicitly.
In discussing nonstatic member classes, we saw that a member class can access any members inherited from superclasses and any members defined by its containing classes.
The same is true for local classes, but local classes can also access final local variables and parameters.
The following code illustrates the many fields and variables that may be accessible to a local class:
A local variable is defined within a block of code that defines its scope.
A local variable ceases to exist outside of its scope.
Java is a lexically scoped language, which means that its concept of scope has to do with the way the source code is written.
Any code within the curly braces that define the boundaries of a block can use local variables defined in that block.*
Lexical scoping simply defines a segment of source code within which a variable can be used.
It is common, however, to think of a scope as a temporal scope—to think of a local variable as existing from the time the Java interpreter begins executing the block until the time the interpreter exits the block.
This is usually a reasonable way to think about local variables and their scope.
The introduction of local classes confuses the picture, however, because local classes can use local variables, and instances of a local class can have a lifetime much longer than the time it takes the interpreter to execute the block of code.
In other words, if you create an instance of a local class, the instance does not automatically go away when the interpreter finishes executing the block that defines the class, as shown in the following code:
This section covers advanced material; first-time readers may want to skip it for now and return to it later.
To make sense of it, remember that the lexical scope of the methods of a local class has nothing to do with when the interpreter enters and exits the block of code that defines the local class.
Here’s another way to think about it: each instance of a local class has an automatically created private copy of each of the final local variables it uses, so, in effect, it has its own private copy of the scope that existed when it was created.
In general terms, a closure is an object that saves the state of a scope and makes that scope available later.
Closures are useful in some styles of programming, and different programming languages define and implement closures in different ways.
Java’s closures are relatively weak (and some would argue that they are not truly closures) because they retain the state of only final variables.
An anonymous class is a local class without a name.
An anonymous class is defined and instantiated in a single succinct expression using the new operator.
While a local class definition is a statement in a block of Java code, an anonymous class definition is an expression, which means that it can be included as part of a larger expression, such as a method call.
In practice, anonymous classes are much more common than local classes.
If you find yourself defining a short local class and then instantiating it exactly once, consider rewriting it using anonymous class syntax, which places the definition and use of the class in exactly the same place.
Consider Example 3-10, which shows the LinkedIterator class implemented as an anonymous class within the iterator( ) method of the LinkedStack class.
Compare it with Example 3-9, which shows the same class implemented as a local class.
One common use for an anonymous class is to provide a simple implementation of an adapter class.
An adapter class is one that defines code that is invoked by some other object.
Take, for example, the list() method of the java.io.File class.
Before it returns the list, though, it passes the name of each file to a FilenameFilter object you must supply.
When you implement the FilenameFilter interface, you are defining an adapter class for use with the File.list() method.
Since the body of such a class is typically quite short, it is easy to define an adapter class as an anonymous class.
Here’s how you can define a FilenameFilter class to list only those files whose names end with .java:
As you can see, the syntax for defining an anonymous class and creating an instance of that class uses the new keyword, followed by the name of a class and a class body definition in curly braces.
If the name following the new keyword is the name of a class, the anonymous class is a subclass of the named class.
If the name following new specifies an interface, as in the two previous examples, the anonymous class implements that interface and extends Object.
The syntax does not include any way to specify an extends clause, an implements clause, or a name for the class.
Because an anonymous class has no name, it is not possible to define a constructor for it within the class body.
This is one of the basic restrictions on anonymous classes.
Any arguments you specify between the parentheses following the superclass name in an anonymous class definition are implicitly passed to the superclass constructor.
Anonymous classes are commonly used to subclass simple classes that do not take any constructor arguments, so the parentheses in the anonymous class definition syntax are often empty.
In the previous examples, each anonymous class implemented an interface and extended Object.
Since the Object( ) constructor takes no arguments, the parentheses were empty in those examples.
Anonymous classes allow you to define a one-shot class exactly where it is needed.
Anonymous classes have all the features of local classes but use a more concise syntax that can reduce clutter in your code.
Because an anonymous class is just a type of local class, anonymous classes and local classes share the same restrictions.
An anonymous class cannot define any static fields, methods, or classes, except for static final constants.
Interfaces, enumerated types, and annotation types cannot be defined anonymously.
Also, like local classes, anonymous classes cannot be public, private, protected, or static.
Since an anonymous class has no name, it is not possible to define a constructor for an anonymous class.
If your class requires a constructor, you must use a local class instead.
However, you can often use an instance initializer as a substitute for a constructor.
The syntax for defining an anonymous class combines definition with instantiation.
Using an anonymous class instead of a local class is not appropriate if you need to create more than a single instance of the class each time the containing block is executed.
We’ve already seen examples of the syntax for defining and instantiating an anonymous class.
Although they are not limited to use with anonymous classes, instance initializers were introduced into the language for this purpose.
As described earlier in this chapter in “Field Defaults and Initializers,” an instance initializer is a block of initialization code contained within curly braces inside a class definition.
The contents of all instance initializers for a class are automatically inserted into all constructors for the class, including any automatically created default constructor.
An anonymous class cannot define a constructor, so it gets a default constructor.
By using an instance initializer, you can get around the fact that you cannot define a constructor for an anonymous class.
As we’ve discussed, an anonymous class behaves just like a local class and is distinguished from a local class merely in the syntax used to define and instantiate it.
In your own code, when you have to choose between using an anonymous class and a local class, the decision often comes down to a matter of style.
In general, you should consider using an anonymous class instead of a local class if:
The name of the class does not make your code any easier to understand.
The common indentation and formatting conventions we are familiar with for block-structured languages like Java and C begin to break down somewhat once we start placing anonymous class definitions within arbitrary expressions.
Based on their experience with nested types, the engineers at Sun recommend the following formatting rules:
The opening curly brace should not be on a line by itself; instead, it should follow the closing parenthesis of the new operator.
Similarly, the new operator should, when possible, appear on the same line as the assignment or other expression of which it is a part.
The body of the anonymous class should be indented relative to the beginning of the line that contains the new keyword.
The closing curly brace of an anonymous class should not be on a line by itself either; it should be followed by whatever tokens are required by the rest of the expression.
Often this is a semicolon or a closing parenthesis followed by a semicolon.
This extra punctuation serves as a flag to the reader that this is not just an ordinary block of code and makes it easier to understand anonymous classes in a code listing.
The preceding sections explained the features and behavior of the four kinds of nested types.
Strictly speaking, that should be all you need to know about nested types.
You may find it easier to understand nested types if you understand how they are implemented, however.
Despite the dramatic changes to the Java language, the introduction of nested types did not change the Java Virtual Machine or the Java class file format.
As far as the Java interpreter is concerned, there is no such thing as a nested type: all classes are normal top-level classes.
In order to make a nested type behave as if it is actually defined inside another class, the Java compiler ends up inserting hidden fields, methods, and constructor arguments into the classes it generates.
You may want to use the javap disassembler to disassemble some of the class files for nested types so you can see what tricks the compiler has used to make the nested types work.
Recall our first LinkedStack example (Example 3-7), which defined a static member interface named Linkable.
When you compile this LinkedStack class, the compiler actually generates two class files.
The $ in this name is automatically inserted by the Java compiler.
This second class file contains the implementation of the static member interface.
As we discussed earlier, a static member type can access all the static members of its containing class.
If a static member type does this, the compiler automatically qualifies the member access expression with the name of the containing class.
A static member type is even allowed to access the private static fields of its containing class.
Since the static member type is compiled into an ordinary toplevel class, however, there is no way it can directly access the private members of its container.
Therefore, if a static member type uses a private member of its containing type (or vice versa), the compiler generates synthetic non-private access methods and converts the expressions that access the private members into expressions that invoke these specially generated methods.
These methods are given the default package access, which is sufficient, as the member class and its containing class are guaranteed to be in the same package.
A nonstatic member class is implemented much like a static member type.
It is compiled into a separate top-level class file, and the compiler performs various code manipulations to make interclass member access work correctly.
The most significant difference between a nonstatic member class and a static member type is that each instance of a nonstatic member class is associated with an instance of the enclosing class.
The compiler enforces this association by defining a synthetic field named this$0 in each member class.
This field is used to hold a reference to the enclosing instance.
Every nonstatic member class constructor is given an extra parameter that initializes this field.
Every time a member class constructor is invoked, the compiler automatically passes a reference to the enclosing class for this extra parameter.
As we’ve seen, a nonstatic member class, like any member of a class, can be declared public, protected, or private, or given the default package visibility.
Member classes are compiled to class files just like top-level classes, but top-level classes can have only public or package access.
Therefore, as far as the Java interpreter is concerned, member classes can have only public or package visibility.
This means that a member class declared protected is actually treated as a public class, and a member class declared private actually has package visibility.
This does not mean you should never declare a member class as protected or private.
Although the Java VM cannot enforce these access control modifiers, the modifiers are stored in the class file and conforming Java compilers do enforce them.
A local class is able to refer to fields and methods in its containing class for exactly the same reason that a nonstatic member class can; it is passed a hidden reference to the containing class in its constructor and saves that reference away in a private synthetic field added by the compiler.
Also, like nonstatic member classes, local classes can use private fields and methods of their containing class because the compiler inserts any required accessor methods.
What makes local classes different from member classes is that they have the ability to refer to local variables in the scope that defines them.
The crucial restriction on this ability, however, is that local classes can reference only local variables and parameters that are declared final.
The reason for this restriction becomes apparent in the implementation.
A local class can use local variables because the compiler automatically gives the class a private instance field to hold a copy of each local variable the class uses.
The compiler also adds hidden parameters to each local class constructor to initialize these automatically created private fields.
A local class does not actually access local variables but merely its own private copies of them.
The only way this can work correctly is if the local variables are declared final so that they are guaranteed not to change.
With this guarantee, the local class can be assured that its internal copies of the variables are always in sync with the real local variables.
Since anonymous classes have no names, you may wonder what the class files that represent them are named.
This is an implementation detail, but Sun’s Java compiler uses numbers to provide anonymous class names.
Modifier Summary As we’ve seen, classes, interfaces, and their members can be declared with one or more modifiers—keywords such as public, static, and final.
Table 3-2 lists the Java modifiers, explains what types of Java constructs they can modify, and explains what they do.
Method The method cannot be overridden (and is not subject to dynamic method lookup)
Variable A local variable, method parameter, or exception parameter cannot have its value changed.
No body is provided; the signature is followed by a semicolon.
None (package) Class A non-public class is accessible only in its package.
Interface A non-public interface is accessible only in its package.
Member A member that is not private, protected, or public has package visibility and is accessible only within its package.
Java shares enough concepts and features with C++ to make it an easy language for C++ programmers to pick up.
Several features of C++ have no parallel in Java, however.
In general, Java does not adopt those features of C++ that make the language significantly more complicated.
C++ supports multiple inheritance of method implementations from more than one superclass at a time.
While this seems like a useful feature, it actually introduces many complexities to the language.
The Java language designers chose to avoid the added complexity by using interfaces instead.
Thus, a class in Java can inherit method implementations only from a single superclass, but it can inherit method declarations from any number of interfaces.
In particular, all values, including intermediate results, must be expressed as IEEE float or double values and cannot take advantage of any extra precision or range offered by native platform floating-point formats or hardware.
There is only one instance of the field, regardless of the number of class instances created.
Initializer The initializer is run when the class is loaded rather than when an instance is created.
For a static method, a lock for the class is acquired before executing the method.
For a non-static method, a lock for the specific object instance is acquired.
This modifier can sometimes be used as an alternative to synchronized.
Java 5.0 introduces parameterized types or “generics” that provide similar functionality in a more robust fashion.
C++ allows you to define operators that perform arbitrary operations on instances of your classes.
In effect, it allows you to extend the syntax of the language.
This is a nifty feature, called operator overloading, that makes for elegant examples.
In practice, however, it tends to make code quite difficult to understand.
After much debate, the Java language designers decided to omit such operator overloading from the language.
Note, though, that the use of the + operator for string concatenation in Java is at least reminiscent of operator overloading.
C++ allows you to define conversion functions for a class that automatically invokes an appropriate constructor method when a value is assigned to a variable of that class.
This is simply a syntactic shortcut (similar to overriding the assignment operator) and is not included in Java.
In C++, objects are manipulated by value by default; you must use & to specify a variable or function argument automatically manipulated by reference.
In Java, all objects are manipulated by reference, so there is no need for the & syntax.
This chapter covers the three most important new language features of Java 5.0
Generics add type-safety and expressiveness to Java programs by allowing types to be parameterized with other types.
A List that contains String objects, for example, can be written as List<String>
Using parameterized types makes Java code clearer and allows us to remove most casts from our programs.
Enumerated types, or enums, are a new category of reference type, like classes and interfaces.
An enumerated type defines a finite (“enumerated”) set of values, and, importantly, provides type-safety: a variable of enumerated type can hold only values of that enumerated type or null.
The third Java 5.0 feature discussed in this chapter is program annotations and the annotation types that define them.
An annotation associates arbitrary data (or metadata) with a program element such as a class, method, field, or even a method parameter or local variable.
The type of data held in an annotation is defined by its annotation type, which, like enumerated types, is another new category of reference type.
The Java 5.0 platform includes three standard annotation types used to provide additional information to the Java compiler.
Annotations will probably find their greatest use with code generation tools in Java enterprise programming.
Java 5.0 also introduces a number of other important new language features that don’t require a special chapter to explain.
Methods with variable-length argument lists, also known as varargs methods.
The ability to narrow the return type of a method when overriding, known as a “covariant return”
The import static directive, which imports the static members of a type into the namespace.
Generic Types Generic types and methods are the defining new feature of Java 5.0
A generic type is defined using one or more type variables and has one or more methods that use a type variable as a placeholder for an argument or return type.
This type has a method named add(), declared to take an argument of type E, and a method named get(), declared to return a value of type E.
In order to use a generic type like this, you specify actual types for the type variable (or variables), producing a parameterized type such as List<String>.* The reason to specify this extra type information is that the compiler can provide much stronger compile-time type checking for you, increasing the type safety of your programs.
This type checking prevents you from adding a String[], for example, to a List that is intended to hold only String objects.
Also, the additional type information enables the compiler to do some casting for you.
The compiler knows that the get( ) method of a List<String> (for example) returns a String object: you are no longer required to cast a return value of type Object to a String.
The collections classes of the java.util package have been made generic in Java 5.0, and you will probably use them frequently in your programs.
Typesafe collections are the canonical use case for generic types.
Even if you never define generic types of your own and never use generic types other than the collections classes in java.
We begin by exploring the basic use of generics in typesafe collections, then delve into more complex details about the use of generic types.
After describing how to use generic types, we explain how to write your own generic types and generic methods.
Our coverage of generics concludes with a tour of important generic types in the core Java API.
It explores these types and their use in depth in order to provide a deeper understanding of how generics work.
The java.util package includes the Java Collections Framework for working with sets and lists of objects and mappings from key objects to value objects.
Here, we discuss the fact that in Java 5.0 the collections classes use type parameters to identify the type of the objects in the collection.
This is not the case in Java 1.4 and earlier.
Without generics, the use of collections requires the programmer to remember the proper element type for each collection.
When you create a collection in Java 1.4, you know what type of.
Throughout this chapter, I’ve tried to consistently use the term “generic type” to mean a type that declares one or more type variables and the term “parameterized type” to mean a generic type that has had actual type arguments substituted for its type varaiables.
In common usage, however, the distinction is not a sharp one and the terms are sometimes used interchangeably.
You must be careful to add elements of the appropriate type.
And when querying elements from a collection, you must write explicit casts to convert them from Object to their actual type.
Generic types solve the type safety problem illustrated by this code.
List and the other collection classes in java.util have been rewritten to be generic.
As mentioned above, List has been redefined in terms of a type variable named E that represents the type of the elements of the list.
The add( ) method is redefined to expect an argument of type E instead of Object and get( ) has been redefined to return E instead of Object.
In Java 5.0, when we declare a List variable or create an instance of an ArrayList, we specify the actual type we want E to represent by placing the actual type in angle brackets following the name of the generic type.
A List that holds strings is a List<String>, for example.
Note that this is much like passing an argument to a method, except that we use types rather than values and angle brackets instead of parentheses.
The elements of the java.util collection classes must be objects; they cannot be used with primitive values.
In Java 5.0, the example above would be rewritten as follows:
Note that this code isn’t much shorter than the nongeneric example it replaces.
The cast, which uses the word String in parentheses, is replaced with the type parameter, which places the word String in angle brackets.
The difference is that the type parameter has to be declared only once, but the list can be used any number of times without a cast.
But even in cases where the generic syntax is more verbose than the nongeneric syntax, it is still very much worth using generics because the extra type information allows the compiler to perform much stronger error checking on your code.
Errors that would only be apparent at runtime can now be detected at compile time.
Furthermore, the compilation error appears at the exact line where the type safety violation occurs.
Without generics, a ClassCastException can be thrown far from the actual source of the error.
Just as methods can have any number of arguments, classes can have more than one type variable.
A Map is a mapping from key objects to value objects.
The Map interface declares one type variable to represent the type of the keys and one variable to represent the type of the values.
As an example, suppose you want to map from String objects to Integer objects:
A parameterized type like List<String> is itself a type and can be used as the value of a type parameter for some other type.
The compiler knows all the types and we can write expressions // like this without casting.
Map<K,V> return a list or map element of type E and V respectively.
Note, however, that generic types can use their variables in more sophisticated ways.
That is, the method returns an instance of a parameterized type whose actual type parameter is the same as the actual type parameter of the list.
This section delves deeper into the details of generic type usage, explaining the following topics:
A hole in the compile-time type safety of generic types and a patch to ensure runtime type safety.
Even though the Java collection classes have been modified to take advantage of generics, you are not required to specify type parameters to use them.
A generic type used without type parameters is known as a raw type.
Existing pre-5.0 code continues to work: you simply write all the casts that you’re already used to writing, and you put up with some pestering from the compiler.
Consider the following code that stores objects of mixed types into a raw List:
If we compile it using Java 5.0, however, javac compiles the code but prints this complaint:
When we recompile with the -Xlint option as suggested, we see these warnings:
The compiler warns us about the add( ) calls because it cannot ensure that the values being added to the list have the correct types.
It is letting us know that because we’ve used a raw type, it cannot verify that our code is typesafe.
Note that the call to get( ) is okay because it is extracting an element that is already safely in the list.
Parameterized types form a type hierarchy, just as normal types do.
The hierarchy is based on the base type, however, and not on the type of the parameters.
This is nonintuitive, and it is important to understand why generics work this way.
At the time of this writing, javac does not yet honor the @SuppressWarnings annotation.
If the conversion to List<Object> were allowed, non-Integer objects could be added to the list.
A List<X> can be converted to a List, however, so that you can pass it to a legacy method that expects an argument of that type and has not been updated for generics.
This ability to convert parameterized types to nonparameterized types is essential for backward compatibility, but it does open up a hole in the type safety system that generics offer:
It is legal to assign a parameterized type to a nonparameterized variable List l = li;
If you compile all your code with the Java 5.0 compiler and do not get any unchecked warnings, these compile-time checks are enough to ensure that your code is also typesafe at runtime.
But if you have unchecked warnings or are working with legacy code that manipulates your collections as raw types, you may want to take additional steps to ensure type safety at runtime.
These methods enclose your collection in a wrapper collection that performs runtime type checks to ensure that only values of the correct type are added to the collection.
For example, we could prevent the type safety hole shown above like this:
Recall that an array of type S[ ] is also of type T[], if T is a superclass (or interface) of S.
Because of this, the Java interpreter must perform a runtime check every time you store an object in an array to ensure that the runtime type of the object and of the array are compatible.
Although the compile-time type of objs is Object[], its runtime type is String[ ], and it is not legal to store an Integer in it.
When we work with generic types, the runtime check for array store exceptions is no longer sufficient because a check performed at runtime does not have access to the compile-time type parameter information.
If the code above were allowed, the runtime array store check would succeed: without compile-time type parameters, the code simply stores an ArrayList into an ArrayList[] array, which is perfectly legal.
Since the compiler can’t prevent you from defeating type safety in this way, it instead prevents you from creating any array of parameterized type.
The scenario above can never occur because the compiler will refuse to compile the first line.
Note that this is not a blanket restriction on using arrays with generics; it is just a restriction on creating arrays of parameterized type.
We’ll return to this issue when we look at how to write generic methods.
Suppose we want to write a method to display the elements of a List.* Before List was a generic type, we’d just write code like this:
The three printList() methods shown in this section ignore the fact that the List implementations classes in java.util all provide working toString() methods.
Notice also that the methods assume that the List implements RandomAccess and provides very poor performance on LinkedList instances.
In Java 5.0, List is a generic type, and, if we try to compile this method, we’ll get unchecked warnings.
In order to get rid of those warnings, you might be tempted to modify the method as follows:
This code compiles without warnings but isn’t very useful because the only lists that can be passed to it are lists explicitly declared of type List<Object>
What we really want is a typesafe printList() method to which we can pass any List, regardless of how it has been parameterized.
The solution is to use a wildcard as the type parameter.
This version of the method compiles without warnings and can be used the way we want it to be used.
The ? wildcard represents an unknown type, and the type List<?> is read as “List of unknown.”
As a general rule, if a type is generic and you don’t know or don’t care about the value of the type variable, you should always use a ? wildcard instead of using a raw type.
Raw types are allowed only for backward compatibility and should be used only in legacy code.
Note, however, that you cannot use a wildcard when invoking a constructor.
There is no sense in creating a List of unknown type.
If you are creating it, you should know what kind of elements it will hold.
You may later want to pass such a list to a method that does not care about its element type, but you need to specify an element type when you create it.
If what you really want is a List that can hold any type of object, do this:
A List<?> has two important properties that result from the use of a wildcard.
In this case, that type is unknown, so these methods return an Object.
Since all we need to do with the object is invoke its toString() method, this is fine for our needs.
Second, consider List methods such as add() that are declared to accept an argument whose type is specified by the type parameter.
This is the more surprising case: when the type parameter is unknown, the compiler does not let you invoke any methods that have a parameter of the unknown type because it cannot check that you are passing an appropriate value.
A List<?> is effectively read-only since the compiler does not allow us to invoke methods like add( ), set(), and addAll( )
Let’s continue now with a slightly more complex variant of our original example.
Suppose that we want to write a sumList() method to compute the sum of a list of Number objects.
As before, we could use a raw List, but we would give up type safety and have to deal with unchecked warnings from the compiler.
But if we use a wildcard, we don’t actually get the type safety that we want because we have to trust that our method will be called with a List whose type parameter is actually Number or a subclass and not, say, a String.
To fix this method and make it truly typesafe, we need to use a bounded wildcard that states that the type parameter of the List is an unknown type that is either Number or a subclass of Number.
We don’t know the type of the elements of the list, but we know that they have an “upper bound” of Number so we can extract them from the list as Number objects.
The use of a for/in loop obscures the process of extracting elements from a list somewhat.
The general rule is that when you use a bounded wildcard with an upper bound, methods (like the get() method of List) that return a value of the type parameter use the upper bound.
The prohibition on calling methods like list.add( ) that have arguments of the type parameter type still stands: if the compiler allowed us to call those methods we could add an Integer to a list that was declared to hold only Short values, for example.
It is also possible to specify a lower-bounded wildcard using the keyword super instead of extends.
This technique has a different impact on what methods can be called.
Lower-bounded wildcards are much less commonly used than upperbounded wildcards, and we discuss them later in the chapter.
First, declare your type variables by enclosing a comma-separated list of their names within angle brackets after the name of the class or interface.
You can use those type variables anywhere a type is required in any instance fields or methods of the class.
Remember, though, that type variables exist only at compile time, so you can’t use a type variable with the runtime operators instanceof and new.
We begin this section with a simple generic type, which we will subsequently refine.
This code defines a Tree data structure that uses the type variable V to represent the type of the value held in each node of the tree:
As you’ve probably noticed, the naming convention for type variables is to use a single capital letter.
The use of a single letter distinguishes these variables from the names of actual types since real-world types always have longer, more descriptive names.
The use of a capital letter is consistent with type naming conventions and.
Collection classes like those in java.util often use the type variable E for “Element type.” When a type variable can represent absolutely anything, T (for Type) and S are used as the most generic type variable names possible (like using i and j as loop variables)
Notice that the type variables declared by a generic type can be used only by the instance fields and methods (and nested types) of the type and not by static fields and methods.
The reason, of course, is that it is instances of generic types that are parameterized.
Static members are shared by all instances and parameterizations of the class, so static members do not have type parameters associated with them.
Methods, including static methods, can declare and use their own type parameters, however, and each invocation of such a method can be parameterized differently.
The type variable V in the declaration above of the Tree<V> class is unconstrained: Tree can be parameterized with absolutely any type.
Often we want to place some constraints on the type that can be used: we might want to enforce that a type parameter implements one or more interfaces, or that it is a subclass of a specified class.
This can be done by specifying a bound for the type variable.
We’ve already seen upper bounds for wildcards, and upper bounds can also be specified for type variables using a similar syntax.
The following code is the Tree example rewritten to make Tree objects Serializable and Comparable.
In order to do this, the example uses a type variable bound to ensure that its value type is also Serializable and Comparable.
Note how the addition of the Comparable bound on V enables us to write the compareTo() method Tree by guaranteeing the existence of a compareTo() method on V.*
The bound shown here requires that the value type V is comparable to itself, in other words, that it implements the Comparable interface directly.
This rules out the use of types that inherit the Comparable interface from a superclass.
We’ll consider the Comparable interface in much more detail at the end of this section and present an alternative there.
The bounds of a type variable are expressed by following the name of the variable with the word extends and a list of types (which may themselves be parameterized, as Comparable is)
Note that with more than one bound, as in this case, the bound types are separated with an ampersand rather than a comma.
Commas are used to separate type variables and would be ambiguous if used to separate type variable bounds as well.
A type variable can have any number of bounds, including any number of interfaces and at most one class.
Earlier in the chapter we saw examples using wildcards and bounded wildcards in methods that manipulated parameterized types.
Our current design of the Tree class requires the value object of every node to have exactly the same type, V.
Perhaps this is too strict, and we should allow branches of a tree to have values that are a subtype of V instead of requiring V itself.
This version of the Tree class (minus the Comparable and Serializable implementation) is more flexible:
If we query the branch with the getBranch( ) method, the value type of the returned branch is unknown, and we must use a wildcard to express this.
The next two lines are legal, but the third is not:
When we query a branch like this, we don’t know the precise type of the value, but we do still have an upper bound on the value type, so we can do this:
What we cannot do, however, is set the value of the branch, or add a new branch to that branch.
As explained earlier in the chapter, the existence of the upper bound does not change the fact that the value type is unknown.
The compiler does not have enough information to allow us to safely pass a value to setValue() or a new branch (which includes a value type) to addBranch()
This example has illustrated a typical trade-off in the design of a generic type: using a bounded wildcard made the data structure more flexible but reduced our ability to safely use some of its methods.
Whether or not this was a good design is probably a matter of context.
In general, generic types are more difficult to design well.
Fortunately, most of us will use the preexisting generic types in the java.util package much more frequently than we will have to create our own.
As noted earlier, the type variables of a generic type can be used only in the instance members of the type, not in the static members.
And although static methods cannot use the type variables of their containing class, they can declare their own type variables.
When a method declares its own type variable, it is called a generic method.
Here is a static method that could be added to the Tree class.
It is not a generic method but uses a bounded wildcard much like the sumList() method we saw earlier in the chapter:
This method could also be rewritten as a generic method by declaring a type variable to express the upper bound imposed by the wildcard:
The generic version of sum() is no simpler than the wildcard version and the declaration of the type variable does not gain us anything.
In a case like this, the wildcard solution is typically preferred over the generic solution.
Generic methods are required where a single type variable is used to express a relationship between two parameters or between a parameter and a return value.
This method uses the type variable N to express the constraint that both arguments and the return value have the same type parameter and that that type parameter is Number or a subclass.
One way to express this is to use two unrelated type variables to represent the two unrelated value types.
Note, however, that we cannot use either variable in the return type of the method and must use a wildcard there:
Since the two type variables N and M have no relation to each other, and since each is used in only a single place in the signature, they offer no advantage over bounded wildcards.
All the examples of generic methods shown here have been static methods.
This is not a requirement: instance methods can declare their own type variables as well.
When you use a generic type, you must specify the actual type parameters to be substituted for its type variables.
The same is not generally true for generic methods: the compiler can almost always figure out the correct parameterization of a generic method based on the arguments you pass to the method.
You need not specify N when you invoke this method because N is implicitly specified in the values of the method arguments t and u.
In the following code, for example, the compiler determines that N is Integer:
The process the compiler uses to determine the type parameters for a generic method is called type inference.
Type inference is relatively intuitive to understand, but the actual algorithm the compiler must use is surprisingly complex and is well beyond the scope of this book.
Let’s look at a slightly more complex version of type inference.
In the first invocation, the compiler can easily determine that T is Boolean.
In the second invocation, the compiler determines that T is Number.
In very rare circumstances you may need to explicitly specify the type parameters for a generic method.
This is sometimes necessary, for example, when a generic method expects no arguments.
You can specify the type parameter explicitly by placing it in angle brackets before the method name:
Type parameters cannot be used with an unqualified method name: they must follow a dot or come after the keyword new or before the keyword this or super used in a constructor.
Although the explicit type parameter specification in the code above can be a helpful clarification, it is not necessary and the line could be rewritten as:
An explicit type parameter is necessary when you use the return value of the emptySet( ) method within a method invocation expression.
If you want to pass an empty set to this method, you could use this code:
In this case, the explicit specification of the type parameter String is required.
Earlier in the chapter we saw that the compiler does not allow you to create an array whose type is parameterized.
This is not, however, a restriction on all uses of arrays with generics.
Its first argument and its return value are both of type T[]
The body of the method does not have to create an array whose element type is T, so the method is perfectly legal.
If you write a method that uses varargs (see “Variable-Length Argument Lists” in Chapter 2) and a type variable, remember that invoking a varargs method performs an implicit array creation.
You can invoke this method with parameters of type Integer because the compiler can insert the necessary array creation code for you when you call it.
Exceptions are thrown and caught at runtime, and there is no way for the compiler to perform type checking to ensure that an exception of unknown origin matches type parameters specified in a catch clause.
For this reason, catch clauses may not include type variables or wildcards.
Since it is not possible to catch an exception at runtime with compile-time type parameters intact, you are not allowed to make any subclass of Throwable generic.
You can, however, use a type variable in the throws clause of a method signature.
This interface represents a “command”: a block of code with a single string argument and no return value.
The code may throw an exception represented by the type parameter X.
Here is an example that uses a parameterization of this interface:
These APIs were carefully created or reviewed by the inventors of generic types, and we can learn a lot about the good design of generic types and methods through the study of these APIs.
The generic types of java.util are relatively easy: for the most part they are collections classes, and type variables are used to represent the element type of the collection.
They are not collections, and it is not immediately apparent why they have been made generic.
Studying these difficult generic types gives us a deeper understanding of how generics work and introduces some concepts that we have not yet covered in this chapter.
Specifically, we’ll examine the Comparable interface and the Enum class (the supertype of enumerated types, described later in this chapter) and will learn about an important but infrequently used feature of generics known as lowerbounded wildcards.
In Java 5.0, the Comparable interface has been made generic, with a type variable that specifies what a class is comparable to.
The raw Comparable interface is problematic from a type-safety standpoint.
It is possible to have two Comparable objects that cannot be meaningfully compared to each other.
Prior to Java 5.0, the nongeneric Comparable interface was useful but not fully satisfactory.
The generic version of this interface, however, captures exactly the information we want: it tells us that a type is comparable and tells us what we can compare it to.
If we implement a BiggerInteger subclass of BigInteger, it inherits the Comparable interface from its superclass.
This means that BigInteger and BiggerInteger objects are mutually comparable, which is usually a good thing.
BiggerInteger can override the compareTo( ) method of its superclass, but it is not allowed to implement a different parameterization of Comparable.
In general, a class is not allowed to implement two different parameterizations of the.
When you’re working with comparable objects (as you do when writing sorting algorithms, for example), remember two things.
First, it is not sufficient to use Comparable as a raw type: for type safety, you must also specify what it is comparable to.
Second, types are not always comparable to themselves: sometimes they’re comparable to one of their ancestors.
The method has a type variable T with complicated bounds that we’ll return to later.
The element type of the collection is specified with a bounded wildcard.
We don’t know the exact type of the collection’s elements, but we know that they have an upper bound of T.
That is, we know that the elements of the collection are type T or a subclass of T.
Any element of the collection could therefore be used as the return value of the method.
Now let’s look again at the type variable declaration used by the max( ) method:
This says first that the type T must implement Comparable.
Generics syntax uses the keyword extends for all type variable bounds, whether classes or interfaces.
This is expected since the purpose of the method is to find the “maximum” object in a collection.
This is a wildcard, but it is bounded with the keyword super instead of the keyword extends.
For other examples of lower-bounded wildcards (that have nothing to do with Comparable), consider the addAll(), copy( ), and fill() methods of Collections.
This is a varargs method that accepts any number of arguments of type T and passes them as a T[ ] named a.
It adds all the elements of a to the collection c.
The element type of the collection is unknown but has a lower bound: the elements are all of type T or a superclass of T.
Recall from our earlier discussion of upper-bounded wildcards that if you have a collection whose element type is an upper-bounded wildcard, it is effectively readonly.
We know that all elements are Serializable, so methods like get() return a value of type Serializable.
The compiler won’t let us call methods like add() because the actual element type of the list is unknown.
You can’t add arbitrary serializable objects to the list because their implementing class may not be of the correct type.
Since upper-bounded wildcards result in read-only collections, you might expect lower-bounded wildcards to result in write-only collections.
The actual element type is unknown, but the only possibilities are Integer or its ancestors Number and Object.
Whatever the actual type is, it is safe to add Integer objects (but not Number or Object objects) to the list.
And, whatever the actual element type is, all elements of the list are instances of Object, so List methods like get( ) return Object in this case.
Enum serves as the supertype of all enumerated types (described later)
It implements the Comparable interface but has a confusing generic signature:
At first glance, the declaration of the type variable E appears circular.
Take a closer look though: what this signature really says is that Enum must be parameterized by a type that is itself an Enum.
The reason for this seemingly circular type variable declaration becomes apparent if we look at the implements clause of the signature.
As we’ve seen, Comparable classes are usually defined to be comparable to themselves.
And subclasses of those classes are comparable to their superclass instead.
Enum, on the other hand, implements the Comparable interface not for itself but for a subclass E of itself!
Enumerated Types In previous chapters, we’ve seen the class keyword used to define class types, and the interface keyword used to define interface types.
This section introduces the enum keyword, which is used to define an enumerated type (informally called an enum)
Enumerated types are new in Java 5.0, and the features described here cannot be used (although they can be partially simulated) prior to that release.
We begin with the basics: how to define and use an enumerated type, including common programming idioms involving enumerated types and values.
Next, we discuss the more advanced features of enums and show how to simulate enums prior to Java 5.0
An enumerated type is a reference type with a finite (usually small) set of possible values, each of which is individually listed, or enumerated.
Like class and interface, the enum keyword defines a new reference type.
The single line of Java code above defines an enumerated type named DownloadStatus.
The body of this type is simply a comma-separated list of the four values of the type.
A variable of type DownloadStatus can be assigned one of these four values or null but nothing else.
The values of an enumerated type are called enumerated values and are sometimes also referred to as enum constants.
It is possible to define more complex enumerated types than the one shown here, and we describe the complete enum syntax later in this chapter.
For now, however, you can define simple, but very useful, enumerated types with this basic syntax.
Prior to the introduction of enumerated types in Java 5.0, the DownloadStatus values would probably have been implemented as integer constants with lines like the following in a class or interface:
The use of integer constants has a number of shortcomings, the most important of which is its lack of type safety.
If a method expects a download status constant value, for example, no error checking prevents me from passing an illegal value.
Fortunately, enumerated types in Java are not simple integer constants.
The type defined by an enum keyword is actually a class and its enumerated values are instances of that class.
This provides type safety: if I try to pass a DownloadStatus value to a method that expects an UploadStatus, the compiler issues an error.
Enumerated types do not have a public constructor, so a program cannot create a new undefined instance of the type.
If a method expects a DownloadStatus, it can be confident that it will not be passed some unknown instance of the type.
If you are accustomed to writing code using integer constants instead of true enumerated types, you have probably already made a list of pragmatic advantages of integers over objects for enumerated values.
Hold your judgment, however: the sections that follow illustrate common enumerated type programming idioms and demonstrate that anything you can do with integer constants can be done elegantly, efficiently, and more safely with enums.
First, however, we consider the basic features of all enumerated types.
The following list describes the basic facts about enumerated types.
These are the features of enums that you need to know to understand and use them effectively:
The only instances of an enumerated type are those declared by the enum.
Enums are not Cloneable, so copies of the existing instances cannot be created.
Instances of an enumerated type are immutable: each enum value retains its identity.
We’ll see later in this chapter that you can add your own fields and methods to an enumerated type, which means that you can create enumerated values that have mutable portions.
This is not recommended, but does not affect the basic identity of each value.
Instances of an enumerated type are stored in public static final fields of the type itself.
By convention, the values of enumerated types are written using all capital letters, just as other static final fields are.
Because there is a strictly limited set of distinct enumerated values, it is always safe to compare enum values using the = = operator instead of calling the equals() method.
Enumerated types do have a working equals( ) method, however.
The method uses = = internally and is final so that it cannot be overridden.
This working equals( ) method allows enumerated values to be used as members of collections such as Set, List, and Map.
Enumerated types have a working hashCode() method consistent with their equals( ) method.
Enumerated types include a working toString( ) method that returns the name of the enumerated value.
This method is not final, and enum types can provide a custom implementation if they choose.
Enumerated types provide a static valueOf( ) method that does the opposite of the default toString( ) method.
Enumerated types define a final instance method named ordinal() that returns an integer for each enumerated value.
The ordinal of an enumerated value represents its position (starting at zero) in the list of value names in the enum declaration.
You do not typically need to use the ordinal( ) method, but it is used by a number of enum-related facilities, as described later in the chapter.
Each enumerated type defines a static method named values( ) that returns an array of enumerated values of that type.
This array contains the complete set of values, in the order they were declared, and is useful for iterating through the complete set of possible values.
Because arrays are mutable, the values( ) method always returns a newly created and initialized array.
You cannot produce an enumerated type by manually extending the Enum class, and it is a compilation error to attempt this.
The only way to define an enumerated type is with the enum keyword.
Enumerated types are effectively final, but the final keyword is neither required nor permitted in their declarations.
Because enums are effectively final, they may not be abstract.
We’ll see how enumerated types may define methods later in the chapter.
The following sections illustrate common idioms for working with enumerated types.
They demonstrate the use of the switch statement with enumerated types and introduce the important new EnumSet and EnumMap collections.
In Java 1.4 and earlier, the switch statement works only with int, short, char, and byte values.
Because enumerated types have a finite set of values, they are ideally suited for use with the switch statement, and this statement has been extended in Java 5.0 to support the use of enumerated types.
If the compile-time type of the switch expression is an enumerated type, the case labels must all be unqualified names of instances of that type.
The following hypothetical code shows a switch statement used with the DownloadStatus enumerated type.
Note that the case labels are just the constant name: the syntax of the switch statement does not allow the class name DownloadStatus to appear here.
The ability to omit the class name is very convenient since it would otherwise appear in every single case.
However the requirement that the class name be omitted is surprising since (in the absence of an import static declaration) the class name is required in every other context.
It is not legal to use null as the value of a case label.
If you use the switch statement on an enumerated type and do not include either a default: label or a case label for each enumerated value, the compiler will most likely issue an -Xlint warning letting you know that you have not written code to handle all possible values of the enumerated type.* Even when you do write a case for each enumerated value, you may still want to include a default: clause; this covers the possibility that a new value is added to the enumerated type after your switch statement has been compiled.
The following default clause, for example, could be added to the switch statement shown earlier:
A common programming technique when using integer constants instead of true enumerated values is to use those constants as array indexes.
In the big picture, this technique creates a mapping from enumerated integer constants to strings.
We can’t use Java’s enumerated values as array indexes, but we can use them as keys in a java.util.Map.
EnumMap requires an enumerated type as its key, and, relying on the fact the number of possible keys is finite, it uses an array to hold the corresponding values.
This implementation means that EnumMap is more efficient than HashMap.
At the time of this writing, this warning is expected to appear in Java 5.1
Like other collection classes in Java 5.0, EnumMap is a generic type that accepts type parameters.
The use of an EnumMap to associate a value with each instance of an enumerated type is appropriate when you’re working with an enum defined elsewhere.
If you defined the enum value yourself, you can create the necessary associations as part of the enum definition itself.
We’ll see how to do this later in the chapter.
Another common programming idiom when using integer-based constants instead of an enumerated type is to define all the constants as powers of two so that a set of those constants can be compactly represented as bit-flags in an integer.
Consider the following flags that describe options that can apply to an American-style espresso drink:
These power-of-two constants can be combined with the bitwise OR operator (|) to create a compact set of constants that is easy to work with:
The bitwise AND operator (&) can be used to test for the presence or absence of bits:
If we step back from the binary representation of these bit flags and the boolean operators that manipulate them, we can see that integer bit flags are simply compact sets of values.
For reference types such as Java’s enumerated values, we can use a java.util.Set instead.
It requires that its members be values of the same enumerated type and uses a compact and fast representation of the set based on bit flags that correspond to the ordinal() of each enumerated value.
The espresso drink code above could be rewritten as follows using an enum and EnumSet:
Note that the code above can be made as compact as the integer-based code with a simple static import:
See “Packages and the Java Namespace” in Chapter 2 for details on the import static declaration.
EnumSet defines a number of useful factory methods for initializing sets of enumerated values.
The of() method shown above is overloaded: several versions of the method take different fixed numbers of arguments.
A varargs (see Chapter 2) form that can accept any number of arguments is also defined.
Here are some other ways that you can use of() and related EnumSet factories:
The example code shown here demonstrates the use and capabilities of the EnumSet class.
At the root, the problem is that the DrinkFlag type is a naive translation of the integer bit flags we began this section with.
A better and more complete representation is captured by the following interface, which requires one value from each of five different enumerated types and a set of values from a sixth enum.
The enums are defined as nested types within the interface itself (see Chapter 3)
This example highlights the type safety provided by enumerated types.
It is not possible (as it would be with integer constants) to specify a drink strength where a drink size is required, for example.
The examples shown so far have all used the simplest enum syntax in which the body of the enum simply consists of a comma-separated list of value names.
The full enum syntax actually provides quite a bit more power and flexibility:
You can define your own fields, methods, and constructors for the enumerated type.
If you define one or more constructors, you can invoke a constructor for each enumerated value by following the value name with constructor arguments in parentheses.
Although an enum may not extend anything, it may implement one or more interfaces.
Most esoterically, individual enumerated values can have their own class bodies that override methods defined by the type.
Rather than formally specifying the syntax for each of these advanced enum declarations, we’ll demonstrate the syntax in the examples that follow.
It is an enum that includes a regular class body following the list of enumerated values.
It defines two instance fields and accessor methods for those fields.
It defines a custom constructor that initializes the instance field.
Each named value of the enumerated type is followed by constructor arguments in parentheses:
These are the private fields set by the constructor private String abbrev; private double multiplier;
Note that enum syntax requires a semicolon after the last enumerated value if that value is followed by a class body.
This semicolon may be omitted in the simple case where there is no class body.
It is also worth noting that enum syntax allows a comma following the last enumerated value.
A trailing comma looks somewhat odd but prevents syntax errors if in the future you add new enumerated values or rearrange existing ones.
An enum cannot be declared to extend a class or enumerated type.
It is perfectly legal, however, for an enumerated type to implement one or more interfaces.
Suppose, for example, that you defined a new enumerated type Unit with an abbrev( ) method like Prefix has.
In this case, you might define an interface Abbrevable for any objects that have abbreviations.
In addition to defining a class body for the enumerated type itself, you can also provide a class body for individual enumerated values within the type.
We’ve seen above that we can add fields to an enumerated type and use a constructor to initialize those fields.
The ability to define class bodies for each enumerated value means that we can write methods for each one: this gives us value-specific behavior.
Value-specific behavior is useful when defining an enumerated type that represents an operator in an expression parser.
To define a class body for an individual enumerated value, simply follow the value name and its constructor arguments with the class body in curly braces.
Individual values must still be separated from each other with commas, and the last value in the list must be separated from the type’s class body with a semicolon: it can be easy to forget about this required punctuation with the presence of curly braces for class and method bodies.
Each value-specific class body you write results in the creation of an anonymous subclass of the enumerated type and makes the enumerated value a singleton instance of that anonymous subclass.
Enumerated types can not be extended, but they are not strictly final in the sense that final classes are since they can have these anonymous subclasses.
Because these subclasses are anonymous, you cannot refer to them in your code: the compile-time type of each enumerated value is the enumerated type, not the anonymous subclass specific to that value.
Therefore, the only useful thing you can do in value-specific class bodies is override methods defined by the type itself.
If you define a new public field or method, you will not be able to refer to or invoke it.
It is perfectly legitimate, of course, to define helper methods or fields that you invoke or use from the overriding methods.
A common pattern is to define default behavior in a method of the type-specific class body.
Then, each enumerated value that requires behavior other than the default can override that method in its value-specific class body.
A very useful variant of this pattern is to declare the method in the type-specific class body abstract and to define a value-specific implementation of the method for every enumerated value.
If the type-specific method is abstract, the compiler forces you to implement that method for every enumerated value in the type: it is not possible to accidentally omit an implementation.
Note that even though the typespecific class body contains an abstract method, the enumerated type as a whole is not abstract (and may not be declared abstract) since each value-specific class body implements the method.
The following code is an excerpt from a larger example that uses an enumerated type to represent the opcodes of a simulated stack-based CPU.
The Opcode enumerated type defines an abstract method perform(), which is then implemented by the class body of each value of the type.
The type includes a constructor to illustrate the full syntax for each enumerated value: name, constructor arguments, and class body.
The code is easiest to understand, however, if you skip past the values and read the type-specific class body first:
Value-specific class bodies are an extremely powerful language feature when each enumerated value must perform a unique computation of some sort.
Keep in mind, however, that value-specific class bodies are an advanced feature that is not commonly used and may be confusing to less experienced programmers.
Before you decide to use this feature, be sure that it is necessary.
Before using value-specific class bodies, ensure that your design is neither too simple nor too complex for the feature.
First, check that you do indeed require value-specific behavior and not simply value-specific data.
Value-specific data can be encoded in constructor arguments as was shown in the Prefix example earlier.
It would be unnecessary and inappropriate to rewrite that example to use valuespecific versions of the abbrev( ) method, for example.
Next, think about whether an enumerated type is sufficient for your needs.
If your design requires value-specific methods with complex implementations or requires more than a few methods for each value, you may find it unwieldy to code everything within a single type.
Instead, consider defining your own custom type hierarchy using traditional class and interface declarations and whatever singleton instances are necessary.
If value-specific behavior is indeed required within the framework of an enumerated type, value-specific class bodies are appropriate.
Whether value-specific bodies are truly elegant or simply confusing is a matter of opinion, and some.
An alternative that appeals to some is to encode the value-specific behavior in a type-specific method that uses a switch statement to treat each value as a separate case.
The compute( ) method of the following enum is an example.
The simplicity of this enumerated type makes a switch statement a compelling alternative to value-specific class bodies:
A shortcoming to the switch approach is that each time you add a new enumerated value, you must remember to add a corresponding case to the switch statement.
And if there is more than one method that uses a switch statement, you’ll have to maintain their switch statements in parallel.
Forgetting to implement value-specific behavior using a switch statement leads to a runtime AssertionError.
With a value-specific class body overriding an abstract method in the type-specific class body, the same omission leads to a compilation error and can be corrected sooner.
The performance of value-specific methods and switch statements in a typespecific method are quite similar.
The overhead of virtual method invocation in one case is balanced by the overhead of the switch statement in the other.
Valuespecific class bodies result in the generation of additional class files, each of which has overhead in terms of storage space and loading time.
Java places a few restrictions on the code that can appear in an enumerated type.
You won’t encounter these restrictions that often in practice, but you should still be aware of them.
When you define an enumerated type, the compiler does a lot of work behind the scenes: it creates a class that extends java.lang.Enum and it generates the values()
If you include a class body for the type, you should not include members whose names conflict with the automatically generated members or with the final methods inherited from Enum.
Enumerated types are effectively final, and the compiler does not allow you to extend an enum.
The class file generated for an enum is not technically declared final if the enum contains value-specific class bodies, however.
Types in Java may not be both final and abstract.
Since enumerated types are effectively final, they may not be declared abstract.
If the type-specific class body of an enum declaration contains an abstract method, the compiler requires that each enum value have a value-specific class body that includes an implementation of that abstract method.
Considered as a self-contained whole, the enumerated type defined this way is not abstract.
The constructor, instance field initializers, and instance initializer blocks of an enumerated type are subject to a sweeping but obscure restriction: they may not use the static fields of the type (including the enumerated values themselves)
The reason for this is that static initialization of enumerated types (and of all types) proceeds from top to bottom.
The enumerated values are static fields that appear at the top of the type and are initialized first.
Since they are self-typed fields, they invoke the constructor and any other instance initializer code of the type.
This means that the instance initialization code is invoked before the static initialization of the class is complete.
Since the static fields have not been initialized yet, the compiler does not allow them to be used.
The only exception is static fields whose values are compile-time constant expressions (such as integers and strings) that the compiler resolves.
If you define a constructor for an enumerated type, it may not use the super( ) keyword to invoke the superclass constructor.
This is because the compiler automatically inserts hidden name and ordinal arguments into any constructor you define.
If you define more than one constructor for the type, it is okay to use this() to invoke one constructor from the other.
Remember that the class bodies of individual enumerated values (if you define any) are anonymous, which means that they cannot have any constructors at all.
If you want to use the enumerated type Prefix (from earlier in the chapter) prior to Java 5.0, you could approximate it with a class like the following one.
He is the creator of and the driving force behind enumerated types.
Also, the code shown here does not include the values() or valueOf( ) methods that the compiler generates automatically for true enum types.
A class like this does not have special serialization support like an enum type does, so if you make it Serializable, you must provide a readResolve( ) method to prevent deserialization from creating multiple instances of the enumerated values.
Keep the fields private so the instances are immutable private String name; private double multiplier;
Annotations Annotations provide a way to associate arbitrary information or metadata with program elements.
Syntactically, annotations are used like modifiers and can be applied to the declarations of packages, types, constructors, methods, fields, parameters, and local variables.
The information stored in an annotation takes the form of name=value pairs, whose type is specified by the annotation type.
The annotation type is a kind of interface that also serves to provide access to the annotation through the Java Reflection API.
Annotations can be used to associate any kind of information you want with a program element.
The only fundamental rule is that an annotation cannot affect the way the program runs: the code must run identically even if you add or remove annotations.
Another way to say this is that the Java interpreter ignores annotations (although it does make “runtime-visible” annotations available for reflective access through the Java Reflection API)
Since the Java VM ignores annotations, an annotation type is not useful unless accompanied by a tool that can do something with the information stored in annotations of that type.
In this chapter we’ll cover standard annotation and meta-annotation types like Override.
The tool that accompanies these types is the Java compiler, which must process them in certain ways (as we’ll describe later in this section)
It is easy to imagine any number of other uses for annotations.* A local variable might be annotated with a type named NonNull, as an assertion that the variable would never have a null value.
An associated (hypothetical) code-analysis tool could then parse the code and attempt to verify the assertion.
The JDK includes a tool named apt (for Annotation Processing Tool) that provides a framework for annotation processing tools: it scans source code for annotations and invokes specially written annotation processor classes that you provide.
Annotations will probably find their widest use in enterprise programming where they may replace tools such as XDoclet, which processes metadata embedded in ad-hoc javadoc comments.
We then cover the standard annotation types introduced in Java 5.0, annotations supported by javac that you can use in your programs right away.
Next, we describe the syntax for writing arbitrary annotations and briefly cover the use of the Java Reflection API for querying annotations at runtime.
At this point, we move on to more esoteric material on defining new annotation types, a task that few programmers will ever need to do.
The key concept to understand about annotations is that an annotation simply associates information or metadata with a program element.
Annotations never affect the way a Java program runs, but they may affect things like compiler warnings or the behavior of auxiliary tools such as documentation generators, stub generators, and so forth.
Of particular importance is the distinction between annotation and annotation type.
Annotations use new syntax introduced in Java 5.0 and behave like modifiers such as public or final.
Each annotation has a name and zero or more members.
Each member has a name and a value, and it is these name=value pairs that carry the annotation’s information.
An annotation type is essentially a Java interface with some restrictions on its members and some new syntax used in its declaration.
When you query an annotation using the Java Reflection API, the returned value is an object that implements the annota* We won’t have to imagine these uses for long.
Java 5.0 includes three standard annotation types in the java.lang package.
We’ll see these annotations in “Using Standard Annotations” later in this chapter.
The method name and return type define the name and type of the member.
A special default syntax allows the declaration of a default value for any annotation member.
An annotation appearing on a program element includes name=value pairs that define values for all annotation members that do not have default values and may also include values that override the defaults of other members.
An annotation of this type carries information simply by its presence or absence.
They are used to specify things like which program elements the annotation can be applied to.
Annotations can be applied to packages, types (classes, interfaces, enumerated types, and even annotation types), type members (methods, constructors, fields, and enumerated values), method parameters, and local variables (including loop variables and catch parameters)
The declaration of an annotation type may include a meta-annotation that restricts the allowable targets for that type of annotation.
Some annotations are discarded by the compiler and appear only in source code.
Of those that are compiled into the class file, some are ignored by the virtual machine, and others are read by the virtual machine when the class that contains them is loaded.
The declaration of an annotation type can use a meta-annotation to specify the retention for annotations of that type.
Because this term is used in many different ways in computer programming literature, I have avoided using it in this chapter.
Java 5.0 defines three standard annotation types in the java.lang package.
The following sections describe these annotation types and explain how to use them to annotate your code.
An annotation of this type serves as an assertion that the annotated method overrides a method of a superclass.
If you use this annotation on a method that does not override a superclass method, the compiler issues a compilation error to alert you to this fact.
This annotation is intended to address a common category of programming errors that result when you attempt to override a superclass method but get the method name or signature wrong.
In this case, you may have overloaded the method name but not actually overridden the method, and your code never gets invoked.
To use this annotation type, simply include @Override in the modifiers of the desired method.
Also by convention, there is no space between the @ character and the name Override, even though it is technically allowed.
Note that because the java.lang package is always automatically imported, you never need to include the package name to use this annotation type.
Here is an example in which the @Override annotation is used on a method that fails to correctly override the toString() method of its superclass.
Without the annotation, the typo might go unnoticed and we’d have a puzzling bug: why isn’t the toString( ) method working correctly? But with the annotation, the compiler gives us the answer: the toString() method does not work as expected because it is not actually overridden.
Note that the @Override annotation applies only to methods that are intended to override a superclass method and not to methods that are intended to implement a method defined in an interface.
The compiler already produces an error if you fail to correctly implement an interface method.
See Chapter 7 for details on writing Java documentation comments.
If you annotate a type or type member with @Deprecated, it tells the compiler that use of the annotated element is discouraged.
If you use (or extend or override) a deprecated type or member from code that is not itself declared @Deprecated, the compiler issues a warning.
The javadoc tag, on the other hand, is intended for the javadoc tool and serves as documentation: it may include a description of why the program element has been deprecated and what it has been superseded by or replaced with.
Here is an example that uses both the annotation and the javadoc tag:
These warnings include the “unchecked warning” that appears when you use a generic collection class without specifying a value for its type parameters, for example, or the warning that appears if a case in a switch statement does not end with a break, return, or throw and allows control to “fall through” to the next case.
Typically, when you see one of these lint warnings from the compiler, you should investigate the code that caused it.
If it truly represents an error, you then correct it.
If it simply represents sloppy programming, you may be able to rewrite your code so that the warning is no longer necessary.
For example, if the warning tells you that you have not covered all possible cases in a switch statement on an enumerated type, you can avoid the warning by adding a defensive default case to the switch statement, even if you are sure that it will never be invoked.
On the other hand, sometimes there is nothing you can do to avoid the error.
For example, if you use a generic collection class in code that must interact with nongeneric legacy code, you cannot avoid an unchecked warning.
This is where @SuppressWarnings comes in: add this annotation to the nearest relevant set of modifiers (typically on method modifiers) to tell the compiler that you’re aware of the issue and that it should stop pestering you about it.
Unlike Override and Deprecated, SuppressWarnings is not a marker annotation.
It has a single member named value whose type is String[ ]
The value of this member is the names of the warnings to be suppressed.
The SuppressWarnings annotation does not define what warning names are allowed: this is an issue for.
The javac compiler did not yet support the @SuppressWarnings annotation when this chapter was written.
For the javac compiler, the warning names accepted by the -Xlint option are also legal for the @SuppressWarnings annotation.
It is legal to specify any warning names you want: compilers ignore (but may warn about) warning names they do not recognize.
So, to suppress warnings named unchecked and fallthrough, you could use an annotation that looks like the following.
Annotation syntax follows the name of the annotation type with a parenthesized, comma-separated list of name=value pairs.
In this case, the SuppressWarnings annotation type defines only a single member, so there is only a single pair within parentheses.
Since the member value is an array, curly braces are used to delimit array elements:
When an annotation has a single member and that member is named “value”, you are allowed (and encouraged) to omit the “value=” in the annotation.
Hopefully you will not often have more than one unresolvable lint warning in any particular method and will need to suppress only a single named warning.
When writing an array value that contains only a single member, you are allowed to omit the curly braces.
In this case we might have an annotation like this:
In the descriptions of the standard annotation types, we’ve seen the syntax for writing marker annotations and the syntax for writing single-member annotations, including the shortcut allowed when the single member is named “value” and the shortcut allowed when an array-typed member has only a single array element.
An annotation consists of the @ character followed by the name of the annotation type (which may include a package name) followed by a parenthesized, commaseparated list of name=value pairs for each of the members defined by the annotation type.
Members may appear in any order and may be omitted if the annotation type defines a default value for that member.
Each value must be a literal or compile-time constant, a nested annotation, or an array.
Near the end of this chapter, we define an annotation type named Reviews that has a single member that is an array of @Review annotations.
The Review annotation type has three members: “reviewer” is a String, “comment” is an optional String with a default value, and “grade” is a value of the nested enumerated type Review.Grade.
Assuming that the Reviews and Review types are properly imported, an annotation using these types might look like this (note the use of nested annotations, enumerated types, and arrays in this annotation):
Another important rule of annotation syntax is that no program element may have more than one instance of the same annotation.
It is not legal, for example, to simply place multiple @Review annotations on a class.
Allowed member types are the primitive types, String, Class, enumerated types, annotation types, and arrays of any of the above types (but not an array of arrays)
For example, the expressions 2*Math.PI and "hello"+"world" are legal values for members of type double and String, respectively.
Annotations are most commonly placed on type definitions (such as classes) and their members (such as methods and fields)
Annotations may also appear on packages, parameters, and local variables.
This section provides more information about these less common annotation targets.
This file should not contain any type declarations (“packageinfo” is not a legal Java identifier, so it cannot contain any public type definitions)
Instead, it should contain an optional javadoc comment, zero or more annotations, and a package declaration.
This interface has no members, and its name, package-info, is not a legal Java identifier, so it cannot be used in Java source code.
It exists simply as a placeholder for package annotations with class or runtime retention.
Note that package annotations appear outside the scope of any package or import declaration.
This means that package annotations should always include the package name of the annotation type (unless the package is java.lang)
Annotations on method parameters, catch clause parameters, and local variables simply appear as part of the modifier list for those program elements.
The Java class file format has no provision for storing annotations on local variables or catch clause parameters, so those annotations always have source retention.
Method parameter annotations can be retained in the class file, however, and may have class or runtime retention.
Finally, note that the syntax for enumerated type definitions does not allow any modifiers to be specified for enumerated values.
It does, however, allow annotations on any of the values.
Annotations must include a value for every member that does not have a default value defined by the annotation type.
Annotations may, of course, include values for other members as well.
There is one important detail to understand about how default values are handled.
Default values are stored in the class file of the annotation type and are not compiled into annotations themselves.
If you modify an annotation type so that the default value of one of its members changes, that change affects all annotations of that type that do not specify an explicit value for that member.
Alreadycompiled annotations are affected, even if they are never recompiled after the change to the type.
Remember that an annotation is only visible at runtime if its annotation type is specified to have runtime retention, that is, if the annotation is both stored in the class file and read by the Java VM when the class file is loaded.
AnnotatedElement represents a program element that can be queried for annotations.
It assumes that the Unstable annotation type, which we’ll define later in the chapter, has runtime retention.
Note that this code uses class literals to specify both the class to be checked and the annotation to check for:
When working with annotations that have members, though, we typically want to know the value of those members.
And here we see the beauty of the Java annotation system: if the specified annotation exists, the object returned by this method implements the annotation type interface, and you can query the value of any member simply by invoking the annotation type method that defines that member.
Consider the @Reviews annotation that appeared earlier in the chapter, for example.
If the annotation type was declared with runtime retention, you could query it as follows:
Note that these reflective methods correctly resolve default annotation values for you.
If an annotation does not include a value for a member with a default value, the default value is looked up within the annotation type itself.
An annotation type is an interface, but it is not a normal one.
An annotation type differs from a normal interface in the following ways:
An annotation type is defined with the keyword @interface rather than with interface.
The methods of an annotation type must be declared with no arguments and may not throw exceptions.
These methods define annotation members: the method name becomes the member name, and the method return type becomes the member type.
The return value of annotation methods may be a primitive type, a String, a Class, an enumerated type, another annotation type, or a single-dimensional array of one of those types.
Any method of an annotation type may be followed by the keyword default and a value compatible with the return type of the method.
This strange new syntax specifies the default value of the annotation member that corresponds to the method.
The syntax for default values is the same as the syntax used to.
The only valid use of generics in annotation types is for methods whose return type is Class.
These methods may use a bounded wildcard to specify a constraint on the returned class.
In other ways, annotation types declared with @interface are just like regular interfaces.
They may include constant definitions and static member types such as enumerated type definitions.
Annotation types may also be implemented or extended just as normal interfaces are.
The classes and interfaces that result from doing this are not themselves annotation types, however: annotation types can be created only with an @interface declaration.
We now define the annotation types used in our examples.
These examples illustrate the syntax of annotation type declarations and demonstrate many of the differences between @interface and interface.
Because we used this type earlier in the chapter in a reflection example, its definition includes a meta-annotation that gives it runtime retention and makes it accessible to the reflection API.
By naming the member value, we enable a syntactic shortcut for anyone using the annotation:
The Reviews annotation type has a single member, but the type of the member is complex: it is an array of Review annotations.
The Review annotation type has three members, one of which has an enumerated type defined as a member of the Review type itself, and another of which has a default value.
Because the Reviews annotation type is used in a reflection example, we’ve given it runtime retention with a meta-annotation:
Finally, suppose we wanted to annotate methods to list the unchecked exceptions (but not errors) that they might throw.
Our annotation type would have a single member of array type.
Each element of the array would be the Class of an exception.
In order to enforce the requirement that only unchecked exceptions are used, we use a bounded wildcard on Class:
Java 5.0 defines four standard meta-annotation types that provide information about the use and meaning of other annotation types.
The Target meta-annotation type specifies the “targets” for an annotation type.
That is, it specifies which program elements may have annotations of that type.
If an annotation type does not have a Target meta-annotation, it can be used with any of the program elements described earlier.
Some annotation types, however, make sense only when applied to certain program elements.
Override is one example: it is only meaningful when applied to a method.
The Target meta-annotation type has a single member named value.
ElementType is an enumerated type whose enumerated values represent program elements that can be annotated.
It specifies whether an annotation is discarded by the compiler or retained in the class file, and, if it is retained in the class file, whether it is read by the VM when the class file is loaded.
By default, annotations are stored in the class file but not available for runtime reflective access.
The Retention meta-annotation type has a single member named value whose type is RetentionPolicy.
Documented is a meta-annotation type used to specify that annotations of some other type should be considered part of the public API of the annotated program element and should therefore be documented by tools like javadoc.
The @Inherited meta-annotation is a marker annotation that specifies that the annotated type is an inherited one.
That is, if an annotation type @Inherited is used to annotate a class, the annotation applies to subclasses of that class as well.
Note that @Inherited annotation types are inherited only by subclasses of an annotated class.
Classes do not inherit annotations from interfaces they implement, and methods do not inherit annotations from methods they override.
This chapter switches gears and covers the Java platform—a vast collection of predefined classes available to every Java program, regardless of the underlying host system on which it is running.
The classes of the Java platform are collected into related groups, known as packages.
This chapter begins with an overview of the packages of the Java platform that are documented in this book.
It then moves on to demonstrate, in the form of short examples, the most useful classes in these packages.
Most of the examples are code snippets only, not full programs you can compile and run.
For fully fleshed-out, real-world examples, see Java Examples in a Nutshell (O’Reilly)
That book expands greatly on this chapter and is intended as a companion to this book.
Java Platform Overview Table 5-1 summarizes the key packages of the Java platform that are covered in this book.
Although some of the classes in this package are for working directly with files, most are for working with streams of bytes or characters.
Table 5-1 does not list all the packages in the Java platform, only the most important of those documented in this book.
Java also defines numerous packages for graphics and graphical user interface programming and for distributed, or enterprise, computing.
The graphics and GUI packages are java.awt and javax.swing and their many subpackages.
These packages, as well as several standard extensions to the Java platform, are documented in Java Enterprise in a Nutshell (O’Reilly)
A weak reference is one that does not prevent the referent object from being garbage-collected.
This package and its subpackages support cryptographic message digests and digital signatures.
Enables the creation of socket types other than the default.
Text Most programs manipulate text in one form or another, and the Java platform defines a number of important classes and interfaces for representing, formatting, and scanning text.
Strings of text are a fundamental and commonly used data type.
In Java, however, strings are not a primitive type, like char, int, and float.
String objects are immutable: once a String object has been created, there is no way to modify the string of text it represents.
Thus, each method that operates on a string typically returns a new String object that holds the modified string.
This code shows some of the basic operations you can perform on strings:
As you know, individual characters are represented in Java by the primitive char type.
The Java platform also defines a Character class, which contains useful class methods for checking the type of a character and for converting the case of a character.
Since String objects are immutable, you cannot manipulate the characters of an instantiated String.
These two classes are identical except that StringBuffer has synchronized methods.
StringBuilder was introduced in Java 5.0 and you should use it in preference to StringBuffer unless it might actually be manipulated by multiple threads.
The following code demonstrates the StringBuffer API but could be easily changed to use StringBuilder:
CharSequence provides a way to perform simple operations on strings of characters regardless of the underlying implementation of those strings.
Appendable is a Java 5.0 interface that represents an object that can have a char or a CharSequence appended to it.
Thus, the Appendable interface represents the common appendability of the text buffer classes and the text output stream classes.
As we’ll see below, a Formatter object can send its output to any Appendable object.
The + operator concatenates two String objects or one String and one value of some other type, producing a new String object.
Be aware that each time a string concatenation is performed and the result stored in a variable or passed to a method, a new String object has been created.
In some circumstances, this can be inefficient and can result in poor performance.
It is especially important to be careful when doing string concatenation within a loop.
When you find yourself writing code like this, switch to a StringBuffer or a StringBuilder and use the append() method:
There is no need to be paranoid about string concatenation, however.
Remember that string literals are concatenated by the compiler rather than the Java interpreter.
Also, when a single expression contains multiple string concatenations, these are compiled efficiently using a StringBuilder (or StringBuffer prior to Java 5.0) and result in the creation of only a single new String object.
Since strings are objects rather than primitive values, they cannot, in general, be compared for equality with the = = operator.
It cannot determine if two distinct strings contain the same text.
In Java 5.0 you can compare the content of a string to any other CharSequence with the contentEquals( ) method.
To compare the order of strings, use the compareTo() method, which is defined by the Comparable<String> interface and is illustrated in the sample code above.
Note that StringBuffer and StringBuilder do not implement Comparable and do not override the default versions of equals( ) and hashCode() that they inherit from Object.
This means that it is not possible to compare the text held in two StringBuffer or StringBuilder objects for equality or for order.
One important, but little understood method of the String class is intern( )
When passed a string s, it returns a string t that is guaranteed to have the same content as s.
What’s important, though, is that for any given string content, it always returns a reference to the same String object.
That is, if s and t are two String objects such that s.equals(t), then:
This means that the intern( ) method provides a way of doing fast string comparisons using ==
Importantly, string literals are always implicitly interned by the Java VM, so if you plan to compare a string s against a number of string literals, you may want to intern s first and then do the comparison with = =
The compareTo() and equals( ) methods of the String class allow you to compare strings.
These are not always the right methods to use, however.
In some languages, the character ordering imposed by the Unicode standard does not match the dictionary ordering used when alphabetizing strings.
When working with these “supplementary characters” (which are primarily Han ideographs), you must use int values to represent the individual character.
In String objects, or for any other type that represents text as a sequence of char values, these supplementary characters are represented as a series of two char values known as a surrogate pair.
Although readers of the English edition of this book are unlikely to ever encounter supplementary characters, you should be aware of them if you are working on programs that might be localized for use in China or another country that uses Han ideographs.
To help you work with supplementary characters, the Character, String, StringBuffer, and StringBuilder classes have been extended with new methods that operate on int codepoints rather than char values.
You can find other, similar methods in the reference section and read about them in the online javadoc documentation.
A common task when working with text output is to combine values of various types into a single block of human-readable text.
One way to accomplish this relies on the string-conversion power of Java’s string concatenation operator.
Java 5.0 introduces an alternative that is familiar to C programmers: a printf( ) method.
The printf( ) method has been added to the PrintWriter and PrintStream output stream classes in Java 5.0
It is a varargs method that expects one or more arguments.
The first argument is the “format string.” It specifies the text to be printed and typically includes one or more “format specifiers,” which are escape sequences beginning with character %
The remaining arguments to printf( ) are values to be converted to strings and substituted into the format string in place of the format specifiers.
The format specifiers constrain the types of the remaining arguments and specify exactly how they are converted to strings.
The string concatenation shown above can be rewritten as follows in Java 5.0:
Times and dates are displayed with locale-appropriate punctuation, for example.
And if you request that a number be displayed with a thousands separator, you’ll get locale-specific punctuation there, too (a comma in England and a period in France, for example)
In addition to the basic printf( ) method, PrintWriter and PrintStream also define a synonymous method named format(): it takes exactly the same arguments and behaves in exactly the same way.
The String class also has a format() method in Java 5.0
It can format text to any Appendable object or to a named file.
The following code uses a Formatter object to write a file:
When you concatenate an object to a string, the object is converted to a string by calling its toString() method.
This is what the Formatter class does by default as well.
We’ll see additional examples of formatting with printf( ) when we cover the APIs for working with numbers, dates, and times.
Server programs that run unattended for long periods need a different solution for output: the.
Programs like this need logging functionality in which output messages are sent to a file for later analysis or through a network socket for remote monitoring.
These messages may report errors and warnings or provide informational messages about interesting events in the application’s life cycle.
They can include debugging information or even trace the execution of important methods within the program.
The system administrator or end user of the application is responsible for setting up a logging configuration file that specifies where log messages are directed (the console, a file, a network socket, or a combination of these), how they are formatted (as plain text or XML documents), and at what severity threshold they are logged (log messages with a severity below the specified threshold are discarded with very little overhead and should not significantly impact the performance of the application)
The logging level severity threshold can be configured independently so that Logger objects associated with different classes or packages can be “tuned in” or “tuned out.” Because of this end-user configurability, you should feel free to use logging output liberally in your program.
In normal operation, most log messages will be discarded efficiently and automatically.
During program development, or when diagnosing a problem in a deployed application, however, the log messages can prove very valuable.
For most applications, using the Logging API is quite simple.
Then, use one of the many Logger instance methods to generate log messages.
The easiest methods to use have names that correspond to severity levels, such as severe(), warning( ), and info()
In Java 1.4 and later, you can perform textual pattern matching with regular expressions.
Regular expression support is provided by the Pattern and Matcher.
Regular expressions use a fairly complex grammar to describe patterns of characters.
The Java implementation uses the same regex syntax as the Perl 5 programming language.
For a complete tutorial on Perl-style regular expressions, see Mastering Regular Expressions (O’Reilly)
The matches( ) method returns true only if the entire string is a match for the specified pattern.
Perl programmers should note that this differs from Perl’s behavior, in which a match means only that some portion of the string matches the pattern.
To determine if a string or any substring matches a pattern, simply alter the regular expression to allow arbitrary characters before and after the desired pattern.
In the following code, the regular expression characters .* match any number of arbitrary characters:
If you are already familiar with Perl’s regular expression syntax, you know that it relies on the liberal use of backslashes to escape certain characters.
In Perl, regular expressions are language primitives and their syntax is part of the language itself.
In Java, however, regular expressions are described using strings and are typically embedded in programs using string literals.
The syntax for Java string literals also uses the backslash as an escape character, so to include a single backslash in the regular expression, you must use two backslashes.
Thus, in Java programming, you will often see double backslashes in regular expressions.
In addition to matching, regular expressions can be used for search-and-replace operations.
The replaceFirst( ) and replaceAll( ) methods search a string for the first substring or all substrings that match a given pattern and replace the string or strings with the specified replacement text, returning a new string that contains the replacements.
For example, you could use this code to ensure that the word “Java” is correctly capitalized in a string s:
The replacement string passed to replaceAll() and replaceFirst( ) need not be a simple literal string; it may also include references to text that matched parenthesized subexpressions within the pattern.
For example, to search for words such as JavaBean, JavaScript, JavaOS, and JavaVM (but not Java or Javanese) and to replace the Java prefix with the letter J without altering the suffix, you could use code such as:
The other String method that uses regular expressions is split(), which returns an array of the substrings of a string, separated by delimiters that match the specified pattern.
To obtain an array of words in a string separated by any number of spaces, tabs, or newlines, do this:
An optional second argument specifies the maximum number of entries in the returned array.
The matches( ), replaceFirst(), replaceAll( ), and split() methods are suitable for when you use a regular expression only once.
This exception is also thrown by the various String convenience methods.
The Pattern class defines split() methods that are similar to the String.split() methods.
For all other matching, however, you must create a Matcher object with the matcher() method and specify the text to be matched against:
Once you have a Matcher object, you can compare the string to the pattern in various ways.
One of the more sophisticated ways is to find all substrings that match the pattern:
The Matcher class has been enhanced in several ways in Java 5.0
The most important of these is the ability to save the results of the most recent match in a MatchResult object.
The previous algorithm that finds all matches in a string could be rewritten in Java 5.0 as follows:
Readable is also new in Java 5.0 and is the opposite of the Appendable interface.
A Scanner can break its input text into tokens separated by whitespace or any desired delimiter character or regular expression.
It implements the Iterator<String> interface, which allows for simple looping through the returned tokens.
Scanner also defines a variety of convenience methods for parsing tokens as boolean, integer, or floating-point values, with locale-sensitive number parsing.
It has skip( ) methods for skipping input text that matches a specified pattern and also has methods for searching ahead in the input text for text that matches a specified pattern.
Here’s how you could use a Scanner to break a String into space-separated words:
Here’s how you might use a Scanner to break a file into lines:
The following method uses Scanner to parse an input line in the form x + y = z.
It demonstrates the ability of a Scanner to scan numbers.
This code also demonstrates the skip() method and shows that a Scanner can scan text directly from an InputStream.
A number of other Java classes operate on strings and characters.
You can even use this class to tokenize words that are delimited by characters other than spaces:
It has a more complicated API and has more powerful features than StringTokenizer.
Numbers and Math Java provides the byte, short, int, long, float, and double primitive types for representing numbers.
The java.lang package includes the corresponding Byte, Short, Integer, Long, Float, and Double classes, each of which is a subclass of Number.
These classes can be useful as object wrappers around their primitive types, and they also define some useful constants:
The Math class defines a number of methods that provide trigonometric, logarithmic, exponential, and rounding operations, among others.
In Java 5.0, several new functions have been added to the Math class, including the following:
In Java 1.4, BigInteger has a method to randomly generate large prime numbers, which is useful in many cryptographic applications:
The BigDecimal class has been overhauled in Java 5.0 and is much more usable in this release.
In addition to its utility for representing very large or very precise floating point numbers, it is also useful for financial calculations because it relies on a decimal representation of fractions rather than a binary representation.
BigDecimal and its associated MathContext and RoundingMode types provide a solution.
Convert term of loan in years to number of monthly payments int payments=years*12;
A Java program that operates on numbers must get its input values from somewhere.
Often, such a program reads a textual representation of a number and must convert it to a numeric representation.
The printf() and format( ) methods of Java 5.0 described earlier in this chapter work well for formatting numbers.
The %d format specifier is for formatting integers in decimal format:
Floating-point numbers can be formatted using %f, %e, or %g format specifiers, which differ in whether and when exponential notation is used:
You’ll notice that the numbers above are all formatted with six digits following the decimal point.
This default can be altered by specifying a precision in the format string:
Other flags can be applied to floating-point conversions as well.
The following code formats a column of numbers right-justified within a field 10 characters wide.
Each number has two digits following the decimal place and includes thousands separators when necessary.
Negative values are formatted in parentheses, a common formatting convention in accounting.
The values of this type represent time granularities or units: seconds, milliseconds, microseconds, and nanoseconds.
They have useful convenience methods but do not themselves represent a time value.
This special date and time is known as the epoch and is measured in Greenwich Mean Time (GMT) or Universal Time (UTC)
Unlike currentTimeMillis( ), the nanoTime() does not return a time relative to any defined.
Using a Date object instead of a long allows simple conversion to a nonlocalized string with the toString method.
Date objects can be compared for equality with the equals( ) method and they can be compared for order with the compareTo() method or the before( ) and after() methods.
The no-argument version of the Date( ) constructor creates a Date that represents the current time.
You can also pass a long number of milliseconds to create a Date that represents some other time.
Date is a mutable class, so you can also pass a number of milliseconds to setTime( )
Date has a number of methods for querying and setting the year, month, day, hour, minute, and second.
All of these methods have been deprecated, however, in favor of the Calendar class, described next.
It is simply a wrapper around a long number of milliseconds but can represent that instant in time according to the calendar of the current locale (usually a Gregorian calendar) and the time zone of the current locale.
Furthermore, it has methods for querying, setting, and doing arithmetic on the various fields of the date and time.
The code below shows common uses of the Calendar class.
Note that the set( ), get(), and add( ) methods all take an initial argument that specifies what field of the date or time is being set, queried, or added to.
Fields such as year, day of month, day of week, hour, minute, and second are defined by integer constants in the class.
Other integer constants define values for the months and weekdays of the Gregorian calendar.
The month constant UNDECIMBER represents a 13th month used in lunar calendars.
The toString() method of Date produces a textual representation of a date and time but does no localization and allows no customization of which fields (day, month and year or hours and minutes, for example) are to be displayed.
The toString( ) method should be used only to produce a machine-readable timestamp, not a human-readable string.
Format strings for displaying dates and times are all two-character sequences that begin with the letter t.
The second letter of each sequence specifies the field or set of fields of the date or time to display.
For example %tR displays the hours and minutes fields using 24-hour time, and %tD displays the month, day, and year fields separated by slashes.
DateFormat even works correctly in locales that use a calendar other than the common era (Gregorian) calendar in use throughout much of the world:
The second array must be the same type as the first, and it can even be the same array:
Arrays can be treated and manipulated as objects in Java.
Given an arbitrary object o, you can use code such as the following to find out if the object is an array and, if so, what type of array it is:
Collections The Java Collections Framework is a set of important utility classes and interfaces in the java.util package for working with collections of objects.
A Collection is a group of objects while a Map is a set of mappings, or associations, between objects.
A Set is a type of Collection with no duplicates, and a List is a Collection in which the elements are ordered.
SortedSet and SortedMap are specialized sets and maps that maintain their elements in a sorted order.
Collection, Set, List, Map, SortedSet, and SortedMap are all interfaces, but the java.util package also defines various concrete implementations, such as lists based on arrays and linked lists, and maps and sets based on hashtables or binary trees.
Other important interfaces are Iterator and ListIterator, which allow you to loop through the objects in a collection.
The Collections Framework was added in Java 1.2, but prior to that release you can use Vector and Hashtable, which are approximately the same as ArrayList and HashMap.
In Java 1.4, the Collections API added the RandomAccess marker interface, which is implemented by List implementations that support efficient random access (i.e., it is implemented by ArrayList and Vector but not by LinkedList)
Java 1.4 also introduced LinkedHashMap and LinkedHashSet, which are hashtable-based maps and sets that preserve the insertion order of elements.
Finally, IdentityHashMap is a hashtable-based Map implementation that uses the == operator to compare key objects rather than using the equals() method to compare them.
Collection<E> is a parameterized interface that represents a generic group of objects of type E.
The group may or may not allow duplicate elements and may or may not impose an ordering on the elements.
Methods are defined for adding and removing objects from the group, testing an object for membership in the group, and iterating through all elements in the group.
Additional methods return the elements of the group as an array and return the size of the collection.
The Java Collections Framework does not provide any implementations of Collection, but this interface is still very important because it defines the features common to all Set, List, and Queue implementations.
The following code illustrates the operations you can perform on Collection objects:
Remember that you can use any of the methods shown above with any Set, List, or Queue.
These subinterfaces may impose membership restrictions or ordering constraints on the elements of the collection but still provide the same basic methods.
Collection, Map, and their subinterfaces do not extend the Cloneable or Serializable interfaces.
All of the collection and map implementation classes provided in the Java Collections Framework, however, do implement these interfaces.
Some collection implementations place restrictions on the elements that they can contain.
An implementation might prohibit null as an element, for example.
And EnumSet restricts membership to the values of a specified enumerated type.
Checking whether a collection contains a prohibited element may also throw such an exception, or it may simply return false.
A set is a collection of objects that does not allow duplicates: it may not contain two references to the same object, two references to null, or references to two objects a and b such that a.equals(b)
Most general-purpose Set implementations impose no ordering on the elements of the set, but ordered sets are not prohibited (see SortedSet and LinkedHashSet)
Sets are further distinguished from ordered collections like lists by the general expectation that they have an efficient contains( ) method that runs in constant or logarithmic time.
Set defines no additional methods beyond those defined by Collection but places additional restrictions on those methods.
The add( ) and addAll() methods of a Set are required to enforce the no-duplicates rules: they may not add an element to the Set if the set already contains that element.
Recall that the add() and addAll( ) methods defined by the Collection interface return true if the call resulted in a change to the collection and false if it did not.
This return value is relevant for Set objects because the no-duplicates restriction means that adding an element does not always result in a change to the set.
Table 5-2 lists the implementations of the Set interface and summarizes their internal representation, ordering characteristics, member restrictions, and the.
You can read more about each class in the reference section.
This legacy class is useful as a compact and efficient list of boolean values but is not part of the Java Collections Framework.
The TreeSet implementation uses a red-black tree data structure to maintain a set that is iterated in ascending order according to the natural ordering of Comparable objects or according to an ordering specified by a Comparator object.
TreeSet actually implements the SortedSet interface, which is a subinterface of Set.
SortedSet offers several interesting methods that take advantage of its sorted nature.
Each element of a list has a position in the list, and the List interface defines methods to query or set the element at a particular position, or index.
In this respect a List is like an array whose size changes as needed to accommodate the number of elements it contains.
In addition to its index-based get( ) and set() methods, the List interface defines methods to add or remove an element at a particular index and also defines methods to return the index of the first or last occurrence of a particular value in the list.
The add( ) and remove() methods inherited from Collection are defined to append to the list and to remove the first occurrence of the specified value from the list.
The inherited addAll() appends all elements in the specified collection to the end of the list, and another version inserts the elements at a specified index.
The retainAll() and removeAll( ) methods behave as they do for any Collection, retaining or removing multiple occurrences of the same value, if needed.
The List interface does not define methods that operate on a range of list indexes.
Instead it defines a single subList method that returns a List object that represents just the specified range of the original list.
The sublist is backed by the parent list, and any changes made to the sublist are immediately visible in the parent list.
Examples of subList( ) and the other basic List manipulation methods are below.
Print the index of all occurrences of last in l.
A general expectation of List implementations is that they can be efficiently iterated, typically in time proportional to the size of the list.
Lists do not all provide efficient random-access to the elements at any index, however.
Sequential-access lists, such as the LinkedList class, provide efficient insertion and deletion operations at the expense of random access performance.
In Java 1.4 and later, implementations that provide efficient random access implement the RandomAccess marker interface, and you can test for this interface with instanceof if you need to ensure efficient list manipulations:
The Iterator returned by the iterator() method of a List iterates the list elements in the order that they occur in the list.
List implements Iterable, and lists can be iterated with a for/in loop just as any other collection can.
To iterate just a portion of a list, you can use the subList( ) method to create a sublist view:
List<String> words = ...;  // Get a list to iterate.
In addition to normal iteration, lists also provide enhanced bidirectional iteration using a ListIterator object returned by the listIterator() method.
To iterate backward through a List, for example, start with a ListIterator with its cursor positioned after the end of the list:
Table 5-3 summarizes the five general-purpose List implementations in the Java platform.
Vector and Stack are legacy implementations left over from Java 1.0
A map is a set of key objects and a mapping from each member of that set to a value object.
The Map interface defines an API for defining and querying mappings.
Map is part of the Java Collections Framework, but it does not extend the Collection interface, so a Map is a little-c collection, not a big-C Collection.
Type variable K represents the type of keys held by the map, and type variable V represents the type of the values that the keys are mapped to.
The most important Map methods are put(), which defines a key/value pair in the map, get( ), which queries the value associated with a specified key, and remove( ), which removes the specified key and its associated value from the map.
The general performance expectation for Map implementations is that these three basic methods are quite efficient: they should usually run in constant time and certainly no worse than in logarithmic time.
An important feature of Map is its support for “collection views.” Although a Map is not a Collection, its keys can be viewed as a Set, its values can be viewed as a Collection, and its mappings can be viewed as a Set of Map.Entry objects.
Map.Entry is a nested interface defined within Map: it simply represents a single key/value pair.
The sample code below shows the get( ), put(), remove( ), and other methods of a Map and also demonstrates some common uses of the collection views of a Map:
Populate the map using the put() method to define mappings from array // elements to the index at which each element appears.
Stack array yes Extends Vector; adds push( ), pop(), peek( )
The Map interface includes a variety of general-purpose and special-purpose implementations, which are summarized in Table 5-4
ConcurrentMap extends Map and defines some additional atomic operations that are important in multithreaded programming.
For example, the putIfAbsent() method is like put( ) but adds the key/value pair to the map only if the key is not already mapped.
TreeMap implements the SortedMap interface, which extends Map to add methods that take advantage of the sorted nature of the map.
EnumMap array 5.0 no yes Keys are instances of an enum.
TreeMap red-black tree 1.2 no yes Sorts by key value.
WeakHashMap hashtable 1.2 yes yes Doesn’t prevent garbage collection of keys.
Properties hashtable 1.0 no no Extends Hashtable with String methods.
And headMap(), tailMap( ), and subMap() return a restricted range of the original map.
A queue is an ordered collection of elements with methods for extracting elements, in order, from the head of the queue.
Queue implementations are commonly based on insertion order as in first-in, first-out (FIFO) queues or last in, first-out queues (LIFO queues are also known as stacks)
Other orderings are possible, however: a priority queue orders its elements according to an external Comparator object, or according to the natural ordering of Comparable elements.
Unlike List, the Queue interface does not define methods for manipulating queue elements at arbitrary positions.
Only the element at the head of the queue is available for examination.
It is common for Queue implementations to have a fixed capacity: when a queue is full, it is not possible to add more elements.
Similarly, when a queue is empty, it is not possible to remove any more elements.
Because full and empty conditions are a normal part of many queue-based algorithms, the Queue interface defines methods that signal these conditions with return values rather than by throwing exceptions.
Specifically, the peek() and poll( ) methods return null to indicate that the queue is empty.
For this reason, most Queue implementations do not allow null elements.
A blocking queue is a type of queue that defines blocking put( ) and take() methods.
The put( ) method adds an element to the queue, waiting, if necessary, until there is space in the queue for the element.
And the take( ) method removes an element from the head of the queue, waiting, if necessary, until there is an element to remove.
Queue, BlockingQueue, and their implementations are new in Java 5.0
See “Blocking Queues” later in this chapter for a list of BlockingQueue implementations.
Queues are not nearly as commonly used as sets, lists, and maps, except perhaps in certain multithreaded programming styles.
In lieu of example code here, we’ll try to clarify the confusing array of queue insertion and removal operations:
In bounded queues, this method may throw an exception if the queue is full.
BlockingQueue defines a timeout version of offer( ) that waits up to a specified amount of time for space to become available in a full queue.
Like the basic version of the method, it returns true if the element was inserted and false otherwise.
BlockingQueue defines a timeout version of poll() that waits up to a specified amount of time for an element to be added to an empty queue.
If the queue is empty, it blocks until some other thread adds an element to the queue.
It does not block to wait for elements to be added to the queue.
A variant of the method accepts a maximum number of elements to drain.
Querying the element at the head, without removing it from the queue.
The LinkedList class has been retrofitted, in Java 5.0, to implement Queue.
It provides unbounded FIFO (first in, first out) ordering, and insertion and removal operations require constant time.
LinkedList allows null elements, although their use is discouraged when the list is being used as a queue.
The only other Queue implementation in the java.util package is PriorityQueue, which orders its elements according to a Comparator or orders Comparable elements according to the order defined by their compareTo( ) methods.
The head of a PriorityQueue is always the smallest element according to the defined ordering.
One important group of these methods are the collection wrapper methods: they return a special-purpose collection wrapped around a collection you specify.
The purpose of the wrapper collection is to wrap additional functionality around a collection that does not provide it itself.
Wrappers exist to provide thread-safety, write-protection and runtime type checking.
Wrapper collections are always backed by the original collection, which means that the methods of the wrapper simply dispatch to the equivalent methods of the wrapped collection.
This means that changes made to the collection through the wrapper are visible through the wrapped collection and vice versa.
The first set of wrapper methods provides threadsafe wrappers around collections.
Except for the legacy classes Vector and Hashtable, the collection implementations in java.util do not have synchronized methods and are not protected against concurrent access by multiple threads.
If you need threadsafe collections, create them with code like this:
A second set of wrapper methods provides collection objects through which the underlying collection cannot be modified.
These wrappers are useful when you must pass a collection to a method that must not be allowed to modify or mutate the content of the collection in any way:
The final set of wrapper methods provides runtime type checking of any values added to the collection.
They were added in Java 5.0 to complement the compiletime type safety provided by generics.
These wrappers are helpful when working with legacy code that has not been converted to use generics.
If you have a SortedSet<String>, for example, and must pass it to a method that expects a Set, you can use a checked wrapper to ensure that that method cannot add anything to the set that is not a String:
These methods are useful, for example, when you need to pass a single object to a method that expects a collection.
The Collections class also includes methods that return empty collections.
If you are writing a method that returns a collection, it is usually best to handle the novalues-to-return case by returning an empty collection instead of a special-case value like null:
Finally, nCopies() returns an immutable List that contains a specified number of copies of a single specified object:
It is possible to convert from one to the other:
Most notable are methods to sort and search the elements of collections:
The Java Collections Framework provides abstract classes that make it simple to implement common types of collections.
The following code extends AbstractList to define a QuadraticSequence, a list implementation that computes list values on demand rather than actually storing them in memory anywhere.
Threads and Concurrency The Java platform has supported multithreaded or concurrent programming with the Thread class and Runnable interface since Java 1.0
Java 5.0 bolsters that support with a comprehensive set of new utilities for concurrent programming.
Java makes it easy to define and work with multiple threads of execution within a program.
One is to subclass Thread, override the run( ) method and then instantiate your Thread subclass.
The other is to define a class that implements the Runnable method (i.e., define a run() method) and then pass an instance of this Runnable object to the Thread() constructor.
In either case, the result is a Thread object, where the run() method is the body of the thread.
When you call the start() method of the Thread object, the interpreter creates a new.
This new thread continues to run until the run( ) method exits.
Meanwhile, the original thread continues running itself, starting with the statement following the start() method.
In Java 5.0, these states are represented by the Thread.State enumerated type, and the state of a thread can be queried with the getState( ) method.
A listing of the Thread.State constants provides a good overview of the lifecycle of a thread:
We’ll see more about synchronized methods and blocks later in this section.
TIMED_WAITING The thread is not running because it has called Thread.sleep() or has called Object.wait( ) or Thread.join() with a timeout value.
Its run( ) method has exited normally or by throwing an exception.
A thread at a given priority level does not typically run unless no higher-priority threads are waiting to run.
Here is some code you can use when working with thread priorities:
A thread terminates normally when it reaches the end of its run( ) method or when it executes a return statement in that method.
A thread can also terminate by throwing an exception, however.
When a thread exits in this way, the default behavior is to print the name of the thread, the type of the exception, the exception message, and a stack trace.
In Java 5.0, you can install a custom handler for uncaught exceptions in a thread.
Often, threads are used to perform some kind of repetitive task at a fixed interval.
This is particularly true when doing graphical programming that involves animation or similar effects.
The key to doing this is making a thread sleep, or stop running, for a specified amount of time.
This is done with the static Thread.sleep( ) method, or, in Java 5.0, with utility methods of enumerated constants of the TimeUnit class:
Notice the pleaseStop() method in this example: it is designed to stop the clock thread in a controlled way.
The example is coded so that it can also be stopped by calling the interrupt() method it inherits from Thread.
The Thread class defines a stop() method, but it is deprecated.
Java provides a number of ways to run tasks asynchronously or to schedule them for future execution without having to explicitly create Thread objects.
Here is some code that behaves much like the Clock class shown earlier:
An Executor is an object that can execute a Runnable object.
A user of an Executor often does not need to be aware of just how the Executor accomplishes this: it just needs to know that the Runnable will, at some point, run.
Executor implementations can be created to use a number of different threading strategies, as the following code makes clear.
Note that this example also demonstrates the use of a BlockingQueue.
These sample implementations help demonstrate how an Executor works and how it separates the notion of executing a task from the scheduling policy and threading details of the implementation.
This class is typically used via one of the static factory methods in the Executors class:
In addition to these convenient factory methods, you can also explicitly create a ThreadPoolExecutor if you want to specify a minimum and maximum size for the thread pool or want to specify the queue type (bounded, unbounded, prioritysorted, or synchronized, for example) to use for tasks that cannot immediately be run by a thread.
If you’ve looked at the signature for ThreadPoolExecutor or for the Executors factory methods cited above, you’ll see that it is an ExecutorService.
The ExecutorService interface extends Executor and adds the ability to execute Callable objects.
Instead of encapsulating arbitrary code in a run() method, however, a Callable puts that code in a call() method.
Because call() returns a result, the Callable interface takes the result type as a parameter.
You can invoke the call( ) method of any Callable object directly, of course, but to execute it using an ExecutorService, you pass it to the submit() method.
Because ExecutorService implementations typically run tasks asynchronously, the submit() method cannot simply return the result of the call( ) method.
A Future is simply the promise of a result sometime in the future.
It is parameterized with the type of the result, as shown in this code snippet:
Once you have a Future object, what can you do with it? You can call isDone() to see if the Callable has finished running.
You can call cancel() to cancel execution of the Callable and can call isCancelled() to see if the Callable was canceled before it completed.
But most of the time, you simply call get( ) to get the result of the call( ) method.
Here is code you might use with the Future objects shown above:
Recall that Callable.call( ) can throw any kind of exception.
If this happens, the Future wraps that exception in an ExecutionException and throws it from get()
Note that the Future.isDone() method considers a Callable to be “done,” even if the call( ) method terminated abnormally with an exception.
It allows you to schedule a Runnable or Callable to be executed once after a specified time delay or to schedule a Runnable for repeated execution.
In each case, the result of scheduling a task for future execution is a ScheduledFuture object.
This is simply a Future that also implements the Delay interface and provides a getDelay( ) method that can be used to query the remaining time before execution of the task.
When using multiple threads, you must be very careful if you allow more than one thread to access the same data structure.
Consider what would happen if one thread was trying to loop through the elements of a List while another thread was sorting those elements.
Preventing this kind of unwanted concurrency is one of the central problems of multithreaded computing.
The basic technique for preventing two threads from accessing the same object at the same time is to require a thread to obtain a lock on the object before the thread can modify it.
While any one thread holds the lock, another thread that requests the lock has to wait until the first thread is done and releases the lock.
Every Java object has the fundamental ability to provide such a locking capability.
The easiest way to keep objects threadsafe is to declare all sensitive methods synchronized.
A thread must obtain a lock on an object before it can execute any of its synchronized methods, which means that no other thread can execute any other synchronized method at the same time.
If a static method is declared synchronized, the thread must obtain a lock on the class, and this works in the same manner.
To do finer-grained locking, you can specify synchronized blocks of code that hold a lock on a specified object for a short time:
Note that when you use the synchronized modifier or statement, the lock you acquire is block-scoped, and is automatically released when the thread exits the method or block.
Lock objects are not automatically block-scoped and you must be careful to use try/finally constructs to ensure that locks are always released.
On the other hand, Lock enables algorithms that are simply not possible with block-scoped locks, such as the following “hand-over-hand” linked list traversal:
When you are using locking to prevent threads from accessing the same data at the same time, you must be careful to avoid deadlock, which occurs when two threads end up waiting for each other to release a lock they need.
Since neither can proceed, neither one can release the lock it holds, and they both stop running.
Whether or not a deadlock actually occurs may vary from system to system and from execution to execution.
It is common in multithreaded programming to require one thread to wait for another thread to take some action.
The Java platform provides a number of ways to coordinate threads, including methods built into the Object and Thread classes, as well as “synchronizer” utility classes introduced in Java 5.0
Sometimes a thread needs to stop running and wait until some kind of event occurs, at which point it is told to continue running.
This is done with the wait() and notify( ) methods.
These aren’t methods of the Thread class, however; they are methods of Object.
Just as every Java object has a lock associated with it, every object can maintain a list of waiting threads.
When a thread calls the wait() method of an object, any locks the thread holds are temporarily released, and the thread is added to the list of waiting threads for that object and stops running.
When another thread calls the notifyAll( ) method of the same object, the object wakes up the waiting threads and allows them to continue running:
Java 5.0 provides an alternative to the wait() and notifyAll( ) methods of Object.
Condition objects are always associated with Lock objects and are used in much the same way as the locking and waiting capability built into each Java object.
The primary benefit is that it is possible to have more than one Condition for each Lock, something that is not possible with Object-based locking and waiting.
Sometimes one thread needs to stop and wait for another thread to complete.
List list;  // A long list of objects to be sorted; initialized elsewhere.
Semaphore The Semaphore class models semaphores, a traditional concurrent programming construct.
Conceptually, a semaphore represents one or more “permits.” A thread that needs a permit calls acquire( ) and then calls release() when done with it.
CountDownLatch A latch is conceptually any variable or concurrency construct that has two possible states and transitions from its initial state to its final state only once.
Once the transition occurs, it remains in that final state forever.
CountDownLatch is a concurrency utility that can exist in two states, closed and open.
In its initial closed state, any threads that call the await( ) method block and cannot proceed until it transitions to its latched open state.
Once this transition occurs, all waiting threads proceed, and any threads that call await() in the future will not block at all.
The transition from closed to open occurs when a specified number of calls to countDown() have occurred.
Exchanger An Exchanger is a utility that allows two threads to rendezvous and exchange values.
The first thread to call the exchange( ) method blocks until a second thread calls the same method.
When this happens, the argument passed to the exchange() method by the first thread becomes the return value of the method for the second thread and vice-versa.
When the two exchange() invocations return, both threads are free to continue running concurrently.
Exchanger is a generic type and uses its type parameter to specify the type of values to be exchanged.
CyclicBarrier A CyclicBarrier is a utility that enables a group of N threads to wait for each other to reach a synchronization point.
The number of threads is specified when the CyclicBarrier is first created.
Threads call the await( ) method to block until the last thread calls await( ), at which point all threads resume again.
Unlike a CountDownLatch, a CyclicBarrier resets its count and is ready for immediate reuse.
CyclicBarrier is useful in parallel algorithms in which a computation is decomposed into parts, and each part is handled by a separate thread.
In such algorithms, the threads must typically rendezvous so that their partial solutions can be merged into a complete solution.
To facilitate this, the CyclicBarrier constructor allows you to specify a Runnable object to be executed by the last thread that calls await( ) before any of the other threads are woken up and allowed to resume.
This Runnable can provide the coordination required to assemble a solution from the threads’ computations or to assign a new computation to each of the threads.
This is necessary because the interrupt() method allows one thread to interrupt the execution of another.
The response that is usually preferred is for an interrupted thread to stop running.
If the interrupt( ) method is called on a thread that is not blocked, the thread continues running, but its “interrupt status” is set to indicate that an interrupt has been requested.
One thread can test the interrupt status of another thread with the instance method isInterrupted( ), which queries the status but does not clear it.
One of the most common times that threads block is while doing input/output; a thread often has to pause and wait for data to become available from the filesystem or from the network.
The java.io, java.net, and java.nio APIs for performing I/O operations are discussed later in this chapter.
Unfortunately, the interrupt() method does not wake up a thread blocked in an I/O method of the java.io package.
This is one of the shortcomings of java.io that is cured by the New I/O API in java.nio.
No exception is thrown in this case; the interrupted thread simply wakes up, and the select() call returns.
As noted in “The Queue and BlockingQueue Interfaces” earlier in this chapter, a queue is a collection in which elements are inserted at the “tail” and removed at the “head.” The Queue interface and various implementations were added to java.util as part of Java 5.0
The use of blocking queues is a common pattern in multithreaded programming: one thread produces objects and places them on a queue for consumption by another thread which removes them from the queue.
ArrayBlockingQueue This implementation is based on an array, and, like all arrays, has a fixed capacity established when it is created.
At the cost of reduced throughput, this queue can operate in a “fair” mode in which threads blocking to put() or take( ) an element are served in the order in which they arrived.
It may have a maximum size specified, but, by default, it is essentially unbounded.
Instead, it orders its elements based on a specified Comparator object, or based on their natural ordering if they are Comparable objects and no Comparator is specified.
The element returned by take() is the smallest element according to the Comparator or Comparable ordering.
Delayed is Comparable and orders elements by how long they are delayed.
But DelayQueue is more than just an unbounded queue that sorts its elements.
It also restricts take( ) and related methods so that elements cannot be removed from the queue until their delay has elapsed.
SynchronousQueue This class implements the degenerate case of a BlockingQueue with a capacity of zero.
A call to put() blocks until some other thread calls take( ), and a call to take( ) blocks until some other thread calls put()
An atomic operation is one that is indivisible: no other thread can observe an atomic variable in the middle of an atomic operation on it.
These utility classes define get() and set( ) accessor methods that have the properties of volatile fields but also define compound operations such as compare-and-set and get-and-increment that behave atomically.
The code below demonstrates the use of AtomicInteger and contrasts it with the use of a traditional synchronized method:
Files and Directories The java.io.File class represents a file or a directory and defines a number of important methods for manipulating files and directories.
The File class gained some important additional functionality as of Java 1.2:
The java.io package also defines a RandomAccessFile class that allows you to read binary data from arbitrary locations in a file.
Input/Output with java.io The java.io package defines a large number of classes for reading and writing streaming, or sequential, data.
The InputStream and OutputStream classes are for reading and writing streams of bytes while the Reader and Writer classes are for reading and writing streams of characters.
Streams can be nested, meaning you might read characters from a FilterReader object that reads and processes characters from an underlying Reader stream.
This underlying Reader stream might read bytes from an InputStream and convert them to characters.
You can perform a number of common operations with streams.
One is to read lines of input the user types at the console:
Reading lines of text from a file is a similar operation.
The following code reads an entire text file and quits when it reaches the end:
You can print text to any output stream using similar techniques.
The following code shows how to output text to a file:
The following lines of code treat a file as a stream of bytes and read the bytes into a large array:
Various other packages of the Java platform define specialized stream classes that operate on streaming data in some useful way.
The following code shows how to use stream classes from java.util.zip to compute a checksum of data and then compress the data while writing it to a file:
The java.util.zip package also contains a ZipFile class that gives you random access to the entries of a ZIP archive and allows you to read those entries through a stream:
So far, we’ve used a variety of stream classes to manipulate streaming data, but the data itself ultimately comes from a file or is written to the console.
The java.io package defines other stream classes that can read data from and write data to arrays of bytes or strings of text:
PipedInputStream and PipedOutputStream and their character-based counterparts, PipedReader and PipedWriter, are another interesting set of streams defined by java.io.
These streams are used in pairs by two threads that want to communicate.
One thread writes bytes to a PipedOutputStream or characters to a PipedWriter, and another thread reads bytes or characters from the corresponding PipedInputStream or PipedReader:
Networking with java.net The java.net package defines a number of classes that make writing networked applications surprisingly easy.
The easiest networking class to use is URL, which represents a uniform resource locator.
Different Java implementations may support different sets of URL protocols, but, at a minimum, you can rely on support for the http://, ftp://, and file:// protocols.
As of Java 1.4, secure HTTP is also supported with the https:// protocol.
Here are some ways you can use the URL class:
Sometimes you need more control over your networked application than is possible with the URL class.
In this case, you can use a Socket to communicate directly with a server.
In Java 1.4 and later, you can use https:// with the URL class as previously shown to securely download documents from web servers that support SSL.
Like all Java security APIs, JSSE is highly configurable and gives low-level control over all details of setting up and communicating over an SSL socket.
The following program is a variant on the preceding code that uses HTTPS instead of HTTP to securely transfer the contents of the requested URL:
Use the factory to create a secure socket connected to the // HTTPS port of the specified web server.
A client application uses a Socket to communicate with a server.
The server does the same thing: it uses a Socket object to communicate with each of its clients.
However, the server has an additional task in that it must be able to recognize and accept client connection requests.
The following code shows how you might use a ServerSocket.
The code implements a simple HTTP server that responds to all requests by sending back (or mirroring) the exact contents of the HTTP request.
A dummy server like this is useful when debugging HTTP clients:
This server code could be modified using JSSE to support SSL connections.
Making a server secure is more complex than making a client secure, however, because a server must have a certificate it can present to the client.
Both URL and Socket perform networking on top of a stream-based network connection.
Setting up and maintaining a stream across a network takes work at the network level, however.
Sometimes you need a low-level way to speed a packet of data across a network, but you don’t care about maintaining a stream.
If, in addition, you don’t need a guarantee that your data will get there or that the packets of data will arrive in the order you sent them, you may be interested in the DatagramSocket and DatagramPacket classes:
In Java 5.0 the InetAddress class has an isReachable( ) method that attempts to determine whether the host is reachable.
The following code uses it in a naive Java implementation of the Unix ping utility:
I/O and Networking with java.nio Java 1.4 introduced an entirely new API for high-performance, nonblocking I/O and networking.
This package also contains important classes used for nonblocking I/O.
The sections that follow contain examples of using all three of these packages as well as examples of specific I/O tasks with the New I/O API.
The java.nio package includes an abstract Buffer class, which defines generic operations on buffers.
This package also defines type-specific subclasses such as ByteBuffer, CharBuffer, and IntBuffer.
See Buffer and ByteBuffer in the reference section for details on these classes and their various methods.
The following code illustrates typical sequences of buffer operations on a ByteBuffer.
You may notice that many buffer methods return the object on which they operate.
This is done so that method calls can be “chained” in code, as follows:
Many methods throughout java.nio and its subpackages return the current object to enable this kind of method chaining.
Note that the use of this kind of chaining is a stylistic choice (which I have avoided in this chapter) and does not have any significant impact on efficiency.
CharBuffer objects can be created by wrapping a string and can also be converted to strings.
Bytes in a ByteBuffer are commonly converted to characters in a CharBuffer and vice versa.
Buffers are not all that useful on their own—there isn’t much point in storing bytes into a buffer only to read them out again.
Instead, buffers are typically used with channels: your program stores bytes into a buffer, then passes the buffer to a channel, which reads the bytes out of the buffer and writes them to a file, network socket, or some other destination.
Or, in the reverse, your program passes a buffer to a channel, which reads bytes from a file, socket, or other source and stores those bytes into the buffer, where they can then be retrieved by your program.
We’ll see examples of these concrete classes later in this chapter.
ByteChannel simply extends the readable and writable interfaces without adding any new methods.
It is a useful shorthand for channels that support both reading and writing.
The gathering and scattering write( ) and read() methods can be useful when working with network protocols that use fixed-size headers that you want to store in a buffer separate from the rest of the transferred data.
One confusing point to be aware of is that a channel read operation involves writing (or putting) bytes into a buffer, and a channel write operation involves reading (or getting) bytes from a buffer.
Thus, when I say that the flip( ) method prepares a buffer for reading, I mean that it prepares a buffer for use in a channel write( ) operation! The reverse is true for the buffer’s compact() method.
Charset and its associated classes, CharsetEncoder and CharsetDecoder, define methods for encoding strings of characters into sequences of bytes and decoding sequences of bytes into strings of characters.
Since these classes are part of the New I/O API, they use the ByteBuffer and CharBuffer classes:
This 8-bit charset is suitable for most Western European languages, including English.
Programmers who work only with English may also use the 7-bit US-ASCII charset.
The Charset class does not do encoding and decoding itself, and the previous convenience routines create CharsetEncoder and CharsetDecoder classes internally.
If you plan to encode or decode multiple times, it is more efficient to create these objects yourself:
For maximum efficiency, you can call lower-level methods to do the encoding and decoding into an existing buffer:
For more complex charsets, such as the UTF-8 encoding of Unicode or the EUC-JP charset.
When this is the case, there is no guarantee that all bytes in a buffer can be decoded at once (the end of the buffer may contain a partial character)
Also, since a single character may encode to more than one byte, it can be tricky to know how many bytes a given string will encode into.
The following code shows a loop you can use to decode bytes in a more general way:
Obtain a FileChannel object by using the java.io package to create a FileInputStream, a FileOutputStream, or a RandomAccessFile and then call the getChannel() method (added in Java 1.4) of that object.
As an example, you can use two FileChannel objects to copy a file:
FileChannel has special transferTo( ) and transferFrom() methods that make it particularly easy (and on many operating systems, particularly efficient) to transfer a specified number of bytes from a FileChannel to some other specified channel, or from some other channel to a FileChannel.
These methods allow us to simplify the preceding file-copying code to the following:
This code could be equally well-written using transferFrom( ) instead of transferTo() (note that these two methods expect their arguments in different orders):
FileChannel has other capabilities that are not shared by other channel classes.
One of the most important is the ability to “memory map” a file or a portion of a file, i.e., to obtain a MappedByteBuffer (a subclass of ByteBuffer) that represents the contents of the file and allows you to read (and optionally write) file contents simply by reading from and writing to the buffer.
Memory mapping a file is a somewhat expensive operation, so this technique is usually efficient only when you are working with a large file to which you need repeated access.
Memory mapping offers you yet another way to perform the same file-copy operation shown previously:
The channel API is low-level and provides methods for reading bytes only.
All of the previous examples have treated files as binary files.
It is possible to use the CharsetEncoder and CharsetDecoder classes introduced earlier to convert between bytes and characters, but when you want to work with text files, the Reader and Writer classes of the java.io package are usually much easier to use than CharBuffer.
Fortunately, the Channels class defines convenience methods that bridge between the old and new APIs.
Here is code that wraps a Reader and a Writer object around input and output channels, reads lines of Latin-1 text from.
Unlike the FileInputStream and FileOutputStream classes, the FileChannel class allows random access to the contents of the file.
The zero-argument position() method returns the file pointer (the position of the next byte to be read), and the one-argument position( ) method allows you to set this pointer to any value you want.
This allows you to skip around in a file in the way that the java.io.
The final feature of FileChannel that we’ll consider here is its ability to lock a file or a portion of a file against all concurrent access (an exclusive lock) or against concurrent writes (a shared lock)
Note that some operating systems strictly enforce all locks while others provide only an advisory locking facility that requires programs to cooperate and to attempt to acquire a lock before reading or writing portions of a shared file.
In the previous random-access example, suppose we wanted to ensure that no other program was modifying the record data while we read it.
We could acquire a shared lock on that portion of the file with the following code:
The New I/O API includes networking capabilities as well as file-access capabilities.
To communicate over the network, you can use the SocketChannel class.
Create a SocketChannel with the static open() method, then read and write bytes from and to it as you would with any other channel object.
The following code uses SocketChannel to send an HTTP request to a web server and saves the server’s response (including all of the HTTP headers) to a file.
These classes were also introduced as part of the New I/O API.
Another way to create a SocketChannel is with the no-argument version of open(), which creates an unconnected channel.
This allows you to call the socket() method to obtain the underlying socket, configure the socket as desired, and connect to the desired host with the connect method.
DatagramChannel is not demonstrated here, but you can read about it in the reference section.
One of the most powerful features of the New I/O API is that channels such as SocketChannel and DatagramChannel can be used in nonblocking mode.
The java.net package defines a Socket class for communication between a client and a server and defines a ServerSocket class used by the server to listen for and accept connections from clients.
Instead of read() and write() methods, it has an accept() method for accepting client connections and obtaining a SocketChannel through which it communicates with the client.
Here is the code for a simple, single-threaded server that listens for connections on port 8000 and reports the current time to any client that connects:
Because it does not maintain a connection with any client, it never needs to communicate with more than one at a time, and there is never more than one SocketChannel in use.
More realistic servers must be able to communicate with more than one client at a time.
The java.io and java.net APIs allow only blocking I/O, so servers written using these APIs must use a separate thread for each client.
For large-scale servers with many clients, this approach does not scale well.
To solve this problem, the New I/O API allows most channels (but not FileChannel) to be used in nonblocking mode and allows a single thread to manage all pending connections.
This is done with a Selector object, which keeps track of a set of registered channels and can block until one or more of those channels is ready for I/O, as the following code illustrates.
If you are here, there should be data to read from // the channel, but double-check.
It is also useful in clients that have more than one network connection pending at the same time.
For example, consider a web browser downloading a web page and the images referenced by that page at the same time.
One other interesting use of nonblocking I/O is to perform nonblocking socket connection operations.
Later, you do a select() call to block until the connection has been established, if it hasn’t been already.
Now go do other stuff while the connection is set up // For example, you can create a GUI here.
Now block if necessary until the SocketChannel is ready to connect.
Since you've registered only one channel with this selector, you // don't need to examine the key set; you know which channel is ready.
The structure and content of the document are fully described by the method calls.
This is a streaming API that does not build any permanent representation of the document.
It is up to the ContentHandler implementation to store any state or perform any actions that are appropriate.
A DOM parser reads an XML document and converts it into a tree of nodes that represent the full content of the document.
Once the tree representation of the document is created, a program can examine and manipulate it however it wants.
Implementations are required to support the W3C XML Schema standard and may also support other schema types as well.
Examples using each of these packages are presented in the following sections.
The first step in parsing an XML document with SAX is to obtain a SAX parser.
If you have a SAX parser implementation of your own, you can simply instantiate the appropriate parser class.
Once you have obtained one, as shown in the previous code, you can parse a document by simply calling one of the various parse() methods.
The DefaultHandler class provides an empty implementation of all the methods of the ContentHandler, ErrorHandler, DTDHandler, and EntityResolver interfaces.
These are all the methods that the SAX parser can call while parsing an XML document.
By subclassing DefaultHandler and defining the methods you care about, you can perform whatever actions are necessary in response to the method calls generated by the parser.
The following code shows a method that uses SAX to parse an XML file and determine the number of XML elements that appear in a document as.
While SAX is an efficient way to scan an XML document, it is not well-suited for programs that want to modify documents.
The conversion of the complete XML document to tree form allows random access to the entire document but can consume substantial amounts of memory.
In the DOM API, each node in the document tree implements the Node interface and a type-specific subinterface.
The most common types of node in a DOM document are Element and Text nodes.
When the parser is done parsing the document, your program can examine and manipulate that tree using the various methods of Node and its subinterfaces.
The following code uses JAXP to obtain a DOM parser (which, in JAXP parlance, is called a DocumentBuilder)
It then parses an XML file and builds a document tree from it.
A Transformer can transform a document from its Source representation into a new Result representation and optionally apply an XSLT transformation to the document content in the process.
Three subpackages define concrete implementations of the Source and Result interfaces, which allow documents to be transformed among three representations:
The following code shows one use of these packages to transform the representation of a document from a DOM Document tree into a stream of XML text.
An interesting feature of this code is that it does not create the Document tree by parsing a file; instead, it builds it up from scratch.
A tutorial on XSLT stylesheets is beyond the scope of this book, but the following code (which contains only six key lines) shows how you can apply such a stylesheet (which is an XML document itself) to another XML document and write the resulting document to a stream:
All implementations must support W3C XML Schema and are allowed to support other schema types, such as RELAX NG.
To use this package, begin with a SchemaFactory instance—a parser for a specific type of schema.
Use this parser to parse a schema file into a Schema object.
Obtain a Validator from the Schema, and then use the Validator to validate your XML document.
The document is specified as a SAXSource or DOMSource object.
If the document is valid, the validate( ) method of the Validator object returns normally.
If it is not valid, validate( ) throws a SAXException.
XPath is a language for referring to specific nodes in an XML document.
A full description of the XPath language is beyond the scope of this book.
You can obtain a Class object in Java in several ways:
Obtain a Class object for primitive types with various predefined constants c = Void.TYPE;          // The special "no-return-value" type c = Byte.TYPE;          // Class object that represents a byte c = Integer.TYPE;       // Class object that represents an int c = Double.TYPE;        // etc; see also Short, Character, Long, Float.
Once you have a Class object, you can perform some interesting reflective operations with it:
Class also provides a simple mechanism for dynamic class loading in Java.
The preceding code works only if the class to be loaded is in the class path.
If this is not the case, you can create a custom ClassLoader object to load a class from a path (or URL) you specify yourself:
Proxy is a powerful but infrequently used class that allows you to dynamically create a new class or instance that implements a specified interface or set of interfaces.
It also dispatches invocations of the interface methods to an InvocationHandler object.
Object Persistence The Java platform provides two mechanisms for object persistence: the ability to save object state so that the object can later be recreated.
Both mechanisms involve serialization; the second is aimed particularly at JavaBeans.
One of the most important features of the java.io package is the ability to serialize objects: to convert an object into a stream of bytes that can later be deserialized back into a copy of the original object.
The following code shows how to use serialization to save an object to a file and later read it back:
Object o;  // The object we are serializing; it must implement Serializable File f;    // The file we are saving it to.
The previous example serializes to a file, but remember, you can write serialized objects to any type of stream.
Thus, you can write an object to a byte array, then read it back from the byte array, creating a deep copy of the object.
You can write the object’s bytes to a compression stream or even write the bytes to a stream connected across a network to another program!
Java 1.4 introduced a serialization mechanism intended for use with JavaBeans components.
Since it is based on the public API rather than on the internal state, the JavaBeans persistence mechanism allows interoperability between different implementations of the same API, handles version skew more robustly, and is suitable for longer-term storage of serialized objects.
These classes write to and read from specified streams, but they are not stream classes themselves.
Here is the corresponding code to decode the bean from its serialized form:
These classes allow Java programs to run untrusted code in a restricted environment from which it can do no harm.
While these are important classes, you rarely need to use them.
The more interesting classes are the ones used for message digests and digital signatures; they are demonstrated in the sections that follow.
A message digest is a value, also known as cryptographic checksum or secure hash, that is computed over a sequence of bytes.
The length of the digest is typically much smaller than the length of the data for which it is computed, but any change, no matter how small, in the input bytes produces a change in the digest.
When transmitting data (a message), you can transmit a message digest along with it.
The recipient of the message can then recompute the message digest on the received data and, by comparing the computed digest to the received digest, determine whether the message or the digest was corrupted or tampered with during transmission.
We saw a way to compute a message digest earlier in the chapter when we discussed streams.
A similar technique can be used to compute a message digest for nonstreaming binary data:
A digital signature combines a message-digest algorithm with public-key cryptography.
The sender of a message, Alice, can compute a digest for a message and then encrypt that digest with her private key.
She then sends the message and the encrypted digest to a recipient, Bob.
Bob knows Alice’s public key (it is public, after all), so he can use it to decrypt the digest and verify that the message has not been tampered with.
In performing this verification, Bob also learns that the digest was encrypted with Alice’s private key since he was able to decrypt the digest successfully using Alice’s public key.
As Alice is the only one who knows her private key, the message must have come from Alice.
A digital signature is called such because, like a pen-and-paper signature, it serves to authenticate the origin of a document or message.
Unlike a pen-and-paper signature, however, a digital signature is very difficult, if not impossible, to forge, and it cannot simply be cut and pasted onto another document.
Assuming that a keystore exists on your system (see the keytool documentation in Chapter 8), you can get one with code like the following:
String signername;  // Who created the signature; initialized elsewhere KeyStore keystore;  // Where certificates stored; initialize as shown earlier.
The SignedObject can then be serialized and transmitted to a recipient, who can deserialize it and use the verify( ) method to verify the signature:
The SignedObject encapsulates the object o; it can now be serialized // and transmitted to a recipient.
Cryptography The java.security package includes cryptography-based classes, but it does not contain classes for actual encryption and decryption.
This package supports symmetric-key cryptography, in which the same key is used for both encryption and decryption and must be known by both the sender and the receiver of encrypted data.
The SecretKey interface represents an encryption key; the first step of any cryptographic operation is to obtain an appropriate SecretKey.
Unfortunately, the keytool program supplied with the JDK cannot generate and store secret keys, so a program must handle these tasks itself.
Here is some code that shows various ways to work with SecretKey objects:
Once you have obtained an appropriate SecretKey object, the central class for encryption and decryption is Cipher.
SecretKey key;     // Obtain a SecretKey as shown earlier byte[] plaintext;  // The data to encrypt; initialized elsewhere.
The Cipher class can also be used with CipherInputStream or CipherOutputStream to encrypt or decrypt while reading or writing streaming data:
This class serializes a specified object and encrypts the resulting stream of bytes.
The SealedObject can then be serialized itself and transmitted to a recipient.
The recipient can retrieve the original object only if she knows the required SecretKey:
Miscellaneous Platform Features The following sections detail important but miscellaneous features of the Java platform, including properties, preferences, processes, and management and instrumentation.
A Properties object maintains a mapping between string keys and string values and defines methods that allow the mappings to be written to and read from a simple text file or (in Java 5.0) an XML file.
This makes the Properties class ideal for configuration and user preference files.
Java 1.4 introduced the Preferences API, which is specifically tailored for working with user and systemwide preferences and is more useful than Properties for this purpose.
This means that the preference names you use must be unique within the package.
Once you have a Preferences object, use the get( ) method to query the string value of a named preference, or use other type-specific methods such as getInt( ), getBoolean(), and getByteArray()
Note that to query preference values, a default value must be passed for all methods.
This default value is returned if no preference with the specified name has been registered or if the file or database that holds the preference data cannot be accessed.
In addition to the get( ) methods for querying preference values, there are corresponding put() methods for setting the values of named preferences:
A Preferences object can export the names and values of its preferences as an XML file and can read preferences from such an XML file.
Preferences objects exist in a hierarchy that typically corresponds to the hierarchy of package names.
Methods for navigating this hierarchy exist but are not typically used by ordinary applications.
Earlier in the chapter, we saw how easy it is to create and manipulate multiple threads of execution running within the same Java interpreter.
A Java program can communicate with an external process using streams in the same way that it might communicate with a server running on some other computer on the network.
Using a Process is always platform-dependent and is rarely portable, but it is sometimes a useful thing to do:
ProcessBuilder allows control of environment variables through a Map and makes it simple to set the working directory.
It also has an option to automatically redirect the standard error stream of the processes it launches to the standard output stream, which makes it much easier to read all output of a Process.
Java 5.0 includes the powerful JMX API for remote monitoring and management of running applications.
The full javax.management API is beyond the scope of this book.
Class redefinition is beyond the scope of this chapter, but the following code uses the new instrumentation and management features of Java 5.0 to determine resource usages of a Java program.
To monitor the resource usage of a Java program with this agent, you first must compile the class normally.
You then store the generated class files in a JAR file with a manifest that specifies the class that contains the premain() method.
Finally, to use the agent, specify the JAR file and the agent arguments with the -javaagent flag to the Java interpreter:
Java programs can dynamically load Java classes from a variety of sources, including untrusted sources, such as web sites reached across an insecure network.
The ability to create and work with such mobile code is one of the great strengths and features of Java.
To make it work successfully, however, Java puts great emphasis on a security architecture that allows untrusted code to run safely, without fear of damage to the host system.
The need for a security system in Java is most acutely demonstrated by applets—miniature Java applications designed to be embedded in web pages.* When a user visits a web page (with a Java-enabled web browser) that contains an applet, the web browser downloads the Java class files that define that applet and runs them.
In the absence of a security system, an applet could wreak havoc on the user’s system by deleting files, installing a virus, stealing confidential information, and so on.
Somewhat more subtly, an applet could take advantage of the user’s system to forge email, generate spam, or launch hacking attempts on other systems.
Java’s main line of defense against such malicious code is access control: untrusted code is simply not given access to certain sensitive portions of the core Java API.
For example, an untrusted applet is not typically allowed to read, write, or delete files on the host system or connect over the network to any computer other than the web server from which it was downloaded.
This chapter describes the Java access control architecture and a few other facets of the Java security system.
Applets are documented in Java Foundation Classes in a Nutshell (O’Reilly) and are not covered in this book.
Security Risks Java has been designed from the ground up with security in mind; this gives it a great advantage over many other existing systems and platforms.
Nevertheless, no system can guarantee 100% security, and Java is no exception.
The Java security architecture was designed by security experts and has been studied and probed by many other security experts.
The consensus is that the architecture itself is strong and robust, theoretically without any security holes (at least none that have been discovered yet)
The implementation of the security architecture is another matter, however, and there is a long history of security flaws being found and patched in particular implementations of Java.
Microsoft fixed the problem, and no longer distributes their VM with the latest versions of their web browser.
In all likelihood, security flaws will continue to be discovered (and patched) in Java VM implementations.
Despite this, Java remains perhaps the most secure platform currently available.
There have been few, if any, reported instances of malicious Java code exploiting security holes “in the wild.” For practical purposes, the Java platform appears to be adequately secure, especially when contrasted with some of the insecure and virus-ridden alternatives.
Java VM Security and Class File Verification The lowest level of the Java security architecture involves the design of the Java Virtual Machine and the byte codes it executes.
The Java VM does not allow any kind of direct access to individual memory addresses of the underlying system, which prevents Java code from interfering with the native hardware and operating system.
These intentional restrictions on the VM are reflected in the Java language itself, which does not support pointers or pointer arithmetic.
The language does not allow an integer to be cast to an object reference or vice versa, and there is no way whatsoever to obtain an object’s address in memory.
Without capabilities like these, malicious code simply cannot gain a foothold.
In addition to the secure design of the Virtual Machine instruction set, the VM goes through a process known as byte-code verification whenever it loads an untrusted class.
This process ensures that the byte codes of a class (and their operands) are all valid; that the code never underflows or overflows the VM stack; that local variables are not used before they are initialized; that field, method, and class access control modifiers are respected; and so on.
The verification step is designed to prevent the VM from executing byte codes that might crash it or put it into an undefined and untested state where it might be vulnerable to other attacks by malicious code.
Byte-code verification is a defense against malicious handcrafted Java byte codes and untrusted Java compilers that might output invalid byte codes.
Authentication and Cryptography The java.security package (and its subpackages) provides classes and interfaces for authentication.
As described in Chapter 5, this piece of the security architecture allows Java code to create and verify message digests and digital signatures.
These technologies can ensure that any data (such as a Java class file) is authentic: that it originates from the person who claims to have originated it and has not been accidentally or maliciously modified in transit.
The Java Cryptography Extension, or JCE, consists of the javax.crypto package and its subpackages.
These packages define classes for encryption and decryption of data.
This is an important security-related feature for many applications, but is not directly relevant to the basic problem of preventing untrusted code from damaging the host system, so it is not discussed in this chapter.
Access Control As we noted at the beginning of this chapter, the heart of the Java security architecture is access control: untrusted code simply must not be granted access to the sensitive parts of the Java API that would allow it to do malicious things.
Since then, the access control model has been relatively stable; it has not changed significantly since Java 1.2
In this first release of Java, all Java code installed locally on the system is trusted implicitly.
When system code is about to perform a restricted operation, such as reading a file from the local filesystem, it first calls an appropriate method (such as checkRead( )) of the currently installed SecurityManager object.
If untrusted code is running, the SecurityManager throws a SecurityException that prevents the restricted operation from taking place.
The most common user of the SecurityManager class is a Java-enabled web browser, which installs a SecurityManager object to allow applets to run without damaging the host system.
The precise details of the security policy are an implementation detail of the web browser, of course, but applets are typically restricted in the following ways:
It cannot query the length or modification date of a file or even check whether a given file exists.
Similarly, an applet cannot create, list, or delete a directory.
An applet cannot connect to or accept a connection from any computer other than the one it was downloaded from.
It cannot use any privileged ports (i.e., ports below and including port 1024)
An applet cannot perform system-level functions, such as loading a native library, spawning a new process, or exiting the Java interpreter.
An applet cannot manipulate any threads or thread groups, except for those it creates itself.
In Java 1.1 and later, applets cannot use the Java Reflection API to obtain information about the nonpublic members of classes, except for classes that were downloaded with the applet.
It cannot initiate a print job or access the system clipboard or event queue.
In addition, all windows created by an applet typically display a prominent visual indicator that they are “insecure” to prevent an applet from spoofing the appearance of some other application.
An applet cannot read certain system properties, notably the user.home and user.dir properties, that specify the user’s home directory and current working directory.
An applet cannot circumvent these security restrictions by registering a new SecurityManager object.
Suppose that an applet (or some other untrusted code running in the sandbox) attempts to read the contents of the file /etc/passwd by passing this filename to the FileInputStream() constructor.
The programmers who wrote the FileInputStream class were aware that the class provides access to a system resource (a file), so use of the class should therefore be subject to access control.
For this reason, they coded the FileInputStream( ) constructor to use the SecurityManager class.
Every time FileInputStream( ) is called, it checks to see if a SecurityManager object has been installed.
If so, the constructor calls the checkRead() method of that SecurityManager object, passing the filename (/etc/passwd, in this case) as the sole argument.
The checkRead() method has no return value; it either returns normally or throws a SecurityException.
If the method returns, the FileInputStream() constructor simply proceeds with whatever initialization is necessary and returns.
Otherwise, it allows the SecurityException to propagate to the caller.
When this happens, no FileInputStream object is created, and the applet does not gain access to the /etc/passwd file.
With these capabilities, Java classes can be digitally signed and verified.
Thus, web browsers and other Java installations can be configured to trust downloaded code that bears a valid digital signature of a trusted entity.
Such code is treated as if it were installed locally, so it is given full access to the Java APIs.
In this release, the javakey program manages keys and digitally signs JAR files of Java code.
Although Java 1.1 added the important ability to trust digitally signed code that would otherwise be untrusted, it sticks to the basic sandbox model: trusted code gets full access and untrusted code gets totally restricted access.
Java 1.2 introduced substantial access control features into the Java security architecture.
These features are implemented by classes in the java.security package.
The Policy class is one of the most important: it defines a Java security policy.
A Policy object maps CodeSource objects to associated sets of Permission objects.
A CodeSource object represents the source of a piece of Java code, which includes both the URL of the class file (and can be a local file) and a list of entities that have applied their digital signatures to the class file.
The Permission objects associated with a CodeSource in the Policy define the permissions that are granted to code from a given source.
Various Java APIs include subclasses of Permission that represent different types of permissions.
Under this access control model, the SecurityManager class continues to be the central class; access control requests are still made by invoking methods of a SecurityManager.
However, the default SecurityManager implementation delegates most of those requests to an AccessController class that makes access decisions based on the Permission and Policy architecture.
The Java 1.2 access control architecture has several important features:
Code from different sources can be given different sets of permissions.
In other words, the architecture supports fine-grained levels of trust.
Even locally installed code can be treated as untrusted or partially untrusted.
Under this architecture, only system classes and standard extensions run as fully trusted.
It is no longer necessary to define a custom subclass of SecurityManager to define a security policy.
The architecture is not limited to a fixed set of access control methods in the SecurityManager class.
Permission subclasses can be defined easily to govern access to system resources (which might be exposed, for example, by standard extensions that include native code)
Let’s return to the example of an applet that attempts to create a FileInputStream to read the file /etc/passwd.
What changed as of Java 1.2 is the default behavior of the checkRead( ) method.
Unless a program has replaced the default security manager with one of its own, the default implementation creates a FilePermission object to represent the access being requested.
It is the AccessController and its checkPermission( ) method that do the real work of access control as of Java 1.2
The method determines the CodeSource of each calling method and uses the current Policy object to determine the Permission objects associated with it.
With this information, the AccessController can determine whether read access to the /etc/passwd file should be allowed.
The Permission class represents both the permissions granted by a Policy and the permissions requested by a method like the FileInputStream() constructor.
When requesting a permission, Java typically uses a FilePermission (or other Permission subclass) with a very specific target, like “/etc/passwd”
When granting a permission, however, a Policy commonly uses a FilePermission object with a wildcard target, such as “/etc/*”, to represent many files.
One of the key features of a Permission subclass such as FilePermission is that it defines an implies() method that can determine whether permission to read “/etc/*” implies permission to read “/etc/passwd”
Security for Everyone Programmers, system administrators, and end users all have different security concerns and, thus, different roles to play in the Java security architecture.
System programmers are the people who define new Java APIs that allow access to sensitive system resources.
These programmers are typically working with native methods that have unprotected access to the system.
They need to use the Java access control architecture to prevent untrusted code from executing those native methods.
To do this, system programmers must carefully insert SecurityManager calls at appropriate places in their code.
A system programmer may choose to use an existing Permission subclass to govern access to the system resources exposed by her API, or she may decide to define a specialized subclass of Permission.
The system programmer carries a tremendous security burden: if she does not perform appropriate access control checks in her code, she compromises the security of the entire Java platform.
The details are complex and are beyond the scope of this book.
Fortunately, however, system programming that involves native methods is rare in Java; almost all of us are application programmers who can simply rely on the existing APIs.
Programmers who use the core Java APIs and standard extensions but do not define new extensions or write native methods can simply rely on the security efforts of the system programmers who created those APIs.
In other words, most of us Java programmers can simply use the Java APIs and need not worry about introducing security holes into the Java platform.
In fact, application programmers rarely have to use the access control architecture.
If you are writing Java code that may be run as untrusted code, you should be aware of the restrictions placed on untrusted code by typical security policies.
Keep in mind that some methods (such as methods that read or write files) can throw SecurityException objects, but don’t feel you must write your code to catch these exceptions.
Often, the appropriate response to a SecurityException is to allow it to propagate uncaught so that it terminates the application.
Sometimes, as an application programmer, you want to write an application (such as an applet viewer) that can load untrusted classes and run them subject to access control checks.
To do this in Java 1.2 and later, you must first install a security manager:
In Java 1.2 and later, system administrators are responsible for defining the default security policy for the computers at their site.
A system administrator can edit this text file by hand or use the policytool program from Sun to edit the file graphically.
While this default policy is adequate for many purposes, it may not be appropriate for all sites.
For example, at some organizations, it may be appropriate to grant extra permissions to code downloaded from a secure intranet.
In order to define effective security policies, a system administrator must understand the various Permission subclasses of the Java platform, the target and action names they support, and the security implications of granting any particular permission.
Most end users do not have to think about security at all: their Java programs should simply run in a secure way with no intervention from them.
Some sophisticated end users may want to define their own security policies, however.
An end user can do this by running policytool himself to define personal policy files that augment the system policy.
The default personal policy is stored in a file named .java.policy in the user’s home directory.
By default, Java loads this policy file and uses it to augment the system policy file.
In Java 1.2 and later, a user can specify an additional policy file to use when starting up the Java interpreter.
This line runs the class UntrustedApp after augmenting the default system and user policies with the policy specified in the file or URL policyfile.
To replace the system and user policies instead of augmenting them, use a double equals sign in the property specification:
Note, however, that specifying a policy file is useful only if there is a SecurityManager installed.
If a user doesn’t trust an application, he presumably doesn’t trust that application to voluntarily install its own security manager.
Permission Classes Table 6-1 lists some important Permission subclasses defined by the core Java platform and summarizes the permissions they represent.
See the reference section for more information on the individual classes.
Controls the ability of a program to modify the logging configuration.
This chapter explains a number of important and useful Java programming and documentation conventions.
Following them, however, will make your code easier to read and maintain, portable, and selfdocumenting.
Naming and Capitalization Conventions The following widely adopted naming conventions apply to packages, reference types, methods, fields, and constants in Java.
Because these conventions are almost universally followed and because they affect the public API of the classes you define, they should be followed carefully:
Packages of code used internally by applications distributed in self-contained JAR files are not publicly visible and need not follow this convention.
It is common in this case to use the application name as the package name or as a package prefix.
Reference types A type name should begin with a capital letter and be written in mixed case (e.g., String)
If a class name consists of more than one word, each word should begin with a capital letter (e.g., StringBuffer)
Since classes and enumerated types are designed to represent objects, you should choose class names that are nouns (e.g., Thread, Teapot, FormatConverter)
When an interface is used to provide additional information about the classes that implement it, it is common to choose an interface name that is an adjective (e.g., Runnable, Cloneable, Serializable)
When an interface works more like an abstract superclass, use a name that is a noun (e.g., Document, FileNameMap, Collection)
Methods A method name always begins with a lowercase letter.
If the name contains more than one word, every word after the first begins with a capital letter (e.g., insert( ), insertObject(), insertObjectAt( ))
Method names are typically chosen so that the first word is a verb.
Method names can be as long as is necessary to make their purpose clear, but choose succinct names where possible.
Fields and constants Nonconstant field names follow the same capitalization conventions as method names.
If a field is a static final constant, it should be written in uppercase.
If the name of a constant includes more than one word, the words should be separated with underscores (e.g., MAX_VALUE)
A field name should be chosen to best describe the purpose of the field or the value it holds.
The constants defined by enum types are also typically written in all capital letters.
Because other programming languages use lowercase or mixed case for enumerated values, however, this convention is not as strong as the convention for capital letters in the static final fields of classes and interfaces.
Parameters Method parameters follow the same capitalization conventions as nonconstant fields.
The names of method parameters appear in the documentation for a method, so you should choose names that make the purpose of the parameters as clear as possible.
Try to keep parameter names to a single word and use them consistently.
For example, if a WidgetProcessor class defines many methods that accept a Widget object as the first parameter, name this parameter widget or even w in each method.
Local variables Local variable names are an implementation detail and never visible outside your class.
Nevertheless, choosing good names makes your code easier to read, understand, and maintain.
Variables are typically named following the same conventions as methods and fields.
In addition to the conventions for specific types of names, there are conventions regarding the characters you should use in your names.
Java allows the $ character in any identifier, but, by convention, its use is reserved for synthetic names.
It is used by the Java compiler, for example, to make inner classes work.
Also, Java allows names to use any alphanumeric characters from the entire Unicode character set.
Portability Conventions and Pure Java Rules Sun’s motto, or core value proposition, for Java is “Write once, run anywhere.” Java makes it easy to write portable programs, but Java programs do not automatically run successfully on any Java platform.
Portability rules like those listed here were the focus of Sun’s now-defunct “100% Pure Java” certification program and branding campaign.
Native methods Portable Java code can use any methods in the core Java APIs, including methods implemented as native methods.
However, portable code must not define its own native methods.
By their very nature, native methods must be ported to each new platform, so they directly subvert the “Write once, run anywhere” promise of Java.
The Runtime.exec( ) method Calling the Runtime.exec( ) method to spawn a process and execute an external command on the native system is rarely allowed in portable code.
This is because the native OS command to be executed is never guaranteed to exist or behave the same way on all platforms.
The only time it is legal to use Runtime.exec( ) is when the user is allowed to specify the command to run, either by typing the command at runtime or by specifying the command in a configuration file or preferences dialog box.
The method was deprecated but has been reintroduced in Java 5.0
Undocumented classes Portable Java code must use only classes and interfaces that are a documented part of the Java platform.
Most Java implementations ship with additional undocumented public classes that are part of the implementation but not part of the Java platform specification.
Nothing prevents a program from using and relying on these undocumented classes, but doing so is not portable because the classes are not guaranteed to exist in all Java implementations or on all platforms.
The java.awt.peer package The interfaces in the java.awt.peer package are part of the Java platform but are documented for use by AWT implementors only.
For example, Microsoft distributed a version of the Java runtime system that.
Any program that depends on such extensions is obviously not portable to other platforms.
Microsoft’s proprietary extension of the Java platform resulted in legal action between Sun and Microsoft and ultimately caused Microsoft to discontinue ongoing support for Java.
If a class or method behaves differently than the specification says it should, a portable program cannot rely on this behavior, which may be different on different platforms, and ultimately may be fixed.
Portable code must not depend on any one specific behavior.
For example, the Java specification does not indicate whether threads of equal priority share the CPU or if one long-running thread can starve another thread at the same priority.
If an application assumes one behavior or the other, it may not run properly on all platforms.
Standard extensions Portable code can rely on standard extensions to the Java platform, but, if it does so, it should clearly specify which extensions it uses and exit cleanly with an appropriate error message when run on a system that does not have the extensions installed.
Complete programs Any portable Java program must be complete and self-contained: it must supply all the classes it uses, except core platform and standard extension classes.
Defining system classes Portable Java code never defines classes in any of the system or standard extension packages.
Doing so violates the protection boundaries of those packages and exposes package-visible implementation details.
Hardcoded filenames A portable program contains no hardcoded file or directory names.
This is because different platforms have significantly different filesystem organizations and use different directory separator characters.
If you need to work with a file or directory, have the user specify the filename, or at least the base directory beneath which the file can be found.
This specification can be done at runtime, in a configuration file, or as a command-line argument to the program.
When concatenating a file or directory name to a directory name, use the File( ) constructor or the File.separator constant.
Line separators Different systems use different characters or sequences of characters as line separators.
Instead, use the println() method of PrintStream or PrintWriter, which automatically terminates a line with the line separator appropriate for.
Java Documentation Comments Most ordinary comments within Java code explain the implementation details of that code.
By contrast, the Java language specification defines a special type of comment known as a doc comment that serves to document the API of your code.
A doc comment appears immediately before a type or member definition and contains documentation for that type or member.
The documentation can include simple HTML formatting tags and other special keywords that provide additional information.
Doc comments are ignored by the compiler, but they can be extracted and automatically turned into online HTML documentation by the javadoc program.
Here is an example class that contains appropriate doc comments:
The body of a doc comment should begin with a one-sentence summary of the type or member being documented.
This sentence may be displayed by itself as summary documentation, so it should be written to stand on its own.
The initial sentence may be followed by any number of other sentences and paragraphs that describe the class, interface, method, or field in full detail.
These tagged paragraphs provide specific information about the class, interface, method, or field that the javadoc program displays in a standard way.
The full set of doc-comment tags is listed in the next section.
Remember, however, that the material you write is embedded within a larger, more complex HTML document.
If you want to include an image in a doc comment, place the image file in a docfiles subdirectory of the source code directory.
Give the image the same name as the class, with an integer suffix.
For example, the second image that appears in the doc comment for a class named Circle can be included with this HTML tag:
Because the lines of a doc comment are embedded within a Java comment, any leading spaces and asterisks (*) are stripped from each line of the comment before processing.
Thus, you don’t need to worry about the asterisks appearing in the generated documentation or about the indentation of the comment affecting the indentation of code examples included within the comment with a <pre> tag.
These doc-comment tags allow you to encode specific information into your comments in a standardized way, and they allow javadoc to choose the appropriate output format for that information.
For example, the @param tag lets you specify the name and meaning of a single parameter for a method.
The following doc-comment tags are recognized by javadoc; a doc comment should typically use these tags in the order listed here:
This tag should be used for every class or interface definition but must not be used for individual methods and fields.
If a class has multiple authors, use multiple @author tags on adjacent lines.
List the authors in chronological order, with the original author first.
If the author is unknown, you can use “unascribed.” javadoc does not output authorship information unless the -author command-line argument is specified.
This tag should be included in every class and interface doc comment but cannot be used for individual methods and fields.
This tag is often used in conjunction with the automated version-numbering capabilities of a version control system, such as SCCS, RCS, or CVS.
The doc comment for a method or constructor must contain one @param tag for each parameter the method expects.
These tags should appear in the same order as the parameters specified by the method.
The tag can be used only in doc comments for methods and constructors.
You are encouraged to use phrases and sentence fragments where possible to keep the descriptions brief.
However, if a parameter requires detailed documentation, the description can wrap onto multiple lines and include as much text as necessary.
For readability in source-code form, consider using spaces to align the descriptions with each other.
This tag should appear in every doc comment for a method, unless the method returns void or is a constructor.
The description can be as long as necessary, but consider using a sentence fragment to keep it short.
A doc comment for a method or constructor should contain an @exception tag for every checked exception that appears in its throws clause.
The @exception tag can optionally be used to document unchecked exceptions (i.e., subclasses of RuntimeException) the method may throw, when these are exceptions that a user of the method may reasonably want to catch.
If a method can throw more than one exception, use multiple @exception tags on adjacent lines and list the exceptions in alphabetical order.
The description can be as short or as long as necessary to describe the significance of the exception.
This tag can be used only for method and constructor comments.
This tag can appear in any kind of doc comment.
The syntax for the reference is explained in “Cross-References in Doc Comments” later in this chapter.
This text should specify when the class or member was deprecated and, if possible, suggest a replacement class or member and include a link to it.
Although the Java compiler ignores all comments, it does take note of the @deprecated tag in doc comments.
When this tag appears, the compiler notes the deprecation in the class file it produces.
This allows it to issue warnings for other classes that rely on the deprecated feature.
This tag should be followed by a version number or other version specification.
If you write a class that you expect to be serialized, you should document its serialization format using @serial and the related tags listed below.
For classes that use the default serialization mechanism, this means all fields that are not declared transient, including fields declared private.
The description should be a brief description of the field and of its purpose within a serialized object.
Each tag specifies the name, type, and description for a particular field in the serialized state of the class.
An Externalizable class defines a writeExternal() method responsible for writing the complete state of an object to the serialization stream.
The @serialData tag should be used in the doc comments for these writeObject( ) and writeExternal() methods, and the description should document the serialization format used by the method.
In addition to the preceding tags, javadoc also supports several inline tags that may appear anywhere that HTML text appears in a doc comment.
Because these tags appear directly within the flow of HTML text, they require the use of curly braces as delimiters to separate the tagged text from the HTML text.
To inherit the entire doc comment, including your own text before and after it, use the tag like this:
If it begins with a quote character, it is taken to be the name of a book or some other printed resource and is displayed as is.
This form of the @see tag can insert links to other online documents, such as a programmer’s guide or user’s manual.
If reference is not a quoted string or a hyperlink, it is expected to have the following form:
In this case, javadoc outputs the text specified by label and encodes it as a hyperlink to the specified feature.
If label is omitted (as it usually is), javadoc uses the name of the specified feature instead.
If the type is specified without its package name, it is resolved as described for typename.
This syntax is ambiguous if the method is overloaded or the class defines a field by the same name.
Use this concise form to refer to other methods in the same class.
This form works with overloaded methods because it lists the types of the method parameters explicitly.
If the type is specified without its package name, it is resolved as described for typename.
Documentation comments for classes, interfaces, methods, constructors, and fields appear in Java source code immediately before the definitions of the features they document.
Since a package is defined in a directory, not in a single file of source code, javadoc looks for the package documentation in a file named package.html in the directory that contains the source code for the classes of the package.
The package.html file should contain simple HTML documentation for the package.
In addition to defining a package.html file for each package, you can also provide high-level documentation for a group of packages by defining an overview.html file in the source tree for those packages.
When javadoc is run over that source tree, it uses overview.html as the highest level overview it displays.
JavaBeans Conventions JavaBeans is a framework for defining reusable modular software components.
The JavaBeans specification includes the following definition of a bean: “a reusable software component that can be manipulated visually in a builder tool.” As you can see, this is a rather loose definition; beans can take a variety of forms.
The most common use of beans is for graphical user interface components, such as components of the java.awt and javax.swing packages, which are documented in Java Foundation Classes in a Nutshell and Java Swing, both from O’Reilly.
Although all beans can be manipulated visually, this does not mean every bean has its own visual representation.
There are no limits on the simplicity or complexity of a JavaBeans component.
But even complex systems, such as an embeddable spreadsheet application, can function as individual beans.
The JavaBeans component model consists of the java.beans, the java.beans.
These conventions are not part of the JavaBeans API itself but are in many ways more important to bean developers than the API itself.
The conventions are sometimes referred to as design patterns; they specify such things as method names and signatures for property accessor methods defined by a bean.
If the class you are writing is not intended to be a bean, suitable for visual manipulation in a builder tool, you don’t need to follow these conventions.
The JavaBeans conventions are widely used and wellunderstood, however, and you can improve the usability and reusabilty of your code by following the relevant ones.
This is particularly true of the property accessor method naming conventions.
First, however, an overview of the JavaBeans model is in order.
Any object that conforms to certain basic rules can be a bean; there is no Bean class that all beans are required to subclass.
Many beans are GUI components, but it is also quite possible, and often useful, to write “invisible” beans that do not have an onscreen appearance.
A bean is characterized by the properties, events, and methods it exports.
It is these properties, events, and methods that an application designer manipulates in a beanbox tool.
A property is a piece of the bean’s internal state that can be programmatically set and/or queried, usually through a standard pair of get and set accessor methods.
A bean communicates with the application in which it is embedded as well as with other beans by generating events.
The JavaBeans API uses the same event model that AWT and Swing components use.
A bean defines an event if it provides add and remove methods for registering and deregistering listener objects for that event.
An application that wants to be notified when an event of that type occurs uses these methods to register an event listener object of the appropriate type.
When the event occurs, the bean notifies all registered listeners by passing an event object that describes the event to a method defined by the event listener interface.
A unicast event is a rare kind of event for which there can be only a single registered listener object.
The methods exported by a bean are simply any public methods defined by the bean, excluding those methods that get and set property values and register and remove event listeners.
In addition to the regular sort of properties described earlier, the JavaBeans API also supports several specialized property subtypes.
An indexed property is a property that has an array value, as well as getter and setter methods that access both individual elements of the array and the entire array.
A constrained property is one that can have any changes vetoed by any interested listener.
A bean class itself must adhere to the following conventions:
Class name There are no restrictions on the class name of a bean.
Beans are often AWT or Swing components, but there are no restrictions.
Instantiation A bean should provide a no-parameter constructor so bean manipulation tools can easily instantiate the bean.
A bean defines a property p of type T if it has accessor methods that follow these patterns (if T is boolean, a special form of getter method is allowed):
Exceptions Property accessor methods can throw any type of checked or unchecked exceptions.
An indexed property is a property of array type that provides accessor methods that get and set the entire array as well as methods that get and set individual elements of the array.
A bean defines an indexed property p of type T[ ] if it defines the following accessor methods:
Exceptions Indexed property accessor methods can throw any type of checked or unchecked exceptions.
Accessor methods The getter and setter methods for a bound property follow the same conventions as a regular property.
Listener registration A bean that defines one or more bound properties must define a pair of methods for the registration of listeners that are notified when any bound property value changes.
Named property listener registration A bean can optionally provide additional methods that allow event listeners to be registered for changes to a single bound property value.
These methods are passed the name of a property and have the following signatures:
Per-property listener registration A bean can optionally provide additional event listener registration methods that are specific to a single property.
For a property p, these methods have the following signatures:
Methods of this type allow a beanbox to distinguish a bound property from an unbound property.
A constrained property is one for which any changes can be vetoed by registered listeners.
Getter The getter method for a constrained property is the same as the getter method for a regular property.
For a property p of type T, the signature looks like this:
Listener registration A bean that defines one or more constrained properties must define a pair of methods for the registration of listeners that are notified when any.
Named property listener registration A bean can optionally provide additional methods that allow event listeners to be registered for changes to a single constrained property value.
These methods are passed the name of a property and have the following signatures:
Per-property listener registration A bean can optionally provide additional listener registration methods that are specific to a single constrained property.
For a property p, these methods have the following signatures:
If, on the other hand, the property change is not vetoed, the bean should update its internal state to reflect the change.
Listener methods The event listener interface can define any number of methods that take a single argument of type EEvent and return void.
Listener registration The bean must define a pair of methods for registering event listeners that want to be notified when an E event occurs.
Unicast events A unicast event allows only one listener object to be registered at a single time.
If E is a unicast event, the listener registration method should have this signature:
Sun’s implementation of Java includes a number of tools for Java developers.
Chief among these are the Java interpreter and the Java compiler, of course, but there are a number of others as well.
Notable omissions are the RMI and IDL tools that are specific to enterprise programming and which are documented in Java Enterprise in a Nutshell (O’Reilly)
The tools documented here are part of Sun’s development kit; they are implementation details and not part of the Java specification itself.
If you are using a Java development environment other than Sun’s JDK, you should consult your vendor’s tool documentation.
Some examples in this chapter use Unix conventions for file and path separators.
If Windows is your development platform, change forward slashes in filenames to backward slashes, and colons in path specifications to semicolons.
Any annotations it finds are passed to appropriate annotation processor factory objects, which can use the annotations to produce auxiliary source or resource files based on annotation content.
If a command-line argument begins with @, apt treats it as a file and reads options and source files from that specified file.
Aname=value Passes the name=value pair as an argument to annotation processors.
Description extcheck checks to see if the extension contained in the specified jarfile (or a newer version of that extension) has already been installed on the system.
Without the -verbose option, it does not print the results of its check.
Instead, it sets its exit code to 0 if the specified extension does not conflict with any installed extensions and can be safely installed.
It sets its exit code to a nonzero value if an extension with the same name is already installed and has a specification version number equal to or greater than the version of the specified file.
Lists the installed extensions as they are checked and displays the results of the check.
Description jarsigner adds a digital signature to the specified jarfile, or, if the -verify option is specified, it verifies the digital signature or signatures already attached to the JAR file.
The specified signer is a case-insensitive nickname or alias for the entity whose signature is to be used.
The specified signer name is used to look up the private key that generates the signature.
When you apply your digital signature to a JAR file, you are implicitly vouching for the contents of the archive.
You are offering your personal word that the JAR file contains only nonmalicious code, files that do not violate copyright laws, and so forth.
When you verify a digitally signed JAR file, you can determine who the signer or signers of the file are and (if the verification succeeds) that the contents of the JAR file have not been changed, corrupted, or tampered with since the signature or signatures were applied.
Verifying a digital signature is entirely different from deciding whether or not you trust the person or organization whose signature you verified.
Options jarsigner defines a number of options, many of which specify how a private key is to be found for the specified signer.
Most of these options are unnecessary when using the -verify option to verify a signed JAR file:
Jjavaoption Passes the specified javaoption directly to the Java interpreter.
If this option is not specified, jarsigner prompts you for the password.
This option specifies the filename or URL of the keystore in which the private and public key certificates of the specified signer are looked up.
The default is the file named .keystore in the user’s home directory (the value of the system property user.home)
This is also the default location of the keystore managed by keytool.
If you leave this option unspecified, the base filename is chosen based on the signer name.
If this option is not specified, jarsigner overwrites the jarfile specified on the command line.
If this option is omitted, jarsigner prompts you for the password.
The default is the system-default keystore type, which on most systems is the Java Keystore type, known as JKS.
If you have the Java Cryptography Extension installed, you may want to use a JCEKS keystore instead.
Description jar is a tool that can create and manipulate Java Archive (JAR) files.
A JAR file is a ZIP file that contains Java class files, auxiliary resource files required by those classes, and optional meta-information.
This meta-information includes a manifest file that lists the contents of the JAR archive and provides auxiliary information about each file.
The jar command can create JAR files, list the contents of JAR files, and extract files from a JAR archive.
In Java 1.2 and later, it can also add files to an existing archive or update the manifest file of an archive.
In Java 1.3 and later, jar can also add an index entry to a JAR file.
The syntax of the jar command is reminiscent of the Unix tar (tape archive) command.
Most options to jar are specified as a block of concatenated letters passed as a single argument rather than as individual command-line arguments.
The first letter of the first argument specifies what action jar is to perform; it is required.
The various file arguments depend on which letters are specified.
As in javac, any command-line argument that begins with @ is taken to be the name of a file that contains options or filenames.
Command options The first letter of the first option to jar specifies the basic operation jar is to perform.
A list of input files and/or directories must be specified as the final arguments to jar.
The newly created JAR file has a META-INF/ MANIFEST.MF file as its first entry.
This automatically created manifest lists the contents of the JAR file and contains a message digest for each file.
This i option must be followed by the name of the JAR file to be indexed.
Any files listed on the command line are added to the archive.
When used with the m option, this adds the specified manifest information to the JAR file.
The files and directories specified on the command line are extracted and created in the current working directory.
If no file or directory names are specified, all the files and directories in the JAR file are extracted.
Modifier options Each of the four command specifier letters can be followed by additional letters that provide further detail about the operation to be performed:
If this option is not present, jar reads a JAR file from standard input and/or writes a JAR file to standard output.
If the f option is present, the command line must contain the name of the JAR file to operate on.
This default manifest simply lists the contents of the JAR file.
Many JAR files require additional information to be specified in the manifest; the m option tells the jar command that a manifest template is specified on the command line.
This m option should be used only with the c or u commands, not with the t or x commands.
Used with the c and u commands to tell jar to store files in the JAR archive without compressing them.
Note that this option is the digit zero, not the letter O.
Files The first option to jar consists of an initial command letter and various option letters.
This first option is followed by a list of files:
If the first option contains both the letters f and m, the JAR and manifest files should be listed in the same order the f and m options appear.
The manifest-file specified with the m option should contain additional manifest entries to be placed in the manifest in addition to the automatically generated entries.
Additional options In addition to all the options listed previously, jar also supports the following:
The subsequent file and directory names are interpreted relative to dir and are inserted into the JAR archive without dir as a prefix.
Any number of -C options can be used; each remains in effect until the next is encountered.
The directory specified by a -C option is interpreted relative to the current working directory, not the directory specified by the previous -C option.
Examples The jar command has a confusing array of options, but, in most cases, its use is quite simple.
To create a simple JAR file that contains all the class files in the current directory and all files in a subdirectory called images, you can type:
To extract the manifest file from a JAR file for examination or editing:
Description java is the Java byte-code interpreter; it runs Java programs.
The program to be run is the class specified by classname.
This must be a fully qualified name: it must include the package name of the class but not the .class file extension.
The specified class must define a main( ) method with exactly the following signature:
This method serves as the program entry point: the interpreter begins execution here.
In Java 1.2 and later, a program can be packaged in an executable JAR file.
To run a program packaged in this fashion, use the -jar option to specify the JAR file.
The manifest of an executable JAR file must contain a Main-Class attribute that specifies which class within the JAR file contains the main( ) method at which the interpreter is to begin execution.
Any command-line options that precede the name of the class or JAR file to execute are options to the Java interpreter itself.
Any options that follow the class name or JAR filename are options to the program; they are ignored by the Java interpreter and passed as an array of strings to the main() method of the program.
The Java interpreter runs until the main( ) method exits, and any threads (except for threads marked as daemon threads) created by the program have also exited.
Interpreter versions The java program is the basic version of the Java interpreter.
In addition to this program, however, there are several other versions of the Java interpreter.
Each of these versions is similar to java but has a specialized function.
This list includes all the interpreter versions, including those that are no longer in use.
Use javaw when you want to run a Java program (from a script, for example) without forcing a console window to appear.
Client or Server VM Sun’s “HotSpot” virtual machine comes in two versions: one is tuned for use with short-lived client applications and one is for use with long-running server code.
As of Java 1.4, you can select the server version of the VM with the -server option.
You can specify the client VM (which is the default) with the -client option.
In Java 5.0, the interpreter automatically enters server mode if it detects that it is running on “server-class” hardware (typically a computer with multiple CPUs)
Very few Java applications needed to use this version of the interpreter, and it was removed in Java 1.4
A JIT converts Java byte codes to native machine instructions at runtime and significantly speeds up the execution of a typical Java program.
If you do not want to use the JIT, you can disable it by setting the JAVA_COMPILER environment variable to “NONE” or the java.compiler system property to “NONE” using the -D option:
If you want to use a different JIT compiler implementation, set the environment variable or system property to the name of the desired implementation.
This environment variable and property are no longer used as of Java 1.4, which uses the HotSpot VM, which includes efficient JIT technology.
To use nonnative, or green, threads (the default), you could specify -green.
In Java 1.3, the default “Client VM” used native threads.
Specifying -green or -native in Java 1.3 implicitly specified -classic as well.
These options are no longer supported (or necessary) as of Java 1.4
Common options The following options are the most commonly used.
In Java 1.2 and later, this option specifies only the location of application classes.
Your Java program can then look up the specified value by its property name.
The manifest of the specified jarfile must contain a Main-Class attribute that identifies the class with the main() method at which program execution is to begin.
Assertion options The following options specify whether and where assertions are tested.
It is new in Java 1.4 and can be abbreviated -da.
Used alone, it disables all assertions (except those in the system classes), which is the default.
To disable assertions in a single class, follow the option with a colon and the fully qualified class name.
To disable assertions in an entire package (and all of its subpackages), follow this option with a colon, the name of the package, and three dots.
Used alone, it enables all assertions (except in system classes)
To enable assertions in a single class, follow the option with a colon and the full class name.
To enable assertions in an entire package (and its subpackages), follow the option with a colon, the package name, and three dots.
Performance tuning options The following options select which version of the VM is to be run and fine-tune its memory allocation, garbage collection, and incremental compilation.
Options beginning with -X are nonstandard and may change from release to release.
This option typically defers some compilation to favor quicker application launch times.
This option is valid in Java 1.4 and later but is currently implemented only for Solaris platforms.
This option is valid in Java 1.4 and later but is currently implemented only for Solaris platforms.
In Java 1.3, using this option also selects the -classic option.
Using native threads can be advantageous in some circumstances, such as when running on a multi-CPU computer.
In Java 1.3, the default HotSpot virtual machine uses native threads.
In general, this option results in slower startup time but better subsequent performance.
In Java 5.0 and later, many VMs automatically select this option if they are running on “server-class” hardware such as a dualprocessor machine.
Xbatch Tells the HotSpot VM to perform all just-in-time compilation in the foreground, regardless of the time required for compilation.
Without this option, the VM compiles methods in the background while interpreting them in the foreground.
In this mode, the garbage collector runs continuously in the background, and a running program is rarely, if ever, subject to noticeable pauses while garbage collection occurs.
Using this option typically results in a 10% decrease in overall performance, however.
Xint Tells the HotSpot VM to operate in interpreted mode only, without performing any just-in-time compilation.
Xmixed Tells the HotSpot VM to perform just-in-time compilation on frequently used methods (“hotspots”) and execute other methods in interpreted mode.
Xms initmem[k|m] Specifies how much memory is allocated for the heap when the interpreter starts up.
You can specify it in kilobytes by appending the letter k or in megabytes by appending the letter m.
For large or memory-intensive applications (such as the Java compiler), you can improve runtime performance by starting the interpreter with a larger amount of memory.
You must specify an initial heap size of at least 1 MB.
Xmxmaxmem[k|m] Specifies the maximum heap size the interpreter uses for dynamically allocated objects and arrays.
You can specify maxmem in kilobytes by appending the letter k and in megabytes by appending the letter m.
You cannot specify a heap size less than 2 MB.
Xsssize[k|m] Sets the thread stack size in bytes, kilobytes, or megabytes.
Instrumentation options The following options support debugging, profiling, and other VM instrumentation.
Options beginning with -X are nonstandard and may change from release to release.
This means that the general -agentlib option will replace tool-specific options such as -Xdebug and -Xrunhprof.
In Java 1.2 and later, this option has been replaced with -Xdebug.
The specified jarfile must have a manifest that includes an Agent-Class attribute.
This attribute must name a class that includes the agent’s premain() method.
Any options will be passed to this premain( ) method along with a java.lang.
In Java 1.2 and later, you can use -verbose:class as a synonym.
Xdebug Starts the interpreter in a way that allows a debugger to communicate with it.
Deprecated in Java 5.0 in favor of the -agentlib option.
Xfuture Strictly checks the format of all class files loaded.
Without this option, java performs the same checks that were performed in Java 1.1
Xloggc:filename Logs garbage collection events with timestamps to the named file.
In Java 1.2, or when using the -classic option, use -Xrunhprof.
Use -Xrunhprof:help for a list of supported options and values.
Deprecated in Java 5.0 in favor of the -agentlib option.
Advanced options The Java interpreter also supports quite a few advanced configuration options that begin with -XX.
Loading classes The Java interpreter knows where to find the system classes that comprise the Java platform.
In Java 1.2 and later, it also knows where to find the class files for all extensions installed in the system extensions directory.
However, the interpreter must be told where to find the nonsystem classes that comprise the application to be run.
Class files are stored in a directory that corresponds to their package name.
By default, the interpreter uses the current working directory as the root and looks for all classes in and beneath this directory.
The interpreter can also search for classes within ZIP and JAR files.
To tell the interpreter where to look for classes, you specify a classpath: a list of directories and ZIP and JAR archives.
When looking for a class, the interpreter searches each of the specified locations in the order in which they are specified.
To specify a classpath in Unix, you might type a command like this:
On a Windows system, you might use a command like the following:
Note that Unix and Windows use different characters to separate directory and path components.
You can also specify a classpath with the -classpath or -cp options to the Java interpreter.
A path specified with one of these options overrides any path specified by the CLASSPATH environment variable.
In Java 1.2 and later, the -classpath option specifies only the search path for application and user classes.
Prior to Java 1.2, or when using the oldjava interpreter, this option specified the search path for all classes, including system classes and extension classes.
Description javac is the Java compiler; it compiles Java source code (in .java files) into Java byte codes (in .class files)
Each source file can contain any number of classes, although only one can be a public top-level class.
The name of the source file (minus the .java extension) must match the name of the public class it contains.
Thus, if you keep a list of Java source files for a particular project in a file named project.list, you can compile all those files at once with the command:
To compile a source file, javac must be able to find definitions of all classes used in the source file.
It looks for definitions in both source-file and class-file form, automatically compiling any source files that have no corresponding class files or that have been modified since they were most recently compiled.
Common options The most commonly used compilation options include the following:
This option overrides any path specified by the CLASSPATH environment variable.
The path specified is an ordered list of directories, ZIP files, and JAR archives, separated by colons on Unix systems or semicolons on Windows systems.
If the -sourcepath option is not set, this option also specifies the search path for source files.
By default, javac stores the .class files it generates in the same directory as the .java files those classes were defined in.
If the -d option is specified, however, the specified directory is treated as the root of the class hierarchy, and .class files are placed in this directory or the appropriate subdirectory below it, depending on the package name of the class.
On the other hand, if the source file specifies that it is in a package:
When the -d option is specified, javac automatically creates any directories it needs to store its class files in the appropriate place.
The valid keywords are: source, which specifies sourcefile information; lines, which specifies line number information; and vars, which specifies local variable debugging information.
Jjavaoption Passes the argument javaoption directly through to the Java interpreter.
The files found in this source path are compiled if no corresponding class files are found or if the source files are newer than the class files.
By default, source files are searched for in the same places class files are searched for.
In particular, it causes javac to list all the source files it compiles, including files that did not appear on the command line.
Warning options The following options control the generation of warning messages by javac:
By default, javac issues only a single warning for each source file that uses deprecated APIs.
Xlint Enables all recommended warnings about program “lint.” At the time of this writing, all the warnings detailed below are recommended.
Xlint:warnings Enables or disables a comma-separated list of named warning types.
At the time of this writing, the available warning types are the following.
A named warning can be suppressed by preceding it with a minus sign:
Tells javac to send warning and error messages to the specified file instead of writing them to the console.
Warns about case clauses in switch statements that “fall through.” In Java 5.0, use -Xlint:fallthrough.
Cross-compilation options The following options are useful when using javac to compile class files intended to run under a different version of Java:
This option does not specify the system classes used to run the compiler itself, only the system classes read by the compiler.
Use of this flag sets the class file version number so that the resulting class file cannot be run by VMs from previous releases.
Description javadoc generates API documentation for any number of packages and classes you specify.
The javadoc command line can list any number of package names and any number of Java source files.
For convenience, when working with a large number of command-line options, or a large number of package or class names, you can place them all in an auxiliary file and specify the name of that file on the command line, preceded by an @ character.
It uses the information it gleans from this processing to generate detailed API documentation.
Most importantly, the generated documentation includes the contents of all documentation comments included in the source files.
See Chapter 7 for information about writing doc comments in your own Java code.
When you specify a Java source file for javadoc to process, you must specify the name of the file that contains the source, including a complete path to the file.
It is more common, however, to use javadoc to create documentation for entire packages of classes.
When you specify a package for javadoc to process, you specify the package name, not the directory that contains the source code for the package.
In this case, you may need to specify the -sourcepath option so that javadoc can find your package source code correctly if it is not stored in a location already listed in your default classpath.
Documentation for this package is included in the standard documentation bundle for Java 1.2 and later.
Here we document Java 1.2 and later versions of the program and do not distinguish these features from those in previous versions.
Some are standard options that are always recognized by javadoc.
Other options are defined by the doclet that produces the.
The options for the standard HTML doclet are included in the following list:
This depends on the encoding used in the documentation comments of your source code, of course.
The encoding value is used in a <meta> tag in the HTML output.
Because javadoc uses the javac compiler, it needs to be able to locate class files for all classes referenced by the packages being documented.
See java and javac for more information about this option and the default value provided by the CLASSPATH environment variable.
If this option is omitted, the current directory is used.
The name of the encoding specified here may not exactly match the name of the charset specified with the -charset option.
If this option is not specified, javadoc generates documentation using the default HTML doclet.
This file is often the first thing readers see when they browse the generated documentation.
This can be different from the desired output encoding specified by -docencoding.
This is useful for excluding version control directories, for example.
By default, these packages are listed in alphabetical order in a single table.
You can break them into groups of related packages with this option, however.
The title specifies the title of the package group, such as “Core Packages.” The packagelist is a colon-separated list of package names, each of which can include a trailing * character as a wildcard.
The javadoc command line can contain any number of -group options.
If this option is not specified, javadoc creates a default help file.
Jjavaoption Passes the argument javaoption directly through to the Java interpreter.
When processing a large number of packages, you may need to use this option to increase the amount of memory javadoc is allowed to use.
Note that because -J options are passed directly to the Java interpreter before javadoc starts up, they cannot be included in an external file specified on the command line with the @list syntax.
For example, when using javadoc to produce documentation for your own packages, you can use this option to link your documentation to the javadoc documentation for the core Java APIs.
The directory specified by url must contain a file named package-list, and javadoc must be able to read this file at runtime.
This file is automatically generated by a previous run of javadoc; it contains a list of all packages documented at the url.
More than one -link option can be specified, although this does not work properly in early releases of Java 1.2
If no -link option is specified, references in the generated documentation to classes and members that are external to the documentation are not hyperlinked.
This is useful when the directory specified by url does not have a package-list file or when that file is not available when javadoc is run.
This is used to look up a resource file that contains localized messages and text for the output files.
This option tells it to additionally omit package names for classes in the specified packages, or, if the all keyword is used, in all packages.
Otherwise, the single index file generated by javadoc will be too large to be useful.
Using this option is often easier than explicitly listing all desired package names.
The characters and their meanings are a (all: valid everywhere), p (packages), t (types: classes and interfaces), c (constructors), m (methods), and f (fields)
A secondary purpose of the -tag option is to specify the order in which tags are processed and in which their output appears.
You can include the names of standard tags after the -tag option to specify this ordering.
Custom tags and taglets can be included within this list of standard -tag options.
This option does not tell javadoc to print its own version number.
This title typically appears as the title of the web browser window and in history and bookmark lists.
This environment variable specifies the default classpath javadoc uses to find the class files and source files.
See java and javac for further discussion of the classpath.
Description javah generates C header and source files (.h and .c files) that are used when implementing Java native methods in C.
In Java 1.1 and earlier, javah generated files for oldstyle native methods.
In Java 1.1, the -jni option specified that javah should generate new-style files.
In Java 1.2 and later, this option is the default.
A full description of how to implement Java native methods in C is beyond the scope of this book.
This option overrides any path specified by the CLASSPATH environment variable.
Prior to Java 1.2, this option can specify the location of the system classes and extensions.
In Java 1.2 and later, it specifies only the location of application classes.
This option is the default in Java 1.2 and later.
This option is only for the Java 1.0 native methods interface.
In Java 1.2 and later, this option is obsolete and has been removed.
In its place, you can use the -verbose:jni option of the Java interpreter.
Causes javah to print messages about what it is doing.
Specifies the default classpath javah searches to find the specified classes.
Description javap reads the class files specified by the class names on the command line and prints a human-readable version of the API defined by those classes.
Enables backward compatibility with the output of the Java 1.1 version of javap.
This option exists for programs that depend on the precise output format of javap.
This option always disassembles all methods, regardless of their visibility level.
This option overrides the path specified by the CLASSPATH environment variable.
Prior to Java 1.2, this argument specifies the path for all system classes, extensions, and application classes.
In Java 1.2 and later, it specifies only the application classpath.
See java and javac for more information on the classpath.
This option is typically useful only when used with -c.
The javac compiler does not include local variable information in its class files by default.
Jjavaoption Passes the specified javaoption directly to the Java interpreter.
Outputs additional information (in the form of Java comments) about each member of each specified class.
Description javaws is the command-line interface to the Java Web Start network application launcher.
When started without a url, javaws displays a graphical cache viewer which allows cached applications to be launched and Java Web Start to be configured.
If the URL of a JNLP (Java Network Launching Protocol) is specified on the command line, javaws launches the specified application.
Allows the creation of file associations during a -silent -import.
This is the default behavior if javaws is invoked with no arguments.
Synopsis jconsole [ options ] jconsole [ options ] pid jconsole [ options ] host:port.
It can monitor one or more local or remote Java processes.
Processes can be monitored only if started with special system properties set.
To allow a Java VM to be monitored locally, start it with:
To allow a Java VM to be monitored remotely, start it with:
You may start jconsole with no local or remote process specified and use its Connection menu to establish connections.
This is the only way to connect jconsole to more than one Java process.
To connect jconsole to a local process when it starts up, simply list the process id on the command line.
To connect jconsole to a remote process when it starts up, specify the hostname and port number on the command line.
Synopsis jdb [ options ] class [ program options ] jdb connect options.
When jdb is invoked with the name of a Java class, it starts another copy of the java interpreter, using any interpreter options specified on the command line.
The new interpreter is started with special options that enable it to communicate with jdb.
The new interpreter loads the specified class file and then stops and waits for debugging commands before executing the first byte code.
Doing so requires that special options be passed to both the java interpreter and to jdb.
You can refer to classes by name, with or without their package names.
You can also refer to static class members by name.
You can refer to individual objects by object ID, which is an eightdigit hexadecimal integer.
Or, when the classes you are debugging contain local variable information, you can often use local variable names to refer to objects.
You can use normal Java syntax to refer to the fields of an object and the elements of an array; you can also use this syntax to write quite complex expressions.
As of Java 1.3, jdb even supports method invocation using standard Java syntax.
Options When invoking jdb with a specified class file, any of the java interpreter options can be specified.
See the java reference page for an explanation of these options.
In order to use jdb to connect to a running VM in this way, the VM must have been started with special command-line options.
A detailed description of those options is beyond the scope of this book.
Specify the name of a connector (a Java class) followed by a colon and a comma-separated list of arguments in name=value form.
This avoids the need to explicitly use the run command to start it.
Each connector is a Java class and a list of arguments.
To make this work, the VM must be with options like these:
A shorthand command that is replaced with the text of the last command entered.
It can be followed with additional text to append to that command.
If no exception is specified, the command lists the exceptions currently being caught.
Clears the breakpoint set in the specified method of the specified class.
This command should be used when the current thread is stopped at a breakpoint.
Prints the value of all fields of the specified object or objects.
If you specify the name of a class, dump displays all class (static) methods and variables of the class and also displays the superclass and list of implemented interfaces.
Objects and classes can be specified by name or by their eight-digit hexadecimal ID numbers.
This command does not cause the Java interpreter to ignore exceptions; it merely tells jdb to ignore them.
If no line number is specified, uses the line number of the current stack frame of the current thread.
The lines listed are from the source file of the current stack frame of the current thread.
Use the use command to tell jdb where to find source files.
Java code must be compiled with the -g option in order to contain local variable information.
Use dump to list the instance variables of an object or the class (static) variables of a class.
Each item can be a class, object, field, or local variable, and can be specified by name or by eight-digit hexadecimal ID number.
You can also refer to threads with the special syntax t@thread-number.
The print command displays an object’s value by invoking its toString() method.
If no threads are specified, all suspended threads are resumed.
If no class or arguments are specified, uses the class and arguments specified on the jdb command line.
If the line invokes a method, steps into that method and stops.
Sets a breakpoint at the beginning of the specified method of the specified class.
This thread is used implicitly by a number of other jdb commands.
If no thread group is specified, lists all threads in the current thread group (specified by threadgroup)
If no path is specified, displays the current source path.
If no thread is specified, displays a stack trace for the current thread.
If all is specified, displays a stack trace for all threads.
When a path is specified with this environment variable, jdb always implicitly appends the location of the system classes to the end of the path.
If this environment variable is not specified, the default path is the current directory and the system classes.
Description jinfo prints the system properties and JVM command-line options for a running Java process or core file.
Specify the process id of a Java process running locally to obtain configuration information about it.
To obtain post-mortem configuration information from a core file, specify the java executable that produced the core file and the core file itself on the command line.
To obtain configuration information about a Java process running remotely, specify the name of the remote host, optionally prefixed by a remote process name.
In Java 5.0, jinfo is experimental, unsupported, and not available on all platforms.
Options These options are mutually exclusive; only one may be specified.
Description jmap prints memory usage information for a local or remote Java process or a Java core file.
Depending on the option it is invoked with, jmap displays one of four memory usage reports.
Specify the process id of a Java process running locally to obtain configuration information about it.
To obtain post-mortem configuration information from a core file, specify the java executable that produced the core file and the core file itself on the command line.
To obtain configuration information about a Java process running remotely, specify the name of the remote host, optionally prefixed by a remote process name and @ sign.
In Java 5.0, jmap is experimental, unsupported, and not available on all platforms.
Options When invoked with no options, jmap prints a memory map of the shared objects or libraries loaded by the VM.
Other reports can be produced by using the options below.
These options are mutually exclusive; only one may be specified.
Description jps lists the Java processes running on the local host or on the specified remote host.
If a remote host is specified, it must be running the jstatd daemon.
For each Java process, it displays a process id and names the class or JAR file that the process is executing.
Process ids are used by a number of other Java tools, such as jconsole, jstat, and jmap.
The single-letter options, except for -q, may be combined into a single command-line argument, such as -lmv:
Synopsis jsadebugd pid [ process-name ]              // running process jsadebugd executable core [ process-name ]  // core file.
Description jsadebugd is a server process that allows remote invocations of jinfo, jmap, and jstack on a local Java process or core file.
Invoke jsadebugd by specifying either the process id of a running Java process or an executable file and core file pair on the command line.
If more than one jsadebugd server will run on the same host at the same time, follow these arguments with an identifying process name that remote clients can use to identify the desired process.
In Java 5.0, jsadebugd is experimental, unsupported, and not available on all platforms.
Description jstack prints stack traces for each of the Java threads running in the specified Java process.
Specify the process id of a Java process running locally to obtain configuration information about it.
To obtain post-mortem configuration information from a core file, specify the Java executable that produced the core file and the core file itself on the command line.
To obtain configuration information about a Java process running remotely, specify the name of the remote host, optionally prefixed by a remote process name and @ sign.
In Java 5.0, jstack is experimental, unsupported, and not available on all platforms.
Without this option, the default is to display Java stack frames only.
Description jstat probes a running JVM once or repeatedly and displays statistics about its class loading, just-in-time compilation, memory, or garbage collection performance.
The type of information to be displayed is specified by options.
A local process to be probed is specified by its process id, as returned, for example, by jps.
A remote Java process may be probed by specifying the remote process id, the remote host name, and the port number on which the remote host’s rmiregistry server is running (if other than the default of 1099)
The remote host must also be running the jstatd server.
You may also specify a probe interval, in milliseconds or seconds, to have it probe repeatedly.
If you do this, you may additionally specify a total number of probes it should conduct.
In Java 5.0, jinfo is experimental, unsupported, and not available on all platforms.
You must use one of the listed options each time you run jstat.
This option must follow one of the report type options below.
The column displays elapsed time (in seconds) since the target Java process was started.
The following options specify the type of statistics to be reported by jstat.
Unless you run jstat with -help, -options or -version, you must specify exactly one of these options, and it must be the first option on the command line.
Most of the options produce detailed reports of garbage collection minutiae.
Consult Sun’s tool documentation (part of the JDK documentation bundle) for the interpretation of these reports.
Description jstatd is a server that provides information about local Java processes to the jps and jstat programs running on remote hosts.
To start jstatd, create the following file and name it jstatd.policy:
This policy grants all permissions to any class loaded from the JDK’s tools.jar JAR file.
To launch jstatd with this policy, use this command line:
If an existing rmiregistry server is running, jstatd uses it.
Binds the jstatd remote object to the name rminame in the RMI registry.
The default name is “JStatRemoteHost”, which is what jps and jstat look for.
Use of this option requires rminame to be used in remote jps and jstat invocations.
Description keytool manages and manipulates a keystore, a repository for public and private keys and public key certificates.
The first option to keytool always specifies the basic command to be performed.
Subsequent options provide details about how the command is to be performed.
If a command requires an option that does not have a default value, keytool prompts you interactively for the value.
Generates a certificate signing request in PKCS#10 format for the specified alias.
The request is written to the specified file or to the standard output stream.
The request should be sent to a certificate authority (CA), which authenticates the requestor and sends back a signed certificate authenticating the requestor’s public key.
This signed certificate can then be imported into the keystore with the -import command.
This command uses the following options: -alias, -file, -keypass, -keystore, -sigalg, -storepass, -storetype, and -v.
This command uses the following options: -alias, -keystore, -storepass, -storetype, and -v.
This command uses the following options: -alias, -file, -keystore, -rfc, -storepass, -storetype, and -v.
Self-signed certificates are not often useful by themselves, so this command is often followed by -certreq.
The identity database is read from the specified file or from standard input if no file is specified.
The keys and certificates are written into the specified keystore file, which is automatically created if it does not exist yet.
This command uses the following options: -file, -keystore, -storepass, -storetype, and -v.
This command uses the following options: -alias, -file, -keypass, -keystore, -noprompt, -storepass, -storetype, -trustcacerts, and -v.
This command uses the following options: -alias, -dest, -keypass, -keystore, -new, -storepass, -storetype, and -v.
This command uses the following options: -alias, -keypass, -new, -storetype, and -v.
With the -v option, prints certificate details in human-readable format.
With -rfc, prints certificate contents in a machine-readable, printableencoding format.
This command uses the following options: -alias, -keystore, -rfc, -storepass, -storetype, and -v.
Unlike most keytool commands, this one does not use a keystore.
This command uses the following options: -alias, -dname, -keypass, -keystore, -sigalg, -storepass, -storetype, -v, and -validity.
The new password must be at least six characters long.
This command uses the following options: -keystore, -new, -storepass, -storetype, and -v.
Options The various keytool commands can be passed various options from the following list.
A distinguished name is a highly qualified name intended to be globally unique.
The -genkey command of keytool prompts for a distinguished name if none is specified.
The -selfcert command uses the distinguished name of the current certificate if no replacement name is specified.
If left unspecified, keytool reads from the standard input or writes to the standard output.
In the default Java implementation shipped from Sun, the only supported algorithm is “DSA”; this is the default if this option is omitted.
If this option is unspecified, keytool first tries the -storepass password.
If that does not work, it prompts for the appropriate password.
If unspecified, a file named .keystore in the user’s home directory is used.
If unspecified, keytool prompts for the value of this option.
If this option is not specified, the -import command prompts the user.
If this option is not specified, -export outputs the certificate in binary format, and -list lists only the certificate fingerprint.
This option cannot be combined with -v in the -list command.
If omitted, the default for this option depends on the type of underlying public key.
If it is a DSA key, the default algorithm is “SHA1withDSA”
If the key is an RSA key, the default signature algorithm is “MD5withRSA”
This password also serves as a default password for any private keys that do not have their own -keypass specified.
If this option is not specified, the default is taken from the system security properties file.
This is helpful when you must edit a file of Java code but do not have an editor that can handle the encoding of the file.
If unspecified, standard input and standard output are used, making native2ascii suitable for use in pipes.
If this option is not specified, the encoding is taken from the file.encoding system property.
Notice that the output file is specified on the command line before the input JAR file.
Basic options All pack200 options exist in both a long form that begins with a double dash and a single-letter form that begins with a single dash.
When the option requires a value, the value should be separated from the long form of the option with an equals sign and no space or should immediately follow the short form with no intervening space or punctuation.
Supported property names are the same as the long-form option names listed here, with with hyphens converted to periods.
Use this option if you want to apply a different compression filter, such as bzip2
If file ends with a /, all files in the directory are passed through without packing.
In this case, the outputfile specified on the command line should be the name of a JAR file.
It is important to do a pack/unpack cycle on a JAR file before signing it with jarsigner because the pack/unpack cycle reorders some internal elements of a class file and invalidates any digital signatures or checksums in the JAR file manifest.
This makes it harder to debug the resulting JAR file.
Advanced packing options The following options provide fine control over the compression performed by pack200
A value of true places a hint in the packed archive that the unpacker should deflate all entries after unpacking them.
A value of true places a hint in the packed archive that the unpacker should store each entry in the JAR file without deflation.
Using a value of true or false reduces the packed file size slightly because deflation hints do not need to be stored for each entry.
If you specify latest instead, only the most recent modification time is transmitted, and is applied to all entries when they are unpacked.
Pack200 files may be divided into separately packed segments in order to reduce the amount of memory required by the unpacker.
Larger segment sizes result in better compression ratios, but require additional memory to unpack.
The default action is pass, which specifies that the entire class file will be transmitted with no compression.
An action of error specifies that pack200 should produce an error message.
An action of strip says that the attribute should be stripped from the class file.
The action may also be a “layout string” that specifies how the attribute should be packed.
See the Pack200 specification for details on the layout language.
These options may be repeated to specify handling for more than one attribute.
Description policytool displays a Swing user interface that makes it easy to edit security policy configuration files.
The Java security architecture is based on policy files, which specify sets of permissions to be granted to code from various sources.
System administrators and users can edit these files with a text editor, but the syntax of the file is somewhat complex, so it is usually easier to use policytool to define and edit security policies.
Selecting the policy file to edit When policytool starts up, it opens the .java.policy file in the user’s home directory by default.
Use the New, Open, and Save commands in the File menu to create a new policy file, open an existing file, and save an edited file, respectively.
Editing the policy file The main policytool window displays a list of the entries contained in the policy file.
Each entry specifies a code source and the permissions that are to be granted to code from that source.
The window also contains buttons that allow you to add a new entry, edit an existing entry, or delete an entry from the policy file.
If you add or edit an entry, policytool opens a new window that displays the details of that policy entry.
With the addition of the JAAS API to the core Java platform in Java 1.4, policytool allows the specification of a Principal to whom a set of permissions is granted.
Every policy file has an associated keystore from which it obtains the certificates it needs when verifying the digital signatures of Java code.
You can usually rely on the default keystore, but if you need to specify the keystore explicitly for a policy file, use the Change Keystore command in the Edit menu of the main policytool window.
Adding or editing a policy entry The policy entry editor window displays the code source for the policy entry and a list of permissions associated with that code source.
It also contains buttons that allow you to add a new permission, delete a permission, or edit an existing permission.
When defining a new policy entry, the first step is to specify the code source.
A code source is defined by a URL from which the code is downloaded and/or a list of digital signatures that must appear on the code.
Specify one or both of these values by typing in a URL and/or a comma-separated list of aliases.
These aliases identify trusted certificates in the keystore associated with the policy file.
After you have defined the code source for a policy entry, you must define the permissions to be granted to code from that source.
Use the Add Permission and Edit Permission buttons to add and edit permissions.
Defining a permission To define a permission in the permission editor window, first select the desired permission type from the Permission pulldown menu, then select an appropriate target value from the Target Name menu.
The choices in this menu are customized depending on the permission type you selected.
Some types of permissions, such as FilePermission, do not have a fixed set of possible targets, and you usually have to type in the target you want.
See the documentation of the individual Permission classes for a description of the targets they support.
Depending on the type of permission you select, you may also have to select one or more action values from the Actions menu.
When you have selected a permission and appropriate target and action values, click the Okay button to dismiss the window.
Description serialver displays the version number of a class or classes.
This version number is used for the purposes of serialization: the version number must change each time the serialization format of the class changes.
If the specified class declares a long serialVersionUID constant, the value of that field is displayed.
Otherwise, a unique version number is computed by applying the Secure Hash Algorithm (SHA) to the API defined by the class.
This program is primarily useful for computing an initial unique version number for a class, which is then declared as a constant in the class.
The output of serialver is a line of legal Java code, suitable for pasting into a class definition.
When using -show, no class names can be specified on the command line.
The specified classes are looked up relative to this classpath.
Specify the name of the packed file and the name of the JAR file to unpack it to on the command line.
Because unpack200 is used as part of the Java installation process, it is a native application that can run on a system without a Java interpreter.
Options All unpack200 options exist in both a long form that begins with a double dash and a single-letter form that begins with a single dash.
When the option requires a value, the value should be separated from the long form of the option with an equals sign and no space or should immediately follow the short form with no intervening space or punctuation.
The default is keep, which specifies that each JAR entry should have the same compression that it had in the original JAR file.
Part II provides quick-reference material for the essential APIs of the Java platform.
Please read the following section, How to Use This Quick Reference, to learn how to get the most out of this material.
The quick-reference section that follows packs a lot of information into a small space.
This introduction explains how to get the most out of that information.
It describes how the quick reference is organized and how to read the individual quick-reference entries.
Finding a Quick-Reference Entry The quick reference is organized into chapters, each of which documents a single package of the Java platform or a group of related packages.
Packages are listed alphabetically within and between chapters, so you never really need to know which chapter documents which package: you can simply search alphabetically, as you might do in a dictionary.
The documentation for each package begins with a quick-reference entry for the package itself.
This entry includes a short overview of the package and a listing of the classes and interfaces included in the package.
In this listing of package contents, package members are first grouped by general category (interfaces, eumerated types, classes and exceptions, for example)
Within each category, they are grouped by class hierarchy, with indentation to indicate the level of the hierarchy.
Finally, classes and interfaces at the same hierarchy level are listed alphabetically.
Each package overview is followed by individual quick-reference entries, in alphabetical order, for the types defined in the package.
The overall organization of the quick-reference is therefore alphabetical by the fully-qualified name of the type.
To look up a quick-reference entry for a particular type, you must also know the name of the package that defines that type.
Use the dictionary-style headers on the upper corner of each page to help you quickly find the package and class you need.
Usually, the package name of a type is obvious from its context, and you should have no trouble looking up the quick-reference entry you want.
Occasionally, you may need to look up a type for which you do not already know the package.
This index allows you to look up a class by class name and find out what package it is part of.
Reading a Quick-Reference Entry The quick-reference entries for classes and interfaces contain quite a bit of information.
The sections that follow describe the structure of a quick-reference entry, explaining what information is available, where it is found, and what it means.
While reading the descriptions that follow, you may find it helpful to flip through the reference section itself to find examples of the features being described.
Each quick-reference entry begins with a four-part title that specifies the name, package name, and availability of the class, and may also specify various additional flags that describe the class.
The class name appears in bold at the upper left of the title.
The package name appears, in smaller print, in the lower left, below the class name.
The upper-right portion of the title indicates the availability of the class; it specifies the earliest release that contained the class.
The availability section of the title is also used to indicate whether a class has been deprecated, and, if so, in what release.
In the lower-right corner of the title you may find a list of flags that describe the class.
Java 5.0 annotations and meta-annotations are listed here, as are the following flags:
In other words, it must be declared in the throws clause of any method that may throw it.
The title of each quick-reference entry is followed by a short description of the most important features of the class or interface.
If a class or interface has a nontrivial class hierarchy, the “Description” section is followed by a figure that illustrates the hierarchy and helps you understand the class in the context of that hierarchy.
The name of each class or interface in the diagram appears in a box; classes and enumerated types appear in rectangles (except for abstract classes, which appear in skewed rectangles or parallelograms)
Interfaces and annotation types appear in rounded rectangles, in which the corners have been replaced by arcs.
The current class—the one that is the subject of the diagram—appears in a box that is bolder than the others.
The boxes are connected by lines: solid lines indicate an “extends” relationship, and dotted lines indicate an “implements” relationship.
Interfaces are usually positioned beneath the classes that implement them, although in simple cases an interface is sometimes positioned on the same line as the class that implements it, resulting in a more compact figure.
Note that the hierarchy figure shows only the superclasses of a class.
If a class has subclasses, those are listed in the cross-reference section at the end of the quick-reference entry for the class.
The most important part of every quick-reference entry is the synopsis, which follows the title and description.
The synopsis for a type looks a lot like the source code for the type, except that the method bodies are omitted and some additional.
If you know Java syntax, you know how to read the synopsis.
The first line of the synopsis contains information about the class itself.
It begins with a list of modifiers, such as public, abstract, and final.
These modifiers are followed by the class, interface, enum, or @interface keyword and then by the name of the class.
The class name may be followed by type variables, an extends clause that specifies the superclass, and an implements clause that specifies any interfaces the class implements.
The class definition line is followed by a list of the fields, methods, and nested types that the class defines.
Once again, if you understand basic Java syntax, you should have no trouble making sense of these lines.
The listing for each member includes the modifiers, type, and name of the member.
For methods, the synopsis also includes the type and name of each method parameter and an optional throws clause that lists the exceptions the method can throw.
The member names are in boldface, so it is easy to scan the list of members looking for the one you want.
The names of method parameters are in italics to indicate that they are not to be used literally.
The member listings are printed on alternating gray and white backgrounds to keep them visually separate.
Each member listing is a single line that defines the API for that member.
These listings use Java syntax, so their meaning is immediately clear to any Java programmer.
There is some auxiliary information associated with each member synopsis that requires explanation, however.
Recall that each quick-reference entry begins with a title section that includes the release in which the class was first defined.
When a member is introduced into a class after the initial release of the class, the version in which the member was introduced appears, in small print, to the left of the member synopsis.
Furthermore, if a member has been deprecated, that fact is indicated with a hash mark (#) to the left of the member synopsis.
The area to the right of the member synopsis is used to display a variety of flags that provide additional information about the member.
Some of these flags indicate additional specification details that do not appear in the member API itself.
This information can be quite useful in understanding the class and in debugging your code, but be aware that it may differ between implementations.
The following flags may be displayed to the right of a member synopsis:
Although native is a Java keyword and can appear in method.
Therefore, this information is included with the member flags, rather than as part of the member listing.
This flag is useful as a hint about the expected performance of a method.
Like the native keyword, the synchronized keyword is part of the method implementation, not part of the specification, so it appears as a flag, not in the method synopsis itself.
This flag is a useful hint that the method is probably implemented in a threadsafe manner.
Whether or not a method is thread-safe is part of the method specification, and this information should appear (although it often does not) in the method documentation.
There are a number of different ways to make a method threadsafe, however, and declaring the method with the synchronized keyword is only one possible implementation.
In other words, a method that does not bear the synchronized flag can still be threadsafe.
Overrides: This flag indicates that a method overrides a method in one of its superclasses.
The flag is followed by the name of the superclass that the method overrides.
As we’ll see in the next section, overriding methods are usually grouped together in their own section of the class synopsis.
The Overrides: flag is only used when an overriding method is not grouped in that way.
Implements: This flag indicates that a method implements a method in an interface.
The flag is followed by the name of the interface that is implemented.
As we’ll see in the next section, methods that implement an interface are usually grouped into a special section of the class synopsis.
The Implements: flag is only used for methods that are not grouped in this way.
This can be a hint to the programmer that the method may need to be overridden in a subclass.
Only methods with a void return type can be truly empty.
Any method declared to return a value must have at least a return statement.
The constant flag indicates that the method implementation is empty except for a return statement that returns a constant value.
Such a method might have a body like return null; or return false;
Like the empty flag, this flag may indicate that a method needs to be overridden.
The flag is followed by the default value of the property.
In practice, however, these defaults are not always documented, and care should be taken, because the default values may change between implementations.
A default value is determined by dynamically loading the class in question, instantiating it using a no-argument constructor, and then calling the method to find out what it returns.
This technique can be used only on classes that can be dynamically loaded and instantiated and that have no-argument constructors, so default values are shown for those classes only.
Furthermore, note that when a class is instantiated using a different constructor, the default values for its properties may be different.
For static final fields, this flag is followed by the constant value of the field.
Only constants of primitive and String types and constants with the value null are displayed.
Some constant values are specification details, while others are implementation details.
The reason that symbolic constants are defined, however, is so you can write code that does not rely directly upon the constant value.
Use this flag to help you understand the class, but do not rely upon the constant values in your own programs.
Within a class synopsis, the members are not listed in strict alphabetical order.
Instead, they are broken down into functional groups and listed alphabetically within each group.
Constructors, methods, fields, and inner classes are all listed separately.
Grouping members by category breaks a class down into smaller, more comprehensible segments, making the class easier to understand.
This grouping also makes it easier for you to find a desired member.
Functional groups are separated from each other in a class synopsis with Java comments, such as // Public Constructors, // Inner Classes, and // Methods Implementing DataInput.
The various functional categories are as follows (in the order in which they appear in a class synopsis):
Public constructors and protected constructors are displayed separately in subgroupings.
If a class defines no constructor at all, the Java compiler adds a default no-argument constructor that is displayed here.
If a class defines only private constructors, it cannot be instantiated, so a special, empty grouping entitled “No Constructor” indicates this fact.
Constructors are listed first because the first thing you do with most classes is instantiate them by calling a constructor.
Constants Displays all of the constants (i.e., fields that are declared static and final) defined by the class.
Inner classes Groups all of the inner classes and interfaces defined by the class or interface.
Each inner class also has its own quick-reference entry that includes a full class synopsis for the inner class.
Like constants, inner classes are listed near the top of the class synopsis because they are often used by a number of other members of the class.
Static methods Lists the static methods (class methods) of the class, broken down into subgroups for public static methods and protected static methods.
Event listener registration methods Lists the public instance methods that register and deregister event listener objects with the class.
The names of these methods begin with the words “add” and “remove” and end in “Listener”
The methods are typically defined in pairs, so the pairs are listed together.
The methods are listed alphabetically by event name rather than by method name.
Public instance methods Contains all of the public instance methods that are not grouped elsewhere.
Implementing methods Groups the methods that implement the same interface.
There is one subgroup for each interface implemented by the class.
Methods that are defined by the same interface are almost always related to each other, so this is a useful functional grouping of methods.
If a class is modified so that it implements an interface after its initial release, the methods of that interface will be grouped here, but will also appear in the “Public Instance methods” section.
Overriding methods Groups the methods that override methods of a superclass broken down into subgroups by superclass.
This is typically a useful grouping, because it helps to make it clear how a class modifies the default behavior of its superclasses.
In practice, it is also often true that methods that override the same superclass are functionally related to each other.
Protected instance methods Contains all of the protected instance methods that are not grouped elsewhere.
Fields Lists all the nonconstant fields of the class, breaking them down into subgroups for public and protected static fields and public and protected instance fields.
For those that do, many object-oriented programmers prefer not to use those fields directly, but instead to use accessor methods when such methods are available.
Deprecated members Deprecated methods and deprecated fields are grouped at the very bottom of the class synopsis.
The synopsis section of a quick-reference entry is followed by a number of optional cross-reference sections that indicate other, related classes and methods that may be of interest.
Subclasses This section lists the subclasses of this class, if there are any.
Passed To This section lists all of the methods and constructors that are passed an object of this type as an argument.
This is useful when you have an object of a given type and want to figure out what you can do with it.
Methods defined by this type itself are not included in the list.
Returned By This section lists all of the methods (but not constructors) that return an object of this type.
This is useful when you know that you want to work with an object of this type, but don’t know how to obtain one.
Thrown By For checked exception classes, this section lists all of the methods and constructors that throw exceptions of this type.
This material helps you figure out when a given exception or error may be thrown.
Note, however, that this section is based on the exception types listed in the throws clauses of methods and constructors.
Subclasses of RuntimeException and Error do not have to be listed in throws clauses, so it is not possible to generate a complete cross-reference of methods that throw these types of unchecked exceptions.
Type Of This section lists all of the fields and constants that are of this type, which can help you figure out how to obtain an object of this type.
If the type defines self-typed fields or constants, they are not included on this list.
Throughout the quick reference, you’ll notice that classes are sometimes referred to by class name alone and at other times referred to by class name and package name.
If package names were always used, the class synopses would become long and hard to read.
On the other hand, if package names were never used, it would sometimes be difficult to know what class was being referred to.
The rules for including or omitting the package name are complex.
If the class name alone is ambiguous, the package name is always used.
If the class being referred to is part of the current package (and has a quickreference entry in the current chapter), the package name is omitted.
The java.io package is large, but most of the classes it contains fall into a well-structured hierarchy.
Most of the package consists of byte streams—subclasses of InputStream or OutputStream and character streams—subclasses of Reader or Writer.
Each of these stream subtypes has a specific purpose, and, despite its size, java.io is a straightforward package to understand and to use.
In Java 1.4, the java.io package was complemented by a “New I/O API” defined in the java.nio package and its subpackages.
The java.nio package is totally new, although it included some compatibility with the classes in this package.
It was designed for high-performance I/O, particularly for use in servers and has a lowerlevel API than this package does.
The I/O facilities of java.io are still quite adequate for most of the I/O required by typical client-side applications.
Before we consider the stream classes that comprise the bulk of this package, let’s examine the important nonstream classes.
File represents a file or directory name in a system-independent way and provides methods for listing directories, querying file attributes, and renaming and deleting files.
FilenameFilter is an interface that defines a method that accepts or rejects specified filenames.
It is used by File to specify what types of files should be included in directory listings.
RandomAccessFile allows you to read from or write to arbitrary locations of a file.
Often, though, you’ll prefer sequential access to a file and should use one of the stream classes.
InputStream and OutputStream are abstract classes that define methods for reading and writing bytes.
Their subclasses allow bytes to be read from and written to a variety of sources and sinks.
PipedInputStream reads bytes from a PipedOutputStream, and PipedOutputStream writes bytes to a PipedInputStream.
These classes work together to implement a pipe for communication between threads.
FilterInputStream and FilterOutputStream are special; they filter input and output bytes.
When you create a FilterInputStream, you specify an InputStream for it to filter.
When you call the read( ) method of a FilterInputStream, it calls the read( ) method of its InputStream, processes the bytes it reads, and returns the filtered bytes.
Calling the write( ) method of a FilterOutputStream causes it to process your bytes in some way and then pass those filtered bytes to the write( ) method of its OutputStream.
FilterInputStream and FilterOutputStream do not perform any filtering themselves; this is done by their subclasses.
DataInputStream reads raw bytes from a stream and interprets them in various binary formats.
It has various methods to read primitive Java data types in their standard binary formats.
DataOutputStream allows you to write Java primitive data types in binary format.
These byte-stream classes are used for serializing and deserializing the internal state of objects for storage or interprocess communication.
The byte streams just described are complemented by an analogous set of character input and output streams.
Reader is the superclass of all character input streams, and Writer is the superclass of all character output streams.
Most of the Reader and Writer streams have obvious byte-stream analogs.
BufferedReader is a commonly used stream; it provides buffering for efficiency and also has a readLine( ) method to read a line of text at a time.
PrintWriter is another very common stream; its methods allow output of a textual representation of any primitive Java type or of any object (via the object’s toString( ) method)
Java 5.0 adds the Closeable and Flushable interfaces to identify types that have close( ) and flush( ) methods.
All streams have a close( ) method and implement the Closeable interface.
And all byte and character output streams have a flush( ) method and implement Flushable.
Finally, both PrintStream and PrintWriter have been enhanced in two ways for Java 5.0
Both now include constructors for creating a stream that writes directly to a file.
And both include formatted-text output methods printf( ) and format( )
This class is a FilterInputStream that provides input data buffering; efficiency is increased by reading in a large amount of data and storing it in an internal buffer.
When data is requested, it is usually available from the buffer.
Thus, most calls to read data do not actually have to read data from a disk, network, or other slow source.
This class is a FilterOutputStream that provides output data buffering; output efficiency is increased by storing values to be written in a buffer and actually writing them out only when the buffer fills up or when the flush( ) method is called.
Protected Instance Fields protected volatile byte[ ] buf; protected int count; protected int marklimit; protected int markpos; protected int pos;
This class applies buffering to a character input stream, thereby improving the efficiency of character input.
You create a BufferedReader by specifying some other character input stream from which it is to buffer input.
You can also specify a buffer size at this time, although the default size is usually fine.
Typically, you use this sort of buffering with a FileReader or InputStreamReader.
BufferedReader defines the standard set of Reader methods and provides a readLine( ) method that reads a line of text (not including the line terminator) and returns it as a String.
It also provides a replacement for the deprecated readLine( ) method of DataInputStream, which did not properly convert bytes into characters.
Public Methods Overriding FilterOutputStream public void flush( ) throws IOException;  synchronized public void write(int b) throws IOException;  synchronized public void write(byte[ ] b, int off, int len) throws IOException;  synchronized.
Protected Instance Fields protected byte[ ] buf; protected int count;
This class applies buffering to a character output stream, improving output efficiency by coalescing many small write requests into a single larger request.
You create a BufferedWriter by specifying some other character output stream to which it sends its buffered and coalesced output.
You can also specify a buffer size at this time, although the default size is usually satisfactory.
Typically, you use this sort of buffering with a FileWriter or OutputStreamWriter.
BufferedWriter defines the standard write( ), flush( ), and close( ) methods all output streams define, but it adds a newLine( ) method that outputs the platform-dependent line separator (usually a newline character, a carriage-return character, or both) to the stream.
This class is a subclass of InputStream in which input data comes from a specified array of byte values.
This is useful when you want to read data in memory as if it were coming from a file, pipe, or socket.
Public Methods Overriding Writer public void close( ) throws IOException; public void flush( ) throws IOException; public void write(int c) throws IOException; public void write(char[ ] cbuf, int off, int len) throws IOException; public void write(String s, int off, int len) throws IOException;
This class is a subclass of OutputStream in which output data is stored in an internal byte array.
The internal array grows as necessary and can be retrieved with toByteArray( ) or toString( )
The reset( ) method discards any data currently stored in the internal array and stores data from the beginning again.
This class is a character input stream that uses a character array as the source of the characters it returns.
You create a CharArrayReader by specifying the character array (or portion of an array) it is to read from.
CharArrayReader defines the usual Reader methods and supports the mark( ) and reset( ) methods.
Note that the character array you pass to the CharArrayReader( ) constructor is not copied.
This means that changes you make to the elements of the array after you create the input stream affect the values read from the array.
Protected Instance Fields protected byte[ ] buf; protected int count;
This class is a character output stream that uses an internal character array as the destination of characters written to it.
When you create a CharArrayWriter, you may optionally specify an initial size for the character array, but you do not specify the character array itself; this array is managed internally by the CharArrayWriter and grows as necessary to accommodate all the characters written to it.
The toString( ) and toCharArray( ) methods return a copy of all characters written to the stream, as a string and an array of characters, respectively.
CharArrayWriter defines the standard write( ), flush( ), and close( ) methods all Writer subclasses define.
Finally, writeTo( ) writes the contents of the internal character array to some other specified character stream.
Protected Instance Fields protected char[ ] buf; protected int count; protected int markedPos; protected int pos;
Signals an error when converting bytes to characters or vice versa.
This interface defines a close( ) method and is implemented by closeable objects such as java.io streams and java.nio channels.
Protected Instance Fields protected char[ ] buf; protected int count;
This class is a type of FilterInputStream that allows you to read binary representations of Java primitive data types in a portable way.
Create a DataInputStream by specifying the InputStream that is to be filtered in the call to the constructor.
DataInputStream reads only primitive Java types; use ObjectInputStream to read object values.
Many of the methods read and return a single Java primitive type, in binary format, from the stream.
By contrast, readFully( ) reads data into an array of bytes, but blocks until all requested data becomes available.
The returned string is not terminated with a newline or carriage return.
This method is deprecated as of Java 1.1; see BufferedReader for an alternative.
UTF-8 is an ASCIIcompatible encoding of Unicode characters that is often used for the transmission and storage of Unicode text.
This class uses a modified UTF-8 encoding that never contains embedded null characters.
This class is a subclass of FilterOutputStream that allows you to write Java primitive data types in a portable binary format.
Create a DataOutputStream by specifying the OutputStream that is to be filtered in the call to the constructor.
DataOutputStream has methods that output only primitive types; use ObjectOutputStream to output object values.
Many of this class’s methods write a single Java primitive type, in binary format, to the output stream.
Public Methods Overriding FilterInputStream public final int read(byte[ ] b) throws IOException; public final int read(byte[ ] b, int off, int len) throws IOException;
UTF-8 is an ASCII-compatible encoding of Unicode characters that is often used for the transmission and storage of Unicode text.
Except for the writeUTF( ) method, this class is used for binary output of data.
Textual output should be done with PrintWriter (or PrintStream in Java 1.0)
This interface defines the methods that must be implemented by an object that wants complete control over the way it is serialized.
The writeExternal( ) and readExternal( ) methods should be implemented to write and read object data in some arbitrary format, using.
Externalizable objects must serialize their own fields and are also responsible for serializing the fields of their superclasses.
Most objects do not need to define a custom output format and can use the Serializable interface instead of Externalizable for serialization.
It also provides methods to list the files in a directory; check the existence, readability, writability, type, size, and modification time of files and directories; make new directories; rename files and directories; delete files and directories; and create and delete temporary and lock files.
The constants defined by this class are the platform-dependent directory and path-separator characters, available as a String and a char.
If not, getAbsolutePath( ) returns an absolute filename created by appending the relative filename to the current working directory.
This can be useful when comparing two File objects to see if they refer to the same file or directory.
In Java 1.4 and later, the toURI( ) method returns a java.net.URI object that uses a file: scheme to name this file.
This file-to-URI transformation can be reversed by passing a file: URI object to the File( ) constructor.
Prior to Java 1.2, the File class doesn’t provide any way to create a file; that task is accomplished typically with FileOutputStream.
Two special-purpose file creation methods were added in Java 1.2
One version of this method creates the file in a specified directory, and the other creates it in the system temporary directory.
Applications can use temporary files for any purpose without worrying about overwriting files belonging to other applications.
The other file-creation method of Java 1.2 is createNewFile( )
This instance method attempts to create a new, empty file with the name specified by the File object.
When working with createTempFile( ) or createNewFile( ), consider using deleteOnExit( ) to request that the files be deleted when the Java VM exits normally.
Public Constants public static final String pathSeparator; public static final char pathSeparatorChar; public static final String separator; public static final char separatorChar;
The static in, out, and err variables are FileDescriptor objects that represent the standard input, output, and error streams, respectively.
There is no public constructor method to create a FileDescriptor object.
You can obtain one with the getFD( ) method of FileInputStream, FileOutputStream, or RandomAccessFile.
This interface, added in Java 1.2, defines an accept( ) method that filters a list of files.
You can list the contents of a directory by calling the listFiles( ) method of the File object that represents the desired directory.
If you want a filtered listing, such as a listing of files but not subdirectories or a listing of files whose names end in .class, you can pass a FileFilter object to listFiles( )
For each entry in the directory, a File object is passed to the.
If accept( ) returns true, that File is included in the return value of listFiles( )
If accept( ) returns false, that entry is not included in the listing.
Use FilenameFilter if compatibility with previous releases of Java is required or if you prefer to filter filenames (i.e., String objects) rather than File objects.
This class is a subclass of InputStream that reads bytes from a file specified by name or by a File or FileDescriptor object.
To read text, you typically use it with an InputStreamReader and BufferedReader.
Call close( ) to close the file when input is no longer needed.
In Java 1.4 and later, use getChannel( ) to obtain a FileChannel object for reading from the underlying file using the New I/O API of java.nio and its subpackages.
This interface defines the accept( ) method that must be implemented by any object that filters filenames (i.e., selects a subset of filenames from a list of filenames)
A typical FilenameFilter object might check that the specified File represents a file (not a directory), is readable (and possibly writable as well), and that its name ends with some desired extension.
An IOException that signals that a specified file cannot be found.
This class is a subclass of OutputStream that writes data to a file specified by name or by a File or FileDescriptor object.
If the specified file already exists, a FileOutputStream can be configured to overwrite or append to the existing file.
To write text, you typically use it with a PrintWriter, BufferedWriter and an OutputStreamWriter (or you use the convenience class FileWriter)
Use close( ) to close a FileOutputStream when no further output will be written to it.
In Java 1.4 and later, use getChannel( ) to obtain a FileChannel object for writing to the underlying file using the New I/O API of java.nio and its subpackages.
A FilePermission has a name, or target, which specifies what file or files it pertains to, and a commaseparated list of actions that may be performed on the file or files.
Read and write permission are required by any methods that read or write a file.
Delete permission is required by File.delete( ), and execute permission is required by Runtime.exec( )
The name of a FilePermission may be as simple as a file or directory name.
FilePermission also supports the use of certain wildcards, however, to specify a permission that applies to more than one file.
If the name is a directory name followed by /– (\– on Windows), it specifies all files in the directory, and, recursively, all files in all subdirectories.
A * alone specifies all files in the current directory, and a – alone specifies all files in or beneath the current directory.
Programmers writing system-level code and system administrators configuring security policies may need to use it, however.
Restricting access (especially write access) to files is one of the cornerstones of the Java security model with regard to untrusted code.
FileReader is a convenience subclass of InputStreamReader that is useful when you want to read text (as opposed to binary data) from a file.
You create a FileReader by specifying the file to be read in any of three possible forms.
The FileReader constructor internally creates a FileInputStream to read bytes from the specified file and uses the functionality of its superclass, InputStreamReader, to convert those bytes from characters in the local encoding to the Unicode characters used by Java.
Because FileReader is a trivial subclass of InputStreamReader, it does not define any read( ) methods or other methods of its own.
FileWriter is a convenience subclass of OutputStreamWriter that is useful when you want to write text (as opposed to binary data) to a file.
You create a FileWriter by specifying the file to be written to and, optionally, whether the data should be appended to the end of an existing file instead of overwriting that file.
If you want to use an encoding other than the default, you cannot use FileWriter; in that case you must create your own OutputStreamWriter and FileOutputStream.
This class provides method definitions required to filter data obtained from the InputStream specified when the FilterInputStream is created.
It must be subclassed to perform some sort of filtering operation and cannot be instantiated directly.
This class provides method definitions required to filter the data to be written to the OutputStream specified when the FilterOutputStream is created.
It must be subclassed to perform some sort of filtering operation and may not be instantiated directly.
This abstract class is intended to act as a superclass for character input streams that read data from some other character input stream, filter it in some way, and then.
FilterReader is declared abstract so that it cannot be instantiated.
But none of its methods are themselves abstract: they all simply call the requested operation on the input stream passed to the FilterReader( ) constructor.
If you were allowed to instantiate a FilterReader, you’d find that it is a null filter (i.e., it simply reads characters from the specified input stream and returns them without any kind of filtering)
Because FilterReader implements a null filter, it is an ideal superclass for classes that want to implement simple filters but do not want to override all the methods of Reader.
In order to create your own filtered character input stream, you should subclass FilterReader and override both its read( ) methods to perform the desired filtering operation.
Note that you can implement one of the read( ) methods in terms of the other, and thus only implement the filtration once.
Recall that the other read( ) methods defined by Reader are implemented in terms of these methods, so you do not need to override those.
In some cases, you may need to override other methods of FilterReader and provide methods or constructors that are specific to your subclass.
This abstract class is intended to act as a superclass for character output streams that filter the data written to them before writing it to some other character output stream.
FilterWriter is declared abstract so that it cannot be instantiated.
But none of its methods are themselves abstract: they all simply invoke the corresponding method on the output stream that was passed to the FilterWriter constructor.
If you were allowed to instantiate a FilterWriter object, you’d find that it acts as a null filter (i.e., it simply passes the characters written to it along, without any filtration)
Because FilterWriter implements a null filter, it is an ideal superclass for classes that want to implement simple filters without having to override all of the methods of Writer.
In order to create your own filtered character output stream, you should subclass FilterWriter and override all its write( ) methods to perform the desired filtering operation.
In some cases, you may want to override other Writer methods and add other methods or constructors that are specific to your subclass.
This interface defines a flush( ) method and is implemented by flushable objects such as java.io streams.
This abstract class is the superclass of all input streams.
It defines the basic input methods all input stream classes provide.
It returns the bytes read, the number of bytes read, or –1 if the endof-file has been reached.
The stream should not be used after close( ) has been called.
If markSupported( ) returns true for a given InputStream, that stream supports mark( ) and reset( ) methods.
This class is a character input stream that uses a byte input stream as its data source.
It reads bytes from a specified InputStream and translates them into Unicode characters according to a particular platform- and locale-dependent character encoding.
It also has a getEncoding( ) method that returns the name of the encoding being used to convert bytes to characters.
When you create an InputStreamReader, you specify an InputStream from which the InputStreamReader is to read bytes and, optionally, the name of the character encoding used by those bytes.
If you do not specify an encoding name, the InputStreamReader uses the default encoding for the default locale, which is usually the correct thing to do.
Prior to Java 1.4, the class allows you to specify only the name of the desired charset encoding.
Methods Implementing Closeable public void close( ) throws IOException;  empty.
An IOException that signals that an input or output operation was interrupted.
The bytesTransferred field contains the number of bytes read or written before the operation was interrupted.
Signals that the serialization mechanism has encountered one of several possible problems with the class of an object that is being serialized or deserialized.
The classname field should contain the name of the class in question, and the getMessage( ) method is overridden to return this class name with the message.
Signals that an exceptional condition has occurred during input or output.
This class is a FilterInputStream that keeps track of the number of lines of data that have been read.
This class is deprecated as of Java 1.1 because it does not properly convert bytes to characters.
This class is a character input stream that keeps track of the number of lines of text that have been read from it.
It supports the usual Reader methods and also the readLine( ) method introduced by its superclass.
In addition to these methods, you can call getLineNumber( ) to query the number of lines set so far.
You can also call setLineNumber( ) to set the line number for the current line.
Subsequent lines are numbered sequentially from this specified starting point.
It indicates that the invoked method was not invoked at the right time or in the correct context.
Typically, it means that an ObjectOutputStream or ObjectInputStream is not currently active and therefore the requested operation cannot be performed.
Public Methods Overriding BufferedReader public void mark(int readAheadLimit) throws IOException; public int read( ) throws IOException; public int read(char[ ] cbuf, int off, int len) throws IOException; public String readLine( ) throws IOException; public void reset( ) throws IOException; public long skip(long n) throws IOException;
It is thrown when serialization is attempted on an instance of a class that does not implement the Serializable interface.
Note that it is also thrown when an attempt is made to serialize a Serializable object that refers to (or contains) an object that is not Serializable.
A subclass of a class that is Serializable can prevent itself from being serialized by throwing this exception from its writeObject( ) and/ or readObject( ) methods.
This interface extends the DataInput interface and adds methods for deserializing objects and reading bytes and arrays of bytes.
If you define such a method, there are several ObjectInputStream methods you can use to help deserialize the object.
It reads the content of the object just as an ObjectInputStream would normally do.
If you wrote additional data before or after the default object contents, you should read that data before or after calling defaultReadObject( )
When working with multiple versions or implementations of a class, you may have to deserialize a set of fields that do not match the fields of your class.
This class holds the values of named fields read by an ObjectInputStream.
It gives the programmer precise control over the deserialization process and is typically used when implementing an object with a set of fields that do not match the set of fields (and the serialization stream format) of the original implementation of the object.
This class allows the implementation of a class to change without breaking serialization compatibility.
In order to use the GetField class, your class must implement a private readObject( ) method that is responsible for custom deserialization.
This array specifies the names and types of all fields expected to be found when reading from a serialization stream.
Within the readObject( ) method of your class, call the readFields( ) method of ObjectInputStream( )
This GetField object is essentially a mapping from field names to field values, and you can extract the values of whatever fields you need in order to restore the proper state of the object being deserialized.
The various get( ) methods return the values of named fields of specified types.
Each method takes a default value as an argument, in case no value for the named field was present in the serialization stream.
This can happen when deserializing an object written by an earlier version of the class, for example.
Use the defaulted( ) method to determine whether the GetField object contains a value for the named field.
If this method returns true, the named field had no value in the stream, so the get( ) method of the GetField object has to return the specified default value.
This ObjectStreamClass can obtain the array of ObjectStreamField objects for the class.
This interface extends the DataOutput interface and adds methods for serializing objects and writing bytes and arrays of bytes.
The ObjectOutputStream serializes objects, arrays, and other values to a stream.
The writeObject( ) method serializes an object or array, and various other methods write primitive data values to the stream.
Note that only objects that implement the Serializable or Externalizable interface can be serialized.
This method is invoked when an object is being serialized and can use several additional methods of ObjectOutputStream.
An object can call this method to serialize itself and then use other methods of ObjectOutputStream to write additional data to the serialization stream.
The class must define a matching readObject( ) method to read that additional data, of course.
When working with multiple versions or implementations of a class, you may have to serialize a set of fields that do not precisely match the fields of your class.
Store field names and values into this object, and then call writeFields( ) to write them out to the serialization stream.
This class holds values of named fields and allows them to be written to an ObjectOutputStream during the process of object serialization.
It gives the programmer precise control over the serialization process and is typically used when the set of fields defined by a class does not match the set of fields (and the serialization stream format) defined by the original implementation of the class.
This array defines the set of fields written to the ObjectOutputStream and therefore defines the serialization format.
Once you have this object, use its various put( ) methods to specify the names and values of the field to be written out.
You may specify the fields in any order; the PutField class is responsible for writing them out in the correct order.
Once you have specified the values of all fields, call the write( ) method of your PutField object in order to write the field values out to the serialization stream.
Methods Implementing ObjectOutput public void close( ) throws IOException; public void flush( ) throws IOException; public void write(int val) throws IOException; public void write(byte[ ] buf) throws IOException; public void write(byte[ ] buf, int off, int len) throws IOException; public final void writeObject(Object obj) throws IOException;
An ObjectStreamClass object contains the name of a class, its unique version identifier, and the name and type of the fields that constitute the serialization format for the class.
It returns either the value of the private serialVersionUID field of the class or a computed value that is based upon the public API of the class.
In Java 1.2 and later, getFields( ) returns an array of ObjectStreamField objects that represent the names and types of the fields of the class to be serialized.
By default, these methods use all the fields of a class except those that are static or transient.
The value of this field should be the desired array of ObjectStreamField objects.
ObjectStreamClass class does not have a constructor; you should use the static lookup( ) method to obtain an ObjectStreamClass object for a given Class object.
The forClass( ) instance method performs the opposite operation; it returns the Class object that corresponds to a given ObjectStreamClass.
The other constants defined by this interface are low-level values used by the serialization protocol.
You do not need to use them unless you are reimplementing the serialization mechanism yourself.
This class is the superclass of a number of more specific exception types that may be raised in the process of serializing and deserializing objects with the ObjectOutputStream and ObjectInputStream classes.
This class represents a named field of a specified type (i.e., a specified Class)
When a class serializes itself by writing a set of fields that are different from the fields it uses in its own implementation, it defines the set of fields to be written with an array of ObjectStreamField objects.
The methods of this class are used internally by the serialization mechanism and are not typically used elsewhere.
Thrown by the readObject( ) method of an ObjectInputStream when it encounters primitive type data where it expects object data.
Despite the exception name, this data is not optional, and object deserialization is stopped.
This abstract class is the superclass of all output streams.
It defines the basic output methods all output stream classes provide.
The stream may not be used once close( ) has been called.
Methods Implementing Closeable public void close( ) throws IOException;  empty.
Methods Implementing Flushable public void flush( ) throws IOException;  empty.
This class is a character output stream that uses a byte output stream as the destination for its data.
It also has a getEncoding( ) method that returns the name of the encoding being used to convert characters to bytes.
If you do not specify an encoding name, the OutputStreamWriter uses the default encoding of the default locale, which is usually the correct thing to do.
Prior to Java 1.4, the class allows you to specify only the name of the desired charset encoding.
This class is an InputStream that implements one half of a pipe and is useful for communication between threads.
A PipedInputStream must be connected to a PipedOutputStream object, which may be specified when the PipedInputStream is created or with the connect( ) method.
Data read from a PipedInputStream object is received from the PipedOutputStream to which it is connected.
See InputStream for information on the low-level methods for reading data from a PipedInputStream.
A FilterInputStream can provide a higher-level interface for reading data from a PipedInputStream.
This class is an OutputStream that implements one half a pipe and is useful for communication between threads.
A PipedOutputStream must be connected to a PipedInputStream, which may be specified when the PipedOutputStream is created or with the connect( ) method.
Data written to the PipedOutputStream is available for reading on the PipedInputStream.
See OutputStream for information on the low-level methods for writing data to a PipedOutputStream.
A FilterOutputStream can provide a higher-level interface for writing data to a PipedOutputStream.
Public Methods Overriding OutputStream public void close( ) throws IOException; public void flush( ) throws IOException;  synchronized public void write(int b) throws IOException; public void write(byte[ ] b, int off, int len) throws IOException;
PipedReader is a character input stream that reads characters from a PipedWriter character output stream to which it is connected.
PipedReader implements one half of a pipe and is useful for communication between two threads of an application.
A PipedReader cannot be used until it is connected to a PipedWriter object, which may be passed to the PipedReader( ) constructor or to the connect( ) method.
PipedWriter is a character output stream that writes characters to the PipedReader character input stream to which it is connected.
PipedWriter implements one half of a pipe and is useful for communication between two threads of an application.
A PipedWriter cannot be used until it is connected to a PipedReader object, which may be passed to the PipedWriter( ) constructor or to the connect( ) method.
Public Methods Overriding Writer public void close( ) throws IOException; public void flush( ) throws IOException;  synchronized.
This class is a byte output stream that implements a number of methods for displaying textual representations of Java primitive data types.
PrintStream converts characters to bytes using the platform’s default charset, or the charset or encoding named in the PrintStream( ) constructor invocation.
In Java 5.0, convenience constructors allow you to specify a file (either as a file name or a File object) as the destination of a PrintStream.
Prior to Java 5.0 the destination had to be another OutputStream object.
The print( ) methods output standard textual representations of each data type.
The println( ) methods do the same and follow the representations with newlines.
Each method converts a Java primitive type to a String representation and outputs the resulting string.
When an Object is passed to a print( ) or println( ), it is converted to a String by calling its toString( ) method.
In Java 5.0, you can also use the printf( ) methods (or the format( ) methods that behave identically) for formatted output.
See also PrintWriter for a character output stream with similar functionality.
And see DataOutputStream for a byte output stream that outputs binary, rather than textual, representations of Java’s primitive types.
This class is a character output stream that implements a number of print( ) and println( ) methods that output textual representations of primitive values and objects.
When you create a PrintWriter object, you specify a character or byte output stream that it should write its characters to and, optionally, whether the PrintWriter stream should be automatically flushed whenever println( ) is called.
If you specify a byte output stream as the destination, the PrintWriter( ) constructor automatically creates the necessary OutputStreamWriter object to convert characters to bytes using the default encoding.
In Java 5.0, convenience constructors allow you to specify a file (either as a file name or a File object) as the destination.
You may optionally specify the name of a charset to use for character-to-byte conversion when writing to the file.
PrintWriter implements the normal write( ), flush( ), and close( ) methods all Writer subclasses define.
It is more common to use the higher-level print( ) and println( ) methods, each of which converts its argument to a string before outputting it.
In Java 5.0, you can also use the printf( ) methods (or the format( ) methods that behave identically) for formatted output.
Instead, when errors occur, they set an internal flag you can check by calling checkError( )
Once an error has occurred on a PrintWriter object, all subsequent calls to checkError( ) return true; there is no way to reset the error flag.
PrintWriter is the character stream analog to PrintStream, which it supersedes.
You can usually easily replace any PrintStream objects in a program with PrintWriter objects.
The only valid remaining use for the PrintStream class is for the System.out and System.err standard output streams.
This class is a FilterInputStream that implements a one-byte pushback buffer or, as of Java 1.1, a pushback buffer of a specified length.
The unread( ) methods push bytes back into the stream; these bytes are the first ones read by the next call to a read( ) method.
This class is a character input stream that uses another input stream as its input source and adds the ability to push characters back onto the stream.
When you create a PushbackReader stream, you specify the stream to be read from and, optionally, the size of the pushback buffer (i.e., the number of characters that may be pushed back onto the stream or unread)
If you do not specify a size for this buffer, the default size is one character.
PushbackReader inherits or overrides all standard Reader methods and adds three unread( ) methods that push a single character, an array of characters, or a portion of an array of characters back onto the stream.
This class allows you to read and write arbitrary bytes, text, and primitive Java data types from or to any specified location in a file.
Because this class provides random, rather than sequential, access to files, it is neither a subclass of InputStream nor of OutputStream, but provides an entirely independent method for reading and writing data from or to files.
RandomAccessFile implements the same interfaces as DataInputStream and DataOutputStream, and thus defines the same methods for reading and writing data as those classes do.
The seek( ) method provides random access to the file; it is used to select the position in the file where data should be read or written.
The various read and write methods update this file position so that a sequence of read or write operations can be performed on a contiguous portion of the file without having to call the seek( ) method before each read or write.
The mode argument to the constructor methods should be “r” for a file that is to be read-only or “rw” for a file that is to be written (and perhaps read as well)
In Java 1.4 and later, two other values for the mode argument are allowed as well.
Public Instance Methods public void unread(int c) throws IOException; public void unread(char[ ] cbuf) throws IOException; public void unread(char[ ] cbuf, int off, int len) throws IOException;
The “rws” mode is similar, but requires synchronous updates to both the file’s content and its metadata (which includes things such as file access times)
Using “rws” mode may require that the file metadata be modified every time the file is read.
In Java 1.4 and later, use the getChannel( ) method to obtain a FileChannel object that you can use to access the file using the New I/O API of java.nio and its subpackages.
If the RandomAccessFile was opened with a mode of “r”, the FileChannel allows only reading.
This abstract class is the superclass of all character input streams.
It is an analog to InputStream, which is the superclass of all byte input streams.
Reader defines the basic methods that all character output streams provide.
If ready( ) returns true, the next call to read( ) is guaranteed not to block.
If markSupported( ) returns true, mark( ) marks a position in the stream and, if necessary, creates a look-ahead buffer of the specified size.
Future calls to reset( ) restore the stream to the marked position if they occur within the specified look-ahead limit.
Note that not all stream types support this mark-and-reset functionality.
To create a subclass of Reader, you need only implement the three-argument version of read( ) and the close( ) method.
Methods Implementing Closeable public abstract void close( ) throws IOException;
This class provides a way of seamlessly concatenating the data from two or more input streams.
It provides an InputStream interface to a sequence of InputStream objects.
Data is read from the streams in the order in which the streams are specified.
When the end of one stream is reached, data is automatically read from the next stream.
This class might be useful, for example, when implementing an include file facility for a parser.
Similarly, the readObject( ) method typically invokes the defaultReadObject( ) method of the ObjectInputStream, reads any additional data written by the corresponding writeObject( ) method, and performs any extra initialization required by the object.
This capability is protected by a permission because malicious code can define object stream subclasses that incorrectly serialize and deserialize objects.
Programmers writing system-level code may use it, and system administrators configuring security policies should be familiar with it.
Signals that the data stream being read by an ObjectInputStream has been corrupted and does not contain valid serialized object data.
This class performs lexical analysis of a specified input stream and breaks the input into tokens.
The public variables sval and nval contain the string and numeric values (if applicable) of the most recently read token.
The remaining methods allow you to specify how tokens are recognized.
If so, the TT_EOL constant is returned for end-of-lines; otherwise, they are treated as whitespace.
If so, no part of the comment is returned as a token.
When a string token is parsed, the quote character is returned as the token value, and the body of the string is stored in the sval variable.
Public Instance Fields public double nval; public String sval; public int ttype;
This class is a subclass of InputStream in which input bytes come from the characters of a specified String object.
This class does not correctly convert the characters of a StringBuffer into bytes and is deprecated as of Java 1.1
This class is a character input stream that uses a String object as the source of the characters it returns.
When you create a StringReader, you must specify the String to read from.
StringReader defines the normal Reader methods and supports mark( ) and reset( )
If reset( ) is called before mark( ) has been called, the stream is reset to the beginning of the specified string.
Protected Instance Fields protected String buffer; protected int count; protected int pos;
This class is a character output stream that uses an internal StringBuffer object as the destination of the characters written to the stream.
When you create a StringWriter, you may optionally specify an initial size for the StringBuffer, but you do not specify the StringBuffer itself; it is managed internally by the StringWriter and grows as necessary to accommodate the characters written to it.
StringWriter defines the standard write( ), flush( ), and close( ) methods all Writer subclasses define, as well as two methods to obtain the characters that have been written to the stream’s internal buffer.
Note that getBuffer( ) returns a reference to the actual internal buffer, not a copy of it, so any changes you make to the buffer are reflected in subsequent calls to toString( )
StringWriter is quite similar to CharArrayWriter, but does not have a byte-stream analog.
Signals that a requested character encoding is not supported by the current Java Virtual Machine.
An IOException that signals that a malformed UTF-8 string has been encountered by a class that implements the DataInput interface.
UTF-8 is an ASCII-compatible transformation format for Unicode characters that is often used to store and transmit Unicode text.
Thrown when reading a stream of data that is incomplete because an exception was thrown while it was being written.
The detail field may contain the exception that terminated the output stream.
In Java 1.4 and later, this exception can also be obtained with the standard Throwable getCause( ) method.
The getMessage( ) method has been overridden to include the message of this detail exception, if any.
This abstract class is the superclass of all character output streams.
It is an analog to OutputStream, which is the superclass of all byte output streams.
Writer defines the basic write( ), flush( ), and close( ) methods all character output streams provide.
The five versions of the write( ) method write a single character, a character array or subarray, or a string or substring to the destination of the stream.
The most general version of this method—the one that writes a specified portion of a character array—is abstract and must be implemented by all subclasses.
By default, the other write( ) methods are implemented in terms of this abstract one.
The flush( ) method is another abstract method all subclasses must implement.
It should force any output buffered by the stream to be written to its destination.
If that destination is itself a character or byte output stream, it should invoke the flush( ) method of the destination stream as well.
A subclass must implement this method so that it flushes and then closes the current stream and also closes whatever destination stream it is connected to.
Once the stream is closed, any future calls to write( ) or flush( ) should throw an IOException.
In Java 5.0, this class has been modified to implement the Closeable and Flushable interfaces.
Methods Implementing Closeable public abstract void close( ) throws IOException;
Methods Implementing Flushable public abstract void flush( ) throws IOException;
This chapter covers the java.lang package which defines the core classes and interfaces that are indispensable to the Java platform and the Java programming language.
The java.lang package contains the classes that are most central to the Java language.
Object is the ultimate superclass of all Java classes and is therefore at the top of all class hierarchies.
There is one Class object for each class that is loaded into Java.
Void is a related class that defines a representation for the void method return type, but that defines no methods.
String is an immutable type, while StringBuffer can have its string changed in place.
In Java 5.0, StringBuilder is like StringBuffer but without synchronized methods, which makes it the preferred choice in most applications.
String, StringBuffer and StringBuilder implement the Java 1.4 interface CharSequence which allows instances of these classes to be manipulated through a simple shared API.
Cloneable is an important marker interface that specifies that the Object.clone( ) method is allowed to make copies of an object.
The Math class (and, in Java 1.3, the StrictMath class) defines static methods for various floating-point mathematical functions.
The Thread class provides support for multiple threads of control running within the same Java interpreter.
The Runnable interface is implemented by objects that have a run( ) method that can serve as the body of a thread.
Runtime provides similar low-level methods, including an exec( ) method that, along with the Process class, defines a platform-dependent API for running external processes.
Java 5.0 allows Process objects to be created more easily with the ProcessBuilder class.
Throwable is the root class of the exception and error hierarchy.
Throwable objects are used with the Java throw and catch statements.
Exception and Error are the superclasses of all exceptions and errors.
RuntimeException defines a special class or “unchecked exceptions” that do not need to be declared in a method’s throws clause.
The Throwable class was overhauled in Java 1.4, adding the ability to “chain” exceptions, and the ability to obtain the stack trace of an exception as an array of StackTraceElement objects.
Iterable marks types that have an iterator( ) method and enables iteration with the for/in looping statement introduced in Java 5.0
The Appendable interface is implemented by classes (such as StringBuilder and character output streams) that can have characters appended to them.
The Readable interface is implemented by classes (such as character input streams) that can sequentially copy characters into a buffer.
Also new in Java 5.0 is Enum, which serves as the superclass of all enumerated types declared with the new enum keyword.
Deprecated, Override, and SuppressWarnings are annotation types that provide metadata for the compiler.
This package-private class is the abstract superclass of StringBuffer and StringBuilder.
Because this class is not public, you may not use it directly.
It is included in this quickreference to fully document the shared API of its two subclasses.
StringBuilder and StringBuffer( ) override those methods and narrow the return type to StringBuilder or StringBuffer.
This is an example of “covariant returns,” which are allowed in Java 5.0 and later.
Objects that implement this interface can have characters or character sequences appended to them.
A RuntimeException that signals an exceptional arithmetic condition, such as integer division by zero.
Signals that an array index less than zero or greater than or equal to the array size has been used.
Signals an attempt to store the wrong type of object into an array.
An instance of this class is thrown if when an assertion fails.
This happens when assertions are enabled, and the expression following an assert statement does not evaluate to true.
If an assertion fails, and the assert statement has a second expression separated from the first by a colon, then the second expression is evaluated and the resulting value is passed to the AssertionError() constructor, where it is converted to a string and used as the error message.
This class provides an immutable object wrapper around the boolean primitive type.
Note that the TRUE and FALSE constants are Boolean objects; they are not the same as the true and false boolean values.
As of Java 1.1, this class defines a Class constant that represents the boolean type.
The class method getBoolean( ) retrieves the boolean value of a named property from the system property list.
The static method valueOf( ) parses a string and returns the Boolean object it represents.
Java 1.4 added two static methods that convert primitive boolean values to Boolean and String objects.
In Java 5.0, the parseBoolean( ) method behaves like valueOf( ) but returns a primitive boolean value instead of a Boolean object.
Prior to Java 5.0, this class does not implement the Comparable interface.
This class provides an immutable object wrapper around the byte primitive type.
It defines useful constants for the minimum and maximum values that can be stored by the byte type and a Class object constant that represents the byte type.
It also provides various methods for converting Byte values to and from strings and other numeric types.
Most of the static methods of this class can convert a String to a Byte object or a byte value: the four parseByte( ) and valueOf( ) methods parse a number from the specified string using an optionally specified radix and return it in one of these two forms.
If it begins with “0”, it is interpreted as an octal number.
One is static and converts a byte primitive value to a string; the other is the usual toString( ) method that converts a Byte object to a string.
Most of the remaining methods convert a Byte to various primitive numeric types.
This class provides an immutable object wrapper around the primitive char data type.
The compareTo( ) method implements the Comparable interface so that Character objects can be ordered and sorted.
The static methods are the most interesting thing about this class, however: they categorize char values based on the categories defined by the Unicode standard.
Some of the methods are only useful if you have a detailed understanding of that standard.
Static methods beginning with “is” test whether a character is in a given category.
Note that these methods work for any Unicode character, not just with the familiar Latin letters and Arabic numbers of the ASCII character set.
In addition to testing the category of a character, this class also defines static methods for converting characters.
It works with any Unicode digit character, and also (for sufficiently large radix values) the ASCII letters a-z and A-Z.
Finally, the static toString( ) method returns a String of length 1 that contains the specified char value.
The two representations for these supplementary characters are as an int codepoint in the range 0 through 0x10ffff, or as a sequence of two char values known as a “surrogate pair.” The first char of such a pair should fall in the “high surrogate” range and the second char should fall in the “low surrogate” range.
Finally, the various character type testing and case conversion methods such as isWhitespace( ) and toUpperCase( ) are available in new versions that take an int codepoint argument instead of a single char argument.
This class represents a named subset of the Unicode character set.
The toString( ) method returns the name of the subset.
Note, in particular, that it does not provide a way to list the members of the subset, nor a way to test for membership in the subset.
This subclass of Character.Subset defines a number of constants that represent named subsets of the Unicode character set.
The subsets and their names are the character blocks defined by the Unicode specification (see http://www.unicode.org/)
When presented with an unknown Unicode character, this method provides a useful way to determine what alphabet it belongs to.
In Java 5.0, the forName( ) factory method allows lookup of a UnicodeBlock by name.
This interface defines a simple API for read-only access to sequences of characters.
Finally, toString( ) returns a String version of the sequence.
Note that CharSequence implementations do not typically have interoperable equals( ) or hashCode( ) methods, and it is not usually possible to compare two CharSequence objects or use multiple sequences in a set or hashtable unless they are instances of the same implementing class.
There is one Class object for each class that is loaded into the Java Virtual Machine, and, as of Java 1.1, there are special Class objects that represent the Java primitive types.
The TYPE constants defined by Boolean, Integer, and the other primitive wrapper classes hold these special Class objects.
Array types are also represented by Class objects in Java 1.1
You can obtain a Class object by calling the getClass( ) method of any instance of the desired class.
In Java 1.1 and later, you can also refer to a Class object by appending .class to the name of a class.
Finally, and most interestingly, a class can be dynamically loaded by passing its fully qualified name (i.e., package name plus class name) to the static Class.forName( ) method.
This method loads the named class (if it is not already loaded) into the Java interpreter and returns a Class object for it.
The newInstance( ) method creates an instance of a given class; this allows you to create instances of dynamically loaded classes for which you cannot use the new keyword.
Note that this method works only when the target class has a no-argument constructor.
In Java 5.0, Class is a generic type and the type variable T specifies the type that is returned by the newInstance( ) method.
In Java 1.2 and later, getPackage( ) returns a Package object that represents the package containing the class.
Java 5.0 adds a number of methods to support the new language features it defines.
Java 5.0 also adds methods that are useful for reflection on inner classes.
Finally, getSimpleName( ) returns the name of a type as it would appear in Java source code.
This is typically more useful than the Java VM formatted names returned by getName( )
Signals an invalid cast of an object to a type of which it is not an instance.
Signals that a circular dependency has been detected while performing initialization for a class.
Signals an error in the binary format of a class file.
This class is the abstract superclass of objects that know how to load Java classes into a Java VM.
Given a ClassLoader object, you can dynamically load a class by calling the public loadClass( ) method, specifying the full name of the desired class.
In order to load classes over the network or from any source other than the class path, you must use a custom ClassLoader object that knows how to obtain data from that source.
Only rarely should an application need to define a ClassLoader subclass of its own.
This method must find the bytes that comprise the named class, then pass them to the defineClass( ) method and return the resulting Class object.
In Java 1.2 and later, the findClass( ) method must also define the Package object associated with the class, if it has not already been defined.
It can use getPackage( ) and definePackage( ) for this purpose.
Custom subclasses of ClassLoader should also override findResource( ) and findResources( ) to enable the public getResource( ) and getResources( ) methods.
In Java 1.4 and later you can specify whether the classes loaded through a ClassLoader should have assertions (assert statements) enabled.
Signals that a class to be loaded cannot be found.
If an exception of this type was caused by some underlying exception, you can query that lower-level exeption with getException( ) or with the newer, more general getCause( )
This interface defines no methods or variables, but indicates that the class that implements it may be cloned (i.e., copied) by calling the Object method clone( )
Signals that the clone( ) method has been called for an object of a class that does not implement the Cloneable interface.
This interface defines a single method, compareTo( ), that is responsible for comparing one object to another and determining their relative order, according to some natural ordering for that class of objects.
Any general-purpose class that represents a value that can be sorted or ordered should implement this interface.
Many of the key classes in the Java API implement this interface.
The type variable T represents the type of the object that is passed to the compareTo( ) method.
The compareTo( ) method compares this object to the object passed as an argument.
It should assume that the supplied object is of the appropriate type; if it is not, it should throw a ClassCastException.
If this object is less than the supplied object or should appear before the supplied object in a sorted list, compareTo( ) should return a negative number.
If this object is greater than the supplied object or should come after the supplied object in a sorted list, compareTo( ) should return a positive integer.
If compareTo( ) returns 0 for two objects, the equals( ) method should typically return true.
The static methods of this class provide an interface to the just-in-time (JIT) byte-codeto-native code compiler in use by the Java interpreter.
If no JIT compiler is in use by the VM, these methods do nothing.
These methods return true if the compilation was successful, or false if it failed or if there is no JIT compiler on the system.
This annotation type marks the annotated program element as deprecated.
The Java compiler issues a warning if the annotated element is used or overrided in code that is not itself @Deprecated.
This annotation type has runtime retention and does not have an @Target meta-annotation, which means it may be applied to any program element.
This class provides an immutable object wrapper around the double primitive data type.
This class also provides some useful constants and static methods for testing double values.
Similarly, isNaN( ) tests whether a double or Double is not-a-number; this is a comparison that cannot be done directly because the NaN constant never tests equal to any other value, including itself.
The static parseDouble( ) method converts a String to a double.
The static valueOf( ) converts a String to a Double, and is basically equivalent to the Double( ) constructor that takes a String argument.
The static and instance toString( ) methods perform the opposite conversion: they convert a double or a Double to a String.
The compareTo( ) method makes Double object Comparable which is useful for ordering and sorting.
This class is the common superclass of all enumerated types.
It is not itself an enum type, however, and a Java compiler does not allow other classes to extend it.
Subclasses of Enum may be only created with enum declarations.
Enum is a generic type, and the type variable E represents the concrete enumerated type that actually extends Enum.
This type variable exists so that Enum can implement Comparable<E>
The final methods name( ) and ordinal( ) return these values.
Most users of enumerated constants will use toString( ) instead of name( )
The implementation of toString( ) defined by Enum returns the same value as name( )
The toString( ) method is not final, however, and it can be overridden in enum declarations.
Enum implements a number of Object and Comparable methods and makes its implementations final so that they are inherited by all enum types and may not be overridden.
Finally, the compareTo( ) method of the Comparable interface is defined to compare enumerated values based on their ordinal( ) value.
It is like the getClass( ) method inherited from Object, but the return values of these two methods will be different for enumerated constants that have value-specific class bodies, since those constants are instances of an anonymous subclass of the enum type.
This unchecked exception is thrown when Java code attempts to use an enum constant that no longer exists.
This can happen only if the enumerated constant was removed from its enumerated type after the referencing code was compiled.
The methods of the exception provide the Class of the enumerated type and the name of the nonexistent constant.
This class forms the root of the error hierarchy in Java.
Subclasses of Error, unlike subclasses of Exception, should not be caught and generally cause termination of the program.
Subclasses of Error need not be declared in the throws clause of a method definition.
This class inherits methods from Throwable but declares none of its own.
Each of its constructors simply invokes the corresponding Throwable() constructor.
This class forms the root of the exception hierarchy in Java.
An Exception signals an abnormal condition that must be specially handled to prevent program termination.
An exception that is not a subclass of RuntimeException must be declared in the throws clause of any method that can throw it.
This class inherits methods from Throwable but declares none of its own.
Each of its constructors simply invokes the corresponding Throwable( ) constructor.
This error is thrown by the Java Virtual Machine when an exception occurs in the static initializer of a class.
You can use the getException( ) method to obtain the Throwable object that was thrown from the initializer.
In Java 1.4 and later, getException( ) has been superseded by the more general getCause( ) method of the Throwable class.
This class provides an immutable object wrapper around a primitive float value.
This class is very similar to Double, and defines the same set of useful methods and constants as that class does.
Signals an attempted use of a class, method, or field that is not accessible.
It is thrown by the Object notify( ) and wait( ) methods used for thread synchronization.
Signals that a method has been invoked on an object that is not in an appropriate state to perform the requested operation.
Signals that a thread is not in the appropriate state for an attempted operation to succeed.
This is the superclass of a group of related error types.
This class holds a thread-local value that is inherited by child threads.
Note that the inheritance referred to in the name of this class is not from superclass to subclass; it is inheritance from parent thread to.
Like its superclass, this class has been made generic in Java 5.0
The type variable T represents the type of the referenced object.
Note that the value associated with the child thread is independent from the value associated with the parent thread.
By default, a child thread inherits a parent’s values unmodified.
Signals an attempt to instantiate an interface or abstract class.
Signals an attempt to instantiate an interface or an abstract class.
This class provides an immutable object wrapper around the int primitive data type.
This class also contains useful minimum and maximum constants and useful conversion methods.
Each can take a radix argument to specify the base the value is represented in.
Other routines return the value of an Integer as various primitive types, and, finally, the getInteger( ) methods return the integer value of a named property from the system property list, or the specified default value.
Java 5.0 adds a number of static methods that operate on the bits of an int value.
List, Set, and Queue collection interfaces of java.util extend this interface, making all collections other than maps Iterable.
You can implement this interface in your own classes if you want to allow them to be iterated with the for/in loop.
The type variable T specifies the type parameter of the returned Iterator object, which, in turn, specifies the element type of the collection being iterated over.
The superclass of a group of errors that signal problems linking a class or resolving dependencies between classes.
This class provides an immutable object wrapper around the long primitive data type.
This class also contains useful minimum and maximum constants and useful conversion methods.
Each can take a radix argument to specify the base the value is represented in.
Other routines return the value of a Long as various primitive types, and, finally, the getLong( ) methods return the long value of a named property or the value of the specified default.
Java 5.0 adds a number of static methods that operate on the bits of a long value.
Except for their argument type and return type, they are the same as the Integer methods of the same name.
Most methods of Math operate on float and double floating-point values.
Remember that these values are only approximations of actual real numbers.
To allow implementations to take full advantage of the floating-point capabilities of a native platform, the methods of Math are not required to return exactly the same values on all platforms.
In other words, the results returned by different implementations may differ slightly in the least-significant bits.
Signals an attempt to allocate an array with fewer than zero elements.
Signals that the definition of a specified class cannot be found.
This exception signals that the specified field does not exist in the specified class.
Signals that the specified method does not exist in the specified class.
Signals an attempt to access a field or invoke a method of a null object.
All classes are subclasses of Object, and thus all objects can invoke the public and protected methods of this class.
For classes that implement the Cloneable interface, clone( ) makes a byte-for-byte copy of an Object.
A number of these Object methods should be overridden by subclasses of Object.
Defining the toString( ) method for all objects also helps with debugging.
The default implementation of the equals( ) method simply uses the = = operator to test whether this object reference and the specified object reference refer to the same object.
Many subclasses override this method to compare the individual fields of two distinct objects (i.e., they override the method to test for the equivalence of distinct objects rather than the equality of object references)
Some classes, particularly those that override equals( ), may also want to override the hashCode( ) method to provide an appropriate hashcode to be used when storing instances in a Hashtable data structure.
A class that allocates system resources other than memory (such as file descriptors or windowing system graphic contexts) should override the finalize( ) method to release these resources when the object is no longer referred to and is about to be garbage-collected.
Signals that the interpreter has run out of memory (and that garbage collection is unable to free any memory)
An annotation of this type may be applied to methods and indicates that the programmer intends for the method to override a method from a superclass.
In effect, it is an assertion for the compiler to verify.
If a method annotated @Override does not, in fact, override another method (perhaps because the method name was misspelled or an argument was incorrectly typed), the compiler issues an error.
You can obtain the Package object for a given Class by calling the getPackage( ) method of the Class object.
Note that a Package object is not defined unless at least one class has been loaded from that package.
Although you can obtain the Package of a given Class, you cannot obtain an array of Class objects contained in a specified Package.
If the classes that comprise a package are contained in a JAR file that has the appropriate attributes set in its manifest file, the Package object allows you to query the title, vendor, and version of both the package specification and the package implementation; all six values are strings.
It consists of one or more integers, separated from each other by periods.
Each integer can have leading zeros, but is not considered an octal digit.
This allows you to test whether the version of a package (typically a standard extension) is new enough for the purposes of your application.
Packages may be sealed, which means that all classes in the package must come from the same JAR file.
If a package is sealed, the no-argument version of isSealed( ) returns true.
The one-argument version of isSealed( ) returns true if the specified URL represents the JAR file from which the package is loaded.
This class describes a process that is running externally to the Java interpreter.
Note that a Process is very different from a Thread; the Process class is abstract and cannot be instantiated.
Call one of the Runtime.exec( ) methods to start a process and return a corresponding Process object.
Specify these strings in a List, a String[ ], or, most conveniently, using a variable-length argument list of strings.
Before launching the command you have specified, you can configure the ProcessBuilder.
Query the current working directory with the no-argument version of directory( ) and set it with the one-argument version of the method.
Query the mapping of environment variables to values with the environment( ) method.
You can alter the mappings in the returned Map to specify the environment you want the child process to run in.
If you do so, you do not have to arrange to read two separate input streams to get the output of the process.
Once you have specified a command and configured your ProcessBuilder as desired, call the start( ) method to launch the process.
You then use methods of the returned Process to provide input to the process, read output from the process, or wait for the process to exit.
This may occur, for example, if the executable filename you have specified does not exist.
The command( ) and directory( ) methods do not perform error checking on the values you provide them; these checks are performed by the start( ) method, so it is also possible for start( ) to throw exceptions based on bad input to the configuration methods.
Note that a ProcessBuilder can be reused: once you have established a working directory and environment variables, you can change the command( ) and launch multiple processes with repeated calls to start( )
This interface specifies the run( ) method that is required to use with the Thread class.
Any class that implements this interface can provide the body of a thread.
In Java 1.3, addShutdownHook( ) registers an unstarted Thread object that is run when the virtual machine shuts down, either through a call to exit( ) or through a user interrupt (a CTRL-C, for example)
The purpose of a shutdown hook is to perform necessary cleanup, such as shutting down network connections, deleting temporary files, and so on.
Any number of hooks can be registered with addShutdownHook( )
Before the interpreter exits, it starts all registered shutdown-hook threads and lets them run concurrently.
Any hooks you write should perform their cleanup operation and exit promptly so they do not delay the shutdown process.
To force an immediate exit that does not invoke the shutdown hooks, call halt( )
Note that any processes run outside of Java may be system-dependent.
Similarly, runFinalization( ) forces the finalize( ) methods of unreferenced objects to be run immediately.
This may free up system resources those objects were holding.
These libraries generally contain native code definitions for native methods.
These methods are used for debugging or profiling an application.
It is not specified how the VM emits the trace information, and VMs are not even required to support this feature.
Note that some of the Runtime methods are more commonly called via the static methods of the System class.
This exception type is not used directly, but serves as a superclass of a group of runtime exceptions that need not be declared in the throws clause of a method definition.
These exceptions need not be declared because they are runtime conditions that can generally occur in any Java method.
Thus, declaring them would be unduly burdensome, and Java does not require it.
This class inherits methods from Throwable but declares none of its own.
Each of the RuntimeException constructors simply invokes the corresponding Exception( ) and Throwable( ) constructor.
A RuntimePermission has a name, or target, that represents the facility for which permission is being sought or granted.
The name of a RuntimePermission may use a “.*” suffix as a wildcard.
RuntimePermission does not use action list strings as some Permission classes do; the name of the permission alone is enough.
System administrators configuring security policies should be familiar with these permission names, the operations they govern access to, and with the risks inherent in granting any of them.
Although system programmers may need to work with this class, application programmers should never need to use RuntimePermssion directly.
Signals that an operation is not permitted for security reasons.
This class defines the methods necessary to implement a security policy for the safe execution of untrusted code.
Before performing potentially sensitive operations, Java calls methods of the SecurityManager object currently in effect to determine whether the operations are permitted.
These methods throw a SecurityException if the operation is not permitted.
Typical applications do not need to use or subclass SecurityManager.
It is typically used only by web browsers, applet viewers, and other programs that need to run untrusted code in a controlled environment.
Prior to Java 1.2, this class is abstract, and the default implementation of each check( ) method throws a SecurityException unconditionally.
The Java security mechanism has been overhauled as of Java 1.2
As part of the overhaul, this class is no longer abstract and its methods have useful default implementations, so there is rarely a need to subclass it.
In Java 1.2 and later, all other check( ) methods of SecurityManager are now implemented on top of checkPermission( )
This class provides an immutable object wrapper around the short primitive type.
It defines useful constants for the minimum and maximum values that can be stored by the short type, and also a Class object constant that represents the short type.
It also provides various methods for converting Short values to and from strings and other numeric types.
Most of the static methods of this class can convert a String to a Short object or a short value; the four parseShort( ) and valueOf( ) methods parse a number from the specified string using an optionally specified radix and return it in one of these two forms.
Note that this class has two different toString( ) methods.
One is static and converts a short primitive value to a string.
The other is the usual toString( ) method that converts a Short object to a string.
Most of the remaining methods convert a Short to various primitive numeric types.
Signals that a stack overflow has occurred within the Java interpreter.
Each instance represents one frame in the stack trace associated with an exception or error.
If the class file contains sufficient information, getFileName( ) and getLineNumber( ) return the.
This class is identical to the Math class, but additionally requires that its methods strictly adhere to the behavior of certain published algorithms.
The methods of StrictMath are intended to operate identically on all platforms, and must produce exactly the same result (down to the very least significant bit) as certain well-known standard algorithms.
A String object is created by the Java compiler whenever it encounters a string in double quotes; this method of creation is typically simpler than using a constructor.
The static valueOf( ) factory methods create new String objects that hold the textual representation of various Java primitive types.
There are also valueOf( ) methods, copyValueOf( ) methods and String( ) constructors for creating a String object that holds a copy of the text contained in another String, StringBuffer, StringBuilder, or a char or int array.
You can also use the String( ) constructor to create a String object from an array of bytes.
If you do this, you may explicitly specify the name of the charset (or character encoding) to be used to decode the bytes into characters, or you can rely on the default charset for your platform.
In Java 5.0, the static format( ) methods provide another useful way to create String objects that hold formatted text.
You can use these two methods to iterate through the characters of a string.
You can obtain a char array that holds the characters of a string with toCharArray( ), or use getChars( ) to copy just a selected region of the string into an existing array.
Use getBytes( ) if you want to obtain an array of bytes that contains the encoded form of the characters in a string, using either the platform’s default encoding or a named encoding.
This class defines many methods for comparing strings and substrings.
As of Java 1.4, the contentEquals( ) method compares a string to a specified StringBuffer object, returning true if they contain the same text.
A two-argument version of startsWith( ) allows you to specify a position within this string at which the prefix comparison is to be done.
The regionMatches( ) method is a generalized version of this startsWith( ) method.
It returns true if the specified region of the specified string matches the characters that begin at a specified position within this string.
The fiveargument version of this method allows you to perform this comparison ignoring the case of the characters being compared.
The final string comparison method is matches( ), which, as described below, compares a string to a regular expression pattern.
This is not always the preferred “alphabetical ordering” in some languages.
They return the position of the match, or -1 if there is no match.
The one argument versions of these methods start at the beginning or end of the string, and the two-argument versions start searching from a specified character position.
Java 5.0 adds new comparison methods that work with any CharSequence.
A new version of contentEquals( ) enables the comparison of a string with any CharSequence, including StringBuilder objects.
The contains( ) method returns true if the string contains any sequence of characters equal to the specified CharSequence.
A one-argument version returns all characters from (and including) the specified start position to the end of the string.
As of Java 1.4, the String class implements the CharSequence interface and defines the subSequence( ) method, which works just like the two-argument version of substring( ) but returns the specified characters as a CharSequence rather than as a String.
Several methods return new strings that contain modified versions of the text held by the original string (the original string remains unchanged)
Java 5.0 adds a generalized version of replace( ) that replaces all occurrences of one CharSequence with another.
More general methods, replaceAll( ) and replaceFirst( ), use regular expression pattern matching; they are described later in this section.
String concatenation is more commonly done, however, with the + operator.
Note that String objects are immutable; there is no setCharAt( ) method to change the contents.
The methods that return a String do not modify the string they are invoked on but instead return a new String object that holds a modified copy of the text of the original.
Use a StringBuffer if you want to manipulate the contents of a string or call toCharArray( ) or getChars( ) to convert a string to an array of char values.
Java 1.4 introduced support for pattern matching with regular expressions.
The split( ) methods return an array of substrings of this string, formed by splitting this string at positions that match the specified regular expression.
See the Pattern and Matcher classes in that package for further details.
Many programs use strings as commonly as they use Java primitive values.
Because the String type is an object rather than a primitive value, however, you cannot in general use the = = operator to compare two strings for equality.
Instead, even though strings are immutable, you must use the more expensive equals( ) method.
For programs that perform a lot of string comparison, the intern( ) provides a way to speed up those comparisons.
The String class maintains a set of String objects that includes all doublequoted string literals and all compile-time constant strings defined in a Java program.
The set is guaranteed not to contain duplicates, and the set is used to ensure that duplicate String objects are not created unnecessarily.
The intern( ) method looks up a string in or adds a new string to this set of unique strings.
It searches the set for a string that contains exactly the same characters as the string you invoked the method on.
If such a string is found, intern( ) returns it.
What this means is that you can safely compare any strings returned by the intern( ) method using the = = and != operators instead of equals( )
You can also successfully compare any string returned by intern( ) to any string constant with = = and !=
In Java 5.0, Unicode supplementary characters may be represented as a single int codepoint value or as a sequence of two char values known as a “surrogate pair.” See Character for more on supplementary characters and methods for working with them.
This class represents a mutable string of characters that can grow or shrink as necessary.
Its mutability makes it suitable for processing text in place, which is not possible with the immutable String class.
Its resizability and the various methods it implements make it easier to use than a char[ ]
You may pass a String that contains the initial text for the buffer to this constructor, but if you do not, the buffer will start out empty.
You may also specify the initial capacity for the buffer if you can estimate the number of characters the buffer will eventually hold.
The methods of this class are synchronized, which makes StringBuffer objects suitable for use by multiple threads.
In Java 5.0 and later, when working with a single thread, StringBuilder is preferred over this class because it does not have the overhead of synchronized methods.
StringBuilder implements the same methods as StringBuffer and can be used in the same way.
Query the character stored at a given index with charAt( ) and set or delete that character with setCharAt( ) or deleteCharAt( )
Use length( ) to return the length of the buffer, and use setLength( ) to set the length of the buffer, truncating it or filling it with null characters (’\u0000’) as necessary.
If you expect a StringBuffer to grow substantially and can approximate its eventual size, you can use ensureCapacity( ) to preallocate sufficient internal storage.
Use the various append( ) methods to append text to the end of the buffer.
Use insert( ) to insert text at a specified position within the buffer.
Note that in addition to strings, primitive values, character arrays, and arbitrary objects may be passed to append( ) and insert( )
These values are converted to strings before they are appended or inserted.
Use delete( ) to delete a range of characters from the buffer and use replace( ) to replace a range of characters with a specified String.
Use substring( ) to convert a portion of a StringBuffer to a String.
The two versions of this method work just like the same-named methods of String.
Call toString( ) to obtain the contents of a StringBuffer as a String object.
Or use getChars( ) to extract the specified range of characters from the StringBuffer and store them into the specified character array starting at the specified index of that array.
As of Java 1.4, StringBuffer implements CharSequence and so also defines a subSequence( ) method that is like substring( ) but returns its value as a CharSequence.
Java 1.4 also added indexOf( ) and lastIndexOf( ) methods that search forward or backward (from the optionally specified index) in a StringBuffer for a sequence of characters that matches the specified String.
These methods return the index of the matching string or -1 if no match was found.
See also the similarly named methods of String after which these methods are modeled.
In Java 5.0, this class has a new constructor and new methods for working with CharSequence objects.
String concatenation in Java is performed with the + operator and is implemented, prior to Java 5.0, using the append( ) method of a StringBuffer.
After a string is processed in a StringBuffer object, it can be efficiently converted to a String object for subsequent use.
Instead, it shares that array with the new String object, making a new copy for itself only if and when further modifications are made to the StringBuffer object.
This class defines the same methods as StringBuffer but does not declare those methods synchronized, which can result in better performance in the common case in which only a single thread is using the object.
StringBuilder is a drop-in replacement for StringBuffer and should be used in preference to StringBuffer except where thread safety is required.
See StringBuffer for an overview of the methods shared by these two classes.
Signals that the index used to access a character of a String or StringBuffer is less than zero or is too large.
An annotation of this type tells the Java compiler not to generate specified kinds of warning messages for code within the annotated program element.
Annotations of this type have source retention and may be applied to any program element except packages and other annotation types.
An @SuppressWarnings annotation has an array of String objects as its value.
These strings specify the names of the warnings to be suppressed.
The available warnings (and their names) depend on the compiler implementation, and compilers will ignore warning names they do not support.
Compiler vendors are expected to cooperate in defining at least a core set of common warning names.
All methods and variables of this class are static, and the class cannot be instantiated.
Because the methods defined by this class are low-level system methods, most require special permissions and cannot be executed by untrusted code.
In Java 1.2 and later, setProperty( ) sets the value of a system property.
In Java 5.0, you can clear a property setting with clearProperty( )
The following table lists system properties that are always defined.
Untrusted code may be unable to read some or all of these properties.
Additional properties can be defined using the -D option when invoking the Java interpreter.
The in, out, and err fields hold the standard input, output, and error streams for the system.
In Java 1.1, setIn( ), setOut( ), and setErr( ) allow these streams to be redirected.
In Java 5.0, nanoTime( ) returns a time in nanoseconds.
The one-argument version of getenv( ) was previously deprecated but has been restored in Java 5.0
It does this regardless of whether or how the hashCode( ) method has been overridden.
This allows Java programs to be used with the Unix inetd daemon, for example.
See also Runtime, which defines several other methods that provide low-level access to system facilities.
This class encapsulates all information about a single thread of control running on the Java interpreter.
To create a thread, you must either pass a Runnable object (i.e., an object that implements the Runnable interface by defining a run( ) method) to the Thread constructor or subclass Thread so that it defines its own run( ) method.
The run( ) method of the Thread or of the specified Runnable object is the body of the thread.
It begins executing when the start( ) method of the Thread object is called.
The static methods of this class operate on the currently running thread.
The instance methods may be called by one thread to operate on a different thread.
A thread can test its own interrupted flag with the static interrupted( ) method or can test the flag of another thread with isInterrupted( )
Calling interrupted( ) implicitly clears the interrupted flag, but calling isInterrupted( ) does not.
Methods related to sleep( ) and interrupt( ) are the wait( ) and notify( ) methods defined by the Object class.
Calling wait( ) causes the current thread to block until the object’s notify( ) method is called by another thread.
Java does not specify what happens to multiple threads of equal priority; some systems perform time-slicing and share the CPU between such threads.
On other systems, one compute-bound thread that does not call yield( ) may starve another thread of the same priority.
The Java VM keeps running as long as at least one nondaemon thread is running.
Call getThreadGroup( ) to obtain the ThreadGroup of which a thread is part.
If a thread must be stoppable, have it periodically check a flag and exit if the flag is set.
In Java 1.4 and later, the four-argument Thread( ) constructor allows you to specify the “stack size” parameter for the thread.
Typically, larger stack sizes allow threads to recurse more deeply before running out of stack space.
Smaller stack sizes reduce the fixed per-thread memory requirements and may allow more threads to exist concurrently.
The meaning of this argument is implementation dependent, and implementations may even ignore it.
Obtain a snapshot of a thread’s current stack trace with getStackTrace( )
This returns an array of StackTraceElement objects: the first element of the array is the most recent method invocation and the last element is the least recent.
The static getAllStackTraces( ) returns stack traces for all running threads (the traces may be obtained at different times for different threads)
This enumerated type defines the possible states of a thread.
Call the getState( ) method of a Thread object to obtain one of the enumerated constants defined here.
A NEW thread has not been started yet, and a TERMINATED thread has exited.
A BLOCKED thread is waiting to enter a synchronized method or block.
A WAITING thread is waiting in Object.wait( ), Thread.join( ), or a similar method.
A TIMED_WAITING thread is waiting but is subject to a timeout, such as in Thread.sleep( ) or the timed versions of Object.wait( ) and Thread.join( )
Finally, a thread that has been started and has not yet exited and is not blocked or waiting is RUNNABLE.
This does not mean that the operating system is currently running it or that it is even making any forward progress, but that it is at least available to run when the operating system gives it the CPU.
This interface defines a handler to be invoked when a thread throws an exception that remains uncaught.
When this happens, the uncaughtException( ) method of the registered handler is invoked with the Thread object that threw the exception and the Throwable exception object as arguments.
The handler is run by the thread that received the exception, and that thread will exit as soon as the handler exits.
If uncaughtException( ) itself throws an exception, that exception will be ignored.
If no handler or default handler is registered, the uncaughtException( ) method of the containing ThreadGroup is used instead.
This error is thrown in a thread when the Thread.stop( ) method is called for that thread.
This is an unusual Error type that simply causes a thread to be terminated, but does not print an error message or cause the interpreter to exit.
You can catch ThreadDeath errors to do any necessary cleanup for a thread, but if you do, you must rethrow the error so that the thread actually terminates.
This class represents a group of threads and allows that group to be manipulated as a whole.
A ThreadGroup can contain Thread objects, as well as other child ThreadGroup objects.
ThreadGroup objects are created as children of some other ThreadGroup, and thus there is a parent/child hierarchy of ThreadGroup objects.
Use getParent( ) to obtain the parent ThreadGroup, and use activeCount( ), activeGroupCount( ), and the various enumerate( ) methods to list the child Thread and ThreadGroup objects.
Most applications can simply rely on the default system thread group.
System-level code and applications such as servers that need to create a large number of threads may find it convenient to create their own ThreadGroup objects, however.
The method throws a SecurityException if the current thread does not have access.
This class provides a convenient way to create thread-local variables.
When you declare a static field in a class, there is only one value for that field, shared by all objects of the class.
When you declare a nonstatic instance field in a class, every object of the class has its own separate copy of that variable.
If you declare a static field to hold a ThreadLocal object, that ThreadLocal holds a different value for each thread.
Objects running in the same thread see the same value when they call the get( ) method of the ThreadLocal object.
Objects running in different threads obtain different values from get( ), however.
In Java 5.0, this class has been made generic and the type variable T represents the type of the object referenced by this ThreadLocal.
The set( ) method sets the value held by the ThreadLocal object for the currently running thread.
Note that there is no way to obtain the value of the ThreadLocal object for any thread other than the one that calls get( )
To understand the ThreadLocal class, you may find it helpful to think of a ThreadLocal object as a hashtable or java.util.Map that maps from Thread objects to arbitrary values.
Calling get( ) first looks up the current thread, then uses the hashtable to look up the value associated with that current thread.
If a thread calls get( ) for the first time without having first called set( ) to establish a thread-local value, get( ) calls the protected initialValue( ) method to obtain the initial value to return.
The default implementation of initialValue( ) simply returns null, but subclasses can override this if they desire.
This is the root class of the Java exception and error hierarchy.
The getMessage( ) method retrieves any error message associated with the exception or error.
It is often the case that an Exception or Error is generated as a direct result of some other exception or error, perhaps one thrown by a lower-level API.
As of Java 1.4 and later, all Throwable objects may have a “cause” which specifies the Throwable that caused.
If there is a cause, pass it to the Throwable( ) constructor, or to the initCause( ) method.
When you catch a Throwable object, you can obtain the Throwable that caused it, if any, with getCause( )
Every Throwable object has information about the execution stack associated with it.
This information is initialized when the Throwable object is created.
If the object will be thrown somewhere other than where it was created, or if it caught and will be rethrown, you can use fillInStackTrace( ) to capture the current execution stack before throwing it.
In Java 1.4, you can also obtain this information with getStackTrace( ) which returns an array of StackTraceElement objects describing the execution stack.
It typically results when a class depends on a type that has changed or been removed and indicates version skew that requires recompilation or code refactoring.
Signals that an unknown error has occurred at the level of the Java Virtual Machine.
Signals that Java cannot satisfy all the links in a class that it has loaded.
Every Java class file contains a version number that specifies the version of the class file format.
This error is thrown when the Java Virtual Machine attempts to read a class file with a version number it does not support.
Signals that a method you have called is not supported, and its implementation does not do anything (except throw this exception)
This exception is used most often by the Java collection framework of java.util.
Immutable or unmodifiable collections throw this exception when a modification method, such as add( ) or delete( ), is called.
Signals that a class has not passed the byte-code verification procedures.
An abstract error type that serves as superclass for a group of errors related to the Java Virtual Machine.
The Void class cannot be instantiated and serves merely as a placeholder for its static TYPE field, which is a Class object constant that represents the void type.
It includes the base Annotation interface that all annotation types extend, meta-annotation types, their associated enumerated types, and exception and error classes related to annotations.
The most important members of this package are the meta-annotation types: Documented, Inherited, Retention, and Target.
A type declared with the @interface syntax is an annotation type that implicitly extends this interface.
Note that the Annotation interface is not itself an annotation type.
Furthermore, if you define an interface (rather than an @interface) that explicitly extends Annotation, the result is not an annotation type either.
The only way to define an annotation type is with an @interface definition.
This interface defines the annotationType( ) method, which returns the Class of the annotation type for any annotation object.
It also includes the equals( ) and hashCode( ) methods of Object to require an implementation to compare annotations by the values of their members rather than simply by using = =
Finally, Annotation also overrides the toString( ) method to require implementations to provide some meaningful string representation of an annotation.
The format of the returned string is not specified, but you can expect implementations to produce a string using a syntax similar to that used to encode annotations in Java source code.
An error of this type indicates that a class file includes a malformed annotation.
An exception of this type indicates version skew in an annotation type.
It occurs when the Java VM attempts to read an annotation from a class file and discovers that the type of an annotation member has changed since the class file (and the annotation it contains) was compiled.
A meta-annotation of this type indicates that the annotated type should be documented by Javadoc and similar documentation tools.
If an annotation type is an @Documented annotation, then the presence of an annotation of that type is part of the public API of the annotated program element.
The constants declared by this enumerated type represent the types of program elements that can be annotated.
The value of an @Target annotation is an array of ElementType constants.
Most of the constants have obvious meanings, but some require additional explanation.
ANNOTATION_TYPE represents only annotation types and is used for metaannotations.
An exception of this type indicates version skew in an annotation type.
It occurs when the Java VM attempts to read an annotation from a class file and discovers that the annotation type has added a new member since the class file was compiled.
Note that this exception does not occur if a new member with a default clause is added to the annotation type.
When an annotation type that has an @Inherited meta-annotation is applied to a class, that annotation should be inherited by subclasses and descendants of the annotated class.
If an @Inherited annotation type is applied to a method or program element other than a class, no inheritance applies.
A meta-annotation of this type specifies how long the annotated annotation type should be retained.
The value( ) of this annotation type is one of the three RetentionPolicy enumerated constants.
The constants declared by the enumerated type specify the possible retention values for an @Retention meta-annotation.
Annotations with SOURCE retention appear in Java source code only and are discarded by the compiler.
This is the default retention for annotation types that do not have an @Retention meta-annotation.
Finally, annotations with RUNTIME retention are stored in the class file and loaded by the Java interpreter at runtime.
A meta-annotation of this type specifies what program elements the annotated annotation type can be applied to.
The value( ) of a Target annotation is an array of ElementType enumerated constants.
If an annotation type does not have an @Target meta-annotation, it can be applied to any program element.
This package defines the API for instrumenting a Java VM by transforming class files to add profiling support, code coverage testing, or other features.
The -javaagent command-line option to the Java interpreter provides a hook for running the premain( ) method of a Java instrumentation agent.
This class is a simple wrapper around a Class object and an array of bytes that represents a class file for that class.
An array of ClassDefinition objects is passed to the redefineClasses( ) method of the Instrumentation class.
Class redefinitions are allowed to change method implementations, but not the members or inheritance of a class or the signature of the methods.
If the transform( ) method wishes to transform the class, it should return the transformed bytes in a newly allocated array.
The array passed to transform( ) should not be modified.
If the transform( ) method does not wish to transform a given class, it should return null.
A Java instrumentation agent specified on the Java interpreter command line with the -javaagent argument must be a class that defines the following method:
The Java interpreter invokes the premain( ) method during startup before calling the main( ) method of the program.
Any arguments specified with the -javaagent command line are passed in the first premain( ) argument, and an Instrumentation object is passed as the second argument.
This might occur, for example, if the redefinition attempts to add or remove members from the class.
This package defines “management bean” or “MXBean” interfaces for managing and monitoring a running Java virtual machine.
It relies on the JMX API of the javax.management package, which is not covered in this book.
ManagementFactory is the main entry point to this API; it defines static factory methods for obtaining instances of the various management bean interfaces.
These instances can then be queried for specific information about the Java VM.
The jconsole tool shipped with the Java 5.0 JDK demonstrates the capabilites of this package.
This MXBean interface defines methods for determining how many classes are currently loaded in the Java VM, how many have ever been loaded, and how many have ever been unloaded.
The setVerbose( ) method turns verbose class loading output from the VM on or off.
This MXBean interface defines methods for querying the just-in-time compiler of the Java virtual machine.
This MXBean interface allows monitoring of the number of garbage collections that have occurred and the approximate time they consumed in milliseconds.
The methods return -1 to indicate that the garbage collector does not maintain those statistics.
Note that VM implementations commonly have more than one garbage collector and use different collection strategies for new objects and old objects.
The static factory methods provide a convenient way to obtain instances of the various MXBean interfaces for the currently running Java virtual machine.
The returned instances can then be queried to monitor memory usage, class loading, and other details of virtual machine performance.
The constant fields of this class define the names of the available beans.
Note that the javax.management package is beyond the scope of this quick reference.
The two defined targets for this permission are control, which grants permission to manage the VM, and monitor, which grants permission to monitor VM state.
This MXBean interface allows monitoring of a single memory manager (such as a garbage collector) in a Java VM.
This MXBean interface allows monitoring of current memory usage information for heap memory (allocated objects) and nonheap memory (loaded classes and libraries)
It also allows the garbage collector to be explicitly invoked and verbose garbagecollection related output to be turned on or off.
See MemoryUsage for details on how memory usage information is returned.
See also MemoryPoolMXBean for a way to obtain both current and peak memory usage for individual memory pools.
This class holds information about memory usage in a given memory pool and is generated when that usage crosses a threshold specified by a MemoryPoolMXBean.
Notifications and the javax.management package are beyond the scope of this book.
This MXBean interface allows monitoring of the current and peak memory usage for a single memory pool.
Typical Java VM implementations segregate garbage-collected heap memory into two or more memory pools based on the age of the objects.
Note that the javax.management package is not covered in this book.
The constants defined by this enumerated type define the type of a memory pool as either heap or nonheap memory.
A MemoryUsage object represents a snapshot of memory usage for a specified type or pool of memory.
Memory usage is measured as four long values, each of which represents a number of bytes.
These bytes may not all be in use, but they are not available to other processes running on the system.
This MXBean interface allows queries of the operating system name, version, and CPU architecture as well as the number of available CPUs.
This MXBean interface provides access to the runtime configuration of the Java virtual machine, including system properties, command-line arguments, class path, virtual machine vendor and version, and so on.
This class represents information about a thread from a ThreadMXBean.
Other more useful information includes the object upon which a thread is waiting and the owner of the lock that the thread is trying to acquire.
If ThreadMXBean indicates that thread contention monitoring is supported and enabled, the ThreadInfo methods getBlockedCount( ) and getBlockedTime( ) return the number of times the thread has blocked or waited and the amount of time it has spent in the blocked and waiting states.
This MXBean interface allows monitoring of thread usage in a Java VM.
Threads are identified by their thread id, which is a long integer.
Complete information, including stack trace, about a thread or set of threads can be obtained with the getThreadInfo( ) methods, which return ThreadInfo objects.
The values returned by these methods are measured in nanoseconds.
It looks for cycles of threads that are deadlocked waiting to lock objects whose locks are held by other threads in the cycle.
The java.lang.ref package defines classes that allow Java programs to interact with the Java garbage collector.
A Reference represents an indirect reference to an arbitrary object, known as the referent.
SoftReference, WeakReference, and PhantomReference are three concrete subclasses of Reference that interact with the garbage collector in different ways, as explained in the individual class descriptions that follow.
Any Reference object may have a ReferenceQueue associated with it.
A Reference object is enqueued on its ReferenceQueue at some point after the garbage collector determines that the referent object has become appropriately unreachable.
The exact level of unreachability depends on the type of Reference being used.
An application can monitor a ReferenceQueue to determine when referent objects enter a new reachability status.
Using the mechanisms defined in this package, you can implement a cache that grows and shrinks in size according to the amount of available system memory.
Or, you can implement a hashtable that associates auxiliary information with arbitrary objects, but does not prevent those objects from being garbage-collected if they are otherwise unused.
The mechanisms provided by this package are low-level ones, however, and typical applications do not use java.lang.ref directly.
Instead, they rely on higher-level utilities built on top of the package.
In Java 5.0, the classes in this package have all been made into generic types.
The type variable T represents the type of the object that is referred to.
This class represents a reference to an object that does not prevent the referent object from being finalized by the garbage collector.
When (or at some point after) the garbage collector determines that there are no more hard (direct) references to the referent object, that there are no SoftReference or WeakReference objects that refer to the referent, and that the referent has been finalized, it enqueues the PhantomReference object on the ReferenceQueue specified when the PhantomReference was created.
This serves as notification that the object has been finalized and provides one last opportunity for any required cleanup code to be run.
To prevent a PhantomReference object from resurrecting its referent object, its get( ) method always returns null, both before and after the PhantomReference is enqueued.
Nevertheless, a PhantomReference is not automatically cleared when it is enqueued, so when you remove a PhantomReference from a ReferenceQueue, you must call its clear( ) method or allow the PhantomReference object itself to be garbage-collected.
This class provides a more flexible mechanism for object cleanup than the finalize( ) method does.
Note that in order to take advantage of it, it is necessary to subclass PhantomReference and define a method to perform the desired cleanup.
Furthermore, since the get( ) method of a PhantomReference always returns null, such a subclass must also store whatever data is required for the cleanup operation.
This abstract class represents some type of indirect reference to a referent.
The garbage collector handles these subclasses differently and clears their references under different circumstances.
Each of the subclasses of Reference defines a constructor that allows a ReferenceQueue to be associated with the Reference object.
The garbage collector places Reference objects onto their associated ReferenceQueue objects to provide notification about the state of the referent object.
This class represents a queue (or linked list) of Reference objects that have been enqueued because the garbage collector has determined that the referent objects to which they refer are no longer adequately reachable.
Use poll( ) to return the first Reference object on the queue; the method returns null if the queue is empty.
Use remove( ) to return the first element on the queue, or, if the queue is empty, to wait for a Reference object to be enqueued.
ReferenceQueue for a Reference object by passing it to the SoftReference( ), WeakReference( ), or PhantomReference( ) constructor.
It is optional with SoftReference and WeakReference objects; for these classes, the get( ) method returns null if the referent object is no longer adequately reachable.
A SoftReference is not cleared while there are any remaining hard (direct) references to the referent.
Once the referent is no longer in use (i.e., there are no remaining hard references to it), the garbage collector may clear the SoftReference to the referent at any time.
However, the garbage collector does not clear a SoftReference until it determines that system memory is running low.
In particular, the Java VM never throws an OutOfMemoryError without first clearing all soft references and reclaiming the memory of the referents.
If a SoftReference has an associated ReferenceQueue, the garbage collector enqueues the SoftReference at some time after it clears the reference.
SoftReference is particularly useful for implementing object-caching systems that do not have a fixed size, but grow and shrink as available memory allows.
This class refers to an object in a way that does not prevent that referent object from being finalized and reclaimed by the garbage collector.
When the garbage collector determines that there are no more hard (direct) references to the object, and that there are no SoftReference objects that refer to the object, it clears the WeakReference and marks the referent object for finalization.
WeakReference on its associated ReferenceQueue, if there is one, in order to provide notification that the referent has been reclaimed.
WeakHashMap is useful when you want to associate auxiliary information with an object but do not want to prevent the object from being reclaimed.
The Constructor, Field, and Method classes represent the constructors, fields, and methods of a class.
Because these types all represent members of a class, they each implement the Member interface, which defines a simple set of methods that can be invoked for any class member.
These classes allow information about the class members to be obtained, methods and constructors to be invoked, and fields to be queried and set.
Class member modifiers are represented as integers that specify a number of bit flags.
The Modifier class defines static methods that help interpret the meanings of these flags.
The Array class defines static methods for creating arrays and reading and writing array elements.
As of Java 1.3, the Proxy class allows the dynamic creation of new Java classes that implement a specified set of interfaces.
When an interface method is invoked on an instance of such a proxy class, the invocation is delegated to an InvocationHandler object.
There have been a number of changes to this package to support the new language features of Java 5.0
The most important changes are support for querying the generic signature of classes, methods, constructors, and fields.
Class, Method and Constructor implement the new GenericDeclaration interface, which provides access to the TypeVariable declarations of generic classes, methods, and constructors.
The Type interface is new in Java 5.0, and represents any kind of generic or nongeneric type.
Class implements Type, so a Type object may simply be an ordinary Class.
Type is also the super-interface for four other new interfaces: ParameterizedType, TypeVariable, WildcardType and GenericArrayType.
A Type object that is not a Class should be an instance of one of these other interfaces, representing a generic type of some sort.
Support for reflection on annotations is provided by the AnnotatedElement interface which is implemented by Class, Package, Method, Constructor and Field.
Other, more minor changes in Java 5.0 include the isEnumConstant( ) method of Field and the isVarArgs( ) method of Method and Constructor.
This class is the superclass of the Method, Constructor, and Field classes; its methods provide a mechanism for trusted applications to work with private, protected, and default visibility members that would otherwise not be accessible through the Reflection API.
The static version of setAccessible( ) is a convenience method that sets the accessible flag for an array of members but performs only a single security check.
The methods of this interface allow you to test for the presence of a specific annotation, query an annotation object of a specific type, or query all annotations present on an annotated element.
It is safe to modify the arrays returned by these methods.
This class contains methods that allow you to set and query the values of array elements, to determine the length of an array, and to create new instances of arrays.
Since the Array class represents a Java value, unlike the Field, Method, and Constructor classes, which represent class members, the Array class is significantly different (despite some surface similarities) from those other classes in this package.
Most notably, all the methods of Array are static and apply to all array values, not just a specific field, method, or constructor.
The get( ) method returns the value of the specified element of the specified array as an Object.
If the array elements are of a primitive type, the value is converted to a wrapper object before being returned.
You can also use getInt( ) and related methods to query array elements and return them as specific primitive types.
The set( ) method and its primitive type variants perform the opposite operation.
Also, the getLength( ) method returns the length of the array.
One version of this method is passed the number of elements in the array and the type of those elements.
Besides specifying the component type of the array, it is passed an array of numbers.
The length of this array specifies the number of dimensions for the array to be created, and the values of each of the array elements specify the size of each dimension of the created array.
Constructor implements the Member interface, so you can use the methods of that interface to obtain the constructor name, modifiers, and declaring class.
In addition, getParameterTypes( ) and getExceptionTypes( ) also return important information about the represented constructor.
In addition to these methods that return information about the constructor, the newInstance( ) method allows the constructor to be invoked with an array of arguments in order to create a new instance of the class that declares the constructor.
If any of the arguments to the constructor are of primitive types, they must be converted to their corresponding wrapper object types to be passed to newInstance( )
Constructor has been modified in Java 5.0 to support generics, annotations, and varargs.
The changes are the same as the Java 5.0 changes to the Method class.
Additionally, Constructor has been made a generic type in Java 5.0
The type variable T represents the type that the constructor constructs, and is used as the return type of the newInstance( ) method.
Field implements the Member interface, so once you have obtained a Field object, you can use getName( ), getModifiers( ), and getDeclaringClass( ) to determine the name, modifiers, and class of the field.
The set( ) method sets the value of the represented field for a specified object.
If the represented field is static, no object need be specified, of course.
If the field is of a primitive type, its value can be specified using a wrapper object of type Boolean, Integer, and so on, or it can be set using the setBoolean( ), setInt( ), and related methods.
Similarly, the get( ) method queries the value of the represented field for a specified object and returns the field value as an Object.
Various other methods query the field value and return it as various primitive types.
In Java 5.0, Field implements AnnotatedElement to support reflection on field annotations.
The new getGenericType( ) method supports reflection on the generic type of fields, and isEnumConstant( ) supports fields of enum types.
This interface extends Type and represents a one-dimensional array of some element Type.
It provides access to the type variables declared by the generic type, method, or constructor.
An error of this type is thrown if the Java interpreter tries to load a class file that contains malformed generic signature information.
This interface defines a single invoke( ) method that is called whenever a method is invoked on a dynamically created Proxy object.
Every Proxy object has an associated InvocationHandler object that is specified when the Proxy is instantiated.
All method invocations on the proxy object are translated into calls to the invoke( ) method of the InvocationHandler.
The first argument to invoke( ) is the Proxy object through which the method was invoked.
The second argument is a Method object that represents the method that was invoked.
Call the getDeclaringClass( ) method of this Method object to determine the interface in which the method was declared.
The third argument to invoke( ) is the array of method arguments.
Any primitive type arguments are wrapped in their corresponding object wrappers (e.g., Boolean, Integer, Double)
The value returned by invoke( ) becomes the return value of the proxy object method invocation and must be of an appropriate type.
If the proxy object method returns a primitive type, invoke( ) should return an instance of the corresponding wrapper class.
An exception of this type is thrown during reflection if the generic type information contained in a class file is syntactically correct but semantically wrong.
An example would be if the number of type parameters in a ParameterizedType differs from the number of type variables declared by the generic type.
Although this type is not an Error, it does indicate a malformed class file and should not arise in common practice.
This interface defines the methods shared by all members (fields, methods, and constructors) of a class.
Method implements the Member interface, so you can use the methods of that interface to obtain the method name, modifiers, and declaring class.
In addition, getReturnType( ), getParameterTypes( ), and getExceptionTypes( ) also return important information about the represented method.
Perhaps most importantly, the invoke( ) method allows the method represented by the Method object to be invoked with a specified array of argument values.
If any of the arguments are of primitive types, they must be converted to their corresponding wrapper object types in order to be passed to invoke( )
If the represented method is an instance method (i.e., if it is not static), the instance on which it should be invoked must also be passed to invoke( )
The return value of the represented method is returned by invoke( )
If the return value is a primitive value, it is first converted to the corresponding wrapper type.
In Java 5.0, Method implements GenericDeclaration to support reflection on the type variables defined by generic methods and AnnotatedElement to support reflection on method annotations.
Finally, the new isVarArgs( ) method returns true if the method was declared using Java 5.0 varargs syntax.
This class defines a number of constants and static methods that can interpret the integer values returned by the getModifiers( ) methods of the Field, Method, and Constructor classes.
The isPublic( ), isAbstract( ), and related methods return true if the modifier value includes the specified modifier; otherwise, they return false.
The constants defined by this class specify the various bit flags used in the modifiers value.
You can use these constants to test for modifiers if you want to perform your own boolean algebra.
This class defines a simple but powerful API for dynamically generating a proxy class.
A proxy class implements a specified list of interfaces and delegates invocations of the methods defined by those interfaces to a separate invocation handler object.
The static getProxyClass( ) method dynamically creates a new Class object that implements each of the interfaces specified in the supplied Class[ ] array.
The newly created class is defined in the context of the specified ClassLoader.
The Class returned by getProxyClass( ) is a subclass of Proxy.
Every class that is dynamically generated by getProxyClass( ) has a single public constructor, which expects a single argument of type InvocationHandler.
You can create an instance of the dynamic proxy class by using the Constructor class to invoke this constructor.
Or, more simply, you can combine the call to getProxyClass( ) with the constructor call by calling the static newProxyInstance( ) method, which both defines and instantiates a proxy class.
Every instance of a dynamic proxy class has an associated InvocationHandler object.
All method calls made on a proxy class are translated into calls to the invoke( ) method of this InvocationHandler object, which can handle the call in any way it sees fit.
The static isProxyClass( ) method returns true if a specified Class object is a dynamically generated proxy class.
This permission is required to call the setAccessible( ) method of AccessibleObject.
Unlike some Permission subclasses, ReflectPermission does not use a list of actions.
System administrators configuring security policies should be familiar with this class, but application programmers should never need to use it directly.
This interface has no members but is implemented or extended by any type that represents a generic or nongeneric type.
Type is also extended by four interfaces that represent four specific kinds of generic types: ParameterizedType, TypeVariable, WildcardType, and GenericArrayType.
This interface extends Type and represents the generic type represented by a type variable.
The returned array is never empty: if the type variable has no bounds declared, the single element of the array is Object.class.
Note that TypeVariable is itself a generic type and is parameterized with the kind of GenericDeclaration that declared the variable.
Thrown by a method of a Proxy object if the invoke( ) method of the proxy’s InvocationHandler throws a checked exception not declared by the original method.
This class serves as an unchecked exception wrapper around the checked exception.
This interface extends Type and represents a generic type declared with a bounded or unbounded wildcard.
If no upper bound is declared, Object.class is the implicit upper bound.
If no lower bound is declared, this method returns an empty array.
It also contains the BigDecimal class for arbitrary precision decimal floating-point arithmetic, which is useful for financial applications that need to be careful about rounding errors.
The BigDecimal class is greatly enhanced in Java 5.0 and is accompanied by the new types MathContext and RoundingMode.
Because it uses a decimal rather than binary floating-point representation, it is not subject to the rounding errors that the float and double types are.
BigDecimal provides add( ), subtract( ), multiply( ), and divide( ) methods to support basic arithmetic.
In Java 5.0, this class has been expanded to define many more methods, including pow( ) for exponentiation.
Many of the new methods use a MathContext to specify the desired precision of the result and the RoundingMode to be used to achieve that precision.
A BigDecimal object is represented as an integer of arbitrary size and an integer scale that specifies the number of decimal places in the value.
When working with BigDecimal values, you can explicitly specify the precision (i.e., the number of decimal places) you are interested in.
Also, whenever a BigDecimal method can discard precision (e.g., in a division operation), you are required to specify what sort of rounding should be performed on the digit to the left of the discarded digit or digits.
The eight constants defined by this class specify the available rounding modes.
In Java 5.0, however, the preferred way to specify a rounding mode is with the enumerated type RoundingMode.
BigInteger defines methods that duplicate the functionality of the standard Java arithmetic and bit-manipulation operators.
The gcd( ), modPow( ), modInverse( ), and isProbablePrime( ) methods perform advanced operations and are used primarily in cryptographic and related algorithms.
This simple class represents a precision (number of significant digits) and a RoundingMode to be used in BigDecimal arithmetic.
The constants are predefined MathContext objects that can be used to select unlimited precision arithmetic or to select specific operating modes that match decimal floating-point modes defined by the IEEE 754R standard.
The constants defined by this enumerated type represent possible ways of rounding numbers.
In this case, they round up, down, or to the “even” neighbor.
The java.net package provides a powerful and flexible infrastructure for networking.
This introduction describes the most commonly used classes in brief.
See also the javax.net.ssl package for classes for secure networking using SSL.
The URL class represents an Internet uniform resource locator (URL)
It provides a very simple interface to networking: the object referred to by the URL can be downloaded with a single call, or streams may be opened to read from or write to the object.
At a slightly more complex level, a URLConnection object can be obtained from a given URL object.
The URLConnection class provides additional methods that allow you to work with URLs in more sophisticated ways.
Java 1.4 introduced the URI class; it provides a powerful API for manipulating URI and URL strings but does not have any networking capabilities itself.
Java 5.0 defines APIs for defining and registering cache, cookie, and proxy handlers to be used by built-in protocol handlers when network resources are requested through the URL class.
If you want to do more than simply download an object referenced by a URL, you can do your own networking with the Socket class.
This class allows you to connect to a specified port on a specified Internet host and read and write data using the InputStream and OutputStream classes of the java.io package.
If you want to implement a server to accept connections from clients, you can use the related ServerSocket class.
Both Socket and ServerSocket use the InetAddress address class, which represents an Internet address.
Java 1.4 also introduced the SocketAddress class as a high-level representation of a network address that is not tied to a specific networking protocol.
An IP-specific InetSocketAddress subclass encapsulates an InetAddress and a port number.
The java.net package allows you to do low-level networking with DatagramPacket objects, which may be sent and received over the network through a DatagramSocket object.
Classes public abstract class Authenticator; public abstract class CacheRequest; public abstract class CacheResponse;
This abstract class defines a customizable mechanism for requesting and performing password authentication when required in URL-based networking.
An Authenticator implementation can obtain the required authentication information from the user however it wants (e.g., through a text- or a GUI-based interface)
RequestorType is a nested enum type that specifies whether the request comes from an HTTP server or a proxy server.
The constants defined by this enumerated type specify whether an authentication request comes from an HTTP origin server or a proxy server.
Signals that a socket cannot be bound to a local address and port.
This often means that the port is already in use.
When a URLStreamHandler reads a network resource, it should call the put( ) method of the currently installed ResponseCache, if there is one.
If the cache wants to save a local copy of the resource, it will return a CacheRequest object to the URLStreamHandler.
The handler should then write the resource to the OutputStream returned by the getBody( ) method.
This class is used by the implementors of URLStreamHandler, not by casual users of the java.net package.
The protocol response headers are available in the form of java.util.Map from getHeaders( )
Note that this class is intended for use in URLStreamHandler implementations, not by casual users of the java.net package.
Signals that a socket cannot be connected to a remote address and port.
This means that the remote host can be reached, but is not responding, perhaps because there is no process on that host that is listening on the specified port.
This abstract class defines a method that reads data from a URLConnection and returns an object that represents that data.
Each subclass that implements this method is responsible for handling a different type of content (i.e., a different MIME type)
You need to subclass ContentHandler only if you are writing a web browser or similar application that needs to parse and understand some new content type.
This interface defines a method that creates and returns an appropriate ContentHandler object for a specified MIME type.
Normal applications never need to use or implement this interface.
This abstract class defines an API to be implemented by an application that wants to manage HTTP cookies for networking done via the URL class.
Install an implementation of this class with the setDefault( ) method.
The default HTTP protocol handler uses getDefault( ) to obtain the CookieHandler implementation.
The protocol handler then calls get( ) when it wants the CookieHandler to copy cookie values into HTTP request headers and calls put( ) when it wants the CookieHandler to read a set of response headers and store the cookies they contain.
This class is intended to be subclassed by advanced users of the package; it is not intended for casual users.
This class implements a packet of data that may be sent or received over the network through a DatagramSocket.
Create a DatagramPacket to be sent over the network with one of the consructor methods that includes a network address.
Create a DatagramPacket into which data can be received using one of the constructors that does not include a network address argument.
The receive( ) method of DatagramSocket waits for data and stores it in a DatagramPacket created in this way.
The contents and sender of a received packet can be queried with the DatagramPacket instance methods.
New constructors and methods were added to this class in Java 1.4 to support the SocketAddress abstraction of a network address.
This class defines a socket that can receive and send unreliable datagram packets over the network using the UDP protocol.
A datagram is a very low-level networking interface: it is simply an array of bytes sent over the network.
Datagram packets are called unreliable because the protocol does not make any attempt to ensure they arrive or to resend them if they don’t.
Thus, packets sent through a DatagramSocket are not guaranteed to arrive in the order sent or even to arrive at all.
On the other hand, this lowoverhead protocol makes datagram transmission very fast.
The packet must contain the destination address to which it should be sent.
Once close( ) has been called, the DatagramSocket should not be used again, except to call the isClosed( ) method which returns true if the socket has been closed.
Each time a packet is sent or received, the system must perform a security check to ensure that the calling code has permission to send data to or receive data from the specified host.
In Java 1.2 and later, if you are sending multiple packets to or receiving multiple packets from a single host, use connect( ) to specify the host with which you are communicating.
This causes the security check to be done a single time, but does not allow the socket to communicate with any other host until disconnect( ) is called.
Use isConnected( ) to determine if the socket is currently connected in this way.
By default, a DatagramSocket sends data through a local address assigned by the system.
If desired, however, you can bind the socket to a specified local address.
Do this by using one of the constructors other than the no-arg constructor.
Or, bind the DatagramSocket to a local SocketAddress with the bind( ) method.
This class defines a number of get/set method pairs for setting and querying a variety of “socket options” for datagram transmission.
Sockets created with one of the DatagramSocket( ) constructors always return null from this method.
This abstract class defines the methods necessary to implement communication through datagram and multicast sockets.
System programmers may create subclasses of this class when they need to implement datagram or multicast sockets in a nonstandard network environment, such as behind a firewall or on a network that uses a nonstandard transport protocol.
Normal applications never need to use or subclass this class.
Application-level code never needs to use or implement this interface.
This interface defines a single method that is called to obtain the MIME type of a file based on the name of the file.
The fileNameMap field of the URLConnection class refers to an object that implements this interface.
An exception of this type is thrown when an HTTP request needs to be retried (due to a server redirect or authentication request, for example) but the protocol handler cannot automatically retry it because the HttpURLConnection has been placed in streaming mode.
The methods of the exception provide details about how the request should be retried.
An instance of this class is returned when the openConnection( ) method is called for a URL object that uses the HTTP protocol.
The many constants defined by this class are the status codes returned by HTTP servers.
The contents of this request must be sent through the OutputStream returned by the getOutputStream( ) method of the superclass.
In order to successfully use this class, you need to understand the details of the HTTP protocol.
See RFC 2373 for complete details about internet addresses of this type.
In Java 5.0, you can also use the getByAddress( ) factory methods of this class directly.
The class does not have a public constructor but instead supports static factory methods for obtaining InetAddress objects.
Once you have obtained an InetAddress object, its instance methods provide various sorts of information about it.
Two of the most important are getHostName( ), which returns the hostname, and getAddress( ), which returns the IP address as an array of bytes, with the highest-order byte as the first element of the array.
The various methods whose names begin with “is” determine whether the address falls into any of the named categories.
Java 5.0 adds isReachable( ) for testing whether the address describes a reachable (and responsive) host.
InetSocketAddress represents an the combination of an IP (Internet Protocol) address and a port number.
The constructors allow you to specify the IP address as an InetAddress or as a hostname, and they also allow you to omit the IP address, in which case the wildcard address is used (this is useful for server sockets)
This class is a specialized URLConnection that represents a connection to a jar: URL.
A jar: URL is a compound URL that includes the URL of a JAR archive and, optionally, a reference to a file or directory within the JAR archive.
The jar: URL syntax uses the ! character to separate the pathname of the JAR archive from the filename within the JAR archive.
Note that a jar: URL contains a subprotocol that specifies the protocol that retrieves the JAR file itself.
To obtain a JarURLConnection, define a URL object for a jar: URL, open a connection to it with openConnection( ), and cast the returned URLConnection object to a JarURLConnection.
The various methods defined by JarURLConnection allow you to read the manifest file of the JAR archive and look up attributes from that manifest for the archive as a whole or for individual entries in the archive.
These methods make use of various classes from the java.util.jar package.
Signals that an unparseable URL specification has been passed to a method.
This subclass of DatagramSocket can send and receive multicast UDP packets.
It extends DatagramSocket by adding joinGroup( ) and leaveGroup( ) methods to join and leave multicast groups.
You do not have to join a group to send a packet to a multicast address, but you must join the group to receive packets sent to that address.
Note that the use of a MulticastSocket is governed by a security manager.
Use setTimeToLive( ) to set a time-to-live value for any packets sent through a MulticastSocket.
This constrains the number of network hops a packet can take and controls the scope of a multicast.
System administrators configuring security policies must be familiar with this class and the permissions it represents.
System programmers may use this class, but application programmers never need to use it explicitly.
Instances of this class represent a network interface on the local machine.
Obtain a NetworkInterface object with one of the static methods defined by this class.
This class is typically only used in advanced networking applications.
This exception signals that a socket cannot be connected to a remote host because the host cannot be contacted.
Typically, this means that some link in the network between the local machine and the remote host is down or that the host is behind a firewall.
This simple immutable class encapsulates a username and a password.
The password is stored as a character array rather than as a String object so that the caller can erase the contents of the array after use for increased security.
An exception of this type may be thrown by a send( ) or receive( ) call on a DatagramSocket if the connect( ) method of that socket has been called, and if the connection attempt resulted in an ICMP “port unreachable” message.
An instance of this class represents a set of proxy server settings: a network address and a proxy server type.
The ProxySelector class provides a way to automate the selection of proxy servers based on requested URLs.
The constants of this enumerated type represent a type of proxy server.
An implementation of this abstract class can be used to automatically select one or more Proxy objects to use to connect to a specified URL.
Install an implementation of this class with the setDefault( ) method.
URLConnection implementations use the installed ProxySelector, if there is one, and call select( ) to obtain a list of suitable Proxy objects for the connection.
If a URLConnection cannot contact the proxy server specified in a Proxy object, it calls the connectFailed( ) method to notify the ProxySelector object of the failure.
This class is intended to be implemented by advanced users of java.net and is not for casual use.
This abstract class defines an API for low-level caching of network resources retrieved through the URL and URLConnection classes.
This class is intended for use by URLStreamHandler implementations, not by casual users of the java.net package.
The static getDefault( ) and setDefault( ) methods query and set a ResponseCache for the system.
If there is a ResponseCache installed, protocol handlers should call put( ) to offer a network resource to the cache.
If the cache is interested, it returns a CacheRequest object into which the URLStreamHandler can write its data.
A URLStreamHandler that wants to query the cache should call get( )
If the ResponseCache holds a cached copy of the requested resource, it returns a CacheResponse from which the URLStreamHandler can read the resource.
This subclass of CacheResponse represents a cached network resource that was retreived through a secure protocol such as HTTPS.
Its methods return certificates and other details about the secure transfer.
This class is not intended for casual users of the java.net package.
This class is used by servers to listen for connection requests from clients.
Before you can use a ServerSocket, it must be bound to the local network address that it is to listen on.
All of the ServerSocket( ) constructors except for the no-argument constructor create a server socket and bind it to the specified local port, optionally specifying a “connection backlog” value: this is the number of client connection attempts that may be queued up before subsequent connection attempts are rejected.
In Java 1.4 and later, the no-argument ServerSocket( ) constructor allows you to create an unbound socket.
Doing this allows you to bind the socket using the bind( ) method which uses a SocketAddress object rather than a port number.
It also allows you to call setReuseAddress( ), which is only useful when done before the socket is bound.
Call isBound( ) to determine whether a server socket has been bound.
Once a ServerSocket has been bound, you can call the accept( ) method to listen on the specified port and block until the client requests a connection on the port.
When this happens, accept( ) accepts the connection, creating and returning a Socket the server can use to communicate with the client.
A typical server starts a new thread to handle the communication with the client and calls accept( ) again to listen for another connection.
ServerSocket defines several methods for setting socket options that affect the socket’s behavior.
A value of 0 means that it should block forever.
Like all sockets, a ServerSocket should be closed with the close( ) method when it is no longer needed.
Once closed, a ServerSocket should not be used, except to call the isClosed( ) method which returns true if it has been closed.
Note, however, that this method always returns null for sockets created with any of the ServerSocket( ) constructors.
This class implements a socket for stream-based communication over the network.
See URL for a higher-level interface to networking and DatagramSocket for a lower-level interface.
Before you can use a socket for communication, it must be bound to a local address and connected to a remote address.
Binding and connection are done automatically for you when you call any of the Socket( ) constructors except the no-argument constructor.
These constructors allow you to specify either the name or the InetAddress of the computer to connect to, and also require you to specify the port number to connect to.
Two of these constructors also allow you to specify the local InetAddress and port number to bind the socket to.
Most applications do not need to specify a local address, and can simply use one of the two-argument versions of Socket( ) and can allow the constructor to choose an ephemeral local port to bind the socket to.
The no-argument Socket( ) constructor is different from the others: it creates an unbound and unconnected socket.
In Java 1.4 and later, you can explicitly call bind( ) and connect( ) to bind and connect the socket.
It can be useful to do this when you want to set a socket option (described below) that must be set before binding or connection.
There is also a version of connect( ) that takes a timeout value in milliseconds: if the connection attempt takes longer than the specified amount of time, connect( ) throws an IOException.
See ServerSocket for a description of how to write server code that accepts socket connection requests from client code.
Java 5.0 includes a constructor that takes a Proxy object as its sole argument.
Like the no-argument constructor, this creates an unbound and unconnected socket.
When you attempt to connect it, the connection will be made through the specified Proxy.
Use isBound( ) and isConnected( ) to determine whether a Socket is bound and connected.
Use getInetAddress( ) and getPort( ) to determine the IP address and port number that the socket is connected to.
Once you have a Socket object that is bound and connected, use getInputStream( ) and getOutputStream( ) to obtain InputStream and OutputStream objects you can use to communicate with the remote host.
You can use these streams just as you would use similar streams for file input and output.
When you are done with a Socket, use close( ) to close it.
Once a socket has been closed, it is not possible to call connect( ) again to reuse it, and you should not call any of its methods except isClosed( )
Because networking code can throw many exceptions, it is common practice to close( ) a socket in the finally clause of a try/catch statement to ensure that the socket always gets closed.
Note, however, that the close( ) method itself can throw an IOException, and you may need to put it in its own try block.
In Java 1.3 and later shutdownInput( ) and shutdownOutput( ) allow you to close the input and output communication channels individually without closing the entire socket.
In Java 1.4 and later, isInputShutdown( ) and isOutputShutdown( ) allow you to test for this.
The Socket class defines a number of methods that allow you to set (and query) “socket options” that affect the low-level networking behavior of the socket.
The default value of 0 specifies that the stream blocks indefinitely.
If lingering is turned on, the close( ) call blocks for up to the specified number of seconds while attempting to transmit the remaining data.
Calling setTcpNoDelay( ) with an argument of true causes data to be sent through the socket as soon as it is available, instead of waiting for the TCP packet to become more full before sending it.
In Java 1.3, use setKeepAlive( ) to enable or disable the periodic exchange of control messages across an idle socket connection.
The keepalive protocol enables a client to determine if its server has crashed without closing the socket and vice versa.
In Java 1.4, pass true to setOOBInline( ) if you want to receive “out of band” data sent to this socket “inline” on the input stream of the socket (by default such data is simply discarded)
This can be used to receive bytes sent with sendUrgentData( )
Java 1.4 also adds setReuseAddress( ) which you can use before binding the socket to specify that the socket should be allowed to bind to a port that is still nominally in use by another socket that is in the process of shutting down.
It returns the SocketChannel associated with this Socket if there is one.
Note, however, that this method always returns null for sockets created with any of the Socket( ) constructors.
If you create a SocketChannel object, and obtain a Socket from it, then the getChannel( ) method provides a way to link back to the parent channel.
Instances of this abstract class are opaque representations of network socket addresses.
The only concrete subclass in the core Java platform is InetSocketAddress which represents an internet address and port number.
This abstract class defines the methods necessary to implement communication through sockets.
Different subclasses of this class may provide different implementations suitable in different environments (such as behind firewalls)
These socket implementations are used by the Socket and ServerSocket classes.
Normal applications never need to use or subclass this class.
SocketImplFactory objects may be registered to create SocketImpl objects for the Socket and ServerSocket classes.
Normal applications never need to use or implement this interface.
This interface defines constants that represent low-level BSD Unix-style socket options and methods that set and query the value of those options.
Any custom socket implementations you define should also provide meaningful implementations for the getOption( ) and setOption( ) methods.
Your implementation may support options other than those defined here.
All other code can use methods defined by Socket, ServerSocket, DatagramSocket, and MulticastSocket to set specific socket options for those socket types.
Like all permissions, a SocketPermission consists of a name, or target, and a list of actions that may be performed on that target.
The target of a SocketPermission is the host and, optionally, the port or ports for which permission is being granted or requested.
The target consists of a hostname optionally followed by a colon and a port specification.
The host may be a DNS domain name, a numerical IP address, or the string “localhost”
If you specify a host domain name, you may use * as a wildcard as the leftmost portion of the hostname.
The port specification, if present, must be a single port number or a range of port numbers in the form n1-n2
If no port is specified, the socket permission applies to all ports of the specified host.
In addition to a target, each SocketPermission must have a comma-separated list of actions, which specify the operations that may be performed on the specified host(s) and port(s)
This action is only valid when used for ports on “localhost”
Finally, the “resolve” action indicates permission to use the DNS name service to resolve domain names into IP addresses.
This action is required for and implied by all other actions.
System administrators configuring security policies must be familiar with this class and understand the risks of granting the various permissions it represents.
System programmers writing new low-level networking libraries or connecting to native code that performs networking may need to use this class.
Application programmers, however, should never need to use it directly.
Signals that a timeout value was exceeded for a socket read or accept operation.
Signals that the name of a specified host could not be resolved.
Signals an attempt to use an unsupported service of a network connection.
A URI is a generalization of the URLs or Uniform Resource Locators used on the world wide web.
The URI supports parsing and textual manipulation of URI strings, but does not have any direct networking capabilities the way that the URL class does.
The advantages of the URI class over the URL class are that it provides more general facilities.
Obtain a URI with one of the constructors, which allow a URI to be parsed from a single string, or allow the specification of the individual components of a URI.
When using hard-coded URIs (rather than URIs based on user input) you may prefer to use the static create( ) method which does not throw any checked exceptions.
Once you have created a URI, object you can use the various get methods to query the various portions of the URI.
The getRaw( ) methods are like the get( ) methods except that they do not decode hexadecimal escape sequences of the form %xx that appear in the URI.
It returns a new URI which represents the same resource as the specified URI argument, but which is relative to this URI.
Finally, the toURL( ) method converts an absolute URI object to the equivalent URL.
Since the URI class provides superior textual manipulation capabilities for URLs, it can be useful to use the URI class to resolve relative URLs (for example) and then convert those URI objects to URL objects when they are ready for networking.
Signals that a string could not be parsed as a valid URI.
This is a checked exception thrown by all the URI( ) constructors.
If you are parsing a hard-coded URI that you do not believe to contain any syntax errors, and wish to avoid the checked exception, you can use the URI.create( ) factory method instead of the one-argument version of the URI( ) constructor.
This class represents a uniform resource locator and allows the data referred to by the URL to be downloaded.
A URL can be specified as a single string or with separate protocol, host, port, and file specifications.
Relative URLs can also be specified with a String and the URL object to which it is relative.
Use openConnection( ) to obtain a URLConnection object with which you can download the content of the URL.
In Java 5.0, you can explicitly specify a Proxy object through which the connection should be opened.
For simple cases, however, the URL class defines shortcut methods that create and invoke methods on a URLConnection internally.
In Java 1.3 and later, you can pass an array of Class objects that specify the type of objects that you are willing to accept as the return value of this method.
If you wish to parse the URL content yourself, call openStream( ) to obtain an InputStream from which you can read the data.
This ClassLoader provides a useful way to load untrusted Java code from a search path of arbitrary URLs, where each URL represents a directory or JAR file to search.
Use the inherited loadClass( ) method to load a named class with a URLClassLoader.
If the class is loaded from a local file: URL that represents a directory, the class is given permission to read all files and directories below that directory.
If the class is loaded from a local file: URL that represents a JAR file, the class is given permission to read that JAR file.
If the class is loaded from a URL that represents a resource on another host, that class is given permission to connect to and accept network connections from that host.
Note, however, that loaded classes are not granted this additional permission if the code that created the URLClassLoader in the first place would not have had that permission.
You can obtain a URLClassLoader by calling one of the URLClassLoader( ) constructors or one of the static newInstance( ) methods.
If you call newInstance( ), the loadClass( ) method of the returned URLClassLoader performs an additional check to ensure that the caller has permission to access the specified package.
This abstract class defines a network connection to an object specified by a URL.
You should use a URLConnection object when you want more control over the downloading of data than is available through the simpler URL methods.
Some methods must be called before the connection is made, and others depend on being connected.
The methods that depend on being connected call connect( ) themselves if no connection exists yet, so you never need to call this method explicitly.
The getContent( ) methods are just like the same-named methods of the URL class: they download the data referred to by the URL and parse it into an appropriate type of object (such as a string or an image)
In Java 1.3 and later, there is a version of getContent( ) that allows you to specify the types of parsed objects that you are willing to accept by passing an array of Class objects.
If you prefer to parse the URL content yourself instead of calling getContent( ), you can call getInputStream( ) (and getOutputStream( ) if the URL protocol supports writing) to obtain a stream through which you can read (or write) data from (or to) the resource identified by the URL.
Before a connection is established, you may want to set request fields (such as HTTP request headers) to refine the URL request.
Once a connection has been established, there are a number of methods you can call to obtain information from the “response headers” of the URL.
In Java 1.4 and later, getHeaderFields( ) returns an unmodifiable Map object that maps response header names to an unmodifiable List that contains the string value or values for the named header.
There are a number of options you can specify to control how the URLConnection behaves.
These options are set with the various set( ) methods and may be queried with corresponding get( ) methods.
The options must be set before the connect( ) method is called.
You can set this to false to force a URL to be reloaded.
In Java 5.0 and later, you can specify how long a URLConnection should wait while connecting or reading data with setConnectTimeout( ) and setReadTimeout( )
This class defines a single static method that converts a string to its URL-encoded form.
That is, spaces are converted to +, and nonalphanumeric characters other than underscore are output as two hexadecimal digits following a percent sign.
This method canonicalizes a URL specification so that it uses only characters from an extremely portable subset of ASCII that can be correctly handled by computers around the world.
This chapter documents the New I/O API defined by the java.nio package and its subpackages.
This package defines buffer classes that are fundamental to the java.nio API.
See Buffer for an overview of buffers, and see ByteBuffer (the most important of the buffer classes) for full documentation of byte buffers.
The other type-specific buffer classes are close analogs to ByteBuffer and are documented in terms of that class.
This class is the abstract superclass of all buffer classes in the java.nio API.
A buffer is a linear (finite) sequence of prmitive values.
The java.nio package defines a Buffer subclass for each primitive type in Java except for boolean.
Buffer itself defines the common, type-independent features of all buffers.
Buffer and its subclasses are intended for use by a single thread at a time, and contain no synchronization code to make them thread-safe.
The purpose of a buffer is to store data, and buffer classes must define methods for reading data from a buffer and writing data into a buffer.
Because each Buffer subclass stores data of a different primitive type, however, the get( ) and put( ) methods that read and write data must be defined by each of the individual subclasses.
See ByteBuffer (the most important subclass) for documentation of these methods; all the other subclasses define similar methods which differ only in the datatype of the values being read or written.
The capacity is specified when a buffer is created, and may not be changed; it can be queried with the capacity( ) method.
Data cannot be read from or written into a buffer beyond the limit.
When data is being written into a buffer, the limit is usually the same as the capacity.
When data is being read from a buffer, the limit may be less than the capacity, and indicates the amount of valid data contained in the buffer.
Two limit( ) methods exist: one to query a buffer’s limit, and one to set it.
It is used and updated by the relative get( ) and put( ) methods defined by ByteBuffer and the other Buffer subclasses.
Two position( ) methods exist to query and set the current position of the buffer.
The remaining( ) method returns the number of elements between the position and the limit and hasRemaining( ) returns true if this number is greater than zero.
Call mark( ) to set the mark to the current position.
Call reset( ) to restore the buffer’s position to the marked position.
Buffer defines several methods that perform important operations on a buffer:
This prepares the buffer to have new data written into it.
After data has been written into a buffer, this method “flips” the purpose of the buffer and prepares it for reading.
It does not alter the limit, and can be used to restart a read operation at the beginning of the buffer.
The isReadOnly( ) method returns true if a buffer is read-only.
Signals that a relative put( ) operation on a buffer could not complete because the number of elements to write exceeds the number of remaining elements between the buffer’s position and its limit.
Signals that a relative get( ) operation on a buffer could not complete because the number of elements to read exceeds the number of remaining elements between the buffer’s position and its limit.
ByteBuffer holds a sequence of bytes for use in an I/O operation.
ByteBuffer is an abstract class, so you cannot instantiate one by calling a constructor.
Instead, you must use allocate( ), allocateDirect( ), or wrap( )
The position of this new buffer is zero, and its limit is set to its capacity.
If you have already allocated an array of bytes, you can use the wrap( ) method to create a ByteBuffer that uses the byte array as its storage.
In the one-argument version of wrap( ) you specify only the array; the buffer capacity and limit are set to the array length, and the position is set to zero.
In the other form of wrap( ) you specify the array, as well as an offset and length that specify a portion of that array.
The capacity of the resulting ByteBuffer is again set to the total array length, but its position is set to the specified offset, and its limit is set to the offset plus length.
Once you have obtained a ByteBuffer, you can use the various get( ) and put( ) methods to read data from it or write data into it.
Several versions of these methods exist to read and write single bytes or arrays of bytes.
Relative get( ) and put( ) methods query or set the byte at the current position and then increment the position.
The absolute forms of the methods take an additional arguement that specifies the buffer element that is to be read or written and do not affect the buffer position.
Two other relative forms of the get( ) method exist to read as sequence of bytes (starting at and incrementing the buffer’s position) into a specified byte array or a specified sub-array.
Two relative forms of the put( ) method copy bytes from a specified array or sub-array into the buffer (starting at and incrementing the buffer’s position)
One final form of the put( ) method transfers all the remaining bytes from one ByteBuffer into this buffer, incrementing the positions of both buffers.
In addition to the get( ) and put( ) methods, ByteBuffer also defines another operation that affect the buffer’s content.
The position is then set to the new limit, and the limit is set to the capacity.
This method compacts a buffer by discarding elements that have already been read, and then prepares the buffer for appending new elements to those that remain.
All Buffer subclasses, such as CharBuffer, IntBuffer and FloatBuffer have analogous methods which are just like these get( ) and put( ) methods except that they operate on different data types.
ByteBuffer is unique among Buffer subclasses in that it has additional methods for reading and writing values of other primitive types from and into the byte buffer.
These methods have names like getInt( ) and putChar( ), and there are methods for all primitive types except byte and boolean.
The absolute methods take an buffer index (it is a byte index and is not multiplied by the size of the primitive value) as an argument and do not modify the buffer position.
The encoding of multi-byte primitive values into a byte buffer can be done most-significant byte to least-significant byte (“big-endian byte order”) or the reverse (“little-endian byte order”)
The byte order used by these primitive-type get and put methods is specified by a ByteOrder object.
The byte order for a ByteBuffer can be queried and set with the two forms of the order( ) method.
Other methods that are unique to ByteBuffer( ) are a set of methods that allow a buffer of bytes to be viewed as a buffer of other primitive types.
The returned buffers have position, limit, and mark values that are independent of those of the underlying buffer.
The initial position of the returned buffer is zero, and the limit and capacity are the number of bytes between the position and limit of the original buffer divided by the size in bytes of the relevant primitive type (two for char and short, four for int and float, and eight for long and double)
Note that the returned view buffer is a view of the bytes between the position and limit of the byte buffer.
Subsequent changes to the position and limit of the byte buffer do not change the size of the view buffer, but changes to the bytes themselves to change the values that are viewed through the view buffer.
View buffers use the byte ordering that was current in the byte buffer when they were created; subsequent changes to the byte order of the byte buffer do not affect the view buffer.
If the underlying byte buffer is direct, then the returned buffer is also direct; this is important because ByteBuffer is the only buffer class with an allocateDirect( ) method.
ByteBuffer defines some additional methods, which, like the get( ) and put( ) methods have analogs in all Buffer subclasses.
The two buffers have independent position, limit, and mark values, although the duplicate buffer starts off with the same values as the original buffer.
The duplicate buffer is direct if the original is direct and is read-only if the original is readonly.
The buffers share content, and content changes made to either buffer are visible through the other.
If this buffer has a backing array and is not a read-only buffer (e.g., if it was created with the allocate( ) or wrap( ) methods) then hasArray( ) returns true, array( ) returns the backing array, and arrayOffset( ) returns the offset within that array of the first element of the buffer.
Finally, ByteBuffer and other Buffer subclasses override several standard object methods.
The equals( ) methods compares the elements between the position and limit of two buffers and returns true only if there are the same number and have the same value.
Note that elements before the position of the buffer are not considered.
The hashCode( ) method is implemented to match the equals( ) method: the hashcode is based only upon the elements between the position and limit of the buffer.
This means that the hashcode changes if either the contents or position of the buffer changes.
This means that instances of ByteBuffer and other Buffer subclasses are not usually useful as keys for hashtables or java.util.Map objects.
ByteBuffer and each of the other Buffer subclasses also implement the Comparable interface and define a compareTo( ) method that performs an element-by-element comparison operation on the buffer elements between the position and the limit of the buffer.
This class is a type-safe enumeration of byte orders, and is used by the ByteBuffer class.
The static nativeOrder( ) method returns whichever of these two constants represents the native byte order of the underlying operating system and hardware.
CharBuffer holds a sequence of Unicode character values for use in an I/O operation.
Most of the methods of this class are directly analogous to methods defined by ByteBuffer except that they use char and char[ ] argument and return values instead of byte and byte[ ] values.
Note that CharBuffer is an abstract class and does not defined a constructor.
Note that there is no allocateDirect( ) method as there is for ByteBuffer.
By calling one of the static wrap( ) methods to create a CharBuffer that uses the specified char array or CharSequence for its content.
Note that wrapping a CharSequence results in a read-only CharBuffer.
By calling the asCharBuffer( ) method of a ByteBuffer to obtain a CharBuffer “view” of the underlying bytes.
If the underlying ByteBuffer is direct, then the CharBuffer view will also be direct.
Note that this class holds a sequence of 16-bit Unicode characters, and does not represent text in any other encoding.
Note that CharBuffer does not include any utility methods for working with int codepoints or surrogate pairs.
DoubleBuffer holds a sequence of double values for use in an I/O operation.
Most of the methods of this class are directly analogous to methods defined by ByteBuffer except that they use double and double[ ] argument and return values instead of byte and byte[ ] values.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” DoubleBuffer by calling the asDoubleBuffer( ) method of an underlying ByteBuffer.
FloatBuffer holds a sequence of float values for use in an I/O operation.
Most of the methods of this class are directly analogous to methods defined by ByteBuffer except that they use float and float[ ] argument and return values instead of byte and byte[ ] values.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” FloatBuffer by calling the asFloatBuffer( ) method of an underlying ByteBuffer.
IntBuffer holds a sequence of int values for use in an I/O operation.
Most of the methods of this class are directly analogous to methods defined by ByteBuffer except that they use int and int[ ] argument and return values instead of byte and byte[ ] values.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” IntBuffer by calling the asIntBuffer( ) method of an underlying ByteBuffer.
Signals that a buffer’s position cannot be reset( ) because there is no mark defined.
LongBuffer holds a sequence of long values for use in an I/O operation.
Most of the methods of this class are directly analogous to methods defined by ByteBuffer except that.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” LongBuffer by calling the asLongBuffer( ) method of an underlying ByteBuffer.
This class is a ByteBuffer that represents a memory-mapped portion of a file.
If it returns true, then operations on the buffer will probably execute very quickly.
For buffers that are mapped in read/write mode, the force( ) method outputs any changes that have been made to the buffer contents to the underlying file.
If the file is on a local device, then it is guaranteed to be updated before force( ) returns.
No such guarantees can be made for mapped network files.
Furthermore, if another thread or process truncates the file, some or all of the elements of the buffer may no longer map to any content of the file.
Signals that a buffer is read-only and that its put( ) or compact( ) methods are not allowed to modify the buffer contents.
ShortBuffer holds a sequence of short values for use in an I/O operation.
Most of the methods of this class are directly analogous to methods defined by ByteBuffer except that they use short and short[ ] argument and return values instead of byte and byte[ ] values.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” ShortBuffer by calling the asShortBuffer( ) method of an underlying ByteBuffer.
This package is at the heart of the NIO API.
Channels serve a similar purpose to the InputStream and OutputStream classes of the java.io package, but are completely unrelated to those classes, and provide important features not available with the java.io API.
The Channel interface simply defines methods for testing whether a channel is open and for closing a channel.
The other interfaces in the package extend Channel and define read( ) and write( ) methods for reading bytes from the channel into one or more byte buffers and for writing bytes from one or more byte buffers to the channel.
The FileChannel class defines an channel-based API for reading and writing from files (and also provides other important file functionality such as file locking and memory mapping that is not available through the java.io package)
The network and pipe channels are all subclasses of the SelectableChannel class, and may be put into nonblocking mode, in which calls to read( ) and write( ) return immediately, even if the channel is not ready for reading or writing.
The Selector class is crucial to the efficient use of nonblocking channels: it allows a program to register interested in I/O operations on several different channels at once.
A call to the select( ) method of a Selector will block until one of those channels becomes ready for I/O, and will then wake up.
This technique is important for writing scalable high-performance network servers.
Finally, this package allows for very fine-grained error handling by defining a large number of exception classes, several of which may be thrown by only a single method within the java.nio API.
Thrown by a call to connect( ) on a SocketChannel that is already connected.
Signals the termination of a blocked I/O operation because another thread closed the channel asynchronously.
It exists simply as a convience that to unify the two interfaces.
Signals an attempt to use a SelectionKey whose cancel( ) method has previously been called.
This interface defines a communication channel for input and output.
Channel defines only two methods: isOpen( ) determines whether a channel is open, and close( ) closes a channel.
Once closed, a channel remains closed forever, and no further I/O operations may take place through it.
Channels is never intended to be instantiated: it serves solely as a placeholder for static methods.
These methods create byte channels based on java.io byte streams, and create java.io byte streams based on byte channels.
An exception of this type is thrown by a thread blocked in an I/O operation on a channel when another thread calls its interrupt( ) method.
Channels may be closed asynchronously, and threads blocking to complete an I/O operation will throw a subclass of this exception type.
Signals an attempt to use a Selector object whose close( ) method has been called.
Signals a call to the connect( ) method of a SocketChannel when there is already a connection pending for that channel.
This class implements a communication channel based on network datagrams.
Obtain a DatagramChannel by calling the static open( ) method.
The send( ) and receive( ) methods typically perform security checks on each invocation to see if the application has permissions to communicate with the remote host.
If your application will use a DatagramChannel to exchange datagrams with a single remote host and port, use the connect( ) method to connect to a specified SocketAddress.
The connect( ) method performs the required security checks once and allows future communication with the specified address without the overhead.
Like the receive( ) method, the read( ) methods silently discard any received bytes that do not fit in the specified ByteBuffer.
The read( ) and write( ) methods throw a NotYetConnected exception if connect( ) has not been called.
DatagramChannel is a SelectableChannel; its validOps( ) method specifies that read and write operations may be selected.
Read and write operations may proceed concurrently, but the class ensures that only one thread may read and one thread write at a time.
This class implements a communication channel for efficiently reading and and writing files.
In addition, however, FileChannel provides methods for: random-access to the file, efficient transfer of bytes between the file and another channel, file locking, memory mapping, querying and setting the file size and forcing buffered updates to be written to disk.
Note that since file operations do not typically block for extended periods the way network operations can, FileChannel does not subclass SelectableChannel (it is the only channel class that does not) and cannot be used with Selector objects.
FileChannel has no public constructor and no static factory methods.
To obtain a FileChannel, first create a FileInputStream, FileOutputStream, or RandomAccessFile object (see the java.io package) and then call the getChannel( ) method of that object.
If you use a FileInputStream, the resulting channel will allow reading but not writing, and if you use a FileOutputStream, the channel will allow writing but not reading.
If you obtain a FileChannel from a RandomAccessFile, then the channel will allow reading, or both reading and writing, depending on the mode argument to the RandomAccessFile constructor.
A FileChannel has a position or file pointer that specifies the current point in the file.
You can set or query the file position with two methods, both of which share the name position( )
The position of a FileChannel and of the stream or RandomAccessFile from which it is derived are always the same: changing the position of the channel changes the position of the stream, and vice versa.
The initial position of a FileChannel is the position of the stream or RandomAccessFile when the getChannel( ) method was called.
If you create a FileChannel from a FileOutputStream that was opened in append mode, then any output to the channel always occurs at the end of the file, and sets the file position to the end end of the file.
Once you have a FileChannel object, you can use the standard read( ) and write( ) methods defined by the various channel interfaces.
In addition to updating the buffer position as they read and write bytes, these methods also update the file position to or from which those bytes are written or read.
These standard read( ) methods return the number of bytes actually read, and return -1 if there are no bytes left in the file to read.
The write( ) methods enlarge the file if they write past the current end-of-file.
If the specified position is past the end-of-file, the read() method does not read any bytes and returns -1, and the write( ) method enlarges the file, leaving any bytes between the old end-of-file and the specified position undefined.
It is common to read bytes from a FileChannel and then immediately write them out to some other channel (such as a SocketChannel: think of a web server, for example), or to read bytes from a channel and immediately write them to a FileChannel (consider an FTP client)
FileChannel provides two methods, transferTo( ) and transferFrom( ) that do this very efficiently, without the need for a temporary ByteBuffer.
It does not alter the file position of the FileChannel, and it returns the number of bytes actually transferred.
For both methods, if the destination or source channel is a FileChannel itself, then the file position of that channel is updated.
The size( ) method returns the size (in bytes) of the underlying file.
If the specified size is greater than or equal to the current file size, the file is unchanged.
If the file position is greater than the new size of the file, it the position is changed to the new size.
Use the force( ) method to force any buffered modifications to the file to be written to the underlying storage device.
If the file resides on a local device, (as opposed to a network filesystem, for example) then force( ) guarantees that any changes to the file made since the channel was opened or since a previous call to force( ) will have been written to the device.
The argument to this method is a hint as to whether file metadata (such as last modification time) is to be forced out in addition to file content.
If this argument is true, the system will force content and meta-data.
Note that force( ) is only required to output change made directly through the FileChannel.
File updates made through a MappedByteBuffer returned by the map( ) method (described below)y should be forced out with the force( ) method of MappedByteBuffer.
FileChannel defines two blocking lock( ) and two nonblocking tryLock( ) methods for locking a file or a region of a file against concurrent access by another program.
These methods are not suitable for preventing concurrent access to a file by two threads within the same Java virtual machine.
The no-argument versions of these methods attempt to acquire an exclusive lock on the entire file.
The three-argument versions of the methods attempt to lock a specified region of the file, and may acquire shared locks in addition to exclusive locks.
A shared lock prevents any other process from acquiring an exclusive lock, but does not prevent other shared locks: typically, you acquire a shared lock when reading a file that should not be concurrently updated, and acquire an exclusive lock before writing file content to ensure that no one else is trying to read it at the same time.
The tryLock( ) methods return a FileLock object, or null if there was already a conflicting lock on the file.
The lock( ) methods block if there is already a conflicting lock and never return null.
The FileChannel file locking mechanism uses whatever locking capability is provided by the underlying platform.
Some operating systems enforce file locking: if one process holds a lock, other processes are prevented by the operating system from accessing the file.
Other operating systems merely prevent other processes from acquiring a conflicting lock: in this case, successful file locking requires the cooperation of all processes.
Some operating systems do not support shared locks: on these systems an exclusive lock is returned even when a shared lock is requested.
The map( ) method returns a MappedByteBuffer that represents the specified region of the file.
File contents can be read directly from the buffer, and (if the mapping is done in read/write mode) bytes placed in the buffer will be written to the file.
The mapping represented by a MappedByteBuffer remains valid until the buffer is garbage collected; the buffer continues to function even if the FileChannel from which it was created is closed.
File mappings can be done in three different modes which specify whether bytes can be written into the buffer and what happens when this is done.
The map( ) method relies on the memory-mapping facilities provided by the underlying operating system.
This means that a number of details may vary from implementation to implementation.
In particular, it is not specified whether changes to the underlying file made after the call to map( ) are visible through the MappedByteBuffer.
Using a mapped file is typically more efficient that an unmapped file only when the file is a large one.
This class defines three constants that define the legal values of the mode argument to the map( ) method of the FileChannel class.
The contents of the MappedByteBuffer returned by the map( ) method may be read but may not be modified.
READ_WRITE The memory mapping is bidirectional: The contents of the returned buffer can be modified, and any modifications will (eventually) be written to the underlying file.
A FileLock object is returned by the lock( ) and tryLock( ) methods of FileChannel and represents a lock on a file or a region of a file.
See FileChannel for more information on file locking with those methods.
When a lock is no longer required, it should be released with the release( ) method.
A lock will also be released if the channel is closed, or when the virtual machine terminates.
The channel( ), position( ), size( ) and isShared( ) methods return basic information about the lock: the FileChannel that was locked, the region of the file that was locked, and whether the lock is shared or exclusive.
If the entire file is locked, then the size( ) method returns a value (Long.MAX_VALUE) that is much greater than the actual file size.
If the underlying operating system does not support shared locks, then isShared( ) may return false even if a shared lock was requested.
Signals that the interrupt( ) method of a thread blocked waiting to acquire a file lock was called.
These methods are passed an array of ByteBuffer objects, and, optionally, an offset and length that define the relevant sub-array to be used.
The write( ) method attempts to write all the remaining bytes from all the specified buffers (in the order in which they appear in the buffer array) to the channel.
The return value of the method is the number of bytes actually written.
Signals an attempt to use a channel in the wrong blocking mode.
Channels that implement this marker interface have two important properties that are relevant to multithreaded programs: they are asynchonously closeable and interruptible.
As the name of this interrupt implies, the channel that the thread was blocked on is closed as a side-effect of the thread interruption.
There is no way to interrupt a blocked thread without closing the channel upon which it is blocked.
This ability to interrupt a blocked thread is particularly noteworthy because it has never worked reliably with the older java.io API.
You can use the instanceof to determine whether an unknown channel object implements this interface.
Signals a call to the read( ) method of a readable channel that is not open for reading, such as a FileChannel created from a FileOutputStream.
Signal a call to a write( ) method of a writable channel that is not open for writing, such as a FileChannel created from a FileInputStream.
Signals an attempt to read( ) or write( ) on a SocketChannel that is not yet connected to a remote host.
This exception is thrown by the lock( ) and tryLock( ) methods of FileChannel if the requested lock region overlaps a file lock that is already held by some thread in this JVM, or if there is already a thread in this JVM waiting to lock an overlapping region of the same file.
The FileChannel file locking mechanism is designed to lock files against concurrent access by two separate processes.
Two threads within the same JVM should not attempt to acquire a lock on overlapping regions of the same file, and any attempt to do so causes an exception of this type to be thrown.
A pipe is an abstraction that allows the one-way transfer of bytes from one thread to another.
Create a new pipe with the static Pipe.open( ) method.
Programmers familiar with Unix-style pipes may find the names and return values of the sink( ) and source( ) methods confusing.
A Unix pipe is an interprocess communication mechanism that is tied to two specific processes, one of which is a source of bytes and one of which is a destination, or sink, for those bytes.
With this conceptual model of a pipe, you would expect the source to obtain the channel it writes to with the source( ) method and the sink to obtain the channel it reads from with the sink( ) method.
While it can be used for communication between two threads, the ends of the pipe are not tied to those threads, and there need not be a single source thread and a single sink thread.
Therefore, in the Pipe API it is the pipe itself that serves as the source and the sink of bytes: bytes are read from the source end of the pipe, and are written to the sink end.
This public inner class is represents the write end of a pipe.
Obtain a Pipe.SinkChannel by creating a Pipe object with Pipe.open( ) and then calling the sink( ) method of that object.
This class subclasses SelectableChannel, so that it can be used with a Selector.
This public inner class is represents the read end of a pipe.
This class subclasses SelectableChannel, so that it can be used with a Selector.
This subinterface of Channel defines a single key read( ) method which reads bytes from the channel and stores them in the specified ByteBuffer, updating the buffer position as it does so.
If the channel is a nonblocking channel, for example, the read( ) will return immediately, even if there are no bytes available to be read.
If a read operation is in progress, then any call to read( ) will block until the in-progress operation completes.
Some channel implementations may allow read and write operations to proceed concurrently, but none will allow two read operations to proceed at the same time.
These methods are passed an array of ByteBuffer objects, and, optionally, an offset and length that define the region of the array to be used.
The read( ) method attempts to read enough bytes from the channel to fill each of the specified buffers in the order in which they appear in the buffer array (the “scattering” process is actually much more orderly and linear than the name implies)
The return value of the method is the number of bytes actually read, which may be different than the sum of the remaining bytes in the buffers.
This abstract class defines the API for channels that can be used with a Selector object to allow a thread to block while waiting for activity on any of a group of channels.
A selectable channel may only be registered with a Selector if it is nonblocking, so this class defines the configureBlocking( ) method.
Pass false to this method to put a channel into nonblocking mode, or pass true to make calls to its read( ) and/or write( ) methods block.
Use isBlocking( ) to determine the current blocking mode of a selectable channel.
Register a SelectableChannel with a Selector by calling the register( ) method of the channel (not of the selector)
There are two versions of this method: both take a Selector object and a bitmask that specifies the set of channel operations that are to be “selected” on that channel.
Both methods return a SelectionKey object that represents the registration of the channel with the selector.
One version of the register( ) method also takes an arbitrary object argument which serves as an “attachment” to the SelectionKey and allows you to associate arbitrary data with it.
The validOps( ) method returns a bitmask that specifies the set of operations that a particular channel object allows to be selected.
The bitmask passed to register( ) may only contain bits that are set in this validOps( ) value.
Note that SelectableChannel does not define a deregister( ) method.
Instead, to remove a channel from the set of channels being monitored by a Selector, you must call the cancel( ) method of the SelectionKey returned by register( )
Call isRegistered( ) to determine whether a SelectableChannel is registered with any Selector.
Note that a single channel may be registered with more than one Selector.
If you did not keep track of the SelectionKey returned by a call to register( ), you can query it with the keyFor( ) method.
See Selector and SelectionKey for further details on multiplexing selectable channels.
A SelectionKey represents the registration of a SelectableChannel with a Selector, and serves to identify a selected channel and the operations that are ready to be performed on that channel.
After a call to the select( ) method of a selector, the selectedKeys( ) method of the selector returns a Set of SelectionKey objects to identify the channel or channels that are ready for reading, for writing, or for another operation.
Create a SelectionKey by passing a Selector object to the register( ) method of a SelectableChannel.
The channel( ) and selector( ) methods of the returned SelectionKey return the SelectableChannel and Selector objects associated with that key.
When you no longer wish the channel to be registered with the selector, call the cancel( ) method of the SelectionKey.
The main purpose of a SelectionKey is to hold the “interest set” of channel operations that the selector should monitor for the channel, and also the “ready set” of operations that the selector has determined are ready to proceed on the channel.
Both sets are represented as integer bitmasks (not java.util.Set objects) formed by OR-ing together any of the OP_ constants defined by this class.
OP_READ In the interest set, this bit specifies an interest in read operations.
In the ready set, this bit specifies that the channel has bytes available for reading, has reached the end-of-stream, has been remotely closed, or that an error has occurred.
OP_WRITE In the interest set, this bit specifies an interest in write operations.
In the ready set, this bit specifies that the channel is ready to have bytes written, or has been closed, or that an error has occurred.
OP_CONNECT In the interest set, this bit specifies an interest in socket connection operations.
In the ready set, it indicates that a socket channel is ready to connect, or that an error has occurred.
OP_ACCEPT In the interest set, this bit specifies an interest in server socket accept operations.
In the ready set, it indicates that a server socket channel is ready to accept a connection or that an error has occurred.
The no-argument version of the interestOps( ) method allows you to query the interest set.
The inital value of the interest set the bitmask that was passed to the register( ) method of the channel.
It can be changed, however, by passing a new bitmask to the one-argument version of interestOps( )
Note that the same method name is used to both query and set the interest set.
The current state of the ready set can be queried with readyOps( )
You can also use the convenience methods isReadable( ), isWritable( ) isConnectable( ) and isAcceptable( ) to test whether individual operation bits are set in the ready set bitmask.
There is no way to explicitly set the state of the ready set--each call to select( ) method updates the ready set for you.
If you never remove the SelectionKey from the set of selected keys, the Selector assumes that none of the I/O readyness conditions represented by the ready set have been handled yet, and leaves their bits set.
Use attach( ) to associate an arbitrary object with a SelectionKey, and call attachment( ) to query that object.
This ability to associate data with a selection key is often useful when using a Selector with multiple channels: it can provide the context necessary to process a SelectionKey that has been selected.
A Selector is an object that monitors multiple nonblocking SelectableChannel objects and (after blocking if necessary) “selects” the channel that is (or the channels that are) ready for I/O.
Create a new Selector with the static open( ) method.
Next register the channels that it is to monitor: a channel is registered by passing the Selector to the register( ) method of the channel (register( ) is defined by the abstract SelectableChannel class)
In addition to the Selector you must also pass a bitmask that specifies which I/O operations (reading, writing, connecting, and accepting) that the Selector is to monitor for that channel.
Each call to this register( ) method returns a SelectionKey object.
The SelectionKey class also defines the constants that are used to form the bitmask of I/O operations.
Note that before a SelectableChannel can be registered, it must be in nonblocking mode, which can be accomplished with the configureBlocking( ) method of SelectableChannel.
Once the channels are registered with the Selector, call select( ) to block until one or more of the channels is ready for I/O.
One version of select( ) takes a timeout value and.
These methods also return if any of the channels is closed, if an error occurs on any channel, if the wakeup( ) method of the Selector is called, or if the interrupt( ) method of the blocked thread is called.
There is also a selectNow( ) method which is like select( ) except that it does not block: it simply polls each of the channels and determines which have become ready for I/O.
The return value of selectNow( ) and of both select( ) methods is the number of channels ready for I/O.
It is possible for this return value to be zero.
The select( ) and selectNow( ) methods returns the number of channels that are ready for I/O; they do not return the channels themselves.
To obtain this information, you must call the selectedKeys( ) method, which returns a java.util.Set containing SelectionKey objects.
Use the channel( ) method of the SelectionKey to determine which channel is ready, and call readyOps( ), isReadable( ), isWritable( ) or related methods of the SelectionKey to determine what kind of I/O operation is ready on the channel.
SelectionKey objects remain in the selectedKeys( ) set until explicitly removed, so after performing the I/O operation for a given SelectionKey, you should remove that key from the Set returned by selectedKeys( ) (use the remove( ) method of the Set of its Iterator)
In addition to the selectedKeys( ) method, Selector also defines a keys( ) method, which also returns a Set of SelectionKey objects.
This set represents the complete set of channels that are being monitored by the Selector and may not be modified, except by closing the channel or deregistring the channel by calling the cancel( ) method of the associated SelectionKey.
Cancelled keys are removed from the keys( ) set on the next call to select( ) or selectNow( )
Call wakeup( ) to cause another thread blocked in a call to select( ) to wake up and return immediately.
If wakeup( ) is called but no thread is currently blocked in a select( ) call, then the next call to select( ) or selectNow( ) will return immediately.
When a Selector object is no longer needed, close it by calling close( )
If any thread is blocked in a select( ) call, it will return immediately as if wakeup( ) had been called.
After calling close( ), you should not call any other methods of a Selector.
Note, however, that the Set object returnd by selectedKeys( ) is not: it should be used by only one thread at a time.
It is a selectable channel that can be used by servers to accept connections from clients.
Unlike other channel classes in this package, this class cannot be used for reading or writing bytes: it does not implement any of the ByteChannel interfaces, and exists only to accept and establish connections with clients, not to communicate with those clients.
Next, call socket( ) to obtain the associated ServerSocket object, and use its bind( ) method to bind the server socket to a specific port on the local host.
You can also call any other ServerSocket methods to configure other socket options at this point.
If the channel is in blocking mode, this method will block until a client connects, and will then return a SocketChannel that is connected to the client.
In nonblocking mode, (see the inherited configureBlocking( ) method) accept( ) returns a SocketChannel only if there is a client currently waiting to connect, and otherwise immediately returns null.
It is a subclass of SelectableChannel and can be used with a Selector.
Create a new SocketChannel with one of the static open( ) methods.
The no-argument version of open( ) creates a new SocketChannel but does not connect it to a remote host.
If you create an unconnected socket, you can explictly connect it with the connect( ) method.
The main reason to open the channel and connect to the remote host in separate steps is if you want to do a nonblocking connect.
To do this, first put the channel into nonblocking mode with the inherited configureBlocking( ) method.
Then, call connect( ): it will return immediately, without waiting for the connection to be established.
When you are notified that your channel is ready to connect (see Selector and SelectionKey for details) simply call the nonblocking finishConnect( ) method to complete the connection.
Once you have opened and connected a SocketChannel, you can read and write bytes to it with the various read( ) and write( ) methods.
SocketChannel is thread-safe: read and write operations may proceed concurrently, but SocketChannel will not allow more than one read operation and more than one write operation to proceed at the same time.
You can use this Socket object to configure socket options, bind the socket to a specific local address, close the socket, or shutdown its input or output sides.
When you are done with a SocketChannel, close it with the close( ) method.
When the input is shut down, any future reads (and any blocked read operation) will return -1 to indicate that the end-ofstream has been reached.
This subinterface of Channel defines a single key write( ) method which writes bytes from a specified ByteBuffer (updating the buffer position as it goes) to the channel.
This is not always possible (with nonblocking channels, for example) so the write( ) method returns the number of bytes that it was actually able to write to the channel.
If a write operation is in progress, then any call to write( ) will block until the in-progress operation completes.
Some channel implementations may allow read and write operations to proceed concurrently; some may not.
It also defines the SelectorProvider class which allows a custom implementation of channels and selectors to be specified for use instead of the default implementation.
This class exists as a convenience for implementors of new Channel classes.
Application programmers should never need to subclass or use it.
This class exists as a convenience for implementors of new selectable channel classes: it defines common methods of SelectableChannel in terms of protected methods whose names begin with impl.
Application programmers should never need to use or subclass this class.
This class exists as a convenience for implementors of new SelectionKey classes.
Application programmers should never need to use or subclass this class.
This class exists as a convenience for implementors of new Selector classes.
Application programmers should never need to use or subclass this class.
A concrete subclass of SelectorProvider implements factory methods that return open socket channels, server socket channels, datagram channels, pipes (with their two internal channels) and Selector objects.
The provider( ) method first looks for the system property, then looks for the JAR file entry.
If it finds neither, it instantiates the implementation’s default SelectorProvider.
Applications are not required to use the default SelectorProvider exclusively.
It is legal to instantiate other SelectorProvider objects and explictly invoke their open( ) methods to create channels in that way.
This package contains classes that represent character sets or encodings, and defines methods that encode characters into bytes and decode bytes into characters.
The key class is Charset, and you can obtain a Charset object for a named character encoding with the static forName( ) method.
Charset defines encode( ) and decode( ) convenience methods, but for full control over the encoding and decoding process, you can also obtain a CharsetEncoder or CharsetDecoder object from the Charset.
The Java platform has had a character encoding and decoding facility since Java 1.1, and defines a number of classes and methods that perform character encoding or decoding.
Some of these classes and methods are specified to use the default charset for the locale; others take the name of a charset as a method or constructor argument.
Most applications will not have to do this, however, and can simply continue to rely on the default charset, or can continue to supply charset names where needed.
Note also that the encode( ) and decode( ) convenience methods of Charset do not throw this exception because they specify that malformed input and unmappable characters or bytes should be replaced.
Each Charset has a cannonical name, returned by name( ), and a set of aliases, returned by aliases( )
In Java 5.0, you can obtain the default Charset used by the Java VM with the static defaultCharset( ) method.
Check whether a charset specified by name or alias is supported with the static isSupported( )
Obtain the complete set of installed charsets with availableCharsets( ) which returns a sorted map from canonical names to Charset objects.
Note that charset names are not casesensitive, and you can use any capitialization for charset names you pass to isSupported( ) and forName( )
Note that there are a number of classes and methods in the Java platform that specify charsets by name rather than by Charset object.
When working with classes and methods such as these, there is no need to use a Charset object.
All implementations of Java are required to support at least the following 6 charsets:
Once you have obtained a Charset with forName( ) or availableCharsets( ), you can use the encode( ) method to encode a String or CharBuffer of text into a ByteBuffer, or you can use the decode( ) method to convert the bytes in a ByteBuffer into characters in a CharBuffer.
These convenience methods create a new CharsetEncoder or CharsetDecoder, specify that malformed input or unmappable characters or bytes should be replaced with the default replacement string or bytes, and then invoke the encode( ) or decode( ) method of the encoder or decoder.
For full control over the encoding and decoding process, you may prefer to obtain your own CharsetEncoder or CharsetDecoder object with newEncoder( ) or newDecoder( )
Note that not all Charset objects support encoding (“auto-detect” charsets can determine the source charset when decoding, but have no way to encode)
Use canEncode( ) to determine whether a given Charset can encode.
The equals( ) method compares two charsets by comparing their canonical.
Assumes big-endian when decoding if there is no byte order mark.
Encodes using bigendian byte order and outputs an appropriate byte order mark.
Charset implements Comparable, and its compareTo( ) method orders charsets by their canonical name.
That is, if every character that can be represented in the specified charset can also be represented in this charset.
Note that those representations need not be the same, however.
A CharsetDecoder is a “decoding engine” that converts a sequence of bytes into a sequence of characters based on the encoding of some charset.
Obtain a CharsetDecoder from the Charset that represents the charset to be decoded.
If you have a complete sequence of bytes to be decoded in a ByteBuffer you can pass that buffer to the one-argument version of decode( )
This convenience method decodes the bytes and stores the resulting characters into a newly allocated CharBuffer, resetting and flushing the decoder as necessary.
It throws an exception if there are problems with the bytes to be decoded.
Typically, however, the three-argument version of decode( ) is used in a multistep decoding process:
Call the reset( ) method, unless this is the first time the CharsetDecoder has been used.
Call the three-argument version of decode( ) one or more times.
The third argument should be true on, and only on, the last invocation of the method.
The first argument to decode( ) is a ByteBuffer that contains bytes to be decoded.
The second argument is a CharBuffer into which the resulting characters are stored.
The return value of the method is a CoderResult object that specifies the state of the ongoing the decoding operation.
In a typical case, however, decode( ) returns after it has decoded all of the bytes in the input buffer.
In this case, you would then typically fill the input buffer with more bytes to be decoded, and read characters from the output buffer, calling its compact( ) method to make room for more.
Pass the output CharBuffer to the flush( ) method to allow any remaining characters to be output.
The decode( ) method returns a CoderResult that indicates the state of the decoding operation.
Otherwise, the reurn value is a CoderResult whose isError( ) method returns true.
If isMalformed( ) returns true then the input included bytes that are not legal for the charset.
These bytes start at the position of the input buffer, and continue for length( ) bytes.
Otherwise, if isUnmappable( ) returns true, then the input bytes include a character for which there is no representation in Unicode.
The relevant bytes start at the position of the input buffer and continue for length( ) bytes.
By default a CharsetDecoder reports all malformed input and unmappable character errors by returning a CoderResult object as described above.
CodingErrorAction defines three constants that represent the three possible actions.
The REPLACE action tells the CharsetDecoder to replace malformed input and unmappable characters with the replacement string.
This replacement string can be set with replaceWith( ), and can be queried with replacement( )
These values can be used to help you choose the size of the CharBuffer to allocate for decoding.
Only one thread should use an instance at a time.
Implementors defining new charsets will need to subclass CharsetDecoder and define the abstract decodeLoop( ) method, which is invoked by decode( )
A CharsetEncoder is an “encoding engine” that converts a sequence of characters into a sequence of bytes using some character encoding.
Obtain a CharsetEncoder with the newEncoder( ) method of the Charset that represents the desired encoding.
Use the encode( ) method to encode characters read from a CharBuffer into bytes stored in a ByteBuffer.
An error of this type is thrown by the encode( ) and decode( ) methods when the protected encodeLoop( ) or decodeLoop( ) methods upon which they are implemented throws an exception of an unexpected type.
There are four possible reasons why a call to the decode( ) or encode( ) would return:
Calling the isUnderflow( ) method on the returned object returns true and calling isError( ) returns false.
Calling isOverflow( ) on the returned object returns true, and calling isError( ) returns false.
If the input data was malformed, containing characters or bytes that are not legal for the charset, and the CharsetEncoder or CharsetDecoder has not specified that malformed input should be ignored or replaced, then the returned value is a CoderResult object.
The position of the input buffer is at the first malformed character or byte, and the length( ) method of the returned object specifies how many characters or bytes are malformed.
The input buffer is positioned at the first unmappable character or byte, and the length( ) method of the CoderResult specifies the number of unmappable characters or bytes.
These constants specify how malformed input and unmappable error conditions should be handled.
This is the default action for both error types for both CharsetDecoder and CharsetEncoder.
Charset names may contain only the characters A–Z (in upper- and lowercase), the digits 0–9, and hyphens, underscores, colons, and periods.
They must begin with a letter or a digit, not with a punctuation character.
Signals that the requested charset is not supported on the current platform.
This exception is thrown by Charset.forName( ) when no Charset object can be obtained for the named charset.
This package defines a “provider” class for system developers who are defining new Charset implementations and want to make them available to the system.
Application programmers never need to us this package or the class it defines.
System programmers developing new Charset implementations should implement this class to make those charsets available to the system.
It defines classes that should work with any type of certificate, and type-specific subclasses for X.509 certificates and CRLs.
Instances of these classes can be used with any security provider.
The java.security package contains the classes and interfaces that implement the Java security architecture.
Second, there are authentication classes that implement message digests and digital signatures and can authenticate Java classes and other objects.
The central access control class is AccessController; it uses the currently installed Policy object to decide whether a given class has Permission to access a given system resource.
The Permissions and ProtectionDomain classes are also important pieces of the Java access control architecture.
The key classes for authentication are MessageDigest and Signature; they compute and verify cryptographic message digests and digital signatures.
These classes use public-key cryptography techniques and rely on the PublicKey and PrivateKey interfaces.
The CodeSource class unites the authentication classes with the access control classes.
The AccessController and Policy classes look at the CodeSource of a class when making access control decisions.
Thus, in addition to defining a security API, this package also defines a service provider interface (SPI)
Various classes with names that end in Spi are part of this SPI.
Security provider implementations must subclass these Spi classes, but applications never need to use them.
Each security provider is represented by a Provider class, and the Security class allows new providers to be dynamically installed.
For example, DigestInputStream and DigestOutputStream make it easy to compute message digests.
SignedObject protects the integrity of an arbitrary Java object by attaching a digital signature, making it easy to detect any tampering with the object.
Although the java.security package contains cryptographic classes for authentication, it does not contain classes for encryption or decryption.
Instead, this functionality is part of the Java Cryptography Extension or JCE which defines the javax.crypto package and its subpackages.
The checkPermission( ) method can make access-control decisions based on the saved state of the call stack.
Sometimes, however, it is necessary to make access-control decisions based on a previous state of the call stack.
This class is used only by system-level code; typical applications rarely need to use it.
Thrown by AccessController to signal that an access request has been denied.
The static methods of this class implement the default access-control mechanism as of Java 1.2
If so, checkPermission( ) returns, and the operation can proceed.
System-level code that needs to perform an access check should invoke the SecurityManager method rather than calling the AccessController method directly.
When checkPermission( ) is traversing the call stack of a thread, it stops if it reaches a privileged block that was executed with doPrivileged( )
This means that privileged code can run with a full set of privileges, even if it was invoked by untrusted or lower-privileged code.
Such a context might be saved and passed to a future call (perhaps a call made from a different thread)
You may also specify a SecureRandom source of randomness when you call init( )
A security provider must implement a concrete subclass of this class for each algorithm it supports.
This class is a generic, opaque representation of the parameters used by some cryptographic algorithm.
You can create an instance of the class with one of the static getInstance( ) factory methods, specifying the desired algorithm and, optionally, the desired provider.
A security provider must implement a concrete subclass of this class for each cryptographic algorithm it supports.
This class is a Permission subclass whose implies( ) method always returns true.
This means that code that has been granted AllPermission is granted all other possible permissions.
This class exists to provide a convenient way to grant all permissions to completely trusted code.
Applications typically do not need to work directly with Permission objects.
This subclass of Provider defines methods that allow users to “log in” before using the provider’s services.
This Permission class is the abstract superclass for a number of simple permission types.
BasicPermission is typically subclassed to implement named permissions that have a name, or target, string, but do not support actions.
The implies( ) method of BasicPermission defines a simple wildcarding capability.
The target “x.*” implies permission for any target that begins with “x.”
Applications typically do not need to work directly with Permission objects.
This interface was used in Java 1.1 to represent an identity certificate.
This class encapsulates the certificate path of a code signer and a signed timestamp.
This class represents the source of a Java class, as defined by the URL from which the class was loaded and the set of digital signatures attached to the class.
In Java 5.0, the class has been generalized to accept an array of CodeSigner objects instead of Certificate objects.
Only applications that create custom ClassLoader objects should ever need to use or subclass this class.
When a CodeSource represents a specific piece of Java code, it includes a fully qualified URL and the actual set of certificates used to sign the code.
When a CodeSource object defines a ProtectionDomain, however, the URL may include wildcards, and the array of certificates is a minimum required set of signatures.
The implies( ) method of such a CodeSource tests whether a particular Java class comes from a matching URL and has the required set of signatures.
This class is a byte input stream with an associated MessageDigest object.
When bytes are read with any of the read( ) methods, those bytes are automatically passed to the update( ) method of the MessageDigest.
When you have finished reading bytes, you can call the digest( ) method of the MessageDigest to obtain a message digest.
If you want to compute a digest just for some of the bytes read from the stream, use on( ) to turn the digesting function on and off.
Digesting is on by default; call on(false) to turn it off.
This class is a byte output stream with an associated MessageDigest object.
When bytes are written to the stream with any of the write( ) methods, those bytes are automatically passed to the update( ) method of the MessageDigest.
When you have finished writing bytes, you can call the digest( ) method of the MessageDigest to obtain a message digest.
If you want to compute a digest just for some of the bytes written to the stream, use on( ) to turn the digesting function on and off.
Digesting is on by default; call on(false) to turn it off.
This interface defines a single combine( ) method that combines two arrays of ProtectionDomain objects into a single equivalent (and perhaps optimized) array.
This class is used only by system-level code; typical applications rarely need to use it.
This class is the superclass of most of the exceptions defined by the java.security package.
The checkGuard( ) method is passed an object to which access has been requested.
If access should be granted, checkGuard( ) should return silently.
The Guard object is used primarily by the GuardedObject class.
This class uses a Guard object to guard against unauthorized access to an arbitrary encapsulated object.
Create a GuardedObject by specifying an object and a Guard for it.
The getObject( ) method calls the checkGuard( ) method of the Guard to determine whether access to the object should be allowed.
If access is allowed, getObject( ) returns the encapsulated object.
The Guard object used by a GuardedObject is often a Permission.
In this case, access to the guarded object is granted only if the calling code is granted the specified permission by the current security policy.
This deprecated class was used in Java 1.1 to represent an entity or Principal with an associated PublicKey object.
In Java 1.1, the public key for a named entity could be retrieved from the system keystore with a line like the following:
This deprecated class was used in Java 1.1 to represent a group of Identity and Signer objects and their associated PublicKey and PrivateKey objects.
As of Java 1.2, it has been replaced by the KeyStore class.
This interface defines the high-level characteristics of all cryptographic keys.
This class translates asymmetric cryptographic keys between the two representations used by the Java Security API.
To convert a Key to a KeySpec or vice versa, create a KeyFactory by calling one of the static getInstance( ) factory methods specifying the name of the key algorithm (e.g., DSA or RSA) and optionally specifying the name or Provider object for the desired provider.
Then, use generatePublic( ) or generatePrivate( ) to create a PublicKey or PrivateKey object from a corresponding KeySpec.
Or use getKeySpec( ) to obtain a KeySpec for a given Key.
Because there can be more than one KeySpec implementation used by a particular cryptographic algorithm, you must also specify the Class of the KeySpec you desire.
If you do not need to transport keys portably between applications and/or systems, you can use a KeyStore to store and retrieve keys and certificates, avoiding KeySpec and KeyFactory altogether.
A security provider must implement a concrete subclass of this class for each cryptographic algorithm it supports.
In Java 1.2, this exception is only thrown by deprecated methods.
This class is a simple container for a PublicKey and a PrivateKey object.
Because a KeyPair contains an unprotected private key, it must be used with as much caution as a PrivateKey object.
This class generates a public/private key pair for a specified cryptographic algorithm.
To create a KeyPairGenerator, call one of the static getInstance( ) methods, specifying the name of the algorithm and, optionally, the name or Provider object of the security provider to use.
The default “SUN” provider shipped with Java 1.2 supports only the “DSA” algorithm.
The “SunJCE” provider of the Java Cryptography Extension (JCE) additionally supports the “DiffieHellman” algorithm.
Once you have created a KeyPairGenerator, initialize it by calling initialize( )
In either case, you may optionally provide your own source of randomness in the guise of a SecureRandom object.
Once you have created and initialized a KeyPairGenerator, call genKeyPair( ) to create a KeyPair object.
Remember that the KeyPair contains a PrivateKey that must be kept private.
Applications should not use any methods inherited from that class.
A security provider must implement a concrete subclass of this class for each cryptographic algorithm for which it can generate key pairs.
This class defines a serialized representation for Key implementations and is typically used only by security providers, not users of the java.security package.
The constants defined by this enumerated type represent the general types of cryptographic keys: public keys, private keys, and secret keys.
Obtain a KeyStore object by calling one of the static getInstance( ) methods, specifying the desired key store type and, optionally, the desired provider.
Use “JKS” to specify the “Java Key Store” type defined by Sun.
If you have the Java Cryptography Extension installed, use the type “JCEKS” and provider “SunJCE” to obtain a KeyStore implementation that offers much stronger password-based encryption of keys.
Once you have created a KeyStore, use load( ) to read its contents from a stream, supplying an optional password that verifies the integrity of the stream data.
Keystores are typically read from a file named .keystore in the user’s home directory.
The KeyStore API has been substantially enhanced in Java 5.0
A KeyStore may contain both public and private key entries.
A public key entry is represented by a Certificate object.
A private key entry in the keystore contains both a password-protected Key and an array of Certificate objects that represent the certificate chain for the public key that corresponds to the private key.
Use setKeyEntry( ) to create a new private key entry.
You must provide a password when reading or writing a private key from the keystore; this password encrypts the key data, and each private key entry should have a different password.
Secret keys are stored like private keys, except that they do not have a certificate chain associated with them.
To delete an entry from a KeyStore, use deleteEntry( )
If you modify the contents of a KeyStore, use store( ) to save the keystore to a specified stream.
You may specify a password that is used to validate the integrity of the data, but it is not used to encrypt the keystore.
In Java 5.0 the KeyStore.Entry interface defines a keystore entry.
You can get or set an entry of any type with the new methods getEntry( ) and setEntry( )
An instance of this class encapsulates the parameters necessary to obtain a KeyStore object at some later time.
This class is useful when you want to defer the initialization of a KeyStore (which may require the user to enter a password) until it is needed.
This interface represents an object passed to the load( ) or store( ) methods of KeyStore.
Note that getPassword( ) returns a reference to the internal array, not a clone of it.
The first element of the returned array is the certificate of the ultimate certificate authority (CA)
This “end entity” certificate is also available through the getCertificate( ) method.
This marker interface should be implemented by classes that provide some form of protection for the entries in a KeyStore.
This implementation of KeyStore.Entry represents a certificate that contains and certifies a public key.
A security provider must implement a concrete subclass of this class for each KeyStore type it supports.
This class computes a message digest (also known as a cryptographic checksum) for an arbitrary sequence of bytes.
Obtain a MessageDigest object by calling one of the static getInstance( ) factory methods and specifying the desired algorithm (e.g., SHA or MD5) and, optionally, the desired provider.
Next, specify the data to be digested by calling any of the update( ) methods one or more times.
Prior to Java 5.0, you must pass a byte[ ] to update( )
This facilitates the computation of message digests when using the New I/O API.
After you pass data to update( ), call digest( ), which computes the message digest and returns it as an array of bytes.
If you have only one array of bytes to be digested, you can pass it directly to digest( ) and skip the update( ) step.
When you call digest( ), the MessageDigest( ) object is reset and is then ready to compute a new digest.
You can also explicitly reset a MessageDigest without computing the digest by calling reset( )
To compute a digest for part of a message without resetting the MessageDigest, clone the MessageDigest and call digest( ) on the cloned copy.
Note that not all implementations are cloneable, so the clone( ) method may throw an exception.
A security provider must implement a concrete subclass of this class for each message-digest algorithm it supports.
Thrown by getInstance( ) factory methods throughout the java.security package.
Signals that a requested cryptographic service provider is not available.
Thrown by getInstance( ) factory methods throughout the java.security package.
This abstract class represents a system resource, such as a file in the filesystem, or a system capability, such as the ability to accept network connections.
Permission objects are used by system code that is requesting access to a resource.
They are also used by Policy objects that grant access to resources.
As of Java 1.2, this is the fundamental Java access-control mechanism.
Each permission has a name (sometimes called the target) and, optionally, a commaseparated list of actions.
For example, the name of a FilePermission is the name of the file or directory for which permission is being granted.
The actions associated with this permission might be “read”; “write”; or “read,write”
The interpretation of the name and action strings is entirely up to the implementation of Permission.
A number of implementations support the use of wildcards; for example, a FilePermission can have a name of “/tmp/*”, which represents access to any files in a /tmp directory.
Permission objects must be immutable, so an implementation must never define a setName( ) or setActions( ) method.
One of the most important abstract methods defined by Permission is implies( )
This method must return true if this Permission implies another Permission.
For example, if an application requests a FilePermission with name “/tmp/test” and action “read”, and the current security Policy grants a FilePermission with name “/tmp/*” and actions “read,write”, the request is granted because the requested permission is implied by the granted one.
In general, only system-level code needs to work directly with Permission and its concrete subclasses.
System administrators who are configuring security policies need to understand the various Permission subclasses.
Applications that want to extend the Java accesscontrol mechanism to provide customized access control to their own resources should subclass Permission to define custom permission types.
This class is used by Permissions to store a collection of Permission objects that are all the same type.
Use the elements( ) method to obtain an Enumeration of the Permission objects in the collection.
Use implies( ) to determine if a specified Permission is implied by any of the Permission objects in the collection.
Permissions is used by system code that manages security policies.
This class represents a security policy that determines the permissions granted to code based on its source and signers, and, in Java 1.4 and later, based on the user on whose behalf that code is running.
There is only a single Policy in effect at any one time.
Obtain the system policy by calling the static getPolicy( ) method.
Code that has appropriate permissions can specify a new system policy by calling setPolicy( )
The refresh( ) method is a request to a Policy object to update its state (for example, by rereading its configuration file)
Applications should not need to use this class unless they implement some kind of custom access-control mechanism.
As of Java 1.4, you can use a ProtectionDomain object to encapsulate a CodeSource and a set of users on whose behalf the code is running.
In addition, there is a new implies( ) method that dynamically queries the Policy to see if the specified permission is granted to the specific ProtectionDomain.
This interface represents any entity that may serve as a principal in a cryptographic transaction of any kind.
A Principal may represent an individual, a computer, or an organization, for example.
It extends the Key interface, but does not add any new methods.
The interface exists in order to create a strong distinction between private and public keys.
In Java 5.0 this interface is generic and the type variable T represents the return type of the run( ) method.
When privileged code is run with the doPrivileged( ) method, the AccessController looks only at the permissions of the immediate caller, not the permissions of the entire call stack.
The immediate caller is typically fully trusted system code that has a full set of permissions, and therefore the privileged code runs with that full set of permissions, even if the system code is invoked by untrusted code with no permissions whatsoever.
Privileged code is typically required only when you are writing a trusted system library (such as a Java extension package) that must read local files or perform other restricted actions, even when called by untrusted code.
To minimize the possibility of security holes, keep the body of the run( ) method as short as possible.
Or, in Java 1.4 and later, use the more general getCause( ) method.
This interface is like PrivilegedAction, except that its run( ) method may throw an exception.
This class represents a “protection domain”: the set of permissions associated with code based on its source, and optionally, the identities of the users on whose behalf the code is running.
The set of permissions is static, and the implies( ) method checks to see whether the specified Permission is implied by any of the permissions granted to this ProtectionDomain.
A ProtectionDomain of this sort represents permisssions granted to code loaded from a specified source, through a specified class loader, and running under the auspices of one or more specified principals.
This allows security policies to be updated (for example to add new permissions for specific users) without having to restart long-running programs such as servers.
It specifies class names for implementations of one or more algorithms for message digests, digital signatures, key generation, key conversion, key management, secure random number generation, certificate conversion, and algorithm parameter management.
The getName( ), getVersion( ), and getInfo( ) methods return information about the provider.
Provider inherits from Properties and maintains a mapping of property names to property values.
These name/value pairs specify the capabilities of the Provider implementation.
In Java 5.0, the individual services provided by a Provider are described by the nested Service class, and various methods for querying and setting the Service objects of a Provider are available.
This nested class represents a single service (such as a hash algorithm) provided by a security Provider.
The various methods return information about the service, including the name of the implementing class.
Signals that an exception has occurred inside a cryptographic service provider.
Note that ProviderException extends RuntimeException and is therefore an unchecked exception that may be thrown from any method without being declared.
It extends the Key interface, but does not add any new methods.
The interface exists in order to create a strong distinction between public and private keys.
This class adds protected methods to those defined by ClassLoader.
The defineClass( ) method is passed the bytes of a class file as a byte[ ] or, in Java 5.0, as a ByteBuffer and a CodeSource object that represents the source of that class.
The default implementation of the getPermissions( ) method uses the default Policy to determine the appropriate set of permissions for a given code source.
The value of SecureClassLoader is that subclasses can use its defineClass( ) method to load classes without having to work explicitly with the ProtectionDomain and Policy classes.
A subclass of SecureClassLoader can define its own security policy by overriding getPermissions( )
In Java 1.2 and later, any application that implements a custom class loader should do so by extending SecureClassLoader, instead of subclassing ClassLoader directly.
Although SecureRandom defines public constructors, the preferred technique for obtaining a SecureRandom object is to call one of the static getInstance( ) factory methods, specifying the desired pseudorandom number-generation algorithm, and, optionally, the desired provider of that algorithm.
Sun’s implementation of Java ships with an algorithm named “SHA1PRNG” in the “SUN” provider.
Once you have obtained a SecureRandom object, call nextBytes( ) to fill an array with pseudorandom bytes.
You can also call any of the methods defined by the Random superclass to obtain random numbers.
The first time one of these methods is called, the SecureRandom( ) method uses its generateSeed( ) method to seed itself.
If you have a source of random or very high-quality pseudorandom bytes, you may provide your own seed by calling setSeed( )
Repeated calls to setSeed( ) augment the existing seed instead of replacing it.
You can also call generateSeed( ) to generate seeds for use with other pseudorandom generators.
A security provider must implement a concrete subclass of this class for each pseudorandom number-generation algorithm it supports.
One of the important features of the java.security properties file is that it specifies a set of security provider implementations and a preference order in which they are to be used.
In Java 1.3 and later, versions of this method exist that only return providers that implement the algorithm or algorithms specified in a String or Map object.
You can also look up a single named Provider object by name with getProvider( )
Note that a provider name is the string returned by getName( ) method of the Provider class, not the classname of the Provider.
You can alter the set of providers installed by default from the java.security file.
Use addProvider( ) to add a new Provider object to the list, placing it at the end of the list, with a lower preference than all other providers.
Use insertProviderAt( ) to insert a provider into the list at a specified position.
Specify a position of 1 to make the provider the most preferred one.
In Java 1.4 and later, the getAlgorithms method returns a Set that includes the names of all supported algorithms (from any installed provider) for the specified “service”
A service name specifies the category of security service you are querying.
It is a caseinsensitive value that has the same name as one of the key service classes from this package or security-related packages—for example, “Signature”, “MessageDigest”, and “KeyStore” (from this package) or “Cipher” (from the javax.crypto package)
This class is a Permission subclass that represents access to various methods of the Policy, Security, Provider, Signer, and Identity objects.
SecurityPermission objects are defined by a name only; they do not use a list of actions.
Obtain a Signature object by calling one of the static getInstance( ) factory methods and specifying the desired digital signature algorithm and, optionally, the desired provider of that algorithm.
A digital signature is essentially a message digest encrypted by a public-key encryption algorithm.
Thus, to specify a digital signature algorithm, you must specify both the digest algorithm and the encryption algorithm.
The only algorithm supported by the default “SUN” provider is “SHA1withDSA”
Once you have obtained a Signature object, you must initialize it before you can create or verify a digital signature.
To initialize a digital signature for creation, call initSign( ) and specify the private key to be used to create the signature.
To initialize a signature for verification, call initVerify( ) and specify the public key of the signer.
Once the Signature object has been initialized, call update( ) one or more times to specify the data to be signed or verified.
Prior to Java 5.0, the data must be specified as an array of bytes.
In Java 5.0 and later, you can also pass a ByteBuffer to update( ), and this facilitates the use of the Signature class with the java.nio package.
Finally, to create a digital signature, call sign( ), passing a byte array into which the signature is stored.
Or, pass the bytes of the digital signature to verify( ), which returns true if the signature is valid or false otherwise.
After calling either sign( ) or verify( ), the Signature object is reset internally and can be used to create or verify another signature.
Signals a problem while creating or verifying a digital signature.
A security provider must implement a concrete subclass of this class for each digital signature algorithm it supports.
This class applies a digital signature to any serializable Java object.
Create a SignedObject by specifying the object to be signed, the PrivateKey to use for the signature, and the Signature object to create the signature.
The SignedObject( ) constructor serializes the specified object into an array of bytes and creates a digital signature for those bytes.
After creation, a SignedObject is itself typically serialized for storage or transmission to another Java thread or process.
Once the SignedObject is reconstituted, the integrity of the object it contains can be verified by calling verify( ) and supplying the PublicKey of the signer and a Signature that performs the verification.
Whether or not verification is performed or is successful, getObject( ) can be called to deserialize and return the wrapped object.
This deprecated class was used in Java 1.1 to represent an entity or Principal that has an associated PrivateKey that enables it to create digital signatures.
An instance of this class is an immutable signed timestamp.
An exception of this type is thrown if a KeyStore.Entry cannot be recovered from a KeyStore.
This exception is thrown if a Key cannot be retrieved from a KeyStore.
This class is used internally to provide a mechanism for delayed resolution of permissions (such as those whose implementation is in an external JAR file that has not been loaded yet)
Java 5.0 adds methods to obtain details about the unresolved permission.
The CertPath class represents a certificate chain, and CertPathValidator provides the ability to validate a certificate chain.
The CertificateFactory class serves as a certificate parser, providing the ability to convert a stream of bytes (or the base64 encoding of those bytes) into a Certificate, a CertPath or a CRL object.
A certificate is an object that contains the name of an entity and a public key for that entity.
Certificates are issued by, and bear the digital signature of, a (presumably trusted) third party, typically a certificate authority (CA)
By issuing and signing the certificate, the CA is certifying that, based on their research, the entity named on the certificate really is who they say they are and that the public key in the certificate really does belong to that entity.
Sometimes the signer of a certificate is not a trusted CA, and the certificate is accompanied by the signer’s certificate which may be signed by a CA, or by another untrusted intermediary who provides his or her own certificate.
A “chain” of such certificates is known as a “certification path”
Use a CertificateFactory to parse a stream of bytes into a Certificate object; getEncoded( ) reverses this process.
Use verify( ) to verify the digital signature of the entity that issued the certificate.
If the signature cannot be verified, the certificate should not be trusted.
Note that this class does not define a method for obtaining the Principal that is associated with the PublicKey.
That functionality is dependent on the type of the certificate.
This protected inner class provides an alternate representation of a certificate that can be used for serialization purposes by the writeReplace( ) method of some Certificate implementations.
This class is the superclass of several more specific exception types that may be thrown when working with certificates.
Signals that a certificate has expired or will have expired by a specified date.
This class defines methods for parsing certificates, certificate chains (certification paths) and certificate revocation lists (CRLs) from byte streams.
Obtain a CertificateFactory by calling one of the static getInstance( ) factory methods and specifying the type of certificate or CRL to be parsed, and, optionally, the desired service provider to perform the parsing.
The default “SUN” provider defines only a single “X.509” certificate type, so you typically obtain a CertificateFactory with this code:
Similarly, call generateCRL( ) to parse a single CRL object from a stream, and call generateCRLs( ) to parse a Collection of CRL objects from the stream.
These CertificateFactory methods read to the end of the specified stream.
If the stream supports mark( ) and reset( ), however, the CertificateFactory resets the stream to the position after the end of the last certificate or CRL read.
A certificate factory for X.509 certificates can parse certificates encoded in binary or printable hexadecimal form.
If the certificate is in hexadecimal form, it must begin with the string “-----BEGIN CERTIFICATE-----” and end with the string “-----END CERTIFICATE-----”
The generateCertPath( ) methods return a CertPath object representing a certificate chain.
These methods can create a CertPath object from a List of Certificate object, or by reading the chained certificates from a stream.
Specify the encoding of the certificate chain by passing the name of the encoding standard to generateCertPath( )
The default “SUN” provider supports the “PKCS7” and the “PkiPath” encodings.
The first encoding returned by the iterator is the default used when no encoding is explicitly specified.
This abstract class defines the service provider interface, or SPI, for the CertificateFactory class.
A security provider must implement this class for each type of certificate it wishes to support.
Signals that a certificate is not yet valid or will not yet be valid on a specified date.
Signals an error or other problem while parsing a certificate.
A CertPath is a immutable sequence or chain of certificates that establishes a “certification path” from an unknown “end entity” to a known and trusted Certificate Authority or “trust anchor”
Use a CertPathValidator to validate a certificate chain and establish trust in the public key presented in the certificate of the end entity.
Also, for X.509 certificate paths, the List returned by getCertificates( ) starts with the certificate of of the end entity, and ends with a certificate signed by the trust anchor.
The signer of any certificate but the last must be the subject of the next certificate in the List.
If the end entity presents a certificate that is directly signed by a trust anchor (which is a not uncommon occurrence) then the List returned by getCertificates( ) consists of only that single certificate.
Note that the list of certificates does not include the certificate of the trust anchor.
The public keys of trusted CAs must be known by the system in advance.
A CertificateFactory can parse or decode a CertPath object from a binary stream.
The getEncoded( ) methods reverse the process and encode a CertPath into an array of bytes.
The first returned encoding name is the default one, but you can use any supported encoding by using the oneargument version of getEncoded( )
The default “SUN” provider supports encodings named “PKCS7” and “PkiPath”
CertPath objects are immutable as is the List object returned by getCertificates( ) and the Certificate objects contained in the list.
CertPathBuilder attempts to build a certification path from a specified certificate to a trust anchor.
Obtain a CertPathBuilder object by calling one of the static getInstance( ) methods, specifying the desired algorithm and, optionally, the desired provider.
The “PKIX” algorithm is the only one supported by the default “SUN” provider, and is the only one that has the required algorithm-specific classes defined by this package.
Once you have a CertPathBuilder, you create a CertPath object by passing a CertPathParameters object to the build( ) method.
Use the getCertPath( ) method of this returned object to obtain the CertPath that was built.
Signal a problem while building a certification path with CertPathBuilder.
An object of this type is returned by the build( ) method of a CertPathBuilder.
The getCertPath( ) method returns the CertPath object that was built; this method will never return null.
Security providers must implement this interface, but applications never need to use it.
CertPathParamters is a marker interface for objects that hold parameters (such as the set of trust anchors) for validating or building a certification path with CertPathValidator and CertPathBuilder.
It defines no methods of its own, but requires that all implementations include a working clone( ) method.
This class validates certificate chains, establishing a chain of trust from the end entity to a trust anchor, and thereby establishing the validity of the public key presented in the end entity’s certificate.
To obtain a CertPathValidator instance, call one of the static getInstance( ) methods specifying the name of the desired validation algorithm and, optionally, the provider to use.
The “PKIX” algorithm for validating X.509 certificates is the only one supported by the default “SUN” provider.
Once you have a CertPathValidator object, you can use it to validate certificate chains by passing the CertPath object to be validated to the validate( ) method along with a CertPathParameters object that specifies valid trust anchors and other validation parameters.
Signals a problem while validating a certificate chain with a CertPathValidator.
This marker interface defines the type of the object returned by the validate( ) method of a CertPathValidator, but does not define any of the contents of that object, other to specify that it must be Cloneable.
Security providers must implement this interface, but applications never need to use it.
This interface defines an API for determining whether a Certificate meets some criteria.
Implementations are used to specify critera by which a certificate or certificates should be selected from a CertStore object.
The match( ) method should examine the Certificate it is passed and return true if it “matches” based on whatever criteria the implementation defines.
See CRLSelector for a similar interface for use when selecting CRL objects from a CertStore.
A CertStore object is a repository for Certificate and CRL objects.
A KeyStore is designed to store a relatively small local collection of private keys and trusted certificates.
A CertStore, however, may represent a large public database (in the form of an LDAP server, for examle) of untrusted certificates.
Optionally, you may also specify the desired provider of your CertStore object.
The “LDAP” type obtains certificates and CRLs from a network LDAP server, and the “Collection” type obtains them from a a specified Collection object.
The CertStore class may be directly useful to applications that want to query a LDAP server for certificates.
Signals a problem while querying a CertStore for certificates or CRLs.
It does not define any methods of its own and simply requires that all implementing classes be cloneable.
Use one of the concrete implementations of this class for CertStore objects of type “LDAP” and “Collection”
Security providers must implement this interface, but applications never need to use it.
Pass the Collection of Certificate and CRL objects to be searched by the CertStore to the constructor method.
A CRL is an object issued by a certificate authority (or other certificate signer) that lists certificates that have been revoked, meaning that they are now invalid and should be rejected.
Use a CertificateFactory to parse a CRL from a byte stream.
Use the isRevoked( ) method to test whether a specified Certificate is listed on the CRL.
Note that type-specific CRL subclasses, such as X509CRL, may provide access to substantially more information about the revocation list.
Signals an error or other problem while working with a CRL.
This interface defines an API for determining whether a CRL object meets some criteria.
Implementations are used to specify critera by which a CRL objects should be selected from a CertStore.
The match( ) method should examine the CRL it is passed and return true if it “matches” based on whatever criteria the implementation defines.
See CertSelector for a similar interface for use when selecting Certificate objects from a CertStore.
It specifies the hostname of the LDAP server to connect to and, optionally, the port to connect on.
Instances of this class are used to specify parameters to the build( ) method of a CertPathBuilder object.
These parameters must include the two mandatory ones passed to the constructors.
The second required parameter is a CertSelector object (typically an X509CertSelector) that specifies the selection criteria for the certificate that is to have the certification path built.
In addition to these parameters that are passed to the constructor, this class also inherits a number of methods for setting other parameters, and defines setMaxPathLength( ) for specifying the maximum length of the certificate chain that is built.
An instance of this class is retured by the build( ) method of a CertPathBuilder created for the “PKIX” algorithm.
This abstract class defines an extension mechanism for the PKIX certification path building and validation algorithms.
The init( ) method is invoked to tell the checker to reset its internal state and to notify it of the direction in which certificates will be presented.
An instance of this class is returned upon successful validation by the validate( ) method of a CertPathValidator created for the “PKIX” algorithm.
This implementation of CertPathParameters defines parameters that are passed to the validate( ) method of a PKIX CertPathValidator and defines a subset of the parameters that are passed to the build( ) method of a PKIX CertPathBuilder.
A full understanding of this class requires a detailed discussion of the PKIX certification path building and validation algorithms, which is beyond the scope of this book.
However, some of the more important parameters are described here.
When you create a PKIXParameters object, you must specify which trust anchors are to be used.
You can do this by passing a Set of TrustAnchor objects to the constructor, or by passing a KeyStore containing trust anchor keys to the constructor.
Once a PKIXParameters object is created, you can modify the set of TrustAnchor objects with setTrustAnchors( )
Specify a Set of CertStore objects to be searched for certificates with setCertStores( ) or add a single CertStore to the set with addCertStore( )
If certificate validity is to be checked for some date and time other than the current time, use setDate( ) to specify this date.
This class represents a node in the policy tree created by the PKIX certification path validation algorithm.
A discussion of X.509 policy extensions and their use in the PKIX certification path algorithms is beyond the scope of this reference.
This class is a low-level representation of a policy qualifier information from a X.509 certificate extension.
A discussion of X.509 policy extensions and their use in the PKIX certification path algorithms is beyond the scope of this reference.
A TrustAnchor represents a certificate authority that is trusted to “anchor” a certificate chain.
A TrustAnchor object includes the X.500 distinguished name of the CA and the public key of the CA.
You may specify the name and key explictly or by passing an X509Certificate to the TrustAnchor( ) constructor.
All forms of the TrustAnchor( ) constructor also allow you to specify a byte array containing a binary representation of a “Name Constraints” extension.
The format and meaning of such name constraints is beyond the scope of this reference, and most applications can simply specify null for this constructor argument.
Its various methods provide complete access to the contents of the certificate.
A full understanding of this class requires detailed knowledge of the X.509 standard which is beyond the scope of this reference.
Some of the more important methods are described here, however.
Note that verify( ) and getPublicKey( ) are inherited from Certificate.
Finally, cast the Certificate returned by this method to an X509Certificate.
Its various set methods allow you to specify values for various certificate fields and extensions.
The match( ) method will only return true for certificates that have the specified values for those fields and extensions.
A full understanding of this class requires detailed knowledge of the X.509 standard which is beyond the scope of this reference.
Some of the more important methods are described here, however.
When you want to match exactly one specific certificate, simply pass the desired X509Certificate to setCertificate( )
Constrain the public key of the certificate with setPublicKey( )
And specify a specific issuer’s serial number for the certificate with setSerialNumber( )
The various methods of this class provide access to the full details of the CRL, and require a complete understanding of the X.509 standard, which is beyond the scope of this reference.
Use verify( ) to check the digital signature of the CRL to ensure that it does indeed originate from the the source it specifies.
Use the inherited isRevoked( ) method to determine whether a given certificate has been revoked.
Call getThisUpdate( ) to obtain the date this CRL was issued.
Use getNextUpdate( ) to find if the CRL has been superseded by a newer version.
Finally, cast the CRL returned by this method to an X509CRL.
It contains the serial number and revocation date for a revoked certificate.
The various set methods allow you to specify criteria that the match( ) method will use to accept or reject CRL objects.
Use addIssuerName( ) to specify the distinguished name of an acceptable issuer for the CRL, or use setIssuerNames( ) or setIssuers( ) to specify a Collection of valid issuers.
Use setDateAndTime( ) to specify a Date for which the CRL must be valid.
Use setMinCRLNumber( ) and setMaxCRLNumber( ) to set bounds on the sequence number of the CRL.
This method does not actually constrain the returned CRL objects, but it may help a CertStore optimize its search for a relevant CRL.
This interface defines methods for handling a set of extensions to X.509 certificates and CRLs.
Each extension has a name, or OID (object identifier), that identifies the type of the extension.
Noncritical extensions whose OIDs are not recognized can safely be ignored.
However, if a critical exception is not recognized, the Certificate or CRL should be rejected.
Each extension in the set has a byte array of data as its value.
The interpretation of these bytes depends on the OID of the extension, of course.
Specific extensions are defined by the X.509 and related standards and their details are beyond the scope of this reference.
These interfaces define methods that provide algorithm-specific information (such as key values and initialization parameter values) about DSA, RSA, and EC public and private keys.
This package remains useful in Java 1.2 and later, however, for identifying the type of a given PublicKey or PrivateKey object.
The interfaces in this package are typically of interest only to programmers who are implementing a security provider or who want to implement cryptographic algorithms themselves.
Use of this package typically requires some familiarity with the mathematics underlying DSA and RSA public-key cryptography.
This interface defines a method that must be implemented by both public and private DSA keys.
This interface defines algorithm-specific KeyPairGenerator initialization methods for DSA keys.
Finally, generate the keys by calling generateKeyPair( ) on the KeyPairGenerator.
This interface defines methods for obtaining the DSA parameters g, p, and q.
These methods are useful only if you wish to perform cryptographic computation yourself.
Using these methods requires a detailed understanding of the mathematics underlying DSA public-key cryptography.
This interface represents a DSA private key and provides direct access to the underlying key value.
If you are working with a private key you know is a DSA key, you can cast the PrivateKey to a DSAPrivateKey.
This interface represents a DSA public key and provides direct access to the underlying key value.
If you are working with a public key you know is a DSA key, you can cast the PublicKey to a DSAPublicKey.
This interface defines the API that must be implemented by all elliptic curve keys.
This interface defines an API that must be implemented by all elliptic curve private keys.
This interface defines an API that must be implemented by all elliptic curve public keys.
This is a superinterface for RSAPublicKey and RSAPrivateKey; it defines a method shared by both classes.
Prior to Java 1.3, the getModulus( ) method was defined independently by RSAPublicKey and RSAPrivateKey.
This interface extends RSAPrivateKey and provides a decomposition of the private key into the various numbers used to create it.
This interface is very similar to RSAPrivateCrtKey, except that it is used to represent RSA private keys that are based on more than two prime factors, and implements the addition getOtherPrimeInfo( ) method to return information about these additional prime numbers.
This interface extends RSAPrivateKey and provides a decomposition (based on the Chinese remainder theorem) of the private-key value into the various pieces that comprise it.
This interface is useful only if you plan to implement your own cryptographic algorithms.
To use this interface, you must have a detailed understanding of the mathematics underlying RSA public-key cryptography.
This interface represents an RSA private key and provides direct access to the underlying key values.
If you are working with a private key you know is an RSA key, you can cast the PrivateKey to an RSAPrivateKey.
This interface represents an RSA public key and provides direct access to the underlying key values.
If you are working with a public key you know is an RSA key, you can cast the PublicKey to an RSAPublicKey.
It also defines a transparent representation for DSA algorithm parameters.
To make use of it, you must be somewhat familiar with the mathematics that underlies DSA and RSA public-key encryption and the encoding standards that specify how keys are encoded as byte streams.
This interface defines no methods; it marks classes that define a transparent representation of cryptographic parameters.
This class represents algorithm parameters used with DSA public-key cryptography.
This class is a transparent representation of a DSA private key.
This class is a transparent representation of a DSA public key.
This interface represents a “finite field” for elliptic curve cryptography.
This class defines an immutable representation of a “characteristic 2 finite field” for elliptic curve cryptography.
This class defines an immutable representation of a “prime finite field” for elliptic curve cryptography.
This class specifies parameters for generating elliptic curve domain parameters.
This class defines an immutable representation for a set of parameters for elliptic curve cryptography.
This class defines an immutable representation of a point on an elliptic curve, using affine coordinates.
This class is an immutable representation of a private key for elliptic curve cryptography.
This class is an immutable representation of a public key for elliptic curve cryptography.
This class is an immutable representation of an elliptic curve.
This abstract class represents a public or private key in an encoded format.
This interface defines no methods; it marks classes that define a transparent representation of a cryptographic key.
The constants represent predefined instances of the class, whose digest algorithm matches the constant name.
This class represents a private key, encoded according to the PKCS#8 standard.
This class represents parameters that generate public/private key pairs for RSA cryptography.
This class is a transparent representation of a multi-prime RSA private key.
This class is a transparent representation of an RSA private key including, for convenience, the Chinese remainder theorem values associated with the key.
This class is a transparent representation of an RSA private key.
This class is a transparent representation of an RSA public key.
This class represents a public or private key encoded according to the X.509 standard.
The java.text package consists of classes and interfaces that are useful for writing internationalized programs that handle local customs, such as date and time formatting and string alphabetization, correctly.
The NumberFormat class formats numbers, monetary quantities, and percentages as appropriate for the default or specified locale.
The concrete DecimalFormat and SimpleDateFormat subclasses of these classes can be used for customized number, date, and time formatting.
MessageFormat allows substitution of dynamic values, including formatted numbers and dates, into static message strings.
ChoiceFormat formats a number using an enumerated set of string values.
See the Format superclass for a general description of formatting and parsing strings with these classes.
Collator compares strings according to the customary sorting order for a locale.
BreakIterator scans text to find word, line, and sentence boundaries following locale-specific rules.
The Bidi class of Java 1.4 implements the Unicode “bidirectional” algorithm for working with languages such as Arabic and Hebrew that display text right-to-left but display numbers left-to-right.
This class is a wrapper for a the value of a text attribute that represents an annotation.
Annotations differ from other types of text attributes in two ways.
First, annotations are linked to the text they are applied to, so changing the text invalidates or corrupts the meaning of the annotation.
Second, annotations cannot be merged with adjacent annotations, even if they have the same value.
Putting an annotation value in an Annotation wrapper serves to indicate these special characteristics.
This interface extends CharacterIterator for working with text that is marked up with attributes in some way.
A run is a string of adjacent characters for which an attribute has the same value or is undefined (i.e., has a value of null)
A run can also be defined for a set of attributes, in which case it is a set of adjacent characters for which all attributes in the set hold a constant value (which may include null)
Programs that process or display attributed text must usually work with it one run at a time.
The no-argument versions of getRunStart( ) and getRunLimit( ) return the start and end of the run that includes the current character and all attributes that are applied to the current character.
The other versions of these methods return the start and end of the run of the specified attribute or set of attributes that includes the current character.
It defines several constant Attribute keys that are commonly used with multilingual text and input methods.
The LANGUAGE key represents the language of the underlying text.
The value of this key should be a Locale object.
The READING key represents arbitrary reading information associated with text.
The value of this attribute should be an Annotation object that contains null.
Other classes may subclass this class and define other attribute keys that are useful in other circumstances or problem domains.
Additional attributes can be specified with the addAttribute( ) and addAttributes( ) methods.
Note that two of the getIterator( ) methods take an array of Attribute keys as an argument.
If the array argument is null, however, the returned iterator contains all attributes.
The Bidi class implements the “Unicode Version 3.0 Bidirectional Algorithm” for working with Arabic and Hebrew text in which letters run right-to-left and numbers run left-to-right.
It is named after the first four letters of “bidirectional.” A full description of the bidirectional text handling and the bidirectional algorithim is beyond the scope of this book, but the simplest use case for this class is outlined here.
Or use createLineBidi( ) to return a substring of an existing Bidi object (this is usually done when formatting a paragraph of text to fit on individual lines)
Once you have a Bidi object, use isLeftToRight( ) and isRightToLeft( ) to determine whether all the text has the same direction.
If both of these methods return false (which is the same as isMixed( ) returning true) then you cannot treat the text as a single run of uni-directional text.
In this case, you must break it into two or more runs of unidirectional text.
For each such numbered run, getRunStart( ) returns the index of the first character of the run, and getRunLimit( ) returns the index of the first character past the end of the run.
Even levels represent left-to-right text, and odd levels represent right-to-left text.
The level divided by two is the nesting level of the text.
This class determines character, word, sentence, and line breaks in a block of text in a way that is independent of locale and text encoding.
These various factory methods return a BreakIterator object that is configured to locate the requested boundary types and is localized to work for the optionally specified locale.
Once you have obtained an appropriate BreakIterator object, use setText( ) to specify the text in which to locate boundaries.
To locate boundaries in a Java String object, simply specify the string.
To locate boundaries in text that uses some other encoding, you must specify a CharacterIterator object for that text so that the BreakIterator object can locate the individual characters of the text.
Having set the text to be searched, you can determine the character positions of characters, words, sentences, or line breaks with the first( ), last( ), next( ), previous( ), current( ), and following( ) methods, which perform the obvious functions.
Note that these methods do not return text itself, but merely the position of the appropriate word, sentence, or line break.
This interface defines an API for portably iterating through the characters that make up a string of text, regardless of the encoding of that text.
Such an API is necessary because the number of bytes per character is different for different encodings, and some encodings even use variable-width characters within the same string of text.
In addition to allowing iteration, a class that implements the CharacterIterator interface for non-Unicode text also performs translation of characters from their native encoding to standard Java Unicode characters.
The first( ) and last( ) methods return the first and last characters in the text, and the next( ) and prev( ) methods allow you to loop forward or backwards through the characters of the text.
These methods return the DONE constant when they go beyond the first or last character in the text; a test for this constant can be used to terminate a loop.
The CharacterIterator interface also allows random access to the characters in a string of text.
The getBeginIndex( ) and getEndIndex( ) methods return the character positions for the start and end of the string, and setIndex( ) sets the current position.
This class is a subclass of Format that converts a number to a String in a way reminiscent of a switch statement or an enumerated type.
When the format( ) method is called to format a number x, the ChoiceFormat finds an index i such that:
If x is less than the first element of the array, the first element is used, and if it is greater than the last, the last element is used.
Once the index i has been determined, it is used as the index into the array of strings, and the indexed string is returned as the result of the format( ) method.
A ChoiceFormat object may also be created by encoding its limits and formats into a single string known as its pattern.
A typical pattern looks like the one below, used to return the singular or plural form of a word based on the numeric value passed to the format( ) method:
You can use the applyPattern( ) method to change the pattern used by a ChoiceFormat object; use toPattern( ) to query the pattern it uses.
The purpose of this class is to allow a program to iterate (with the next( ) method) through the characters of a string, returning ordering values for.
Note that collation keys are not exactly the same as characters.
In the traditional Spanish collation order, for example, the twocharacter sequence “ch” is treated as a single collation key that comes alphabetically between the letters “c” and “d.” The value returned by the next( ) method is the collation order of the next collation key in the string.
The value returned by next( ) can also be decomposed into primary, secondary, and tertiary ordering values with the static methods of this class.
This class is used by RuleBasedCollator to implement its compare( ) method and to create CollationKey objects.
To compare two CollationKey objects, invoke the compareTo( ) method of key A, passing the key B as an argument (both CollationKey objects must be created through the same Collation object)
The return value of this method is less than zero if the key A is collated before the key B, equal to zero if they are equivalent for the purposes of collation, or greater than zero if the key A is collated after the key B.
Use getSourceString( ) to obtain the string represented by a CollationKey.
This class compares, orders, and sorts strings in a way appropriate for the default locale or some other specified locale.
Because it is an abstract class, it cannot be instantiated directly.
Instead, you must use the static getInstance( ) method to obtain an instance of a Collator subclass that is appropriate for the default or specified locale.
Once an appropriate Collator object has been obtained, you can use the compare( ) method to compare strings.
The equals( ) method is a convenient shortcut for testing two strings for collation equivalence.
When sorting an array of strings, each string in the array is typically compared more than once.
Using the compare( ) method in this case is inefficient.
A more efficient method for comparing strings multiple times is to use getCollationKey( ) for each string to create CollationKey objects.
These objects can then be compared to each other more quickly than the strings themselves can be compared.
You can customize the way the Collator object performs comparisons by calling setStrength( )
If you pass the constant PRIMARY to this method, the comparison looks only at primary differences in the strings; it compares letters but ignores accents and case differences.
If you pass the constant SECONDARY, it ignores case differences but does not ignore accents.
And if you pass TERTIARY (the default), the Collator object takes both accents and case differences into account in its comparison.
This class formats and parses dates and times in a locale-specific way.
As an abstract class, it cannot be instantiated directly, but it provides a number of static methods that return instances of a concrete subclass you can use to format dates in a variety of ways.
The getDateInstance( ) methods return a DateFormat object suitable for formatting dates in either the default locale or a specified locale.
A formatting style may also optionally be specified; the constants FULL, LONG, MEDIUM, SHORT, and DEFAULT specify this style.
These methods also optionally take a format style constant and a Locale.
Finally, getInstance( ) returns a default DateFormat object that formats both dates and times in the SHORT format.
Once you have created a DateFormat object, you can use the setCalendar( ) and setTimeZone( ) methods if you want to format the date using a calendar or time zone other than the default.
The various format( ) methods convert java.util.Date objects to strings using whatever format is encapsulated in the DateFormat object.
The parse( ) and parseObject( ) methods perform the reverse operation; they parse a string formatted according to the rules of the DateFormat object and convert it into to a Date object.
The DEFAULT, FULL, MEDIUM, LONG, and SHORT constants specify how verbose or compact the formatted date or time should be.
The remaining constants, which all end with _FIELD, specify various fields of formatted dates and times and are used with the FieldPosition object that is optionally passed to format( )
This class defines accessor methods for the various pieces of data, such as names of months and days, used by SimpleDateFormat to format and parse dates and times.
You do not typically need to use this class unless you are formatting dates for an unsupported locale or in some highly customized way.
This is the concrete Format class used by NumberFormat for all locales that use base 10 numbers.
Most applications do not need to use this class directly; they can use the static methods of NumberFormat to obtain a default NumberFormat object for a desired locale and then perform minor locale-independent customizations on that object.
Applications that require highly customized number formatting and parsing may create custom DecimalFormat objects by passing a suitable pattern to the DecimalFormat( ) constructor method.
A pattern consists of a string of characters from the table below.
This is useful when working with very large numbers, very precise numbers, or financial applications that use BigDecimal to avoid rounding errors.
Separates positive number format (on left) from optiona negative number format (on right)
Quotes a reserved character, so it appears literally in the output (apostrophe)
This class defines the various characters and strings, such as the decimal point, percent sign, and thousands separator, used by DecimalFormat when formatting numbers.
You do not typically use this class directly unless you are formatting dates for an unsupported locale or in some highly customized way.
FieldPosition objects are optionally passed to the format( ) methods of the Format class and its subclasses to return information about the start and end positions of a specific part or “field” of the formatted string.
This kind of information is often useful for aligning formatted strings in columns—for example, aligning the decimal points in a column of numbers.
The field of interest is specified when the FieldPosition( ) constructor is called.
The NumberFormat and DateFormat classes define integer various constants (which end with the string _FIELD) that can be used here.
In Java 1.4 and later you can also construct a FieldPosition by specifying the Format.Field object that identifies the field.
After a FieldPosition has been created and passed to a format( ) method, use getBeginIndex( ) and getEndIndex( ) methods of this class to obtain the starting and ending character positions of the desired field of the formatted string.
This abstract class is the base class for all number, date, and string formatting classes in the java.text package.
It defines the key formatting and parsing methods that are implemented by all subclasses.
Status information for these two operations is returned in FieldPosition and ParsePosition objects.
Java 1.4 defined a variant on the format( ) method.
The attribute keys are all instances of the Format.Field inner class.
See ChoiceFormat, DateFormat, MessageFormat, and NumberFormat for subclasses that perform specific types of formatting.
This class formats and substitutes objects into specified positions in a message string (also known as the pattern string)
It provides the closest Java equivalent to the printf( ) function of the C programming language.
If a message is to be displayed only a single time, the simplest way to use the MessageFormat class is through the static format( ) method.
This method is passed a message or pattern string and an array of argument objects to be formatted and substituted into the string.
If the message is to be displayed several times, it makes more sense to create a MessageFormat object, supplying the pattern string, and then call the format( ) instance method of this object, supplying the array of objects to be formatted into the message.
A digit within curly braces in a pattern string may be followed optionally by a comma, and one of the words “date”, “time”, “number”, or “choice”, to indicate that the corresponding argument should be formatted as a date, time, number, or choice before being substituted into the pattern string.
Any of these keywords can additionally be followed by a comma and additional pattern information to be used in formatting the date, time, number, or choice.
You can pass a Locale to the constructor or call setLocale( ) to specify a nondefault locale that the MessageFormat should use when obtaining DateFormat and NumberFormat objects to format dates, time, and numbers inserted into the pattern.
You can change the Format object used at a particular position in the pattern with the setFormat( ) method, or change all Format objects with setFormats( )
Both of these methods depend on the order of in which arguments are displayed in the pattern string.
The pattern string is often subject to localization and the arguments may appear in different orders in different localizations of the pattern.
Therefore, in Java 1.4 and later it is usually more convenient to use the “ByArgumentIndex” versions of the setFormat( ), setFormats( ) methods, and getFormats( ) methods.
You can set a new pattern for the MessageFormat object by calling applyPattern( ), and you can obtain a string that represents the current formatting pattern by calling toPattern( )
MessageFormat also supports a parse( ) method that can parse an array of objects out of a specified string, according to the specified pattern.
The value associated with this ARGUMENT attribute will be an Integer specifying the argument number.
This class formats and parses numbers in a locale-specific way.
As an abstract class, it cannot be instantiated directly, but it provides a number of static methods that return instances of a concrete subclass you can use for formatting.
The getInstance( ) method returns a NumberFormat object suitable for normal formatting of numbers in either the default locale or in a specified locale.
These methods return a NumberFormat suitable for the default locale, or for the specified Locale object.
Note that the NumberFormat class is not intended for the display of very large or very small numbers that require exponential notation, and it may not gracefully handle infinite or NaN (not-a-number) values.
In order to customize the locale-dependent behavior, you can use instanceof to test if the NumberFormat object is an instance of DecimalFormat, and, if so, cast it to that type.
Note, however, that a NumberFormat customized in this way may no longer be appropriate for the desired locale.
After creating and customizing a NumberFormat object, you can use the various format( ) methods to convert numbers to strings or string buffers, and you can use the parse( ) or parseObject( ) methods to convert strings to numbers.
The constants defined by this class are to be used by the FieldPosition object.
Signals that a string has an incorrect format and cannot be parsed.
It is typically thrown by the parse( ) or parseObject( ) methods of Format and its subclasses, but is also thrown by certain methods in the java.text package that are passed patterns or other rules in string form.
The getErrorOffset( ) method of this class returns the character position at which the parsing error occurred in the offending string.
ParsePosition objects are passed to the parse( ) and parseObject( ) methods of Format and its subclasses.
The ParsePosition class represents the position in a string at which parsing should begin or at which parsing stopped.
Before calling a parse( ) method, you can specify the starting position of parsing by passing the desired index to the ParsePosition( ) constructor or by calling the setIndex( ) of an existing ParsePosition object.
When parse( ) returns, you can determine where parsing ended by calling getIndex( )
When parsing multiple objects or values from a string, a single ParsePosition object can be used sequentially.
This class is a concrete subclass of the abstract Collator class.
It performs collations using a table of rules that are specified in textual form.
You should need to use this class only if you are collating strings for a locale that is not supported by default or if you need to implement a highly customized collation order.
This is the concrete Format subclass used by DateFormat to handle the formatting and parsing of dates.
Most applications should not use this class directly; instead, they should obtain a localized DateFormat object by calling one of the static methods of DateFormat.
This creates a SimpleDateFormat object that uses the DateFormatSymbols object for the default locale.
You may also specify an locale explicitly, to use the DateFormatSymbols object for that locale.
You can even provide an explicit DateFormatSymbols object of your own if you need to format dates and times for an unsupported locale.
You can use the applyPattern( ) method of a SimpleDateFormat to change the formatting pattern used by the object.
The syntax of this pattern is described in the following table.
Any characters in the format string that do not appear in this table appear literally in the formatted date.
This class is a trivial implementation of the CharacterIterator interface that works for text stored in Java String objects.
This chapter documents the java.util package, and each of its subpackages.
In Java 5.0 the collection classes and interfaces have been converted into generic types.
They are based on the classes of the java.util.zip package.
The java.util package defines a number of useful classes, primarily collections classes that are useful for working with groups of objects.
This package should not be considered merely a utility package that is separate from the rest of the language; it is an integral and frequently used part of the Java platform.
The most important classes in java.util are the collections classes.
Prior to Java 1.2, these were Vector, a growable list of objects, and Hashtable, a mapping between arbitrary key and value objects.
Java 1.2 adds an entire collections framework consisting of the Collection, Map, Set, List, SortedMap, and SortedSet interfaces and the classes that implement them.
Other important classes and interfaces of the collections framework are Comparator, Collections, Arrays, Iterator, and ListIterator.
Java 1.4 extends the Collections framework with the addition of new Map and Set implementations, and a new RandomAccess marker interface used by List implementations.
It also adds EnumSet and EnumMap which efficiently implement the Set and Map interfaces for use with enumerated types.
BitSet is a related class that is not actually part of the Collections framework (and is not even a set)
It provides a very compact representation of an arbitrary-size array or list of boolean values or bits.
The other classes of the package are also quite useful.
Locale represents the language and related text formatting conventions of a country, region, or culture.
ResourceBundle and its subclasses represent a bundle of localized resources that are read in by an internationalized program at runtime.
Random generates and returns pseudorandom numbers in a variety of forms.
StringTokenizer is a simple parser that breaks a string into tokens.
In Java 1.3 and later, Timer and TimerTask provide a powerful API for scheduling code to be run by a background thread, once or repetitively, at a specified time in the future.
In Java 5.0, the Formatter class enables poweful formatted text output in the style of the C programming language’s printf( ) function.
The Java 5.0 Scanner class is a text tokenizer or scanner that can also parse numbers and match tokens based on regular expressions.
This abstract class is a partial implementation of Collection that makes it easy to define custom Collection implementations.
To create an unmodifiable collection, simply override size( ) and iterator( )
The Iterator object returned by iterator( ) has to support only the hasNext( ) and next( ) methods.
To define a modifiable collection, you must additionally override the add( ) method of AbstractCollection and make sure the Iterator returned by iterator( ) supports the remove( ) method.
Some subclasses may choose to override other methods to tune performance.
In addition, it is conventional that all subclasses provide two constructors: one that takes no arguments and one that accepts a Collection argument that specifies the initial contents of the collection.
Note that if you subclass AbstractCollection directly, you are implementing a bag—an unordered collection that allows duplicate elements.
If your add( ) method rejects duplicate elements, you should subclass AbstractSet instead.
This abstract class is a partial implementation of the List interface that makes it easy to define custom List implementations based on random-access list elements (such as objects stored in an array)
To create an unmodifiable List, simply subclass AbstractList and override the (inherited) size( ) and get( ) methods.
To create a modifiable list, you must also override set( ) and, optionally, add( ) and remove( )
All other methods of the List interface are implemented in terms of size( ), get( ), set( ), add( ), and remove( )
In some cases, you may want to override these other methods to improve performance.
By convention, all List implementations should define two constructors: one that accepts no arguments and another that accepts a Collection of initial elements for the list.
This abstract class is a partial implementation of the Map interface that makes it easy to define simple custom Map implementations.
To define an unmodifiable map, subclass AbstractMap and override the entrySet( ) method so that it returns a set of Map.Entry objects.
The returned set should not support add( ) or remove( ), and its iterator should not support remove( )
In order to define a modifiable Map, you must additionally override the put( ) method and provide support for the remove( ) method of the iterator returned by entrySet( ).iterator( )
In addition, it is conventional that all Map implementations define two constructors: one that accepts no arguments and another that accepts a Map of initial mappings.
AbstractMap defines all Map methods in terms of its entrySet( ) and put( ) methods and the remove( ) method of the entry set iterator.
Note, however, that the implementation is based on a linear search of the Set returned by entrySet( ) and is not efficient when the Map contains more than a handful of entries.
Some subclasses may want to override additional AbstractMap methods to improve performance.
HashMap and TreeMap use different algorithms are are substantially more efficient.
This abstract class provides a framework for simple Queue implementations.
A concrete subclass must implement offer( ), peek( ), and poll( ) and must also implement the inherited size( ) and iterator( ) methods of the Collection interface.
The Iterator returned by iterator( ) must support the remove( ) operation.
This abstract class is a partial implementation of the List interface that makes it easy to define List implementations based on a sequential-access data model, as is the case with the LinkedList subclass.
To implement a List based on an array or other random-access model, subclass AbstractList instead.
To implement an unmodifiable list, subclass this class and override the size( ) and listIterator( ) methods.
If you want to allow the list to be modified, the ListIterator should also support the set( ) method and, optionally, the add( ) and remove( ) methods.
Some subclasses may want to override additional methods to improve performance.
In addition, it is conventional that all List implementations define two constructors: one that accepts no arguments and another that accepts a Collection of initial elements for the list.
This abstract class is a partial implementation of the Set interface that makes it easy to create custom Set implementations.
Since Set defines the same methods as Collection, you can subclass AbstractSet exactly as you would subclass AbstractCollection.
Note, however, that when subclassing AbstractSet, you should be sure that your add( ) method and your constructors do not allow duplicate elements to be added to the set.
This class is a List implementation based on an array (that is recreated as necessary as the list grows or shrinks)
ArrayList implements all optional List and Collection methods and allows list elements of any type (including null)
Because ArrayList is based on an array, the get( ) and set( ) methods are very efficient.
This is not the case for the LinkedList implementation, for example.
ArrayList is a general-purpose implementation of List and is quite commonly used.
ArrayList is very much like the Vector class, except that its methods are not synchronized.
See List and Collection for details on the methods of ArrayList.
An ArrayList has a capacity, which is the number of elements in the internal array that contains the elements of the list.
When the number of elements exceeds the capacity, a new array, with a larger capacity, must be created.
In addition to the List and Collection methods, ArrayList defines a couple of methods that help you manage this capacity.
If you know in advance how many elements an ArrayList will contain, you can call ensureCapacity( ), which can increase efficiency by avoiding incremental reallocation of the internal array.
You can also pass an initial capacity value to the ArrayList( ) constructor.
Finally, if an ArrayList has reached its final size and will not change in the future, you can call trimToSize( ) to reallocate the internal array with a capacity that matches the list size exactly.
When the ArrayList will have a long lifetime, this can be a useful technique to reduce memory usage.
This class defines static methods for sorting, searching, and performing other useful operations on arrays.
It also defines the asList( ) method, which returns a List wrapper around a specified array of objects.
Any changes made to the List are also made to the underlying array.
This is a powerful method that allows any array of objects to be manipulated in any of the ways a List can be manipulated.
It provides a link between arrays and the Java collections framework.
The various sort( ) methods sort an array (or a specified portion of an array) in place.
Variants of the method are defined for arrays of each primitive type and for arrays of Object.
For arrays of primitive types, the sorting is done according to the natural ordering of the type.
When sorting an array of objects, a stable sorting algorithm is used so that the relative ordering of equal objects is not disturbed.
This allows repeated sorts to order objects by key and subkey, for example.
The binarySearch( ) methods perform an efficient search (in logarithmic time) of a sorted array for a specified value.
If a match is found in the array, binarySearch( ) returns the index of the match.
If no match is found, the method returns a negative number.
For a negative return value r, the index –(r+1) specifies the array index at which the specified value can be inserted to maintain the sorted order of the array.
The equals( ) methods test whether two arrays are equal.
Two arrays of primitive type are equal if they contain the same number of elements and if corresponding pairs of elements are equal according to the == operator.
Two arrays of objects are equal if they contain the same number of elements and if corresponding pairs of elements are equal according to the equals( ) method defined by those objects.
The fill( ) methods fill an array or a specified range of an array with the specified value.
Java 5.0 adds hashCode( ) methods that compute a hashcode for the contents of the array.
These methods are compatible with the equals( ) methods: equal( ) arrays will always have the same hashCode( )
Java 5.0 also adds deepEquals( ) and deepHashCode( ) methods that handle multi-dimensional arrays.
Finally, the Java 5.0 toString( ) and deepToString( ) methods convert arrays to strings.
The returned strings are a comma-separated list of elements enclosed in square brackets.
This class implements an array or list of boolean values storing them using a very compact representation that requires only about one bit per value stored.
It implements methods for setting, querying, and flipping the values stored at any given position within the list, for counting the number of true values stored in the list, and for finding the next true or false value in the list.
It also defines a number of methods that perform bitwise boolean operations on two BitSet objects.
Despite its name, BitSet does not implement the Set interface, and does not even have the behavior associated with a set; it is a list or vector for boolean values, but is not related to the List interface or Vector class.
You may optionally specify a size (the number of bits) for the BitSet, but this merely provides an optimization since a BitSet will grow as needed to accomodate any number of boolean values.
BitSet does not define a precise notion of the size of a “set.” The size( ) method returns the number of boolean values that can be stored before more internal storage needs to be allocated.
The length( ) method returns one more than the highest index of a set bit (i.e., a true value)
This means that a BitSet that contains all false values will have a length( ) of zero.
If your code needs to remember the index of the highest value stored in a BitSet, regardless of whether that value was true or false, then you should maintain that length information separately from the BitSet.
Set values in a BitSet with the set( ) method.
Two set the value at a specific index, and two set values for a range of indexes.
Two of the set( ) methods do not take a value argument to set: they “set” the specified bit or range of bites, which means they store the value true.
The other two methods take a boolean argument, allowing you to set the specified value or range of values to true (a set bit) or.
There are also two clear( ) methods that “clear” (or set to false) the value at the specified index or range of indexes.
The flip( ) methods flip, or toggle (change true to false and false to true), the value or values at the specified index or range.
The set( ), clear( ), and flip( ) methods, as well as all other BitSet methods that operate on a range of values specify the range with two index values.
They define the range as the values starting from, and including, the value stored at the first specified index up to, but not including, the value stored at the second specified index.
A number of methods of String and related classes follow the same convention for specifying a range of characters.
To test the value stored at a specified location, use get( ), which returns true if the specified bit is set, or false if it is not set.
There is also a get( ) method that specifies a range of bits, and returns their state in the form of a BitSet: this get( ) method is analogous to the substring( ) method of a String.
Because a BitSet does not define a maximum index, it is legal to pass any non-negative value to get( )
If the index you specify is greater than or equal to the value returned by length( ), then the returned value will always be false.
You can use this method in a loop to iterate through the indexes of true values.
The intersects( ) method returns true if the target BitSet and the argument BitSet intersect: that is if there is at least one index at which both BitSet objects have a true value.
These methods combine the BitSet on which they are invoked (called the “target” BitSet below) with the BitSet passed as an argument, and store the result in the target BitSet.
If you want to perform a Boolean operation without altering the original BitSet, you should first make a copy of the original with the clone( ) method and invoke the method on the copy.
The and( ) method preforms a bitwise Boolean AND operation, much like the & does when applied to integer arguments.
A value in the target BitSet will be true only if it was originally true and the value at the same index of argument BitSet is also true.
For all false values in the argument BitSet, and( ) sets the corresponding value in the target BitSet to false, leaving other values unchanged.
The andNot( ) method combines a Boolean AND operation with a Boolean NOT operation on the argument BitSet (it does not alter the contents of that argument BitSet, hoever)
The result is that for all true values in the argument BitSet, the corresponding values in the target BitSet are set to false.
The or( ) method performs a bitwise Boolean OR operation like the | operator: a value in the BitSet will be set to true if its original value was true or the corresponding value in the argument BitSet was true.
For all true values in the argument BitSet, the or( ) method sets the corresponding value in the target BitSet to true, leaving the other values unchanged.
The xor( ) method performs an “exclusive OR” operation: sets a value in the target BitSet to true if it was originally true or if the corresponding value in the argument BitSet was true.
If both values were false, or if both values were true, however, it sets the value to false.
Finally, the toString( ) method returns a String representation of a BitSet that consists of a list within curly braces of the indexes at which true values are stored.
This abstract class defines methods that perform date and time arithmetic.
It also includes methods that convert dates and times to and from the machine-usable millisecond format used by the Date class and units such as minutes, hours, days, weeks, months, and years that are more useful to humans.
Instead, it provides static getInstance( ) methods that return instances of a Calendar subclass suitable for use in a specified or default locale with a specified or default time zone.
Some of these are values that represent days of the week and months of the year.
Other constants, such as HOUR and DAY_OF_WEEK, represent various fields of date and time information.
These field constants are passed to a number of Calendar methods, such as get( ) and set( ), in order to indicate what particular date or time field is desired.
The add( ) method adds (or subtracts) values to a calendar field, incrementing the next larger field when the field being set rolls over.
Many of the methods of the Calendar class are replacements for methods of Date that have been deprecated as of Java 1.1
While the Calendar class converts a time value to its various hour, day, month, and other fields, it is not intended to present those fields in a form suitable for display to the end user.
Calendar implements Comparable in Java 5.0, but not in earlier releases.
In Java 5.0 this is a generic interface and the type variable E represents the type of the objects in the collection.
The objects may or may not be ordered, and the collection may or may not contain duplicate objects.
Instead, most collection classes implement one of the more specific subinterfaces: Set, an unordered collection that does not allow duplicates, or List, an ordered collection that does allow duplicates.
The Collection type provides a general way to refer to any set, list, or other collection of objects; it defines generic methods that work with any collection.
Another version of toArray( ) takes an array as an argument and stores all elements of the Collection (which must all be compatible with the array) into that array.
If the array is not big enough, the method allocates a new, larger array of the same type.
If the array is too big, the method stores null into the first empty element of the array.
This version of toArray( ) returns the array that was passed in or the new array, if one was allocated.
The previous methods all query or extract the contents of a collection.
The Collection interface also defines methods for modifying the contents of the collection.
All these modification methods except clear( ) return true if the collection was modified as a result of the call.
An interface cannot specify constructors, but it is conventional that all implementations of Collection provide at least two standard constructors: one that takes no arguments and creates an empty collection, and a copy constructor that accepts a Collection object that specifies the initial contents of the new Collection.
Protected Instance Fields protected boolean areFieldsSet; protected int[ ] fields; protected boolean[ ] isSet; protected boolean isTimeSet; protected long time;
Implementations of Collection and its subinterfaces are not required to support all operations defined by the Collection interface.
Furthermore, implementations are free to impose restrictions on the types of objects that can be members of a collection.
Some implementations might require elements to be of a particular type, for example, and others might not allow null as an element.
This class defines static methods and constants that are useful for working with collections and maps.
One of the most commonly used methods is sort( ), which sorts a List in place (the list cannot be immutable, of course)
The sorting algorithm is stable, which means that equal elements retain the same relative order.
It efficiently (in logarithmic time) searches a sorted List for a specified object and returns the index at which a matching object is found.
If no match is found, it returns a negative number.
For a negative return value r, the value –(r+1) specifies the index at which the specified object can be inserted into the list to maintain the sorted order of the list.
As with sort( ), binarySearch( ) can be passed a Comparator that defines the order of the sorted list.
See Arrays for methods that perform sorting and searching operations on arrays instead of collections.
The various methods whose names begin with synchronized return a threadsafe collection object wrapped around the specified collection.
Vector and Hashtable are the only two collection objects threadsafe by default.
Use these methods to obtain a synchronized wrapper object if you are using any other type of Collection or Map in a multithreaded environment where more than one thread can modify it.
The various methods whose names begin with unmodifiable function like synchronized methods.
They return a Collection or Map object wrapped around the specified collection.
The returned object is unmodifiable, however, so its add( ), remove( ), set( ), put( ), etc.
In Java 5.0, the “checked” methods return wrapped collections that enforce a specified element type for the collection, so that it is not possible to add an element of the wrong type.
In addition to the “synchronized”, “unmodifiable”, and “checked” methods, Collections defines a number of other methods that return special-purpose collections or maps: singleton( ) returns an unmodifiable set that contains only the specified object.
In Java 5.0, the emptySet( ), emptyList( ), and emptyMap( ) methods are preferred alternatives to these constants, because they are generic methods and return correctly parameterized empty collections.
The Collections class also defines methods that mutate a collection.
Specifying a negative rotation rotates the list in the other direction.
In Java 5.0, the addAll( ) method adds the specified elements to the specified collection.
This method is a varargs method and allows elements to be specified in an array or listed individually in the argument list.
Finally, Collections defines methods (in addition to the binarySearch( ) methods described above) that search the elements of a collection: min( ) and max( ) methods search an unordered Collection for the minimum and maximum elements, according either to a specified Comparator or to the natural order defined by the Comparable elements themselves.
They return the start index of any such matching sublist, or return -1 if no match was found.
These methods are like the indexOf( ) and lastIndexOf( ) methods of String, and do not require the List to be sorted, as the binarySearch( ) methods do.
In Java 5.0, frequency( ) returns the number of occurences of a specified element in a specified collection, and disjoint( ) determines whether two collections are entirely disjoint—whether they have no elements in common.
This interface defines a compare( ) method that specifies a total ordering for a set of objects, allowing those objects to be sorted.
The Comparator is used when the objects to be ordered do not have a natural ordering defined by the Comparable interface, or when you want to order them using something other than their natural ordering.
Comparator has been made generic in Java 5.0 and the type variable T represents the type of objects being compared.
If the first argument is less than the second argument or should be placed before the second argument in a sorted list, compare( ) should return a negative integer.
If the first argument is greater than the second argument or should be placed after the second argument in a sorted list, compare( ) should return a positive integer.
Comparator implementations may assume that both Object arguments are of appropriate types and cast them as desired.
If either argument is not of the expected type, the compare( ) method throws a ClassCastException.
Note that the magnitude of the numbers returned by compare( ) does not matter, only whether they are less than, equal to, or greater than zero.
This is particularly important when using a Comparator to impose an ordering on a TreeSet or a TreeMap.
See Collections and Arrays for various methods that use Comparator objects for sorting and searching.
Signals that a modification has been made to a data structure at the same time some other operation is in progress and that, as a result, the correctness of the ongoing operation cannot be guaranteed.
It is typically thrown by an Iterator or ListIterator object to stop an iteration if it detects that the underlying collection has been modified while the iteration is in progress.
Obtain a Currency object by passing a “currency code” such as “USD” for U.S.
Once you have a Currency object, use getSymbol( ) to obtain the currency symbol (which is often different from the currency code) for the default locale or for a specified Locale.
If no symbol is known, this method returns the currency code.
This class represents dates and times and lets you work with them in a system-independent way.
If you call the Date constructor with no arguments, the Date is initialized to the current time and date.
The instance methods of the class allow you to get and set the various date and time fields, to compare dates and times, and to convert dates to and from string representations.
As of Java 1.1, many of the date methods have been deprecated in favor of the methods of the Calendar class.
As of Java 1.2, the Map interface replaces the functionality of this class.
This interface defines the methods necessary to enumerate, or iterate, through a set of values, such as the set of values contained in a hashtable.
This interface is superseded in Java 1.2 by the Iterator inteface.
In Java 5.0 this interface has been made generic and defines the type variable E to represent the type of the objects being enumerated.
An Enumeration is usually not instantiated directly, but instead is created by the object that is to have its values enumerated.
A number of classes, such as Vector and Hashtable, have methods that return Enumeration objects.
To use an Enumeration object, you use its two methods in a loop.
Within a loop, a call to nextElement( ) returns a value from the enumeration.
An Enumeration makes no guarantees about the order in which the values are returned.
The values in an Enumeration can be iterated through only once; there is no way to reset it to the beginning.
This class is a Map implementation for use with enumerated types.
The key type K must be an enumerated type, and all keys must be enumerated constants defined by that type.
The value type V is unrestricted and null values are permitted.
The EnumMap implementation is based on an array of elements of type V.
The length of this array is the same as the number of constants defined by the enumerated type K.
The iterators of the keySet( ), entrySet( ), and values( ) collections iterate their elements in the ordinal order of the enumerated constants.
This Set implementation is specialized for use with enumerated constants.
The element type E must be an enumerated type, and null is not allowed as a member of the set.
Instead, it defines various static factory methods for creating sets.
Use one of the of( ) methods for creating an EnumSet and initializing its elements.
For efficiency, versions of this method that accept one through five arguments are defined.
If you pass more than five arguments, the varargs version will be invoked.
The allOf( ) and noneOf( ) methods define full and empty sets but require the Class of the enumerated type since they do not have any other arguments to define the element type.
The range( ) factory creates a set that includes the two specified values and any enumerated constants that fall between them in the enumerated type declaration.
Note that this definition of a range includes both endpoints and differs from most Java methods, in which the second argument specifies the first value past the end of the range.
The EnumSet implementation is based on a bit vector that includes one bit for each constant defined by the enumerated type E.
Because of this compact and efficient representation, basic Set operations occur in constant time, and the Iterator returns.
EventListener is a base interface for the event model that is used by AWT and Swing in Java 1.1 and later.
This interface defines no methods or constants; it serves simply as a tag that identifies objects that act as event listeners.
This abstract class serves as the superclass for event listener proxy objects.
Subclasses of this class implement an event listener interface and serve as a wrapper around an event listener of that type, defining methods that provide additional information about the listener.
The only common feature shared by all events is a source object, which is the object that, in some way, generated the event.
The source object is passed to the EventObject( ) constructor and is returned by the getSource( ) method.
This interface should be implemented by classes that want to interact with the Formatter class more intimately than is possible with the toString method.
When a Formattable object is the argument for a %s or %S conversion, its formatTo( ) method is invoked rather than its toString( ) method.
The flags argument is a bitmask of zero or more FormattableFlags constants.
Each flag provides information about the format specification that resulted in the invocation of formatTo( )
The interpretation of the alternate form is entirely up to the Formattable implementation.
LEFT_JUSTIFY means that the - flag was used and that the Formattable should pad its output on the right, instead of on the left.
The width and precision arguments specify the width and precision specified along with the %s format specifier, or -1 if no width and precision are specified.
The Formattable object should treat these values the same way that Formatter does.
The text to be output should first be truncated to fit within precision characters and then padded on the left (or right if the LEFT_JUSTIFY flag is set) with spaces for a total length of width characters.
Note that a Formattable implementation may fulfill the obligations imposed by the LEFT_JUSTIFY and UPPERCASE flags and the width and precision arguments by constructing a suitable format string to pass back to the specified Formatter.
If a Formattable implementation wants to perform locale-specific formatting, it can query the Locale of the Formatter with the locale( ) method.
Note, however, that the returned value is the locale specified when the Formatter was created, not the Locale, if any, passed to the format( ) method.
There is no way for a Formattable object to access that Locale.
The Formatter class is a utility for formatting text in the style of the printf( ) method of the C programming language.
The format string uses a grammar, described in detail later in the entry, to specify how the arguments that follow are to be converted to strings.
After the arguments are converted, they are substituted into the format string, and the resulting text is appended to the Appendable.
A variant of the format( ) method accepts a Locale object that can affect the argument conversions.
When using a Formatter with a stream-based Appendable object that may throw an IOException, you can use the ioException( ) method to obtain the most recently thrown exception, or null if no exception has been thrown by the Appendable.
Formatter implements the Closeable and Flushable interfaces of the java.io package, and its close( ) and flush( ) methods call the corresponding methods on its Appendable object, if that object itself implements Closeable or Flushable.
When a Formatter sends its output to a stream or similar Appendable, remember to call close( ) when you are done with it.
It is always safe to call close( ) even if the underlying Appendable is not Closeable.
Note that once a Formatter has been closed, no other method except ioException( ) may be called.
This is useful when the Appendable is a StringBuilder, for example, as it is when the no-argument version of the Formatter( ) constructor is used.
If the Appendable is a stream class, however, the toString( ) method is not typically useful.
Note that the Java 5.0 API provides a number of convenience methods that use the Formatter class, and in many cases it is unnecessary to create a Formatter object explicitly.
If you do need to create a Formatter object explicitly, you can choose from a number of constructors.
The most general case is to pass the desired Appendable or the desired Locale and Appendable objects to the constructor.
The no-argument constructor is a convenience that creates a StringBuilder to append to.
Obtain this StringBuilder with out( ) or obtain its contents as a String with toString( )
If you specify a single Locale argument, the resulting Formatter uses the specified locale with a StringBuilder.
You can use a Formatter to write formatted output to a file by specifying either the File object or filename as a String.
Variants of these constructors allow you to specify the name of the charset to use for character-to-byte conversion and also a Locale.
Note that these methods overwrite existing files rather than appending to them.
In the OutputStream case, you may optionally specify the charset to use or the charset and a Locale.
The power of these formatting methods lies in the format string that is the first argument (or second argument if a Locale is specified) to the various format( ) and printf( ) methods.
The format string may contain any amount of regular text, which is printed or appended literally to the destination Appendable object.
This plain text may be interspersed with format specifiers which specify how a subsequent argument is to be formatted as a string.
In contrast to the simple API, the grammar for these format specifiers is surprisingly complex.
Experienced C programmers will find that the grammar is largely compatible with the printf( ) format string grammar of the standard C library.
Each format specifier begins with a percent sign and ends with a one- or two-character conversion type that specifies most of the details of the conversion and formatting.
In between these two are optional flags that provide additional details about how the formatting should be done.
The general syntax of a format specifier is as follows.
Note that the percent sign and the type are the only two required portions of a format specifier.
We begin, therefore, with a listing of conversion types (see Table 16-1)
In the table of conversion types below, if uppercase and lowercase variants of the type specifier are listed together, the uppercase variant produces the same output as the lowercase variant except that all lowercase letters are converted to uppercase.
A null argument is formatted as “null” or “NULL” for all conversion characters except %b and %B, which produce “false” or “FALSE”
Outputs a single percent sign.This is simply an escape sequence used to embed percent signs literally in the output string.
If the argument implements Formattable, its formatTo( ) method is called to perform the formatting.
Otherwise, its toString( ) method is called to convert it to a string.
If the argument is null, the output string is “null” or “NULL”
The argument value must represent a valid Unicode code point.
The argument may be of any type and any value.
If it is a Boolean argument, the output reflects the argument value.
Otherwise, if the argument is null, the output is “false” or “FALSE”
For any other value, the output is “true” or “TRUE”
Note that this differs from normal Java conversions in which boolean values are not convertible to or from any other type.
The allowed argument types are the same as for %d.
For any argument type other than BigInteger, the value is treated as unsigned.
The allowed argument types and values are the same as for %d.
For any argument type other than BigInteger, the value is treated as unsigned.
The output consists of a single digit, a locale-specific decimal point, and the number of fractional digits specified by the precision of the format specifier, or six fractional digits if no precision is specified.
These digits are followed by the letter e or E and the exponent of the number.
The values NaN and Infinity are formatted as “NaN” and “Infinity” or their uppercase equivalents.
If the number is large, this may produce quite a few digits.
Because exponential notation is never used, the output will never include a letter, and there is no uppercase variant of this conversion.
Legal argument types and special-case values are as for %e.
If the value has more than the allowed number of significant digits, it is printed using exponential notation (see %e) to limit the display to the specified number of digits.
Otherwise, all digits of the value are printed explicitly as they would be with the %f conversion type.
Legal argument types and special case values are as for %e.
Legal argument types and special case values are as for %e.
The specific format types are listed below, in alphabetical order, using %t as the prefix.
Upper- and lowercase variants of the second letter of a time or date format type are sometimes completely unrelated.
Other times, the lowercase conversion produces an abbreviation of the value produced by the uppercase conversion.
The argument for a date or time conversion must be a Date, Calendar, or Long.
In the case of Long, the value is interpreted as milliseconds since the epoch, as in System currentTimeMillis( )
Argument Specifier Every format specifier in a format string except for %% and %n requires an argument that contains the value to format.
These arguments follow the format string in the call to format( ) or printf( )
By default, a format specifier uses the next unused argument.
In the following printf( ) call, the first and second %s format specifiers format the second and third arguments, respectively:
If a format specifier includes the character < after the %, it specifies that the argument of the previous format specifier should be reused.
This allows the same object (such as a date) to be formatted more than once (yielding a formatted date and time, for example):
It is an error to use < in the first format specifier of a format string.
If the % sign is followed by one or more digits and a $ sign, those digits specify an argument number.
For example %1$d specifies that the first argument following the format string should be formatted as an integer.
Absolute argument numbers are particularly useful for localization since the different translations of a message may need to interpolate the arguments in a different order.
The following example includes a format string that might be used in a locale where a person’s family name is typically printed (in uppercase) before the given name.
Note that the arguments are not passed in the same order that they are formatted.
Note that platforms are not required to able to resolve times with nanosecond precision.
Equivalent to “%tI:%tM:%tS %tP” except that the am/pm indicator %tP may be in a different locale-dependent position.
The code above could be rewritten like this, for example:
Flags Following the optional argument specifier, a format specifier may include one or more flag characters.
The defined flags, their effects, and the format types for which they are legal are specified in Table 16-2:
Width The width portion of a format specifier is one or more digits that specify the minimum number of characters to be produced.
If the formatted value is narrower than the specified width, (by default) it is padded on the left with spaces, producing a right-justified value.
The - and 0 flags can be used to specify left-justification or padding with zeros instead.
A width may be specified with any format type except %n.
A hyphen specifies that the formatted value should be left-justified within the specified width.
This flag can be used with any conversion type except %n as long as the conversion specifier also includes a width (see below)
When a width is specified without this flag, the formatted string is padded on the left to produce right-justified output.
The # flag specifies that output should appear in an “alternate form” that depends on the type being formatted.
For the %s and %S conversions, the # flag may be used if the argument implements Formattable.
In this case, the flag is passed on to the formatTo( ) method of the argument, and it is up to that formatTo( ) method to produce its output in some alternate form.
This flag specifies that numeric output should always include a sign: a value that is nonnegative will have “+” added in front of it.
This flag may be used with any numeric conversion that may yield a signed result.
This includes %d, %e, %f, %g, %a, and their uppercase variants.
It also includes %o, %x, and %X conversions applied to BigInteger arguments.
The space character is a (hard-to-read) flag that specifies that non-negative values should be prefixed with a space.
This flag may be used with the same conversion and argument types as the + flag, and is useful when aligning positive and negative numbers in a column.
This flag specifies that negative numbers should be enclosed in parentheses, as is commonly done in financial statements, for example.
This flag may be used with the same format and argument types as the + flag, except that it may not be used with %a conversions.
The digit zero, used as a flag, specifies that numeric values should be padded on the left (after the sign character, if any) with zeros.
This flag may be used only if a width is specified, and may not be used in conjunction with the - flag.
This flag specifies that numbers should be formatted using the locale-specific grouping separator.
In the US locale, for example, a comma would appear every three digits to separate the number into thousands, millions, and so on.
This flag may be used with %d, %e, %E, %f, %g, and %G conversions only.
Precision The precision portion of a format specifier is one or more digits following a decimal point.
The meaning of this number depends on which format type it is used with:
For %e, %E, and %f, the precision specifies the number of digits to appear after the decimal point.
For %g and %G format types, the precision specifies the total number of significant digits to be displayed.
As a corollary, it specifies the largest and smallest values that can be displayed without resorting to exponential notation.
For %s, %h and %b format types, and their uppercase variants, the precision specifies the maximum number of characters to be output.
If the formatted output would exceed the precision of characters, it is truncated.
If precision is smaller than width, the formatted value is first truncated as necessary and then padded within the specified width.
Specifying a precision for any other conversion type causes an exception at runtime.
This enumerated type is intended for internal use by the Formatter class, but was inadvertently declared public.
This type serves no useful purpose and should not be used.
An exception of this type is thrown when an attempt is made to use a Formatter whose close( ) method has been called.
This concrete subclass of Calendar implements the standard solar calendar with years numbered from the birth of Christ that is used is most locales throughout the world.
There is a discontinuity in the Gregorian calendar that represents the historical switch from the Julian calendar to the Gregorian calendar.
This class implements the Map interface using an internal hashtable.
It supports all optional Map methods, allows key and value objects of any types, and allows null to be used as a key or a value.
Because HashMap is based on a hashtable data structure, the get( ) and put( ) methods are very efficient.
HashMap is much like the Hashtable class, except that the HashMap methods are not synchronized (and are therefore faster), and HashMap allows null to be used as a key or a value.
If you are working in a multithreaded environment, or if compatibility with previous versions of Java is a concern, use Hashtable.
If you know in advance approximately how many mappings a HashMap will contain, you can improve efficiency by specifying initialCapacity when you call the HashMap( ) constructor.
The initialCapacity argument times the loadFactor argument should be greater.
A good value for loadFactor is 0.75; this is also the default value.
It supports all optional Set and Collection methods and allows any type of object or null to be a member of the set.
Because HashSet is based on a hashtable, the basic add( ), remove( ), and contains( ) methods are all quite efficient.
HashSet makes no guarantee about the order in which the set elements are enumerated by the Iterator returned by iterator( )
If you know in advance approximately how many mappings a HashSet will contain, you can improve efficiency by specifying initialCapacity when you call the HashSet( ) constructor.
The initialCapacity argument times the loadFactor argument should be greater than the number of mappings the HashSet will contain.
A good value for loadFactor is 0.75; this is also the default value.
See Set and Collection for details on the methods of HashSet.
This class implements a hashtable data structure, which maps key objects to value objects and allows the efficient lookup of the value associated with a given key.
In Java 1.2 and later Hashtable has been modified to impement the Map interface.
The HashMap class is typically preferred over this one, although the synchronized methods of this class are useful in multi-threaded applications.
In Java 5.0 this class has been made generic along with the Map interface.
The type variable K represents the type of the hashtable keys and the type variable V represents the type of the hashtable values.
Objects used as keys in a Hashtable must have valid equals( ) and hashCode( ) methods (the versions inherited from Object are okay)
This Map implementation has a API that is very similar to HashMap, and uses an internal hashtable, like HashMap does.
However, it behaves differently from HashMap in one very important way.
When testing two keys to see if they are equal, HashMap, LinkedHashMap and TreeMap use the equals( ) method to determine whether the two objects are indistinguishable in terms of their content or state.
IdentityHashMap is different: it uses the == operator to determine whether the two key objects are identical--whether they are exactly the same object.
This one difference in how key equality is tested has profound ramifications for the behavior of the Map.
In most cases, the equality testing of a HashMap, LinkedHashMap or TreeMap is the appropriate behavior, and you should use one of those classes.
For certain purposes, however, the identity testing of IdentityHashMap is what is required.
An exception of this type is thrown by a Formatter when there is problem with the format string.
This package defines many subclasses of this exception type to describe particular format string problems.
An exception of this type is thrown by a Scanner that is not of the expected type or is out of range.
This interface defines methods for iterating, or enumerating, the elements of a collection.
It has been made generic in Java 5.0 and the type variable E represents the type of the elements in the collection.
The hasNext( ) method returns true if there are more elements to be enumerated or false if all elements have already been returned.
These two methods make it easy to loop through an iterator with code such as the following:
In Java 1.2, Iterator is preferred over Enumeration because it provides a well-defined way to safely remove elements from a collection while the iteration is in progress.
The remove( ) method removes the object most recently returned by next( ) from the collection that is being iterated through.
While you are iterating through a collection, you are allowed to modify the collection only by calling the remove( ) method of the Iterator.
This class is a Map implementation based on a hashtable, just like its superclass HashMap.
It defines no new public methods, and can be used exactly as HashMap is used.
What is unique about this Map is that in addition to the hashtable data structure, it also uses a.
You can iterate through the keys or values of a LinkedHashMap by calling entrySet( ), keySet( ), or values( ) and then obtaining an Iterator for the returned collection, just as you would for a HashMap.
When you do this, however, the keys and/or values are returned in a welldefined order rather than the essentially random order provided by a HashMap.
The default ordering for LinkedHashMap is the insertion order of the key: the first key inserted into the Map is enumerated first (as is the value associated with it), and the last entry inserted is enumerated last.
The iteration order of a value in the map is the iteration order of the key with which it is associated.
Insertion order is the default iteration order for this class, but if you instantiate a LinkedHashMap with the three-argument constructor, and pass true for the third argument, then the iteration order will be based on access order: the first key returned by an iterator is the one that was least-recently used in a get( ) or put( ) operation.
The last key returned is the one that has been most-recently used.
As with insertion order, the values( ) collection is iterated in the order defined by the keys with which those values are associated.
To facilitate this use, LinkedHashMap defines the protected removeEldestEntry( ) method.
Each time the put( ) method is called (or for each mapping added by putAll( )) the LinkedHashMap calls removeEldestEntry( ) and passes the least-recently used (or first inserted if insertion order is being used) Map.Entry object.
If the method returns true, then that entry will be removed from the map.
In LinkedHashMap, removeEldestEntry( ) always returns false, and old entries are never automatically removed, but you can override this behavior in a subclass.
The decision to remove an old entry might be based on the content of the entry itself, or might more simply be based on the size( ) of the LinkedHashMap.
Note that removeEldestEntry( ) need simply return true or false; it should not remove the entry itself.
This subclass of HashSet is a Set implementation based on a hashtable.
It defines no new methods and is used just like a HashSet is used.
What is unique about a LinkedHashSet is that in addition to the hashtable data structure, it also uses a doubly-linked list to connect the elements of the set into an internal list in the order in which they were inserted.
This means that the Iterator returned by the inherited iterator( ) method always enumerates the elements of the set in the order which they were inserted.
By contrast, the elements of a HashSet are enumerated in an order that is essentially random.
Note that the iteration order is not affected by reinsertion of set elements.
That is, if you attempt to add an element that already exists in the set, the iteration order of the set is not modified.
If you delete an element and then reinsert it, the insertion order, and therefore the iteration order, does change.
This class implements the List interface in terms of a doubly linked list.
In Java 5.0, it also implements the Queue interface and uses its list as a first-in, first-out (FIFO) queue.
LinkedList is a generic type, and the type variable E represents the type of the elements of the list.
LinkedList supports all optional methods of List, Queue and Collection and allows list elements of any type, including null (in this it differs from most Queue implementations, which prohibit null elements)
Because LinkedList is implemented with a linked list data structure, the get( ) and set( ) methods are substantially less efficient than the same methods for an ArrayList.
However, a LinkedList may be more efficient when the add( ) and remove( ) methods are used frequently.
In addition to the methods defined by the List interface, LinkedList defines methods to get the first and last elements of the list, to add an element to the beginning or end of the list, and to remove the first or last element of the list.
These convenient and efficient methods make LinkedList well-suited for use as a stack or queue.
See List and Collection for details on the methods of LinkedList.
In Java 5.0 List is a generic interface and the type variable E represents the type of the objects in the list.
Each element in a List has an index, or position, in the list, and elements can be inserted, queried, and removed by index.
The last element in a list has index size( )-1
In addition to the methods defined by the superinterface, Collection, List defines a number of methods for working with its indexed elements.
Versions of add( ) and addAll( ) that take an index argument insert an object or Collection of objects at a specified index.
The versions of add( ) and addAll( ) that do not take an index argument insert an object or collection of objects at the end of the list.
List defines a version of remove( ) that removes the object at a specified index.
The iterator( ) method is just like the iterator( ) method of Collection, except that the Iterator it returns is guaranteed to enumerate the elements of the List in order.
Each method returns the index of the first matching object it finds, or –1 if it does not find a match.
Finally, subList( ) returns a List that contains only a specified contiguous range of list elements.
The returned list is simply a view into the original list, so changes in the original List are visible in the returned List.
This subList( ) method is particularly useful if you want to sort, search, clear( ), or otherwise manipulate only a partial range of a larger list.
An interface cannot specify constructors, but it is conventional that all implementations of List provide at least two standard constructors: one that takes no arguments and creates an empty list, and a copy constructor that accepts an arbitrary Collection object that specifies the initial contents of the new List.
Different implementations of List may have significantly different efficiency characteristics.
For example, the get( ) and set( ) methods of an ArrayList are much more efficient than those of a LinkedList.
On the other hand, the add( ) and remove( ) methods of a LinkedList can be more efficient than those of an ArrayList.
This interface is an extension of Iterator for use with ordered collections, or lists.
It defines methods to iterate forward and backward through a list, to determine the list index of the elements being iterated, and, for mutable lists, to safely insert, delete, and edit elements in the list while the iteration is in progress.
For some lists, notably LinkedList, using an iterator to enumerate the list’s elements may be substantially more efficient than looping through the list by index and calling get( ) repeatedly.
Like the Iterator interface, ListIterator has been made generic in Java 5.0
The type variable E represents the type of the elements on the list.
In addition to these two methods, however, ListIterator also defines hasPrevious( ) and previous( ) that allow you to iterate backward through the list.
ListIterator defines three optionally supported methods that provide a safe way to modify the contents of the underlying list while the iteration is in progress.
Calling add( ) does not affect the value that is returned by next( ), however.
If you call previous( ) immediately after calling add( ), the method returns the object you just added.
You can only call remove( ) once per call to next( ) or previous( )
If you have called add( ), you must call next( ) or previous( ) again before calling remove( )
If you have called add( ) or remove( ), you must call next( ) or previous( ) again before calling set( )
Remember that support for the add( ), remove( ), and set( ) methods is optional.
This abstract class provides a simple way to define a ResourceBundle.
You may find it easier to subclass ListResourceBundle than to subclass ResourceBundle directly.
ListResourceBundle provides implementations for the abstract handleGetObject( ) and getKeys( ) methods defined by ResourceBundle and adds its own abstract getContents( ) method a subclass must override.
Each element of this array must itself be an array with two elements: the first element of each subarray should be a String that specifies the name of a resource, and the corresponding second element should be the value of that resource; this value can be an Object of any desired type.
The Locale class represents a locale: a political, geographical, or cultural region that typically has a distinct language and distinct customs and conventions for such things as formatting dates, times, and numbers.
Locale also defines a static getDefault( ) method that returns the default Locale object, which represents a locale value inherited from the host system.
If none of these methods for obtaining a Locale object are suitable, you can explicitly create your own Locale object.
To do this, you must specify a language code and optionally a country code and variant string.
Given a Locale object, you can invoke the various getDisplay methods to obtain a description of the locale suitable for display to a user.
These methods may themselves take a Locale argument, so the names of languages and countries can be localized as appropriate.
This interface represents a collection of mappings, or associations, between key objects and value objects.
The type variable K represents the type of the keys held by the map and the type variable V represents the type of the values associated with those keys.
The set of key objects in a Map must not have any duplicates; the collection of value objects is under no such constraint.
The key objects should usually be immutable objects, or, if they are not, care should be taken that they do not change while in use in a Map.
As of Java 1.2, the Map interface replaces the abstract Dictionary class.
Although a Map is not a Collection, the Map interface is still considered an integral part, along with Set, List, and others, of the Java collections framework.
You can add a key/value association to a Map with the put( ) method.
Use putAll( ) to copy all mappings from one Map to another.
Call get( ) to look up the value object associated with a specified key object.
Use remove( ) to delete the mapping between a specified key and its value, or use clear( ) to delete all mappings from a Map.
For most implementations, containsValue( ) is a much more expensive operation than containsKey( ), however.
The collections returned by values( ), keySet( ), and entrySet( ) are based on the Map itself, so changes to the Map are reflected in the collections.
An interface cannot specify constructors, but it is conventional that all implementations of Map provide at least two standard constructors: one that takes no arguments and creates an empty map, and a copy constructor that accepts a Map object that specifies the initial contents of the new Map.
Implementations are required to support all methods that query the contents of a Map, but support for methods that modify the contents of a Map is optional.
This interface represents a single mapping, or association, between a key object and a value object in a Map.
Like Map itself, Map.Entry has been made generic in Java 5.0 and defines the same type variables that Map does.
The entrySet( ) method of a Map returns a Set of Map.Entry objects that represent the set of mappings in the map.
Use the iterator( ) method of that Set to enumerate these Map.Entry objects.
Use getKey( ) and getValue( ) to obtain the key and value objects for the entry.
Use the optionally supported setValue( ) method to change the value of an entry.
Signals that no ResourceBundle can be located for the desired locale or that a named resource cannot be found within a given ResourceBundle.
Signals that there are no elements in an object (such as a Vector) or that there are no more elements in an object (such as an Enumeration)
This class is the superclass for classes that want to provide notifications of state changes to interested Observer objects.
Register an Observer to be notified by passing it to the addObserver( ) method of an Observable, and de-register it by passing it to the deleteObserver( ) method.
You can delete all observers registered for an Observable with deleteObservers( ), and can find out how many observers have been added with countObservers( )
Note that there is not a method to enumerate the particular Observer objects that have been added.
An Observable subclass should call the protected method setChanged( ) when its state has changed in some way.
After an operation or series of operations that may have caused the state to change, the Observable subclass should call notifyObservers( ), optionally passing an arbitrary Object argument.
If the state changed flag is set, this notifyObservers( ) calls the update( ) method of each registered Observer (in some arbitrary order), passing the Observable object, and the optional argument, if any.
Once the update( ) method of each Observable has been called, notifyObservers( ) calls clearChanged( ) to clear the state changed flag.
If notifyObservers( ) is called when the state changed flag is not set, it does not do anything.
You can use hasChanged( ) to query the current state of the changed flag.
The Observable class and Observer interface are not commonly used.
Most applications prefer the event-based notification model defined by the JavaBeans component framework and by the EventObject class and EventListener interface of this package.
This interface defines the update( ) method required for an object to observe subclasses of Observable.
An Observer registers interest in an Observable object by calling the addObserver( ) method of Observable.
Observer objects that have been registered in this way have their update( ) methods invoked by the Observable when that object has changed.
This interface is conceptually similar to, but less commonly used than, the EventListener interface and its various event-specific subinterfaces.
This class is a Queue implementation that orders its elements according to a specified Comparator or orders Comparable elements according to their compareTo( ) methods.
The head of the queue (the element removed by remove( ) and poll( )) is the smallest element on the queue according to this ordering.
The Iterator return by the iterator( ) method is not guaranteed to iterate the elements in their sorted order.
This class is an extension of Hashtable that allows key/value pairs to be read from and written to a stream.
The Properties class implements the system properties list, which supports user customization by allowing programs to look up the values of named resources.
Because the load( ) and store( ) methods provide an easy way to read and write properties from and to a text stream, this class provides a convenient way to implement an application configuration file.
As of Java 1.2, store( ) is preferred over the deprecated save( ) method, which writes properties in the same way but suppresses any I/O exceptions that may be thrown in the process.
The second argument to both store( ) and save( ) is a comment that is written out at the beginning of the property file.
Finally, load( ) reads key/value pairs from a stream and stores them in a Properties object.
It is suitable for reading both properties written with store( ) and hand-edited properties files.
In Java 5.0, storeToXML( ) and loadFromXML( ) are alternatives that write and read properties files using a simple XML grammar.
A PropertyPermission object has a name, or target, and a comma-separated list of actions.
The name of the permission is the name of the property of interest.
The action string can be “read” for getProperty( ) access, “write” for setProperty( ) access, or “read,write” for both types of access.
If a name ends with “.*”, it represents any property names that share the specified prefix.
Granting access to system properties is not overtly dangerous, but caution is still necessary.
Some properties, such as “user.home”, reveal details about the host system that malicious code can use to mount an attack.
Programmers writing system-level code and system administrators configuring security policies may need to use this class, but applications never need to use it.
It reads a Properties file from a specified InputStream and implements the ResourceBundle API for looking up named resources from the resulting Properties object.
Each such line defines a named property with the specified String value.
A Queue<E> is an ordered Collection of elements of type E.
Unlike List, the Queue interface does not permit indexed access to its elements: elements may be inserted at the tail of the queue and may be removed from the head of the queue, but the elements in between may not be accessed by their position.
Queues may be manipulated through the methods of the Collection interface, including iteration via the iterator( ) method and the Iterator object it returns.
It is more common to manipulate queues through the more specialized methods defined by the Queue interface, however.
Place an element at the tail of the queue with offer( )
If the queue is already full, offer( ) returns false.
Remove an element from the head of the queue with remove( ) or poll( )
Most queue implementations prohibit null elements for this reason, but LinkedList is an exception.
Query the element at the head of a queue without removing it with element( ) or peek( )
Most Queue implementations order their elements in first-in, first-out (FIFO) order.
A queue Iterator is not required to traverse the queue’s elements in order.
A Queue implementation with a fixed size is a bounded queue.
When a bounded queue is full, it is not possible to insert a new element until an element is first removed.
Unlike the List and Set interfaces, the Queue interface does not require implementations to override the equals( ) method, and Queue implementations typically do not override it.
In Java 5.0, the LinkedList class has been retrofitted to implement Queue as well as List.
PriorityQueue is a Queue implementation that orders elements based on the Comparable or Comparator interfaces.
AbstractQueue is an abstract implementation that offers partial support for simple Queue implementations.
This class implements a pseudorandom number generator suitable for games and similar applications.
As of Java 1.2, if you pass an argument to nextInt( ), it returns a value between zero (inclusive) and the specified number (exclusive)
You can use the setSeed( ) method or the optional constructor argument to initialize the pseudorandom number generator with some variable seed value other than the current time (the default) or with a constant to ensure a repeatable sequence of pseudorandomness.
This marker interface is implemented by List implementations to advertise that they provide efficient (usually constant time) random access to all list elements.
ArrayList and Vector implement this interface, but LinkedList does not.
Classes that manipulate generic List objects may want to test for this interface with instanceof and use different algorithms for lists that provide efficient random access than they use for lists that are most efficiently accessed sequentially.
This abstract class allows subclasses to define sets of localized resources that can then be dynamically loaded as needed by internationalized programs.
Such resources may include user-visible text and images that appear in an application, as well as more complex things such as Menu objects.
Use getBundle( ) to load a ResourceBundle subclass that is appropriate for the default or specified locale.
Use getObject( ), getString( ), and getStringArray( ) to look up a named resource in a bundle.
To define a bundle, provide implementations of handleGetObject( ) and getKeys( )
The name of any localized ResourceBundle class you define should include the locale language code, and, optionally, the locale country code.
It can read input from any Readable object, and convenience constructors can read text from a specified string, file, byte stream, or byte channel.
The constructors for files, byte streams, and byte channels optionally allow you to specify the name of the charset to use for byte-to-character conversions.
These configuration methods may be called at any time and are not required to be called before scanning begins.
Scanner implements the Iterable<String> interface, and you can use the hasNext( ) and next( ) methods of this interface to break the input into a series of String tokens separated by whitespace or by the delimiter specified with useDelimiter( )
In addition to these Iterable methods, however, Scanner defines a number of nextX and hasNextX methods for various numeric types X.
Two variants of the next( ) method accept a regular expression as an argument and return the next chunk of text matching a specified regular expression.
The corresponding hasNext( ) methods accept a regular expression and return true if the input matches it.
The skip( ) method ignores delimiters and skips text matching the specified regular expression.
If a match is found, the Scanner advances past that text and returns it.
If an IOException occurs, the Scanner assumes that no more input is available from the Readable.
Call ioException( ) to obtain the most recent IOException, if any, thrown by the Readable.
The close( ) method checks whether the Readable object implements the Closeable interface and, if so, calls the close( ) method on that object.
This interface represents an unordered Collection of objects that contains no duplicate elements.
The Set interface defines the same methods as its superinterface, Collection.
It constrains the add( ) and addAll( ) methods from adding duplicate elements to the Set.
In Java 5.0 Set is a generic interface and the type variable E represents the type of the objects in the set.
An interface cannot specify constructors, but it is conventional that all implementations of Set provide at least two standard constructors: one that takes no arguments and creates an empty set, and a copy constructor that accepts a Collection object that specifies the initial contents of the new Set.
This copy constructor must ensure that duplicate elements are not added to the Set, of course.
This concrete subclass of TimeZone is a simple implementation of that abstract class that is suitable for use in locales that use the Gregorian calendar.
Programs do not normally need to instantiate this class directly; instead, they use one of the static factory methods of TimeZone to obtain a suitable TimeZone subclass.
In that case, you can call setStartRule( ) and setEndRule( ) to specify the starting and ending dates of daylight-savings time for the time zone.
This interface represents a Map object that keeps its set of key objects in sorted order.
As with Map, it is conventional that all implementations of this interface define a noargument constructor to create an empty map and a copy constructor that accepts a Map object that specifies the initial contents of the SortedMap.
Furthermore, when creating a SortedMap, there should be a way to specify a Comparator object to sort the key objects of the map.
The inherited keySet( ), values( ), and entrySet( ) methods return collections that can be iterated in the sorted order.
This interface is a Set that sorts its elements and guarantees that its iterator( ) method returns an Iterator that enumerates the elements of the set in sorted order.
As with the Set interface, it is conventional for all implementations of SortedSet to provide a noargument constructor that creates an empty set and a copy constructor that expects.
Furthermore, when creating a SortedSet, there should be a way to specify a Comparator object that compares and sorts the elements of the set.
SortedSet defines a few methods in addition to those it inherits from the Set interface.
Note that all three methods return a SortedSet that is implemented as a view onto the original SortedSet.
Changes in the original set are visible through the returned set and vice versa.
In Java 1.2, you can instead use a LinkedList as a stack.
When a StringTokenizer is instantiated with a String, it breaks the string up into tokens separated by any of the characters in the specified string of delimiters.
For example, words separated by space and tab characters are tokens.
The hasMoreTokens( ) and nextToken( ) methods obtain the tokens in order.
StringTokenizer implements the Enumeration interface, so you may also access the tokens with the familiar hasMoreElements( ) and nextElement( ) methods.
When you create a StringTokenizer, you can specify a string of delimiter characters to use for the entire string, or you can rely on the default whitespace delimiters.
You can also specify whether the delimiters themselves should be returned as tokens.
Finally, you can optionally specify a new string of delimiter characters when you call nextToken( )
This class implements a timer: its methods allow you to schedule one or more runnable TimerTask objects to be executed (once or repetitively) by a background thread at a specified time in the future.
You can create a timer with the Timer( ) constructor.
The no-argument version of this constructor creates a regular non-daemon background thread, which means that the Java VM will not terminate while the timer thread is running.
Pass true to the constructor if you want the background thread to be a daemon thread.
In Java 5.0 you can also specify the name of the background thread when creating a Timer.
To schedule a task for a single execution, use one of the two-argument schedule( ) methods and specify the desired execution time either as a number of milliseconds in the future or as an absolute Date.
If the number of milliseconds is 0, or if the Date object represents a time already passed, the task is scheduled for immediate execution.
These methods are passed an argument that specifies the time (either as a number of milliseconds or as a Date object) of the first execution of the task and another argument, period, that specifies the number of milliseconds between repeated executions of the task.
The schedule( ) methods schedule the task for fixedinterval execution.
That is, each execution is scheduled for period milliseconds after the previous execution ends.
Use schedule( ) for tasks such as animation, where it is important to have a relatively constant interval between executions.
That is, each repetition of the task is scheduled for period milliseconds after the previous execution begins.
A single Timer object can comfortably schedule many TimerTask objects.
Note, however, that all tasks scheduled by a single Timer share a single thread.
If you are scheduling many rapidly repeating tasks, or if some tasks take a long time to execute, other tasks may have their scheduled executions delayed.
When you are done with a Timer, call cancel( ) to stop its associated thread from running.
This is particularly important when you are using a timer whose associated thread is not a daemon thread, because otherwise the timer thread can prevent the Java VM from exiting.
To cancel the execution of a particular task, use the cancel( ) method of TimerTask.
This abstract Runnable class represents a task that is scheduled with a Timer object for one-time or repeated execution in the future.
You can define a task by subclassing TimerTask and implementing the abstract run( ) method.
The Timer object will then invoke the run( ) method at the scheduled time or times.
Call cancel( ) to cancel the one-time or repeated execution of a TimerTask( )
This method returns true if a pending execution was actually canceled.
It returns false if the task has already been canceled, was never scheduled, or was scheduled for one-time execution and has already been executed.
Some tasks may choose to do nothing if they are not invoked on time.
The TimeZone class represents a time zone; it is used with the Calendar and DateFormat classes.
Instead, you should call the static getDefault( ) method to obtain a TimeZone object that represents the time zone inherited from the host operating system.
Or you can call the static getTimeZone( ) method with the name of the desired zone.
You can obtain a list of the supported time-zone names by calling the static getAvailableIDs( ) method.
Once you have a TimeZone object, you can call inDaylightTime( ) to determine whether, for a given Date, daylight-savings time is in effect for that time zone.
Call getID( ) to obtain the name of the time zone.
Call getOffset( ) for a given date to determine the number of milliseconds to add to GMT to convert to the time zone.
Signals that an AWT component, JavaBeans component, or Swing component can have only one EventListener object registered for some specific type of event.
That is, it signals that a particular event is a unicast event rather than a multicast event.
This exception type serves a formal purpose in the Java event model; its presence in the throws clause of an EventListener registration method (even if the method never actually throws the exception) signals that an event is a unicast event.
This class implements the SortedMap interface using an internal Red-Black tree data structure and guarantees that the keys and values of the mapping can be enumerated in ascending order of keys.
The objects used as keys in a TreeMap must all be mutually Comparable, or an appropriate Comparator must be provided when the TreeMap is created.
Because TreeMap is based on a binary tree data structure, the get( ), put( ), remove( ), and containsKey( ) methods operate in relatively efficient logarithmic time.
If you do not need the sorting capability of TreeMap, however, use HashMap instead, as it is even more efficient.
See Map and SortedMap for details on the methods of TreeMap.
In order for a TreeMap to work correctly, the comparison method from the Comparable or Comparator interface must be consistent with the equals( ) method.
That is, the equals( ) method must compare two objects as equal if and only if the comparison method also indicates those two objects are equal.
This class implements SortedSet, provides support for all optional methods, and guarantees that the elements of the set can be enumerated in ascending order.
In order to be sorted, the elements of the set must all be mutually Comparable objects, or they must all be compatible with a Comparator object that is specified when the TreeSet is created.
TreeSet is implemented on top of a TreeMap, so its add( ), remove( ), and contains( ) methods all operate in relatively efficient logarithmic time.
If you do not need the sorting capability of TreeSet, however, use HashSet instead, as it is significantly more efficient.
In order for a TreeSet to operate correctly, the Comparable or Comparator comparison method must be consistent with the equals( ) method.
This class is an immutable representation of 128-bit Universal Unique Identifier, or UUID, which serves as an identifier that is (with very high probability) globally unique.
Create a UUID based on random bits with the randomUUID( ) factory method.
Create a UUID based on the MD5 hash code of an array of bytes with the nameUUIDFromBytes( ) factory method.
Or create a UUID by parsing a string with the fromString( ) factory method.
The toString( ) method converts a UUID object to a string using this standard format.
You can also create a UUID object by explicitly passing the 128 bits in the form of two long values to the UUID( ) constructor, but this option should be used only if you are intimately familiar with the relevant UUID standards.
The toString( ) and equals( ) methods define the most common operations on a UUID.
The UUID class implements the Comparable interface and defines an ordering for UUID objects.
Note, however, that the ordering does not represent any meaningful property, such as generation order, of the underlying bits.
Various accessor methods provide details about the bits of a UUID, but these details are rarely useful.
Note that the UUID class does not provide a factory method for creating a time-based UUID.
In Java 1.2, Vector has been modified to implement the List interface.
Unless the synchronized methods of the Vector class are actually needed, ArrayList is preferred in Java 1.2 and later.
The type variable E represents the type of the elements of the vector.
It is similar in features and performance to HashMap, except that it uses the capabilities of the java.lang.ref package, so that the key-to-value mappings it maintains do not prevent the key objects from being reclaimed by the garbage collector.
When there are no more references to a key object except for the weak reference maintained by the WeakHashMap, the garbage collector reclaims the object, and the WeakHashMap deletes the mapping between the reclaimed key and its associated value.
If there are no references to the value object except for the one maintained by the WeakHashMap, the value object also becomes available for garbage collection.
Thus, you can use a WeakHashMap to associate an auxiliary value with an object without preventing either the object (the key) or the auxiliary value from being reclaimed.
See HashMap for a discussion of the implementation features of this class.
See Map for a description of the methods it defines.
WeakHashMap is primarily useful with objects whose equals( ) methods use the == operator for comparison.
It is less useful with key objects of type String, for example, because there can be multiple String objects that are equal to one another and, even if the original key value has been reclaimed by the garbage collector, it is always possible to pass a String with the same value to the get( ) method.
This package includes a number of powerful utilities for multithreaded programming.
These classes achieve threadsafety without relying exclusively on synchronized methods, greatly increasing the number of threads that can safely use them concurrently.
ConcurrentHashMap implements the ConcurrentMap interface, which adds important atomic methods to the base java.util.Map interface.
In addition to these Map, List, Set, and Queue implementations, this package also defines the BlockingQueue interface.
The Future interface represents the future result of the asynchronous execution of a task.
The Executors class provides convenient factory methods for obtaining instances of these thread pool implementations.
Synchronizers A number of classes in this package are useful for synchronizing two or more concurrent threads.
This abstract class implements the submit( ), invokeAll( ), and invokeAny( ) methods of the ExecutorService interface.
It does not implement the ExecutorService shutdown methods or the crucial execute( ) method for asynchronous execution of Runnable tasks.
FutureTask implements Runnable and Future, which are first passed to the abstract execute( ) method to be run asynchronously and then returned to the caller.
See ThreadPoolExecutor for a concrete implementation, and see Executors for convenient ExecutorService factory methods.
This BlockingQueue implementation uses an array to store queue elements.
The internal array has a fixed size that is specified when the queue is created, which means that this is a bounded queue and the put( ) method blocks when the queue has no more room.
ArrayBlockingQueue orders its elements on a first-in, first-out (FIFO) basis.
If you pass true as the second argument to the ArrayBlockingQueue constructor, the queue enforces a fairness policy for blocked threads: threads blocked in put( ) or take( ) are themselves queued in FIFO order, and the thread that has been waiting the longest is served first.
This prevents thread starvation but may decrease overall throughput for the ArrayBlockingQueue.
Blocking queues are useful in many concurrent algorithms in which a producer thread puts objects onto a queue and a consumer thread removes them for some kind of processing.
The producer thread must block if a bounded queue fills up, and the consumer thread must block if no objects are available on the queue.
In addition to put( ) and take( ) methods that block indefinitely, BlockingQueue also defines timed versions of the Queue methods offer( ) and poll( ) that wait up to the specified time.
The timeout is specified as both a long and a TimeUnit constant.
A variant on this method puts an upper bound on the number of elements removed from the queue.
For bounded queues, this method provides a hint as to whether a call to put( ) will block.
A CyclicBarrier enters a broken state when one of the waiting threads is interrupted or times out.
Unlike the run( ) method of Runnable, the call( ) method of Callable can return a value and throw an Exception.
Callable is a generic type, and the type variable V represents the return type of the call( ) method.
An ExecutorService accepts Callable objects for asynchronous execution and returns a Future object representing the future result of the call( ) method.
An exception of this type is thrown to indicate that the result of a computation cannot be retrieved because the computation was canceled.
This interface combines the features of an ExecutorService with the features of a BlockingQueue.
A producer thread may submit Callable or Runnable tasks for asynchronous execution.
As each submitted task completes, its result, in the form of a Future object, becomes available to be removed from the queue by a consumer thread that calls poll( ) or take( )
This generic type declares a type variable V, which represents the result type of all tasks on the queue.
This class is a threadsafe implementation of the java.util.Map interface, and of the atomic operations added by the ConcurrentMap interface.
It is more efficient than that class, however, because it provides threadsafety without using synchronized methods that lock the entire data structure.
ConcurrentHashMap allows any number of concurrent read operations without locking.
Locking is required for updates to a ConcurrentHashMap, but the internal data structure is segmented so that only the segment being updated is locked, and reads and writes can proceed concurrently in other segments.
You can specify the number of internal segments with the concurrencyLevel argument to the constructor.
Set this to the approximate number of updater threads you expect to access the data structure.
Like Hashtable, ConcurrentHashMap does not allow null keys or values.
It provides threadsafety without using synchronized methods that would lock the entire data structure.
Note that the size( ) method must traverse the internal data structure and is therefore a relatively expensive operation for this class.
This interface extends the java.util.Map interface to add four important atomic methods.
As with the Map interface, the type variables K and V represent the types of the mapped keys and values.
There are two versions of the atomic replace( ) method.
The first checks whether the specified value is already mapped to a value.
If so, it replaces the existing mapping with the specified value and returns true.
The three-argument version of replace( ) maps the specified key to the specified new value, but only if the key is currently mapped to the specified old value.
It returns true if the replacement was made and false otherwise.
Two new indexOf( ) and lastIndexOf( ) methods are defined that specify a starting index for the search.
These provide a convenient alternative to using a subList( ) view when searching for repeated matches in a list.
All threads that call await( ) block until the countDown( ) method is invoked a specified number of times.
The required number of calls is specified when the CountDownLatch is created.
Once countDown( ) has been called the required number of times, all threads blocked in await( ) are allowed to resume, and any subsequent calls to await( ) do not block.
Note that there is no way to reset the count.
Once a CountDownLatch has “latched,” it remains in that state forever.
Create a new CountDownLatch if you need to synchronize another group of threads.
This class synchronizes a group of n threads, where n is specified to the CyclicBarrier( ) constructor.
Threads call the await( ) method, which blocks until n threads are waiting.
In the simple case, all n threads are then allowed to proceed, and the CyclicBarrier resets itself until it has another n threads blocked in await( )
More complex behavior is possible if you pass a Runnable object to the CyclicBarrier constructor.
This Runnable is a “barrier action” and when the last of the n threads invokes await( ), that method uses the thread to invoke the run( ) method of the Runnable.
This Runnable is typically used to perform some sort of coordinating action on the blocked threads.
When the run( ) method returns, the CyclicBarrier allows all blocked threads to resume.
When threads resume from await( ), the return value of await( ) is an integer that represents the order in which they called await( )
This is useful if you want to be able to distinguish between otherwise identical worker threads.
For example, you might have the thread that arrived first perform some special action while the remaining threads resume.
The reset( ) method is the only way to restore a broken barrier to its initial state.
This is difficult to coordinate properly, however, unless one controller thread is coded differently from the other threads at the barrier.
An object that implements this interface has an associated delay.
Typically, it is some kind of task, such as a Callable, that has been scheduled to execute at some future time.
If no time remains, getDelay( ) should return zero or a negative value.
This BlockingQueue implementation restricts its elements to instances of some class E that implements the Delay interface.
Elements on the queue are ordered by the amount of delay remaining.
The element whose getDelay( ) method returns the smallest value is the first to be removed from the queue.
No element may be removed, however, until its getDelay( ) method returns zero or a negative number.
This class allows two threads to rendezvous and exchange data.
This is a generic type, and the type variable V represents the type of data to be exchanged.
Each thread should call exchange( ) and pass the value of type V that it wants to exchange.
The first thread to call exchange( ) blocks until the second thread calls it.
Both threads receive as their return value the object of type V passed by the other thread.
Note that this class also defines a timed version of exchange( ) that throws a TimeoutException if no exchange occurs within the specified timeout interval.
Unlike a CountDownLatch, which is a one-shot latch, and CyclicBarrier which can be “broken,” an Exchanger may be reused for any number of exchanges.
An exception of this type is like a checked wrapper around an arbitrary exception thrown while executing a task.
The get( ) method of a Future object, for example, throws an ExecutionException if the call( ) method of a Callable throws an exception.
A variety of implementations are possible for the execute( ) method.
An implementation might simply synchronously invoke the run( ) method of the specified Runnable.
Another implementation might create and start a new thread for each Runnable object it is passed.
Another might select an existing thread from a thread pool to run the Runnable or queue the Runnable for future execution when a thread becomes available.
ExecutorService extends this interface with methods to execute Callable tasks and methods for canceling tasks.
ThreadPoolExecutor is an ExecutorService implementation that creates a configurable thread pool.
Finally, the Executors class defines a number of factory methods for easily obtaining ExecutorService instances.
This class implements the CompletionService interface, which uses an Executor object passed to its constructor for executing the tasks passed to its submit( ) method.
As these tasks complete, their result (or exception) is placed, in the form of a Future object, on an internal queue and becomes available for removal with the blocking take( ) method or the nonblocking or timed poll( ) methods.
This class is useful when you want to execute a number of tasks concurrently and want to process their results in whatever order they complete.
See Executors for a source of Executor objects to use with this class.
Each of the factory methods has a variant that allows you to explicitly specify a ThreadFactory.
ExecutorService that uses a thread pool with the specified number of threads and an unbounded queue.
When a task terminates, its thread is cached for reuse.
Cached threads are allowed to terminate if they remain unused for 60 seconds.
If the returned objects are cast to these implementing types, they can be configured (to change the thread pool size, for example)
Executors also define methods related to access control and the Java security system.
When passed a Callable in this way, it returns a new Callable that can be used later to invoke the original callable in a privileged access control context, granting it permissions that it would not otherwise have.
This interface extends Executor to add methods to obtain a Future result of the asynchronous execution of a Callable task.
It also adds methods for graceful termination or shutdown of an ExecutorService.
ThreadPoolExecutor is a useful and highly configurable implementation of this interface.
An easy way to obtain instances of this class is through the factory methods of the Executors utility class.
Note that ExecutorService is not a generic type; it does not declare any type variables.
It does have a number of generic methods, however, that use the type variable T to represent the result type of Callable and Future objects.
The submit( ) method allows you to submit a Callable<T> object to an ExecutorService for execution.
Typical ExecutorService implementations invoke the call( ) method of the Callable on another thread, and the return value (of type T) of the method is therefore not available when the call to submit( ) returns.
The run( ) method of a Runnable has no return value, so the two-argument version of submit( ) accepts a dummy return value of type T and returns a Future<T> that makes this dummy value available when the Runnable has completed running.
The other Runnable variant of the submit( ) method takes no return value and returns a Future<?> value.
The get( ) method of this Future object returns null when the Runnable is done.
It executes them and blocks until all have completed, or until an optionally specified timeout has elapsed.
Note that a Callable<T> task can complete either by returning a result of type T or by throwing an exception.
It blocks until any one of these Callable tasks has returned a value of type T and returns that value.
If all tasks throw an exception, invokeAny( ) throws an ExecutionException.
Before invokeAny( ) returns, it cancels the execution of any still-running Callable tasks.
Like invokeAll( ), invokeAny( ) has a variant with a timeout value.
ExecutorService defines several methods for gracefully shutting down the service.
Once this has occurred, the isTerminated( ) method returns true.
This interface represents the result of a computation that may not be available until some time in the future.
Future is a generic type, with a type variable V.
The key method of the Future interface is get( )
It returns the result (of type V) of the computation, blocking, if necessary, until that result is ready.
If the computation throws an exception of its own (as the Callable.call( ) method can), get( ) throws an ExecutionException wrapped around that exception.
Additionally, the timed version of the get( ) method throws a TimeoutException if the timeout elapses before the computation completes.
As noted above, the computation represented by a Future object can be canceled by calling its cancel( ) method.
This method returns true if the computation was canceled successfully, and false otherwise.
If you pass false to cancel( ), any computation that has started running is allowed to complete.
In this case, only computations that have not yet started can be canceled.
Note, however, that interrupting a thread does not guarantee that it will stop running.
This may be because it returned a value, threw an exception, or was canceled.
If isDone( ) returns true, the get( ) method does not block.
This class is a Runnable wrapper around a Callable object (or around another Runnable)
FutureTask is a generic type and the type variable V represents the return type of the wrapped Callable object.
FutureTask also implements the Future interface, which means that the get( ) method waits for the run( ) method to complete and provides access to the result (or exception) of the Callable’s execution.
The protected methods set( ) and setException( ) are invoked when the Callable returns a value or throws an exception.
Subclasses can override any of these methods to insert hooks for notification, logging, and so on.
This threadsafe class implements the BlockingQueue interface based on a linked-list data structure.
You may specify a maximum queue capacity, creating a bounded queue.
It is an unbounded queue that orders its elements according to a Comparator, or, for Comparable elements, according to their compareTo( ) method.
The head of the queue (the next element to be removed) is always the smallest element.
Note that the Iterator returned by the iterator( ) method is not guaranteed to return elements in this order.
An exception of this type is thrown by an Executor when it cannot accept a task for execution.
ThreadPoolExecutor defines several nested implementations of that handler interface that can handle the rejected task without throwing an exception of this type.
This interface defines an API for a handler method invoked by a ThreadPoolExecutor when its execute( ) method cannot accept any more Runnable objects.
This can occur when both the thread pool and the queue of waiting tasks is full, or when the ThreadPoolExecutor has been shut down.
ThreadPoolExecutor includes several predefined implementations of this interface as static member classes.
This interface extends Executor and ExecutorService to add methods for scheduling Callable or Runnable tasks for future execution on a one-time basis or a repeating basis.
The schedule( ) methods schedule a Callable or a Runnable task for one-time execution after a specified delay.
The delay is specified by a long plus a TimeUnit.
This is like a Future<V> object but also implements the Delay interface so you can call getDelay( ) to find out how much time remains before execution begins.
If you schedule( ) a Runnable object, the result is a ScheduledFuture<?>
Since a Runnable has no return value, the get( ) method of this ScheduledFuture returns null, but the cancel( ), getDelay( ), and isDone( ) methods remain useful.
This means that the Runnable runs at a fixed rate, regardless of how long each execution takes.
But it waits for this first execution (and all subsequent executions) to complete before scheduling the next execution for delay time units in the future.
Both methods return a ScheduledFuture object that you can use to cancel( ) the repeated execution of tasks.
This interface extends Future and Delayed and adds no methods of its own.
A ScheduledFuture represents a computation and the future result of that computation just as Future does, but it adds a getDelay( ) method that returns the amount of time until the computation begins.
Instances of this class are usually obtained through the static factory methods of the Executors utility class.
Also, there is no need to specify a maximumPoolSize since this configuration parameter is irrelevant with unbounded queues.
That is the time at which they first become eligible to run.
If all threads are busy with other tasks, however, eligible tasks may get queued up to run later.
This class implements semaphores, a classic thread synchronization primitive that can be used to implement mutual exclusion and wait/notify-style thread synchronization.
A Semaphore maintains some fixed number (specified when the Semaphore( ) constructor is called) of permits.
The acquire( ) method blocks until a permit is available, then decrements the number of available permits and returns.
The release( ) method does the reverse: it increments the number of permits, possibly unblocking a thread waiting in acquire( )
If you pass true as the second argument to the Semaphore( ) constructor, the semaphore treats waiting threads fairly by placing them on a FIFO queue in the order they called acquire( ) and granting permits to the threads in this order.
This BlockingQueue implementation is the degenerate case of a bounded queue with a capacity of zero.
Every call to put( ) blocks until a corresponding call to take( ), and vice versa.
You can think of this as an Exchanger that does only a one-way exchange.
The iterator( ) method returns an Iterator for which the hasNext( ) method returns false.
An instance of this interface is an object that creates Thread objects to run Runnable objects.
A number of the factory methods of the Executors utility class rely on ThreadPoolExecutor and accept a ThreadFactory argument.
This class implements the ExecutorService interface to execute tasks using a highly configurable thread pool.
The easiest way to instantiate this class is through the static factory methods of the Executors class.
If you want a more highly configured thread pool, you can instantiate it directly.
Many of these parameters may also be queried and adjusted after the executor has been created through various ThreadPoolExecutor accessor methods.
The most important configuration parameters specify the size of the thread pool, and the queue that the executor uses to hold tasks that it cannot currently run.
If corePoolSize threads have already been created, newly submitted tasks are placed on the work queue.
As these core threads finish the tasks they are executing, they take( ) a new task from the work queue.
It may be any BlockingQueue object and the behavior of the thread pool depends strongly on the behavior of the queue you specify.
If the work queue becomes empty, it is inefficient to leave all the core threads sitting idly waiting for work.
Threads are terminated if they are idle for more than the “keep alive” time.
You specify this time with the keepAliveTime parameter and a TimeUnit constant.
If the work queue fills up, the maximumPoolSize parameter comes into play.
ThreadPoolExecutor prefers to maintain corePoolSize threads but allows this number to grow up to maximumPoolSize.
A new thread is created only when the workQueue is full.
If you specify an unbounded work queue, maximumPoolSize is irrelevant because the queue never fills up.
If on the other hand you specify a SynchronousQueue (which is always full), if none of the existing threads are waiting for a new task, a new thread is always created (up to the maximumPoolSize limit)
If a ThreadPoolExecutor has already created the maximum number of threads and its work queue is full, it must reject any newly submitted tasks.
The four inner classes of this class are implementations of four handlers that address this case.
The final way that you can customize a ThreadPoolExecutor is to pass ThreadFactory to the constructor or to the setThreadFactory( ) method.
If the ThreadPoolExecutor has been shut down, the Runnable is simply discarded instead of being run.
Otherwise, it discards the oldest pending task that has not run and tries again to execute( ) the rejected task.
An exception of this type is thrown by timed methods to indicate that the specified timeout has elapsed.
Other timed methods are able to indicate their timeout status in a boolean or other return value.
The constants defined by this enumerated type represent granularities of time.
TimeUnit defines conversion methods that convert values expressed in one unit to values in another unit.
More interestingly, it defines convenient alternatives to Thread.sleep( ), Thread.join( ), and Object.wait( )
This package includes classes that provide atomic operations on boolean, integer, and reference values.
Instances of the classes defined here have the properties of volatile fields but also add atomic operations like the canonical compareAndSet( ), which verifies that the field holds an expected value, and, if it does, sets it to a new value.
The classes also define a weakCompareAndSet( ) method that may be more efficient than compareAndSet( ) but may also fail to set the value even when the field holds the expected value.
The “Array” classes provide atomic access to arrays of values and provide volatile access semantics for array elements, which is not possible with the volatile modifier itself.
The “FieldUpdater” classes use reflection to provide atomic operations on a named volatile field of an existing class.
These classes can be useful in concurrent algorithms that detect concurrent updates with version numbering, for example.
Most implementations of this package rely on low-level atomic instructions in the underlying CPU and perform atomic operations without the overhead of locking.
In addition to the get( ) and set( ) iterators, it provides atomic compareAndSet( ), weakCompareAndSet( ), and getAndSet( ) operations.
Access the int value with the get( ) method and the various methods inherited from Number.
You can set the value with the set( ) method or through various atomic methods.
In addition to the basic compareAndSet( ) and weakCompareAndSet( ) methods, this class defines methods for atomic pre-increment, post-increment, pre-decrement and post-decrement operations as well as generalized addAndGet( ) and getAndAdd( ) methods.
It provides threadsafe access to the array elements, treating each as if it was a volatile field, and defines atomic operations on them.
The methods of this class are like those of AtomicInteger, except that each has an additional parameter that specifies the array index.
Create an AtomicIntegerArray by specifying the desired array length or an actual int[ ] from which initial values can be copied.
Obtain an instance of this class with the newUpdater( ) factory method.
Pass the name of the field (which must have been declared volatile int) to be updated and the class that it is defined within to this factory method.
This is a generic type, and the type variable T represents the type whose volatile int field is being updated.
This threadsafe class holds a mutable long value and defines atomic operations on that value.
It behaves just like AtomicInteger, with the substitution of long for int.
This threadsafe class provides atomic operations for an array of long values.
This threadsafe class holds a mutable reference to an object of type V and also holds a mutable boolean value or “mark.” It defines atomic operations and volatile access semantics for the reference and the mark.
The set( ) method unconditionally sets the reference and mark value.
The get( ) method queries both, returning the reference as its return value, and storing the current value of the mark in element 0 of the specified boolean array.
The reference and mark can also be queried individually (and nonatomically) with getReference( ) and isMarked( )
The atomic compareAndSet( ) and weakCompareAndSet( ) methods take expected and new values for both the reference and the mark, and neither is set to its new value unless both match their expected values.
Like weakCompareAndSet( ), this method may fail spuriously, even if the reference does equal the expected value.
Repeated invocation eventually succeeds, however, as long as the expected value is correct, and other threads are not continuously changing the reference value.
This threadsafe class holds a mutable reference to an object of type V, provides volatile access semantics, and defines atomic operations for manipulating that value.
This threadsafe class holds an array of elements of type E.
It provides volatile access semantics for these array elements and defines atomic operations for manipulating them.
Its methods are like those of AtomicReference with the addition of a parameter that specifies the array index of the desired element.
This threadsafe class holds a mutable reference to an object of type V and also holds a mutable int value or “stamp.” It defines atomic operations and volatile access semantics for the reference and the stamp.
This package defines Lock and associated Condition interfaces as well as concrete implementations (such as ReentrantLock) that provide an alternative to locking with synchronized blocks and methods and to waiting with the wait( ), notify( ), and notifyAll( ) methods of Object.
Although Lock and Condition are somewhat more complex to use than the built-in locking, waiting, and notification mechanisms of Object, they are also more flexible.
Lock, for example, does not require that locks be block-structured and enables algorithms such as “hand-over-hand locking” for traversing linked data structures.
A thread waiting to acquire a Lock can time out or be interrupted, which is not possible with synchronized locking.
Also, more than one Condition can be associated with a given Lock, which is simply not possible with Object-based locking and waiting.
Interfaces public interface Condition; public interface Lock; public interface ReadWriteLock;
Subclasses must define tryAcquire( ), tryRelease( ), tryAcquireShared( ), tryReleaseShared( ), and isHeldExclusively.
Obtain a Condition with the newCondition( ) method of Lock.
The no-argument version of await( ) is the simplest: it blocks until the thread is signaled or interrupted.
The other three waiting methods are timed waits: they all wait until signaled, interrupted, or until the specified time elapses.
It returns zero or a negative number if the timeout elapses.
If it wakes up because of a signal (or because of a spurious wakeup), it returns an estimate of the time remaining in the timeout.
If it turns out that the thread needs to continue waiting, this return value can be used as the new timeout value.
The signal( ) and signalAll( ) methods are just like the notify( ) and notifyAll( ) methods of Object.
Locking considerations apply to the use of a Condition object just as they apply to the use of the wait( ) and notify( ) methods of Object.
Before a thread can call any of the waiting or signaling methods of a Condition, it must hold the Lock associated with the condition.
When the thread begins waiting, it automatically relinquishes the Lock, and when it awakes because of a signal, timeout, or interrupt, it must reacquire the lock before it can proceed.
A thread is guaranteed to hold the lock when it returns from one of the waiting methods.
Threads waiting on a Condition may wake up spuriously, just as they may when waiting on an Object.
Therefore, calls to wait on a Condition are typically written in the form of a loop so that the desired condition is retested when the thread wakes up.
This interface represents a flexible API for preventing thread concurrency with locking.
The simplest method is lock( ) which blocks indefinitely and uninterruptibly until the lock is acquired.
The no-argument version of tryLock( ) acquires the lock and returns true if the lock is currently available or returns false without blocking if the lock is unavailable.
Once a Lock has been acquired, no other thread can acquire it until it is released with the unlock( ) method.
In order to ensure that locks are always released, even in the presence of unanticipated exceptions, it is typical to begin a try block immediately after acquiring the lock and to call unlock( ) from the associated finally clause.
Obtain a Condition object associated with a Lock by calling newCondition( )
See ReentrantLock for a concrete implementation of the Lock interface.
This class provides a low-level alternative to the deprecated methods Thread.suspend( ) and Thread.resume( )
The park( ), parkNanos( ), and parkUntil( ) methods suspend, or park, the thread until it is unparked by another thread with unpark( ), or until it is interrupted by another thread, or until the specified time elapses.
Any call to these parking methods may return spuriously, so it is important to call park( ) in a loop that can repark the thread if it should not have resumed.
Note that while the parking methods affect the current thread, the unpark( ) method affects the thread you specify.
If the specified thread is not parked, the next time that thread calls one of the park( ) methods, it returns immediately instead of blocking.
This interface represents a pair of Lock objects with special locking behavior that is useful for concurrent algorithms in which reader threads frequently access a data structure and writer threads only infrequently modify the structure.
The Lock returned by readLock( ) may be locked by multiple threads at the same time as long as no thread has the writeLock( ) locked.
This class implements the Lock interface and adds instrumentation methods to determine what thread currently holds the lock, to return the number of threads waiting to acquire the lock or waiting on an associated Condition, and to test whether a specified thread is waiting to acquire the lock.
The name of this class includes the term “reentrant” because the thread that holds the lock can call any of the locking methods again, and they return immediately without blocking.
A “fair” lock may be created by passing true to the ReentrantLock( ) constructor.
If you do this, the lock will always be granted to the thread that has been waiting for it the longest.
The locks returned by the readLock( ) and writeLock( ) methods are instances of the inner classes ReadLock and WriteLock.
Any number of threads can acquire the read lock as long as no thread holds or is attempting to acquire the write lock.
When a thread attempts to acquire the write lock, no new read locks are granted.
When all existing readers have relinquished the lock, the writer acquires the lock, and no reads are allowed until the writer has relinquished it.
A thread that holds the write lock may downgrade to a read lock by acquiring the read lock and then relinquishing the write lock.
Because the read lock is not exclusive, it cannot have a Condition associated with it.
Any number of threads can acquire the lock as long as the corresponding WriteLock is not held.
This lock can be acquired only when all holders of the corresponding ReadLock have relinquished the locks.
While this lock is held, no other thread may acquire either this lock or the corresponding ReadLock.
The java.util.jar package contains classes for reading and writing Java archive, or JAR, files.
A JAR file is nothing more than a ZIP file whose first entry is a specially named manifest file that contains attributes and digital signatures for the ZIP file entries that follow it.
Many of the classes in this package are relatively simple extensions of classes from the java.util.zip package.
The easiest way to read a JAR file is with the random-access JarFile class.
This class allows you to obtain the JarEntry that describes any named file within the JAR archive.
It also allows you to obtain an enumeration of all entries in the archive and an InputStream for reading the bytes of a specific JarEntry.
Each JarEntry describes a single entry in the archive and allows access to the Attributes and the digital signatures associated with the entry.
The JarFile also provides access to the Manifest object for the JAR archive; this object contains Attributes for all entries in the JAR file.
Attributes is a mapping of attribute name/value pairs, of course, and the inner class Attributes.Name defines constants for various standard attribute names.
This class requires to you read each entry of the file sequentially, however.
JarOutputStream allows you to write out a JAR file sequentially.
This class is a java.util.Map that maps the attribute names of a JAR file manifest to arbitrary string values.
Thus, this class uses Attributes.Name as the type of attribute names, in addition to the more general String class.
Although you can create your own Attributes objects, you more commonly obtain Attributes objects from a Manifest.
This class represents the name of an attribute in an Attributes object.
It defines constants for the various standard attribute names used in JAR file manifests.
Attribute names can contain only ASCII letters, digits, and the hyphen and underscore characters.
JarEntry objects can be read from a JAR file with JarFile or JarInputStream, and they can be written to a JAR file with JarOutputStream.
Use getAttributes( ) to obtain the Attributes for the entry.
In Java 5.0, this digital signature information may be more conveniently retrieved as an array of CodeSigner objects.
Signals an error while reading or writing a JAR file.
This class represents a JAR file and allows the manifest, file list, and individual files to be read from the JAR file.
Create a JarFile by specifying a filename or File object.
If you do not want JarFile to attempt to verify any digital signatures contained in the JarFile, pass an optional boolean argument of false to the JarFile( ) constructor.
As of Java 1.3, temporary JAR files can be automatically deleted when they are closed.
Once you have created a JarFile object, obtain the JAR Manifest with getManifest( )
Get the JarEntry for a specified file in the JAR file with getJarEntry( )
To read the contents of a specific entry in the JAR file, obtain the JarEntry or ZipEntry object that represents that entry, pass it to getInputStream( ), and then read until the end of that stream.
JarFile does not support the creation of new JAR files or the modification of existing files.
This class allows a JAR file to be read from an input stream.
To create a JarInputStream, simply specify the InputStream from which to read.
If you do not want the JarInputStream to attempt to verify any digital signatures contained in the JAR file, pass false as the second argument to the JarInputStream( ) constructor.
The JarInputStream( ) constructor first reads the JAR manifest entry, if one exists.
The manifest must be the first entry in the JAR file.
Then, call a read( ) method (including the inherited versions) to read the contents of that entry.
When the stream reaches the end of file, call getNextJarEntry( ) again to start reading the next entry in the file.
When all entries have been read from the JAR file, getNextJarEntry( ) and getNextEntry( ) return null.
This class can write a JAR file to an arbitrary OutputStream.
Create a JarOutputStream by specifying the stream to write to and, optionally, the Manifest object for the JAR file.
The JarOutputStream( ) constructor starts by writing the contents of the Manifest object into an appropriate JAR file entry.
It is the programmer’s responsibility to ensure that the contents of the JAR entries written subsequently match those specified in the Manifest object.
This class provides no explicit support for attaching digital signatures to entries in the JAR file.
Then, call any of the inherited write( ) methods to write the contents of the entry to the stream.
When that entry is finished, call putNextEntry( ) again to begin writing the next entry.
When you have written all JAR file entries in this way, call close( )
Before writing any entry, you may call the inherited setMethod( ) and setLevel( ) methods to specify how the entry should be compressed.
This class represents the manifest entry of a JAR file.
You can edit the contents of the Manifest by adding, deleting, or editing entries in the Map.
Configure the packer before using it by setting properties in the Map returned by the properties( ) method.
The constants defined by this class represent the names (and in some cases values) of properties that can be set.
Pack a JAR file by passing JarFile or JarInputStream to a pack( ) method along with the byte output stream to which the packed representation should be written.
You can monitor the progress of the packer engine by querying the PROGRESS property in the properties( ) map.
Before using an unpacker, you may configure it by setting properties in the Map returned by the properties( ) method.
Unpack a JAR file with the unpack( ) method, specifying a File or stream of packed bytes.
Monitor the progress of the unpacker by querying the PROGRESS key in the Map returned by properties( )
An application generates log messages by calling various methods of a Logger object.
The content of a log message (with other pertinant details such as the time and sequence number) is encapsulated in a LogRecord object generated by the Logger.
Concrete subclasses of Handler support destinations such as files and sockets.
Most Handler objects have an associated Formatter that converts a LogRecord object into the actual text that is logged.
The subclasses SimpleFormatter and XMLFormatter produce simple plain-text log messages and detailed XML logs respectively.
The Level class defines a type-safe enumeration of defined levels.
Logger and Handler objects both have an associated Level, and discard any log messages whose severity is less than that specified level.
In addition to this level-based filtering, Logger and Handler objects may also have an associated Filter object which may be implemented to filter log messages based on any desired criteria.
Applications that desire complete control over the logs they generate can create a Logger object, along with Handler, Formatter and Filter objects that control the destination, content, and appearance of the log.
Simpler applications need only to create a Logger for themselves, and can leave the rest to the LogManager class.
LogManager reads a systemwide configuration file (or a configuration class) and automatically directs log messages to a standard destination (or destinations) for the system.
In Java 5.0, LoggingMXBean defines an interface for monitoring and management of the logging facility through the javax.management packages (which are beyond the scope of this book)
This Handler subclass formats LogRecord objects and outputs the resulting string to the System.err output stream.
The table below lists these properties, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
An important feature of the Logging API is that the logging methods called by applications never throw exceptions: it is not reasonable to expect programmers to nest all their logging calls within try/catch blocks, and even if they did, there is no useful way for an application to recover from an exception in the logging subsystem.
Since handler classes such as FileHandler are inherently subject to I/O exceptions, the ErrorManager provides a way for a handler to report an exception instead of simply discarding it.
All Handler objects have an instance of ErrorManager associated with them.
If an exception occurs in the handler, it passes the exception, along with a message and one of the error code constants defined by ErrorManager to the error( ) method.
You can of course define subclasses of ErrorManager that override error( ) to provide some other reporting mechanism.
If you do this, register an instance of your custom ErrorManager by calling the setErrorManager( ) method of your Handler.
This Handler subclass formats LogRecord objects and outputs the resulting strings to a file or to a rotating set of files.
Arguments passed to the FileHandler( ) constructor specify which file or files are used, and how they are used.
The substitutions performed to convert this pattern to a filename are described below.
If count is set to greater than one, then when a log file reaches this maximum, FileHandler closes it, renames it, and then starts a new log with the original filename.
The pattern argument is the most important of these: it specifies which file or files the FileHandler will write to.
FileHandler performs the following substitutions on the specified pattern to convert it to a filename:
This means that you can always use a forward slash in your patterns, even on Windows filesystems that use backward slashes.
Older files are similarly renamed, with their generation number being incremented.
When the number of log files reaches the number specifed by count, then the oldest file is deleted to make room for the new one.
The table below lists these arguments and properties, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
This interface defines the method that a class must implement if it wants to filter log messages for a Logger or Handler class.
It should return false if the LogRecord should be filtered out not appear in any destination log.
Note that both Logger and Handler provide built-in filtering based on the severity level of the LogRecord.
This Filter interface exists to provide a customized filtering capability.
A Formatter object is used by a Handler to convert a LogRecord to a String prior to logging it.
Most applications can simply use one one of the pre-defined concrete subclasses: SimpleFormatter or XMLFormatter.
Applications requiring custom formatting of log messages will need to subclass this class and define the format( ) method to perform the desired conversion.
A Handler takes LogRecord objects from a Logger and, if their severity level is high enough, formats and publishes them to some destination (a file or socket, for example)
These are property getter and setter methods to specify the severity Level of logging messages to be handled, an optional Filter, a Formatter to convert log messages from LogRecord objects to text, a text encoding for the output text, and an ErrorManager to handle any exceptions that arise during log output.
Subclass-specific defaults for each of these properties are typically defined as properties of LogManager and are read from a system-wide logging configuration file.
In the simplest uses of the Logging API, a Logger sends it log messages to one or more handlers defined by the LogManager class for its “root logger”
In this case there is no need for the application to ever instantiate or use a Handler directly.
Applications that want custom control over the destination of their logs create and configure an instance of a Handler subclass, but never need to call its publish( ), flush( ) or close( ) methods directly: that is done by the Logger.
This class defines constants that represent the seven standard severity levels for log messages plus constants that turn logging off and enable logging at any level.
When logging is enabled at one severity level, it is also enabled at all higher levels.
The seven level constants, in order from most severe to least severe are: SEVERE, WARNING, INFO, CONFIG, FINE, FINER, and FINEST.
The constant ALL enables logging of any message, regardless of its level.
Note that these constants are all Level objects, rather than integers.
Application code should rarely, if ever, need to use any of the methods of this class: instead they can simply use the constants it defines.
Logger does not have a public constructor, but there are several ways to obtain a Logger object to use in your code:
Typically, applications call the static getLogger( ) method to create or lookup a named Logger within a hierarchy of named loggers.
Loggers have dot-separated hierarchical names, which should be based on the name of the class or package that uses them.
Loggers obtained in this way inherit their logging level, resource bundle (for localization), and Handler objects from their ancestors in the hierarchy and, ultimately, from the root Logger defined by the global LogManager.
A Logger created by this method has the LogManager root logger as its parent, and inherits the logging level and handlers of that root logger.
Finally, the static Logger.global field refers to a pre-defined Logger named “global”; programmers may find this pre-defined Logger convenient during the early stages of application development, but it should not be used in production code.
Once a suitable Logger has been obtained, there are a variety of methods that can be used to create a log message:
The log( ) methods log a specified message at the specified level, with optional parameters that can be used in message localization.
These methods examine the call stack and make an attempt to determine the class and method name from which the method is emitted.
Because of code optimization and just-in-time compilation techniques, however, they may not always be able to determine this information.
The logp( ) (“log precise”) methods are like the log( ) methods but allow you to explicitly specify the name of the class and method that are emitting the log message.
The logrb( ) methods are like the logp( ) methods, but additionally take the name of a resource bundle to use for localizing the message.
Note that there are variants of entering( ) and exiting( ) that allow specification of method arguments and return values.
Finally, Logger defines a set of easy-to-use convenience methods for logging a simple message at a specific logging level.
These methods have the same names as the logging levels: severe( ), warning( ), info( ), config( ), fine( ), finer( ), finest( )
A Logger has an associated logging Level, and discards any log messages with a severity lower than this.
The severity level is initialized from the system configuration file, which is usually the desired behavior.
If level-based filtering of log messages is not sufficient, you can associate a Filter with your Logger by calling setFilter.
If you do this, any log messages rejected by the Filter will be discarded.
A Logger sends its log messages to any Handler objects that have been registered with addHandler( )
Call getHandlers( ) to obtain an array of all registered handlers, and call removeHandler( ) to de-register a handler.
By default, all log messages are also sent to the handlers of the parent logger and any other ancestor loggers.
Since all named and anonymous loggers have the LogManager root logger as a parent or ancestor, all loggers by default send their log messages to the handlers defined in the system logging configuration file.
If a resource bundle is specified for the Logger or for a specific log message, then the message argument to the various logging methods is treated not as a literal message but instead as a localization key for which a localized version is to be looked up in the resource bundle.
Note, however that this localization and formatting is not performed by the Logger itself: instead, it simply stores the ResourceBundle and parameters in the LogRecord.
It is the Formatter associated with the output Handler object that actually performs the localization.
All the methods of this class are threadsafe and do not require external synchronization.
This interface defines the API for the javax.management “management bean” for the logging system.
The methods of this class allow the monitoring of all registered loggers and their logging level and allow management to change the logging level of any named logger.
The methods in this package that throw SecurityException all require a LoggingPermission named “control” in order to run.
System adminstrators configuring security policies may need to be familiar with it.
This class handles the important behind-the-scenes details that makes the Logging API work.
Typical applications can make use of logging without ever having to use this class explicitly.
Although its API is not commonly used by application programmers, it is still useful to understand the LogManager class, so it is described in detail here.
There is a single global instance of LogManager, which is obtained with the static getLogManager( ) method.
By default, this global log manager object is an instance of the LogManager class itself.
The most important purpose of the configuration file is to specify a set of Handler objects to which all log messages are sent.
This is done by setting the handlers property in the file to a space-separated list of Handler class names.
The LogManager will load the specified classes, and instantiate each one (using the default no-arg constructor), and then register those Handler objects on the root Logger, where they are inherited by all other loggers.
The configuration file may also contain property name that are formed by appending “.level” to the name of a logger.
The value of any such property is taken as the name of a logging Level for the named Logger.
When the named logger is created and registered with the LogManager (described below) its logging level is automatically set to the specified level.
An application or any custom Handler or Formatter subclass or Filter implementation can read its own properties from the logging configuration file with the getProperty( ) method of LogManager.
This is a useful way to provide customizability for logging-related classes.
In addition to managing the configuration file properties, a second purpose of LogManager is to maintain a tree of Logger objects organized into a hierarchy based on their dot-separated hierarchical names.
The addLogger( ) method registers a new Logger object with the LogManager and inserts it into the tree.
The getLogger( ) method of LogManager finds and returns a named Logger object within the tree.
Use getLoggerNames( ) to obtain an Enumeration of the names of all registered loggers.
At the root of the tree is a root logger, created by the LogManager, and initialized with default Handler objects specified in the logging configuration file as described above.
This root logger has no name, and you can obtain a reference to it by passing the empty string to the getLogger( ) method.
When the LogManager determines the position of a logger within the tree of loggers, it calls the setParent( ) method of the newly-registered Logger to tell it who its parent is.
This is important because, by default, loggers inherit their logging level and handlers from their parent.
When they are created, however, their parent is set to the root logger of the LogManager.
For this reason, anonymous loggers inherit the default handlers specified in the logging configuration file.
The readConfiguration( ) methods are used to force the LogManager to re-read the system configuration file, or to read a new configuration file from the specified stream.
Both methods also first invoke the reset( ) method which discards the properties of the current configuration file, removes and closes all handlers for all loggers, and sets the logging level of all loggers to null, except for the root logger’s logging level, which it sets to Level.INFO.
It is unlikely that you would ever want to invoke reset( ) yourself.
A number of LogManager methods throw a SecurityException if the caller does not have appropriate permissions.
You can use checkAccess( ) to test whether the current calling context has the required LoggingPermission named “control”
All LogManager methods can be safely used by multiple threads.
Instances of this class are used to represent log messages as they are passed between Logger, Handler, Filter and Formatter objects.
LogRecord defines a number of JavaBeans-type property getter and setter methods.
The values of the various properties encapsulate all details of the log message.
The LogRecord( ) constructor takes arguments for the two most important properties: the log level and the log message (or localization key)
The constructor also initializes the millis property to the current time, the sequenceNumber property to a unique (within the VM) value that can be used to compare the order of two log messages, and the threadID property to a unique identifier for the current thread.
All other properties of the LogRecord are left uninitialized with their default null values.
A MemoryHandler stores LogRecord objects in a fixed-sized buffer in memory.
When the buffer fills up, it discards the oldest record one each time a new record arrives.
It maintains a reference to another Handler object, and whenever the push( ) method is called, or whenver a LogRecord arrives with a level at or higher than the pushLevel threshold, it “pushes” all of buffered LogRecord objects to that other Handler object, which typically formats and outputs them to some appropriate destination.
Because MemoryHandler never outputs log records itself, it does not use the formatter or encoding properties inherited from its superclass.
The table below lists these properties, as well as the target, size, and pushLevel constructor arguments, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
This Formatter subclass converts a LogRecord object to a human-readable log message that is typically one or two lines long.
This Handler subclass formats LogRecord objects and outputs the resulting strings to a network socket.
The table below lists these properties, as well as the host and port arguments, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
It exists primarily to serve as the common superclass of ConsoleHandler, FileHandler, and SocketHandler.
This Formatter subclass converts a LogRecord to an XML-formatted string.
Note however, that if an application terminates abnormally, the logging facility may be unable to terminate the log file with the closing <log> tag.
Some will also use the event objects and listener interfaces defined by this package, and some may need to explicitly catch the types of exceptions defined by this package.
To use the Preferences class, first use a static method to obtain an appropriate Preferences object or objects, and then use a get( ) method to query a preference value or a put( ) method to set a preference value.
This class implements all the abstract methods of Preferences on top of a smaller set of abstract methods.
Programmers creating a Preferences implementation (or “service provider”) can subclass this class and need define only the nine methods whose names end in “Spi”
The most commonly used methods of the Preferences class do not throw this exception, and are guaranteed to succeed even if the implementation’s preferences data is not available.
Note that although this class inherits the Serializable interface, implementations are not actually required to be serializable.
Note that although this class inherits the Serializable interface, implementations are not actually required to be serializable.
Protected Instance Fields protected final Object lock; protected boolean newNode;
A NodeChangeEvent object is passed to the methods of any NodeChangeListener objects registered on a Preferences object when a child Preferences node is added or removed.
This parent Preferences object is the one on which the NodeChangeListener was registered.
Although this class inherits the Serializable interface, it is not actually serializable.
This interface defines the methods that an object must implement if it wants to be notified when a child preferences node is added to or removed from a Preferences object.
If the preference value was added or modified, getNewValue( ) returns that value.
Although this class inherits the Serializable interface, it is not actually serializable.
This interface defines the method that an object must implement if it wants to be notified when a preference key/value pair is added to, removed from, or changed in a Preferences object.
A Preferences object represents a mapping between preference names, which are casesensitive strings, and corresponding preference values.
Although all preference values are stored as strings, various convenience methods whose names begin with “get” and “put” exist to convert preference values of type boolean byte[ ], double, float, int, and long to and from strings.
The remove( ) method allows you to delete a named preference altogether, and clear( ) deletes all preference values stored in a Preferences object.
The keys( ) method returns an array of strings that specify the names of all preferences in the Preferences object.
Note that all the get( ) methods of this class require a default value to be specified.
They return this default if no value has been stored for the named preference, or if the backing store is unavailable for any reason.
The Preferences class is completely independent of the underlying implementation, except that it enforces an.
To obtain a Preferences object for use in your application, you must must use one of the static methods described below.
Each Preferences object is a node in a hierarchy of Preferences nodes.
There are two distinct hierarchies: one stores user-specific preferences, and one stores system-wide preferences.
All Preferences nodes (in either hierarchy) have a unique name and use the same naming convention that Unix filesystems use.
Applications (and classes) may store their preferences in a Preferences node with any name, but the convention is to use a node name that corresponds to the package name of the application or class, with all “.” characters in the package name converted to “/” characters.
Preferences defines static methods that you can use to obtain the Preferences objects your application requires.
If you want to navigate the entire tree of preferences nodes (which most applications never need to do) call systemRoot( ) and userRoot( ) to obtain the root node of the two hierarchies, and then use the node( ) method to look up child nodes of those roots.
Various Preferences methods allow you to traverse the preferences hierarchies.
If the specified node name begins with a slash, it is an absolute name and is interpreted relative to the root of the hierarchy.
Otherwise, it is a relative name and is interpreted relative to the Preferences object on which node( ) was called.
Finally, isUserNode( ) allows you to determine whether a Preferences object is part of the user or system hierarchies.
Many applications will simply read their preference values once at startup.
Applications that are interested in changes to the Preferences hierarchy itself can register a NodeChangeListener.
Call flush( ) to force any preference changes to this Preferences node (and any of its descendants in the hierarchy) to be stored persistantly.
Note that it is not necessary to call flush( ) before an application terminates: all preferences will eventually be made persistant.
More than one application (within more than one Java virtual machine) may set preference values in the same Preferences node at the same time.
Call sync( ) to ensure that future calls to get( ) and its related convenience methods retrieve current preference values set by this or other virtual machines.
Note that the flush( ) and sync( ) operations are typically much more expensive than get( ) and put( ) operations, and applications do not often need to use them.
Preferences implementations ensure that all the methods of this class are thread safe.
If multiple threads or multiple VMs write store the same preferences concurrently, their values may overwrite one another, but the preference data will not be corrupted.
Note that, for simplicity, Preferences does not define any way to set multiple preferences in a single atomic transaction.
If you need to ensure atomicity for multiple preference values, define a data format that allows you to store all the requisite values in a single string, and set and query those values with a single call to put( ) or get( )
The contents of a Preferences node, or of a node and all of its descendants may be exported as an XML file with exportNode( ) and exportSubtree( )
The static importPreferences( ) method reads an exported XML file back into the preferences hierarchy.
These methods allow backups to be made of preference data, and allow preferences to be transferred between systems or between users.
The PreferencesFactory interface defines the factory methods used by the static methods of the Preferences class to obtain the root Preferences nodes for user-specific and system-wide preferences hierarchies.
An implementation of the preferences API for a specific back-end data store must include an implementation of this interface that works with that data store.
This small package provides a facility for textual pattern matching with regular expressions.
Pattern objects represent regular expressions, which are specified using a syntax very close to the one used by the Perl programming language.
In Java 5.0, the MatchResult interface represents the result of a match.
Applications with simple pattern matching needs can use these convenience methods and may never have to directly use the Pattern or Matcher classes.
Classes public final class Matcher implements MatchResult; public final class Pattern implements Serializable;
Obtain a Matcher by passing the character sequence to be matched to the matcher( ) method of the desired Pattern object.
You can also reuse an existing Matcher object with a new character sequence (but the same Pattern) by passing a new CharSequence to the matcher’s reset( ) method.
In Java 5.0, you can use a new Pattern object on the current character sequence with the usePattern( ) method.
Once you have created or reset a Matcher, there are three types of comparisons you can perform between the regular expression and the character sequence.
All three comparisons operate on the current region of the character sequence.
In Java 5.0, however, you can set the bound of the region with region( )
The simplest type of comparison is the matches( ) method.
It returns true if the pattern matches the complete region of the character sequence, and returns false otherwise.
The lookingAt( ) method is similar: it returns true if the pattern matches the complete region, or if it matches some subsequence at the beginning of the region.
If the pattern does not match the start of the region, lookingAt( ) returns false.
The find( ) method, on the other hand, has neither of these requirements: it returns true if the pattern matches any part of the region.
As will be described below, find( ) has some special behavior that allows it to be used in a loop to find all matches in the text.
If matches( ), lookingAt( ), or find( ) return true, then several other Matcher methods can be used to obtain details about the matched text.
The MatchResult interface defines the start( ), end( ) and group( ) methods that return the starting position, the ending position and the text of the match, and of any matching subexpressions within the Pattern.
Calling MatchResult methods on a Matcher returns results from the most recent match.
If you want to store these results, call toMatchResult( ) to obtain an indepedent, immutable MatchResult object whose methods can be queried later.
The no-argument version of find( ) has special behavior that makes it suitable for use in a loop to find all matches of a pattern within a region.
The first time find( ) is called after a Matcher is created or after the reset( ) method is called, it starts it search at the beginning of the string.
If it finds a match, it stores the start and end position of the matched text.
If reset( ) is not called in the meantime, then the next call to find( ) searches again but starts the search at the first character after the match: at the position returned by end( )
If the previous call to find( ) matched the empty string, then the next call begins at end( )+1 instead.
In this way, it is possible to find all matches of a pattern within a string simply by calling find( ) repeatedly until it returns false indicating that no match was found.
After each repeated call to find( ) you can use the MatchResult methods to obtain more information about the text that matched the pattern and any of its subpatterns.
It then returns a string that is the character sequence with the matched text replaced with the specified replacement string.
The replacement string passed to replaceFirst( ) and replaceAll( ) is not always replaced literally.
If the replacement contains a dollar sign followed by an integer that is a valid group number, then the dollar sign and the number are replaced by the text that matched the numbered group.
If you want to include a literal dollar sign in the replacement string, preceed it with a backslash.
In Java 5.0, you can use the static quoteReplacement( ) method to properly quote any special characters in a replacement string so that the string will be interpreted literally.
However, Matcher also defines lower-level methods that you can use to do a custom search-and-replace operation in conjunction with calls to find(), and build up a modified string in a StringBuffer.
In order to understand this search-andreplace procedure, you must know that a Matcher maintains a “append position”, which starts at zero when the Matcher is created, and is restored to zero by the reset( ) method.
The appendReplacement( ) method is designed to be used after a successful call to find( )
It copies all the text between the append position and the character before the start( ) position for the last match into the specified string buffer.
Then it appends the specified replacement text to that string buffer (performing the same substitutions that replaceAll( ) does)
Finally, it sets the append position to the end( ) of the last match, so that a subsequent call to appendReplacement( ) starts at a new character.
When find( ) cannot find another match and returns false, you should complete the replacement operation by calling appendTail( ): this method copies all text between the end( ) position of the last match and the end of the character sequence into the specified StringBuffer.
It erases any saved information about the last match, and restores the Matcher to its initial state so that subsequent calls to find( ) and appendReplacement( ) start at the begining of the character sequence.
The oneargument version of reset( ) also allows you to specify an entirely new character sequence to match against.
It is important to understand that several other Matcher methods call reset( ) themselves before they perform their operation.
They are: matches( ), lookingAt( ), the one-argument version of find( ), replaceAll( ), and replaceFirst( )
Prior to Java 5.0, the region of the input text that a Matcher operates on is the entire character sequence.
In Java 5.0, you can define a different region with the region( ) method, which specifies the position of the first character in the region and the position of the first character after the end of the region.
Matcher is not threadsafe, and should not be used by more than one thread concurrently.
This interface represents the results of a regular expression matching operation performed by a Matcher.
Matcher implements this interface directly, and you can use the methods defined here to obtain the results of the most recent match performed by a Matcher.
You can also save those most recent match results in a separate immutable MatchResult object by calling the toMatchResult( ) method of the Matcher.
The no-argument versions of the start( ) and end( ) method return the index of the first character that matched the pattern and the index of the last character that matched plus one (the index of the first character following the matched text), respectively.
If this occurs, end( ) returns the same value as start( )
The no-argument version of group( ) returns the text that matched the pattern.
If the matched Pattern includes capturing subexpressions within parentheses, the other methods of this interface provide details about the text that matched each of those subexpressions.
Pass a group number to start( ), end( ), or group( ) to obtain the start, end, or text that matched the specified group.
When there are nested groups, their ordering is based on the position of the opening left parenthesis that begins the group.
It has no public constructor: obtain a Pattern by calling one of the static compile( ) methods, passing the string representation of the regular expression, and an optional bitmask of flags that modify the behavior of the regex.
If you want to perform only a single match operation with a regular expression, and don’t need to use any of the flags, you don’t have to create a Pattern object: simply pass the string representation of the pattern and the CharSequence to be matched to the static matches( ) method: the method returns true if the specified pattern matches the complete specified text, or returns false otherwise.
Pattern represents a regular expression, but does not actually define any primitive methods for matching regular expressions to text.
To do that, you must create a Matcher object that encapsulates a pattern and the text it is to be compared with.
Do this by calling the matcher( ) method and specifying the CharSequence you want to match against.
See Matcher for a description of what you can do with it.
The split( ) methods are the exception to the rule that you must obtain a Matcher in order to be able to do anything with a Pattern (although they create and use a Matcher internally)
They take a CharSequence as input, and split it into substrings, using text that matches the regular expression as the delimiter, returning the substrings as a String[ ]
The two-argument version of split( ) takes an integer argument that specifies the maximum number of substrings to break the input into.
Pattern defines the following flags that control various aspects of how regular expression matching is performed.
CANON_EQ The Unicode standard sometimes allows more than one way to specify the same character.
If this flag is set, characters are compared by comparing their full canonical decompositions, so that characters will match even if expressed in different ways.
Unlike all the other flags, there is no way to temporarily enable this flag within a pattern.
By default this flag only affects the comparisons of ASCII letters.
Also set the UNICODE_CASE flag if you want to ignore the case of all Unicode characters.
You can enable this flag within a pattern with (?i)
Comments are all characters between a # and end of line.
You can enable this flag within a pattern with (?x)
If it is not set, then it does not match line terminator characters.
This is also known as “single-line mode” and you can enable it within a pattern with (?s)
Within a pattern you can enable this flag with (?m)
You can enable both flags within a pattern with (?iu)
You can turn this flag on within a pattern with (?d)
Although the API for the Pattern class is quite simple, the syntax for the text representation of regular expressions is fairly complex.
The table below, is a quick-reference for regular expression syntax.
It is very similar to the syntax used in Perl.
Because Java strings also use the backslash character as an escape, you must double the backslashes when expressing a regular expression as a string literal: “\\d”
In Java 5.0, the static quote( ) method quotes all special characters in a string so that you can match arbitrary text literally without worrying that punctuation in that text will be interpreted specially.
For complete details on regular expressions see a book like Programming Perl by Larry Wall et.
Characters may be specified literally, and the syntax also allows the specification of character ranges, with intersection, union, and subtraction operators.
If the DOTALL flag is set, then it matches any character including line terminators.
Also “capture” the characters that match this group for use later.
Group subexpression as with ( ), but do not capture the text that matched.
Be careful when n is followed by another digit: the largest number that is a valid group number will be used.
The beginning of the input string, or if the MULTILINE flag is specified, the beginning of the string or of any new line.
The end of the input string, or if the MULTILINE flag is specified, the end of the string or of line within the string.
Like ^, but never matches the beginning of a new line, regardless of what flags are set.
Require that the following characters match x, but do not include those characters in the match.
Require that the following characters do not match the pattern x.
Require that the characters immediately before the position match x, but do not include those characters in the match.
Require that the characters immediately before the position do not match x.
A group of this form does not capture the matched text.
Don t match anything, but turn on the flags specified by onflags, and turn off the flags specified by offflags.
Flag settings specified in this way take effect at the point that they appear in the expression and persist until the end of the expression, or until the end of the parenthesized group of which they are a part, or until overridden by another flag setting expression.
Match x, applying the specified flags to this subexpression only.
All characters within such a quoted section are interpreted as literal characters to match, and none (except \E) have special meanings.
Signals a syntax error in the text representation of a regular expression.
An exception of this type may be thrown by the Pattern.compile( ) and Pattern.matches( ) methods, and also by the String matches( ), replaceFirst( ), replaceAll( ) and split( ) methods which call those Pattern methods.
The inherited getMessage( ) method combines the information provided by these other three methods into a single multiline message.
The java.util.zip package contains classes for data compression and decompression.
The Deflater and Inflater classes perform data compression and decompression.
This class implements the Checksum interface and computes a checksum on a stream of data using the Adler-32 algorithm.
This algorithm is significantly faster than the CRC32 algorithm and is almost as reliable.
This is useful when you want to check the integrity of a stream of data against a published checksum value.
The read( ) and skip( ) methods are the same as those of other input streams.
As bytes are read, they are incorporated into the checksum that is being computed.
The getChecksum( ) method does not return the checksum value itself, but rather the Checksum object.
You must call the getValue( ) method of this object to obtain the checksum value.
The write( ) methods are similar to those of other OutputStream classes.
You must call getValue( ) on this object in order to obtain the actual checksum value.
This interface defines the methods required to compute a checksum on a stream of data.
The checksum is computed based on the bytes of data supplied by the update( ) methods; the current value of the checksum can be obtained at any time with the getValue( ) method.
The checksum value computed by a Checksum object and returned through the getValue( ) method must fit into a long value.
Therefore, this interface is not suitable for the cryptographic checksum algorithms used in cryptography and security.
This class implements the Checksum interface and computes a checksum on a stream of data using the CRC-32 algorithm.
Signals that invalid or corrupt data has been encountered while uncompressing data.
This class implements the general ZLIB data-compression algorithm used by the gzip and PKZip compression programs.
The constants defined by this class are used to specify the compression strategy and the compression speed/strength tradeoff level to be used.
If you set the nowrap argument to the constructor to true, the ZLIB header and checksum data are omitted from the compressed output, which is the format both gzip and PKZip use.
The important methods of this class are setInput( ), which specifies input data to be compressed, and deflate( ), which compresses the data and returns the compressed output.
The remaining methods exist so that Deflater can be used for stream-based compression, as it is in higher-level classes, such as GZIPOutputStream and ZipOutputStream.
The Inflater class uncompresses data compressed with a Deflater object.
You can set various options on the Deflater object to specify just what type of compression is to be performed.
To create a GZIPInputStream, simply specify the InputStream to read compressed data from and, optionally, a buffer size for the internal decompression buffer.
Once a GZIPInputStream is created, you can use the read( ) and close( ) methods as you would with any input stream.
To create a GZIPOutputStream, specify the OutputStream to write to and, optionally, a size for the internal compression buffer.
Once the GZIPOutputStream is created, you can use the write( ) and close( ) methods as you would any output stream.
This class implements the general ZLIB data-decompression algorithm used by gzip, PKZip, and other data-compression applications.
It decompresses or inflates data compressed through the Deflater class.
The important methods of this class are setInput( ), which specifies input data to be decompressed, and inflate( ), which decompresses the input data into an output buffer.
A number of other methods exist so that this class can be used for stream-based decompression, as it is in the higher-level classes, such as GZIPInputStream and ZipInputStream.
Applications often prefer one of its subclasses, GZIPInputStream or ZipInputStream, that work with compressed data written in the standard gzip and PKZip file formats.
This class describes a single entry (typically a compressed file) stored within a ZIP file.
The various methods get and set various pieces of information about the entry.
The ZipEntry class is used by ZipFile and ZipInputStream, which read ZIP files, and by ZipOutputStream, which writes ZIP files.
When you are reading a ZIP file, a ZipEntry object returned by ZipFile or ZipInputStream contains the name, size, modification time, and other information about an entry in the file.
When writing a ZIP file, on the other hand, you must create your own ZipEntry objects and initialize them to contain the entry name and other appropriate information before writing the contents of the entry.
Protected Instance Fields protected byte[ ] buf; protected Inflater inf; protected int len;
Signals that an error has occurred in reading or writing a ZIP file.
It uses a random-access file internally so that the entries of the ZIP file do not have to be read sequentially, as they do with the ZipInputStream class.
A ZipFile object can be created by specifying the ZIP file to be read either as a String filename or as a File object.
Create a ZipInputStream by specifying the InputStream from which it is to read the contents of the ZIP file.
Once the ZipInputStream is created, you can use getNextEntry( ) to begin reading data from the next entry in the ZIP file.
This method must be called before read( ) is called to begin reading the first entry.
The read( ) methods of ZipInputStream read until the end of the current entry and then return –1, indicating that there is no more data to read.
To continue with the next entry in the ZIP file, you must call getNextEntry( ) again.
Similarly, the skip( ) method only skips bytes within the current entry.
Before writing any data to the ZipOutputStream, you must begin an entry within the ZIP file with putNextEntry( )
The ZipEntry object passed to this method should specify at least a name for the entry.
Once you have begun an entry with putNextEntry( ), you can write the contents of that entry with the write( ) methods.
When you reach the end of an entry, you can begin a new one by calling putNextEntry( ) again, you can close the current entry with closeEntry( ), or you can close the stream itself with close( )
Before beginning an entry with putNextEntry( ), you can set the compression method and level with setMethod( ) and setLevel( )
The constants DEFLATED and STORED are the two legal values for setMethod( )
If you use STORED, the entry is stored in the ZIP file without any compression.
If you are storing an entry without compression, the ZIP file format requires that you specify, in advance, the entry size and CRC-32 checksum in the ZipEntry object for the entry.
An exception is thrown if these values are not specified or specified incorrectly.
This chapter documents the cryptographic features (including encryption and decryption) of the javax.crypto package and its subpackages.
These packages were originally part of the Java Cryptography Extension (JCE) before being integrated into Java 1.4, which is why they have the “javax” extension prefix.
All of the commonly-used cryptography classes are in the javax.crypto package itself.
The javax.crypto package defines classes and interfaces for various cryptographic operations.
The central class is Cipher, which is used to encrypt and decrypt data.
CipherInputStream and CipherOutputStream are utility classes that use a Cipher object to encrypt or decrypt streaming data.
SealedObject is another important utility class that uses a Cipher object to encrypt an arbitrary serializable Java object.
The KeyGenerator class creates the SecretKey objects used by Cipher for encryption and decryption.
The KeyAgreement class enables two or more parties to agree on a SecretKey in such a way that an eavesdropper cannot determine the key.
The Mac class computes a message authentication code (MAC) that can ensure the integrity of a transmission between two parties who share a SecretKey.
A MAC is akin to a digital signature, except that it is based on a secret key instead of a public/private key pair.
Like the java.security package, the javax.crypto package is provider-based, so that arbitrary cryptographic implementations may be plugged into any Java installation.
Various classes in this package have names that end in Spi.
These classes define a service-provider interface and must be implemented by each cryptographic provider that wishes to provide an implementation of a particular cryptographic service or algorithm.
This package was originally shipped as part of the Java Cryptography Extension (JCE), but it has been added to the core platform in Java 1.4
This package is distributed with a cryptographic provider named “SunJCE” that includes a robust set of implementations for Cipher, KeyAgreement, Mac, and other classes.
This provider is installed by the default java.security properties in Java 1.4 distributions.
A full tutorial on cryptography is beyond the scope of this chapter and of this book.
In order to use this package, you need to have a basic understanding of cryptographic algorithms such as DES.
In order to take full advantage of this package, you also need to have a detailed understanding of things like feedback modes, padding schemes, the Diffie-Hellman key-agreement protocol, and so on.
For a good introduction to modern cryptography in Java, see Java Cryptography by Jonathan Knudsen (O’Reilly)
For more in-depth coverage, not specific to Java, see Applied Cryptography by Bruce Schneier (Wiley)
Signals that input data to a Cipher is not padded correctly.
Cipher is provider-based, so to obtain a Cipher object, you must call the static getInstance( ) factory method.
The arguments to getInstance() are a string that describes the type of encryption desired and, optionally, the name of the provider whose implementation should be used.
To specify the desired type of encryption, you can simply specify the name of an encryption algorithm, such as “DES”
In Java 5.0, the “SunJCE” provider supports the following algorithm names:
Advanced users may specify a three-part algorithm name that includes the encryption algorithm, the algorithm operating mode, and the padding scheme.
Finally, if you are requesting a block cipher algorithm in a stream mode, you can specify the number of bits to be processed at a time by following the name of the feedback mode with a number of bits.
Details of supported operating modes and padding schemes are beyond the scope of this book.
Once you have obtained a Cipher object for the desired cryptographic algorithm, mode, and padding scheme, you must initialize it by calling one of the init( ) methods.
If you use one of the symmetric (i.e., nonpublic key) encryption algorithms supported by the “SunJCE” provider, this Key object is a SecretKey implementation.
Note that some cryptographic providers restrict the maximum allowed key length based on a jurisdiction policy file.
If you do not, the Cipher implementation provides its own pseudorandom number generator.
When encrypting, you can omit these parameters, and the Cipher implementation uses default values or generates appropriate random parameters for you.
These parameters are required in order to decrypt, and must therefore be saved or transferred along with the encrypted data.
The “PBEWithMD5AndDES” algorithm requires a salt and iteration count as parameters.
Once you have obtained and initialized a Cipher object, you are ready to use it for encryption or decryption.
If you have only a single array of bytes to encrypt or decrypt, pass that input array to one of the doFinal( ) methods.
Some versions of this method return the encrypted or decrypted bytes as the return value of the function.
Other versions store the encrypted or decrypted bytes to another byte array you specify.
If you choose to use one of these latter methods, you should first call getOutputSize( ) to determine the required size of the output array.
If you want to encrypt or decrypt data from a streaming source or have more than one array of data, pass the data to one of the update( ) methods, calling it as many times as necessary.
Then pass the last array of data to one of the doFinal( ) methods.
If you are working with streaming data, consider using the CipherInputStream and CipherOutputStream classes instead.
Java 5.0 adds versions of the update( ) and doFinal( ) that work with ByteBuffer objects, which facilitates the use of encryption and decryption with the New I/O API of java.nio.
This class is an input stream that uses a Cipher object to encrypt or decrypt the bytes it reads from another stream.
You must initialize the Cipher object before passing it to the CipherInputStream( ) constructor.
This class is an output stream that uses a Cipher object to encrypt or decrypt bytes before passing them to another output stream.
If you are using a Cipher with any kind of padding, you must not call flush( ) until you are done writing all data to the stream; otherwise decryption fails.
A cryptographic provider must implement a concrete subclass of this class for each encryption algorithm it supports.
A provider can implement a separate class for each combination of algorithm, mode, and padding scheme it supports or implement more general classes and leave the mode and/or padding scheme to be specified in calls to engineSetMode( ) and engineSetPadding( )
Pass a Cipher object to getKeySpec( ) to decrypt the key.
Some countries place legal restrictions on the use of cryptographic algorithms.
In some cases, a program may be exempt from these restrictions if it implements an “exemption mechanism” such as key recovery, key escrow, or key weakening.
This class defines a very general API to such mechanism.
This class is rarely used, and is not supported in the default implementation provided by Sun.
Using this class successfully is quite complex, and is beyond the scope of this reference.
For details, see the discussion “How to Make Applications ‘Exempt’ from Cryptographic Restrictions” in the JCE Reference Guide which is part of the standard bundle of documentation shipped by Sun with the JDK.
Security providers may implement this interface, but applications never need to use it.
Note that the default “SunJCE” provider does not provide an implementation.
Signals that the length of data provided to a block cipher (as implemented, for example, by Cipher and SealedObject) does not match the block size for the cipher.
This class provides an API to a key-agreement protocol that allows two or more parties to agree on a secret key without exchanging any secrets and in such a way that an eavesdropper listening in on the communication between those parties cannot determine the secret key.
The “SunJCE” provider implements a single key-agreement algorithm named “DiffieHellman”
To use a KeyAgreement object, each party first calls the init( ) method and supplies a Key object of its own.
Then, each party obtains a Key object from one of the other parties to the agreement and calls doPhase( )
Each party obtains an intermediate Key object as the return value of doPhase( ), and these keys are again exchanged and passed to doPhase( )
When doPhase( ) is called the last time, the second argument must be true to indicate that it is the last phase of the agreement.
After all calls to doPhase( ) have been made, each party calls generateSecret( ) to obtain an array of bytes or a SecretKey object for a named algorithm type.
All parties obtain the same bytes or SecretKey from this method.
The KeyAgreement class is not responsible for the transfer of Key objects between parties or for mutual authentication among the parties.
The most common type of key agreement is “DiffieHellman” key agreement between two parties.
Each party passes its private key to the init( ) method of its KeyAgreement object.
Next, the two parties exchange public keys, typically through some kind of networking mechanism (the KeyAgreement class is not responsible for the actual exchange of keys)
Each party passes the public key of the other party to the doPhase( ) method of its KeyAgreement object.
There are only two parties to this agreement, so only one phase is required, and the second argument to doPhase( ) is true.
At this point, both parties call generateSecret( ) to obtain the shared secret key.
A three-party Diffie-Hellman key agreement requires two phases and is slightly more complicated.
Each generates a key pair and uses its private key to initialize its KeyAgreement object, as before.
Then Alice passes her public key to Bob, Bob passes his to Carol, and Carol passes hers to Alice.
Since this is not the final doPhase( ), the second argument is false, and doPhase( ) returns an intermediate Key object.
The three parties exchange these intermediate keys again in the same way: Alice to Bob, Bob to.
Now each party passes the intermediate key it has received to doPhase( ) a second time, passing true to indicate that this is the final phase.
Finally, all three can call generateSecret( ) to obtain a shared key to encrypt future communication.
A cryptographic provider must implement a concrete subclass of this class for each encryption algorithm it supports.
This class provides an API for generating secret keys for symmetric cryptography.
In Java 5.0 the “SunJCE” provider includes KeyGenerator implementations algorithms with the following names:
Once you have obtained a KeyGenerator, you initialize it with the init( ) method.
In either case, you can also specify a source of randomness in the form of a SecureRandom object.
If you do not specify a SecureRandom, the KeyGenerator instantiates one of its own.
None of the algorithms supported by the “SunJCE” provider require algorithm-specific parameters.
After calling getInstance( ) to obtain a KeyGenerator and init( ) to initialize it, simply call generateKey( ) to create a new SecretKey.
Take precautions when storing or transmitting the key, so that it does not fall into the wrong hands.
A cryptographic provider must implement a concrete subclass of this class for each keygeneration algorithm it supports.
This class defines an API for computing a message authentication code (MAC) that can check the integrity of information transmitted between two parties that share a secret key.
A MAC is similar to a digital signature, except that it is generated with a secret key rather than with a public/private key pair.
Obtain a Mac object by calling one of the static getInstance( ) factory methods and specifying the name of the desired MAC algorithm and, optionally, the name of the provider of the desired implementation.
In Java 5.0 The “SunJCE” provider implement MAC algorithms with the following names:
After obtaining and initializing a Mac object, specify the data for which the MAC is to be computed.
If the data is contained in a single byte array, simply pass it to doFinal( )
If the data is streaming or is stored in various locations, you can supply the data in multiple calls to update( )
In Java 5.0, you can pass a ByteBuffer to update( ) which facilities use with the java.nio New I/O API.
End the series of update( ) calls with a single call to doFinal( )
Note that some versions of doFinal( ) return the MAC data as the function return value.
If you use this version of doFinal( ), be sure to call getMacLength( ) to instantiate an array of the correct length.
A call to doFinal( ) resets the internal state of a Mac object.
If you want to compute a MAC for part of your data and then proceed to compute the MAC for the full data, you should clone( ) the Mac object before calling doFinal( )
Note, however, that Mac implementations are not required to implement Cloneable.
A cryptographic provider must implement a concrete subclass of this class for each MAC algorithm it supports.
Signals that no implementation of the requested padding scheme can be found.
This trivial subclass of Cipher implements an identity cipher that does not transform plain text in any way.
It serializes the object and encrypts the resulting data stream, thereby protecting the confidentiality of the object.
Create a SealedObject by specifying the object to be sealed and a Cipher object to perform the encryption.
The SealedObject keeps track of the encryption algorithm and parameters so that a Key object alone can decrypt the object.
This interface represents a secret key used for symmetric cryptographic algorithms that depend on both the sender and receiver knowing the same secret.
The interface exists in order to keep secret keys distinct from the public and private keys used in public-key, or asymmetric, cryptography.
A secret key is nothing more than arrays of bytes and does not require a specialized encoding format.
Therefore, an implementation of this interface should return the format name “RAW” from getFormat( ) and should return the bytes of the key from getEncoded( )
In Java 5.0, the “SunJCE” provider provides SecretKeyFactory implementations for algorithms with the following names:
Or call getKeySpec( ) to obtain a KeySpec for a Key object.
Because there can be more than one suitable type of KeySpec, getKeySpec( ) requires a Class object to specify the type of the KeySpec to be created.
A cryptographic provider must implement a concrete subclass of this class for each type of secret key it supports.
Signals that an output buffer is too short to hold the results of an operation.
The “DH” interfaces respresent DiffieHellman public/private key pairs used in the Diffie-Hellman key-agreement protocol.
These interfaces are typically of interest only to programmers who are implementing a cryptographic provider or who want to implement cryptographic algorithms themselves.
Use of this package requires basic familiarity with the encryption algorithms and the mathematics that underlie them.
See the subinterfaces DHPublicKey and DHPrivateKey for the actual key values.
If you are working with a PrivateKey you know is a Diffie-Hellman key, you can cast your PrivateKey to a DHPrivateKey.
If you are working with a PublicKey you know is a Diffie-Hellman key, you can cast your PublicKey to a DHPublicKey.
If you are working with a SecretKey that you know is a password-based key, you can cast it to a PBEKey.
In order to make good use of this package, you must be familiar with the specifications of the various cryptographic algorithms it supports and the basic mathematics that underlie those algorithms.
This class is a transparent representation of a DESede (triple-DES) key.
This class is a transparent representation of a DES key.
This class is a transparent representation of the values needed to generate a set of Diffie-Hellman parameters (see DHParameterSpec)
This class is a transparent representation of the set of parameters required by the Diffie-Hellman key-agreement algorithm.
All parties to the key agreement must share these parameters and use them to generate a Diffie-Hellman public/private key pair.
An IV is required for block ciphers used in feedback mode, such as DES in CBC mode.
This class specifies parameters for OAEP padding, defined by the PKCS #1 standard.
This class is a transparent representation of a password used in password-based encryption (PBE)
The password is stored as a char array rather than as a String, so that the characters of the password can be overwritten when they are no longer needed (for increased security)
This class is a transparent representation of the parameters used with the passwordbased encryption algorithm defined by PKCS#5
This class is a representation of the source of “encoding input P” in OAEP padding, defined by the PKCS #1 standard.
It explicitly specifies the bytes of “encoding input P” for OAEP padding.
This class is a transparent representation of the parameters used by the RC2 encryption algorithm.
An object of this class initializes a Cipher object that implements RC2
Note that the “SunJCE” provider supplied by Sun does not implement RC2
This class is a transparent representation of the parameters used by the RC5 encryption algorithm.
An object of this class initializes a Cipher object that implements RC5
Note that the “SunJCE” provider supplied by Sun does not implement RC5
This class is useful only for encryption algorithms (such as DES and DESede) whose secret keys can be represented as arbitrary byte arrays and do not require auxiliary parameters.
This chapter documents the javax.net package and, more importantly, its subpackage javax.net.ssl.
These packages were originally defined by the Java Secure Sockets Extension (JSSE) before they were integrated into Java 1.4, which is why they have a “javax” prefix.
This small package defines factory classes for creating sockets and server sockets.
More importantly, however, these factory classes can be subclassed to serve as factories for other types of sockets such as the SSL-enabled sockets of the javax.net.ssl package.
This abstract class defines a factory API for creating server socket objects.
This abstract class defines a factory API for creating socket objects.
This default SocketFactory is the one used by the Socket( ) constructor, which usually provides an easier way to create normal sockets.
Once you have a SocketFactory object, call one of the createSocket( ) methods to create a new socket and optionally connect it to a remote host and optionally bind it to a local address and port.
This package defines an API for secure network sockets using the SSL (Secure Sockets Layer) protocol, or the closely related TLS (Transport Layer Security) protocol.
It defines the SSLSocket and SSLServerSocket subclasses of the java.net socket and server socket.
Clients that want to perform simple SSL-enabled networking can create an SSLSocket with code like the following:
Once a connection is established over an SSLSocket, you can use the getSession( ) method to obtain an SSLSession object that provides information about the connection.
Note that despite the name of this package and of its key classes, it supports the TLS protocol in addition to the SSL.
The TLS protocol is closely related to SSL, and we’ll simply use the term SSL here.
The SSLSocket class allows you to do arbitrary networking with an SSL-enabled peer.
The most common use of SSL today is with the https: protocol on the web.
The addition of this package to the core Java platform enables support for https: URLs in the java.net.URL class, which allows you to securely transfer data over the web without having to directly use this package at all.
When you call openConnection( ) on a https: URL, the URLConnection object that is returned can be cast to an HttpsURLConnection object, which defines some SSL-specific methods.
Although the code shown above to create a SSLSocket is quite simple, this package is much more complex because it exposes a lot of SSL infrastructure so that applications with advanced networking needs can configure it as needed.
If you want to explore this package beyond the two socket classes, the two factory classes, and the HttpsURLConnection class, start with SSLContext.
This class is a factory for socket factories, and as such is the central class of the API.
To customize the way SSL networking is done, you create an SSLContext optionally specifing the desired provider of the implementation.
The method and package exist only for backward compatibility with earlier versions of the JSSE API, and should be considered deprecated.
An object that implements this interface may be used with an HttpsURLConnection object to handle the case in which the hostname that appears in the URL does not match the hostname obtained during the SSL handshake with the server.
This occurs, for example, when a website uses the secure certificate of its parent web hosting company, for example.
In this situation, the verify( ) method of the HostnameVerifier is called to determine whether the connection should proceed or not.
The hostname argument to verify( ) specifies the hostname that appeared in the URL.
The session argument specifies the SSLSession object that was established during the handshake.
Call getPeerHost( ) on this object to determine the hostname reported during server authentication.
If no HostnameVerifier is registered with a HttpsURLConnection object, and no default verifier is registered with the HttpsURLConnection class, then hostname mismatches will always cause the connection to fail.
In user-driven applications such as web browsers, a HostnameVerifier can be used to ask the user whether to proceed or not.
Static versions of these methods allow you to specify a default factory and verifier objects for use with all HttpsURLConnection objects.
After the connection has been established, several other methods exist to obtain information (such as the cipher suite and the server certificates) about the connection itself.
Obtain a HttpsURLConnection object by calling the openConnection( ) method of a URL that uses the https:// protocol specifier, and casting the returned value to this type.
If you do not specify a HostnameVerifier for the instance, or a default one for the class, then hostname mismatches will always cause the connection to fail.
If you do not specify an SSLSocketFactory for the instance or class, then a default one will be used.
This is a marker interface to identify key manager objects.
A key manager is responsible for obtaining and managing authentication credentials (such as a certificate chain and an associated private key) that the local host can use to authenticate itself to the remote host.
It is usually used on the server-side of an SSL connection, but can be used on the client-side as well.
KeyManager objects returned by a KeyManagerFactory can always be cast to a subinterface specific to a particular type of authentication credentials.
A KeyManagerFactory is responsible for creating KeyManager objects for a specific key management algorithm.
Obtain a KeyManagerFactory object by calling one of the getInstance( ) methods and specifying the desired algorithm and, optionally, the desired provider.
After calling getInstance( ), you initialize the factory object with init( )
Once a KeyManagerFactory has been created and initialized, use it to create a KeyManager by calling getKeyManagers( )
This method returns an array of KeyManager objects because some key management algorithms may handle more than one type of key.
This returned array is typically passed to the init( ) method of an SSLContext object.
Security providers must implement this interface, but applications never need to use it.
In the default “SunJSSE” provider shiped by Sun, the only supported type for these factory classes is “SunX509”
Therefore, the javax.net.ssl package does not define any subinterfaces of this interface, and it is never used with the default provider.
This class is a factory for socket and server socket factories.
Although most applications do not need to use this class directly, it is the central class of the javax.net.ssl package.
Applications that want to perform SSL networking using a security provider other than the default provider, or that want to customize key management or trust management for the SSL connection should use custom socket factories created from a custom SSLContext.
In Java 5.0, this class also includes createSSLEngine( ) factory methods for creating SSLEngine objects.
Create an SSLContext by passing the name of the desired secure socket protocol and, optionally, the desired provider to getInstance( )
Once you have created an SSLContext object, call its init( ) method to supply the KeyManager, TrustManager, and SecureRandom objects it requires.
If any of the init( ) arguments is null, a default value will be used.
Security providers must implement this interface, but applications never need to use it.
This class performs SSL handshaking, encryption and decryption, but does not send or receive messages over the network.
This leaves the network transport mechanism up to the user of this class, and enables SSL communication using the nonblocking I/O mechanisms of the java.nio package.
The price of this flexibility is that your code must follow a relatively complex protocol to use an SSLEngine correctly.
Next, configure it with the various setter methods to specify authentication requirements, encryption algorithms, etc.
After creating and configuring an engine, you use it to encrypt outbound data from one ByteBuffer to another with wrap( ) and to decrypt inbound data from one byte buffer to another with unwrap( )
Note that the wrap( ) and unwrap( ) methods also come in gathering and scattering variants.
The initial call or calls to wrap( ) produce outbound handshaking data without consuming any of the source bytes in the buffer you provide.
Initial calls to unwrap( ) may consume inbound handshaking data without producing any result bytes.
When handshaking is complete, you can call getSession( ) to obtain the SSLSession object that describes session details negotiated during handshaking.
Remember that either peer of an SSL connection may request a new handshake at any time; this means that you must monitor the HandshakeStatus after every wrap( ) or unwrap( ) call in case a new handshake has been requested.
You can request a new handshake yourself with beginHandshake( )
As part of the handshaking protocol, the SSLEngine typically needs to use the KeyManager or TrustManager of the originating SSLContext object.
When this happens, you must call getDelegatedTask( ) repeatedly, calling the run( ) methods of the Runnable objects it returns until it returns null to indicate that all necessary tasks have been completed.
Once all such tasks have been run, the original call to wrap( ) or unwrap( ) should be repeated.
When you are done sending outbound data, call closeOutbound( ), and then call wrap( ) one or more times to flush any remaining data from the engine.
Similarly, if you are done reading inbound data, call closeInbound( ) and final calls to unwrap( ) until the connection is closed.
It is safe for one thread to call wrap( ) while another thread is calling unwrap( )
It is not safe, however, for either method to be called by two threads at once.
An object of this type is returned by the wrap( ) and unwrap( ) methods of an SSLEngine.
Use the methods of this object to determine how much data was consumed and produced and to obtain the Status of the operation and the HandshakeStatus of the connection.
Correct operation of an SSLEngine requires that your code respond correctly to the Status and HandshakeStatus results.
The constants defined by this enumerated type specify the handshake status of the SSLEngine and often specify the action your code must take next in order to ensure correct operation.
NEED_WRAP The SSLEngine needs to send more handshake data, so a call to wrap( ) is necessary.
NEED_UNWRAP The SSLEngine needs to receive more handshake data, so a call to unwrap( ) is necessary.
NEED_TASK The SSLEngine needs to perform an authentication or related task, so you must repeatedly call getDelegatedTask( ) and run( ) any Runnable objects it returns.
The constants of this enumerated type indicate the status of a wrap( ) or unwrap( ) operation:
Or, that connection is already closed, and so the wrap( ) or unwrap( ) call could not proceed.
BUFFER_OVERFLOW There were not enough bytes in the destination buffer to hold the results.
BUFFER_UNDERFLOW There were not enough incoming bytes in the source buffer to produce a complete output packet.
Fill the buffer with more bytes from the network and call unwrap( ) again.
This class serves as the common superclass of more specific SSL exception subclasses.
When this exception is thrown, the SSLSocket object is no longer usable.
Signals a problem with the public key certificate and private key used by a server (or client) for authentication.
Signals that authentication of the remote host was not successfully completed.
This Permission class controls access to sensitive methods in the javax.net.ssl package.
An exception of this type usually indicates that there is a bug in the SSL implementation being used locally or on the remote host.
Once a SSLServerSocket is created, use it as you would a regular ServerSocket: call the inherited accept( ) method to wait for and accept a connection from a client, returning a Socket object.
With SSLServerSocket, the Socket returned by accept( ) can always be cast to an instance of SSLSocket.
SSLServerSocket defines methods for setting the enabled protocols and cipher suites, and for querying the full set of supported protocols and suites.
See SSLSocket, which has methods with the same names, for details.
If your server desires or requires authentication by its clients, call setWantClientAuth( ) or setNeedClientAuth( )
These methods cause the SSLSocket objects returned by accept( ) to be configured to request or require client authentication.
In typical SSL networking scenarios, the client requires the server to provide authentication information.
The key store should only contain valid keys and certificate chains that identify the server; the X509KeyManager automatically chooses a key and certificat chain that are appropriate for the client.
A SSLSession object contains information about the SSL connection established through an SSLSocket.
Use the the getSession( ) method of a SSLSocket to obtain the SSLSession object for that socket.
Many of the SSLSession methods return information that was obtained during the handshake phase of the connection.
In Java 5.0 and later the peer’s identity can also be queried with getPeerPrincipal( )
It does not affect any current connections, but all future connections and any re-negotiations of existing connections will need to establish a new SSLSession.
Multiple SSL connections between two hosts may share the same SSLSession as long as they are using the same protocol version and cipher suite.
There is no way to enumerate the SSLSocket objects that share a session, but these sockets can exchange information by using putValue( ) to bind a shared object to some well-known name that can be looked up by other sockets with getValue( )
This interface is implemented by an object that want to be notified when it is bound or unbound in an SSLSession object.
If the object passed to the putValue( ) method of a SSLSession implements this interface, then its valueBound( ) method will be called by putValue( ), and its valueUnbound( ) method will be called when that object is removed from the SSLSession with removeValue( ) or when it is replaced with a new object by putValue( )
It is a low-level interface and is not commonly used in application code.
An SSLSessionContext can serve as a cache for SSLSession objects, facilitating reuse of those objects for multiple connections between the same two hosts.
Create a SSLSocket for connecting to a SSL-enabled server by calling one of the createSocket( ) methods of a SSLSocketFactory object.
If you are writing server code, then you will obtain a SSLSocket for communicating with an SSL-enabled client from the inherited accept( ) method of an SSLServerSocket.
In addition, however, it also defines methods that control how the secure connection is established.
These methods may be called before the SSL “handshake” occurs.
The handshake does not occur when the socket is first created and connected, so that you can configure various SSL parameters that control how the handshake occurs.
Calling startHandshake( ), getSession( ), or reading or writing data on the socket trigger a handshake, so you must configure the socket before doing any of these things.
Note that not all supported cipher suites are enabled by default: only suites that provide encryption and require the server to authenticate itself to the client are enabled.
Specific protocols and cipher suites are not described here because using them correctly requires a detailed understanding of cryptography, which is beyond the scope of this reference.
Most applications can simply rely on the default set of enabled protocols and cipher suites.
If you are writing a server and have obtained an SSLSocket by accepting a connection on an SSLServerSocket, then you may call setWantClientAuth( ) to request that the client authenticate itself to you, and you may call setNeedClientAuth( ) to require that the client authenticate itself during the handshake.
Note, however, that it is usually more efficient to request or require client authentication on the server socket than it is to call these methods on each SSLSocket it creates.
The configuration methods described above must be called before the SSL handshake occurs.
Call getSession( ) to obtain an SSLSession object that you can query for for information about the handshake, such as the protocol and cipher suite in use, and the identity of the server.
Note that a call to getSession( ) will cause the handshake to occur if it has not already occurred, so you can call this method at any time.
Most applications use the default SSLSocketFactory returned by the static getDefault( ) method.
Once this SSLSocketFactory has been obtained, they use one of the inherited createSocket( ) methods to create, and optionally connect and bind, a new SSLSocket.
SSLSocketFactory defines one new version of createSocket( ) in addition to the ones it inherits from its superclass.
This version of the method creates an SSLSocket that is layered over an existing Socket object rather than creating a new socket entirely from scratch.
Applications that need to customize the SSL configuration and cannot use the default socket factory may obtain a custom SSLSocketFactory from an SSLContext, which is essentially a factory for socket factories.
This is a marker interface to identify trust manager objects.
A trust manager is responsible for examining the authentication credentials (such as a certificate chain) presented by the remote host and deciding whether to trust those credentials and accept them.
A TrustManager is usually used an SSL client to decide whether the SSL server is authentic, but may also be used by an SSL server when client authentication is also required.
After calling getInstance( ), you initialize the factory object with init( )
For the “SunX509” algorithm, you pass a KeyStore object to init( )
This KeyStore should contain the public keys of trusted CAs (certification authorities)
This method returns an array of TrustManager objects because some trust management algorithms may handle more than one type of key or certificate.
This returned array is typically passed to the init( ) method of an SSLContext object.
Sun ships a default cacerts file that contains certificates for several wellknown and reputable CAs.
You can use the keytool program to edit the cacerts keystore (the default password is “changeit”)
Security providers must implement this interface, but applications never need to use it.
This class implements the X509KeyManager interface and extends it with two methods.
This interface is a KeyManager for working with X.509 certificates.
This is usually done on the server side of the.
Applications do not call the methods of an X509KeyManager themselves.
Instead, they simply supply an appropriate X509KeyManager object to the SSLContext object that is responsible for setting up SSL connections.
When the system needs to authenticate itself during an SSL handshake, it calls various methods of the key manager object to obtain the information in needs.
An X509KeyManager retrieves keys and certificae chains from the KeyStore object that was passed to the init( ) method of the KeyManagerFactory object from which it was created.
The other methods are called to list all aliases in the keystore or to choose one alias from the keystore that matches the specified keytype and certificate authority criteria.
In this way, a X509KeyManager can choose a certificate chain (and it corresponding key) based on the types of keys and the list of certificate authorities recognized by the remote host.
This interface is a TrustManager for working with X.509 certificates.
Trust managers are used during the handshake phase of SSL connection to determine whether the authentication credentials presented by the remote host are trusted.
This is usually done on the client-side of an SSL connection, but may also be done on the server side.
Applications do call the methods of this interface themselves; instead, they simply provide an appropriate X509TrustManager object to the SSLContext object that is responsible for setting up SSL connections.
When the system needs to determine whether the authentication credentials presented by the remote host are trusted, it calls the methods of the trust manager.
Before being integrated into Java 1.4, JAAS was available as a standard extension, which is why these packages have the “javax” prefix.
This is the top-level package of the Java Authentication and Authorization Service (JAAS)
The key class is Subject, which represents an authenticated user, and defines static methods that allow Java code be run as (i.e., using the permissions of) a specified Subject.
The target name of the permission specifies which methods are allowed; AuthPermission objects have no actions list.
System implementors may need to use it, and system administrators who configure security policies may need to be familiar with the following table of target names and the permissions they represent:
If name is  * , it allows a LoginContext of any name to be created.
Classes that encapsulate sensitive information, such as security credentials, may implement this interface to provide an API that allows the sensitive information to be destroyed or erased.
The destroy( ) method erases or clears the sensitive information.
It may also throw a SecurityException if the caller does not have whatever permissions are required.
Once destroy( ) has been called on an object, the isDestroyed( ) method returns true.
Signals that the destroy( ) method of a Destroyable object did not succeed.
Thus, this class is no longer required and has been deprecated.
This Permission class protects access to private credential objects belonging to a Subject (as specified by a set of one or more Principal objects)
System programmers implementing new private credentials classes may need to use it, and system administrators configuring security policy files should be familiar with it.
The target name for this permission has a complex syntax and specifies the name of the credential class and a list of one or more principals.
Each principal is specified as the name of the Principal class followed by the principal name in quotes.
For example, a security policy file might contain a statement like the following to allow permission to read the private KerberosKey credentials of a KerberosPrincipal named “david”
A class implements this interface if its instances that have a limited period of validity (as some security credentials do) and need to be periodically “refreshed” in order to remain valid.
And may also throw a SecurityException if the caller does not have the requisite permissions.
Signals that the refresh( ) method of a Refreshable object failed.
The Subject class is the key abstraction of the JAAS API.
It represents a person or other entity, and consists of:
Subject defines methods that allow you to retreive each of these three sets, or to retreive a subset of each set that contains only objects of a specified Class.
Unless the Subject is read-only, you can use the methods of java.util.Set to modify each of the three sets.
Once setReadOnly( ) has been called, however, the sets become immutable and their contents may not be modified.
Once an authenticated Subject has been obtained from a LoginContext, an application can call the doAs( ) method to run code using the permissions granted to that Subject combined with the permissions granted to the code itself.
Note that many of the methods of this class throw a SecurityException if the caller has not been granted the requisite AuthPermission.
It is used to merge permissions based on code source and code signers with permissions granted to the specified Subject.
The LoginModule sends messages and requests for information in the form of objects that implement the Callback interface.
An application that want to provide a customized login interface must implement its own CallbackHandler.
The CallbackHandler API consists of only a single method, but the implementation of that method can require a substantial amount of code.
See the various Callback classes for directions on how a CallbackHandler should handle them.
Programmers wanting to write a custom CallbackHandler may also find it useful to study the source code of these two existing handlers.
This interface defines no methods but serves as a “marker interface” to identify the type of objects that can be passed to the handle( ) method of a CallbackHandler.
When an application needs to authenticate a user, it creates a LoginContext and specifies a CallbackHandler object for that context.
The underlying LoginModule uses the CallbackHandler to communicate with the end user--for example prompting them to enter a name and password.
The LoginModule passes an array of objects that implement the Callback interface to the handle( ) method of CallbackHandler.
The handle( ) method must determine the type of Callback object, and display the information and/or prompt for the input it represents.
Different Callback classes have different purposes and must be handled differently.
NameCallback and PasswordCallback are two of the most commonly used: they represent requests for the user’s name and password.
TextOutputCallback is also common: it represents a request to display a message (such as “Authentication Failed”) to the user.
See the descriptions of the individual Callback classes for information on how a CallbackHandler should handle them.
The handle( ) method is passed an array of Callback objects.
A CallbackHandler (such as a typical console-based handler) may choose to handle the Callback objects one at a time, prompting for and returning the user’s input before moving on to the next.
Or (for example in GUI-based handlers) it may choose to present all of the callbacks in a single unified “login dialog box”
LoginModule implementations may, of course, call the handle( ) method more than once.
Note, finally, that if a CallbackHandler implementation has knowledge of the user from some other source, it is allowed to handle certain callbacks automatically, such as automatically providing the user’s name for a NameCallback.
No such default is defined by the default security policy that ships with Sun’s distribution.
Note that these are part of Sun’s implementation, and are not part of the specification; they are not guaranteed to exist in all releases.
A Callback of this type represents a request to display set of text choices and allow the user to select one or more of them.
A CallbackHandler, should display the prompt returned by getPrompt( ) and also the strings returned by getChoices( )
In either case, the CallbackHandler should also call getDefaultChoice( ) and make the choice at the returned index the default choice.
A Callback of this type represents a request to ask the user a yes/no or multiple-choice question.
A CallbackHandler should first call getPrompt( ) to obtain the text of the question.
It should also call getMessageType( ) to determine the message type (INFORMATION, WARNING, or ERROR) and present the question to the user in a suitable manner based on that type.
Next, the CallbackHandler must determine the appropriate set of responses to the question.
YES_NO_OPTION The CallbackHandler should allow the user to respond to the question with a “yes” or a “no” (or their localized equivalents)
OK_CANCEL_OPTION The CallbackHandler should allow “ok” and “cancel” (or their localized equivalents) responses.
UNSPECIFIED_OPTION The CallbackHandler should call getOptions( ) and use present all strings it returns as possible responses.
In each of these cases, the CallbackHandler should also call getDefaultOption( ) to determine which response should be presented as the default response.
If getOptionType( ) returned UNSPECIFIED_TYPE, then getDefaultOption( ) returns an index into the array of options returned by getOptions( )
Otherwise getDefaultOption( ) returns one of the constants YES, NO, OK, or CANCEL.
When the user has selected a response to the callback, the CallbackHandler should pass that response to setSelectedIndex( )
The response value should be one of the constants YES, NO, OK, or CANCEL, or an index into the array of options returned by getOptions( )
This Callback class represents a request for the user’s preferred language (as represented by a Locale object), which a LoginModule can use to localize things such as prompts and error messages in subsequent Callback objects.
If a CallbackHandler already has knowledge of the user’s preferred langauge, it is not required to prompt the user for this information and can simply pass an appropriate Locale object to setLocale( )
This Callback class represents a request for the username or other text that identifies the user to be authenticated.
An interactive CallbackHandler should call getPrompt( ) and getDefaultName( ) and should display the returned prompt and optionally, the returned default name to the user.
When the user has entered a name (or accepted the default name) the handler should pass the user’s input to setName( )
A CallbackHandler should handle it by displaying the prompt returned by getPrompt( ) and then allowing the user the enter a password.
When the user has entered the password, it should pass the entered text to setPassword( )
If isEchoOn( ) returns true, then the Handler should display the password as the user types it.
A Callback of this type is a request to prompt the user for text input; it is essentially a generic version of NameCallback.
A CallbackHandler should call getPrompt( ) and should display the returned prompt text to the user.
It should then allow the user to enter text, and provide the option of selecting the default text returned by getDefaultText( )
When the user has entered text (or selected the default text) it should pass the user’s input to setText( )
A Callback of this type represents a request to display text to the user.
A callback handler should call getMessage( ) and display the returned string to the user.
It should also call getMessageType( ) and use the returned value (which is one of the constants defined by the class) to indicate the type or severity of the information.
CallbackHandler implementations may throw exceptions of this type from their handle( ) method if a Callback object passed to that method is of an unrecognized or unsupported type.
Note that the offending Callback object must be passed to the constructor method.
This package defines classes for use with Kerberos: a secure network authentication protocol.
A full description of Kerberos is beyond the scope of this book; so it is assumed that the reader is familar with Kerberos authentication.
The first specifies the service that is being delegated to, and the second specifies the service that is to be used by the first on behalf of the original Kerberos principal.
This class represents a Kerberos principal, specified as a principal name with an optional realm.
This class represents a Kerberos ticket: a credential used to authenticate a Kerberos principal to some Kerberos-enabled network service.
The target name of of a ServicePermission is the Kerberos principal name of the service.
The action for the ServicePermission is either “initiate” for clients or “accept” for servers.
This package defines the LoginContext class which is one of the primary JAAS classes used by application programmers.
Next, the application calls the login( ) method of the LoginContext to perform the actual login.
In order to make this kind of authentication work correctly, a fair bit of configuration is required in various files in the jre/lib/security directory of the Java installation and possibly elsewhere.
In particular, a login configuration file is required to specify which login modules are required to authenticate users for a particular application (some applications may require more than one)
A description of how to do this is beyond the scope of this reference.
See the Configuration class for a run-time representation of the login configuration information, however.
A LoginException exception of this type signals a problem logging in to the specified account.
Signals that login failed because the user’s account has expired.
Prior to Java 5.0, this exception was a direct subclass of LoginException.
An exception of this type indicates that the account for which login was attempted has been “locked” or otherwise made unavailable.
An exception of this type indicates that the account specified in a login attempt does not exist.
An instance of this class represents a login module to be used for user authentication for a particular application.
This inner class defines a “control flag” type and four specific instances of that type.
The constants defined by this class specify whether a login module is required or optional, and have the following meanings:
However, even if authentication fails for this module, the LoginContext continues to attempt authentication with any other modules in the list.
If authentication fails for this module, the LoginContext does not try any further login modules.
However, if authentication by this module does succeed, the LoginContext does not try any further login modules, but instead returns immediately.
Whether or not it succeeds, the LoginContext continues to with any other modules on the list.
This abstract class is a representation of the system and user login configuration files.
The static getConfiguration( ) method returns the global Configuration object, and the static setConfiguration( ) allows that global object to be replaced with some other implementation.
The instance method refresh( ) causes a Configuration to re-read the underlying configuration files.
LoginContext uses this class to determine which login modules to use to authenticate a user of the named application.
Application programmers do not typically need to use this class themselves.
See the documentation for your Java implementation for the syntax of the underlying login configuration files.
An exception of this type indicates a problem with the credential (e.g., the password) presented during the login attempt.
Signals that a login failed because a credential (such as a password) has expired and is no longer valid.
Prior to Java 5.0, this is a direct subclass of LoginException.
An exception of this type indicates that a credential (such as a Kerberos ticket) necessary for login could not be found.
Typically this is because an incorrect username, password, or other information was presented.
Login modules that throw this exception may provide human-readable details through the getMessage( ) method.
This is one of the most important classes in the JAAS API for application programmers: it defines the login( ) method (and the corresponding logout( ) method) that allows an application to authenticate a user.
Create a LoginContext object using one of the public constructors.
If no Subject is specified, then the LoginContext will instantiate a new one to represent the authenticated user.
If a Subject is supplied, then the LoginContext adds new entries to its sets of principals and credentials.
Once a LoginContext is successfully created, you can authenticate a user simply by calling the login( ) method, and then calling getSubject( ) to obtain the Subject object that represents the authenticated user.
When this Subject is no longer required, you can log them out by calling the logout( ) method.
Signals that something went wrong while creating a LoginContext or during the login or logout process.
The subclasses of this class represent more specific exception types.
This package defines the “service provider interface” for JAAS: it defines a single LoginModule interface that must be implemented by developers of login modules.
Developers of login modules to be used with the JAAS authentication API must implement this interface.
Because this interface is not typically used by application developers, its methods are not documented here.
This package defines classes for use with authentication schemes for on X.500 principals.
The constructor methods can accept the distinguished name in string form or in binary encoded form.
Finally, getEncoded( ) returns a binary-encoded form of the name.
It defines Source and Result interfaces to represent a source document and a result document.
This package has many important subpackages but defines only a single class XMLConstants, which, as its name implies, provides symbolic names for constants defined by various XML specifications.
This class is a repository for constants defined by various XML standards.
This package defines Java data types that correspond to certain time, date, and duration data types required by the W3C XML Schema, XQuery, and XPath standards.
This package is of primary interest to those implementing schema validators and XPath evaluators and should not be required by applications that use schemas or XPath expressions.
This class defines a typesafe enumeration for some of the constants in DatatypeConstants.
Note that it is a class, not a Java 5.0 enum type.
An instance of this class represents a length of time.
This small package defines types for working with XML namespaces.
NamespaceContext represents a mapping between namespace URIs and namespace prefixes.
QName represents a qualified name consisting of a local part and a namespace.
This interface represents a mapping between namespace URIs and the local prefixes that are bound to them.
Use getNamepaceURI( ) to obtain the URI that a prefix is bound to.
More than one prefix can be bound to the same URI, and the getPrefixes( ) method returns an Iterator that you can use to loop through all prefixes that have been associated with a given URI.
A QName represents an XML “qualified name,” such as an XML element name that has both a local name and a namespace.
Note that a QName does not always have a prefix and that the prefix, if it exists, is ignored for the purposes of the equals( ), hashCode( ), and toString( ) methods.
The static valueOf( ) method parses a QName from a string in the format of toString( ):
This package defines classes that represent XML parsers and factory classes for obtaining instances of those parser classes.
SAXParser is a SAX-based XML parser created from a SAXParserFactory.
Furthermore, this package does not define a DOM or SAX API for working with XML documents.
The DOM API is defined in org.w3c.dom, and the SAX API is defined in org.xml.sax and its subpackages.
This class defines a high-level API to an underlying DOM parser implementation.
These classes are defined by the SAX API but are useful for DOM parsers as well.
You may also want to call isNamespaceAware( ), isXIncludeAware( ) and isValidating( ) to ensure that the parser is configured with the features your application requires.
In Java 5.0, you can call reset( ) to restore the parser to its original state for reuse.
If you want to obtain an empty Document object (so that you can build the document tree from scratch, for example) call newDocument( )
See the org.w3c.dom package for information on what you can do with a Document object once you have used a DocumentBuilder to create it.
Once you have obtained a factory object, you can use the various set methods to configure the properties of the DocumentBuilder objects it will create.
These methods allow you to specify whether the parsers created by the factory will:
And you can use setXIncludeAware( ) to indicate that parsers should process XInclude markup.
Otherwise, a default implementation provided by the Java implementation will be used.
This usually means that a pluggable parser implementation has been incorrectly plugged in and the getInstance( ) method cannot locate the specified factory implementation class.
Signals a parser configuration problem that prevents a parser factory object from creating a parser object.
Call setProperty( ) if desired to set a property on the underlying parser.
A SAX parser does not build a document tree to describe an XML document like a DOM parser does.
Instead, it describes the XML document to your application by invoking methods on an object the application provides.
For example, when the parser encounters an XML tag in a document, it parses the tag, and calls the startElement( ) method to tell you about it.
And when it finds a run of plain text, it passes that text to the characters( ) method.
In Java 5.0, the reset( ) method restores a SAXParser to its original state so that it can be reused.
Instead of using one of the parse( ) methods of this class, you can also call getXMLReader( ) to obtain the underlying XMLReader object and work with it directly to parse the desired document.
Obtain a SAXParserFactory by calling the newInstance( ) method which instantiates the default SAXParserFactory subclass provided with your Java implementation, or instantiates some other SAXParserFactory that has been “plugged in”
Once you have a SAXParserFactory object, you can use setValidating( ) and setNamespaceAware( ) to specify whether the parsers it creates will be validating parsers or not and whether they will know how to handle XML namespaces.
You may also call setFeature( ) to set a feature of the underlying parser implementation.
See http://www.saxproject.org for the names of standard parser features that can be enabled and disabled with this method.
In Java 5.0, call setXIncludeAware( ) to specify that created parsers will recognize XInclude markup.
Use setSchema( ) to specify a W3C XML Schema against which parsers should validate the document.
Once you have created and configured your factory object, simply call newSAXParser( ) to create a SAXParser object.
This pluggability is provided by the getInstance( ) method, which follows the following steps to determine which SAXBuilderFactory subclass to use:
Otherwise, a default implementation provided by the Java platform will be used.
The Source interface is a very generic description of a document source.
Three concrete implementations that represent documents in text form, as DOM trees, and as sequences of SAX parser events are defined in the three subpackages of this package.
The Result interface is a similarly high-level description of what form the source document should be transformed into.
The three subpackages define three Result implementations that represent XML documents as streams or files, as DOM trees, and as sequnces of SAX parser events.
The implementation provides a default factory that represents an XSLT engine.
Documents are actually transfomed from Soruce to Result with a Transformer object, which is obtained from a Templates object, or directly from a TransformerFactory.
Interfaces public interface ErrorListener; public interface Result; public interface Source; public interface SourceLocator; public interface Templates; public interface URIResolver;
This interface defines methods that Transformer and TransformerFactory use for reporting warnings, errors, and fatal errors to an application.
To use an ErrorListener, an application must implement this interface and pass an implementing object to the setErrorListener( ) method of Transformer or TransformerFactory.
A Transformer or TransformerFactory is not required to continue processing after reporting a nonrecoverable error with an invocation of the fatalError( ) method.
This class defines string constants that hold the names of the attributes of an <xsl:output> tag in an XSLT stylesheet.
This interface represents, in a very general way, the result of an XML transformation.
All other methods related to the result are the responsibility of the concrete implementation of this interface.
See the DOMResult, SAXResult and StreamResult implementations in the three subpackages of this package.
This interface represents, in a very general way, the source of an XML document.
This is useful for resolving relative URLs and for error reporting even when the document is not read directly from a URL.
All other methods related to the document source are the responsibility of the concrete implementation of this interface.
See the DOMSource, SAXSource and StreamSource implementations in the three subpackages of this package.
This interface defines methods that return the system and public identifiers of an XML document, and return a line number and column number within that document.
Note, however that system and public identifiers are not always available for a document, and so getSystemId( ) and getPublicId( ) may return null.
Also, a Tranformer is not required to track line and column numbers precisely, or at all, so.
If they return a value other than -1, it should be considered an approximation to the actual value.
This interface represents a set of transformation instructions for transforming a Source document into a Result document.
Once you have a Templates object, you can use the newTransformer( ) method to create a Transformer object for applying the templates to a Source to produce a Result document.
These properties are specified in an XSLT stylesheet with the <xsl:output> element.
The constants defined by the OutputKeys are legal output property names.
The returned Properties object contains explicitly properties directly, and contains default values in a parent Properties object.
This means that if you query a property value with getProperty( ), you’ll get an explicitly specified value of a default value.
On the other hand, if you query a property with the get( ) method (inherited by Properties from its superclass) you’ll get a property value if it was explictly specified in the stylesheet, or null if it was not specified.
A Templates object can be used to create any number of Transformer objects.
Objects of this type are used to transform a Source document into a Result document.
Once you have a Transformer object, you may need to configure it before using it to transform documents.
OutputKeys defines constants that represent the set of standard output property names.
The output properties you specify with these methods override any output properties specified (with an <xsl:output> tag) in the Templates object.
Use setParameter( ) to supply values for any top-level parameters defined (with <xsl:param> tags) in the stylesheet.
Note that if the name of any such parameter is a qualified name, then it appears in the stylesheet with a namespace prefix.
You can’t use the prefix with the setParameter( ) method, however, and you must instead specify the parameter name using the URI of the namespace within curly braces followed by the local name.
If no namespace is involved, then you can just use the simple name of the parameter with no curly braces or URIs.
Once you have created and configured a Transformer object, use the transform( ) method to perform a document transformation.
This method transforms the specified Source document and creates the transformed document specified by the Result object.
In Java 5.0, you can reset( ) a Transformer to restore it to its original state and prepare it for reuse.
You can reuse a Transformer object and call transform( ) any number of times (just not concurrently)
The output properties and parameters you specify are not changed by calling the transform( ) method, and can be reused.
This may occur, for exmaple, if there is a syntax error in the XSL stylesheet that contains the transformation instructions.
Use the inherited getLocator( ) method to obtain a SourceLocator that describes the document location at which the exception occurred.
Call getLocator( ) to obtain a SourceLocator object that describes the document location at which the exception occured.
An instance of this abstract class represents a document “transformation engine” such as an XSLT processor.
A TransformerFactory is used to create Transformer objects that perform document transformations, and can also be used to process transformation instructions (such as XSLT stylesheets) into compiled Templates objects.
Obtain a TransformerFactory instance by calling the static newInstance( ) method.
The default TransformerFactory implementation provided with the Java distribution transforms XML documents using XSL stylesheets.
You can configure a TransformerFactory instance by calling setErrorListener( ) and setURIResolver( ) to specify an ErrorListener object and a URIResolver object to be used by the factory when reading and parsing XSL stylesheets.
The default engine supplied by Sun does not define any attributes.
The getFeature( ) method is used to test whether the factory supports a given feature.
For uniqueness, feature names are expressed as URIs, and each of the Source and Result implementations defined in the three subpackages of this package define a FEATURE constant that specifies a URL that you can use to test whether a TransformerFactory supports that particular Source or Result type.
Once you have obtained and configured your TransformerFactory object, you can use it in several ways.
If you call the newTransformer( ) method that takes no arguments, you’ll obtain a Transformer object that transforms the format or representation of an XML document without transforming its content.
Another way to use a TransformerFactory is to call the newTemplates( ) method, passing in a Source object that represents an XSL stylesheet.
This produces a Templates object, which you can use to obtain a Transformer object that applies the stylesheet to transform document content.
Alternatively, if you do not plan to create more than one Transformer object from the Templates object, you can combine the two steps and simply pass the Source object representing the stylesheet to the one-argument version of newTransformer( )
If you want to process an XML document using the stylesheet that it defines itself, use this method to obtain a Source object that you can pass to newTransformer( ) to create the Transformer object that you can use to transform the document.
This error class signals a fatal problem while creating a TransformerFactory.
This interface allows an application to tell a Transformer how to resolve the URIs that appear in an XSLT stylesheet.
If you pass a URIResolver to the setURIResolver( ) method of a Transformer or TransformerFactory then when the Transformer or TransformerFactory encounters a.
URI, it first passes that URI, along with the base URI to the resolve( ) method of the URIResolver.
If resolve( ) returns a Source object, then the Transformer will use that Source.
If a Transformer or TransformerFactory has no URIResolver registered, or if the resolve( ) method returns null, then the tranformer or factory will attempt to resolve the URI itself.
This package contains Source and Result implementations that work with DOM document trees and subtrees.
This class extends SourceLocator to define a method for retrieving a DOM Node object, which is typically used to indicate the source of an error in the transformation process.
This class is a Result implementation that writes XML content by generating a DOM tree to represent that content.
If you do not specify a node, the DOMResult will create a new Document node when it creates the result tree.
In Java 5.0, you can also pass two Node objects to the constructor: these specify the parent node of the result tree and the child of that parent before which the result tree should be inserted.
This class is a Source implementation that reads an XML document from a DOM document tree or subtree.
When possible, it is also useful to provide a system id (a filename or URL) for use in error messages and for resolving relative URLs contained in the document.
This package defines Source and Result implementations that work with SAX events.
In addition, it includes an extension to the TransformerFactory class that has additional methods for returning TemplatesHandler and TransformerHandler objects.
These objects implement SAX handler interfaces and are able to work with a SAX parser object to turn a series of SAX parse events into a Templates object or into a Result document.
This class is a Result implementation that describes the content of a transformed document by triggering the methods of the specified ContentHandler.
This class is a Source implementation that describes a document represented as a series of SAX event method calls.
If no XMLReader or XMLFilter is specified, then the Transformer object will a default XMLReader.
Note that since an InputSource is required, a SAXSource does not behave significantly differently than a StreamSource unless an XMLFilter is used.
This class extends TransformerFactory to define additional factory methods that are useful when working with documents that are represented as sequences of SAX events.
Use the FEATURE_XMLFILTER constant with getFeature( ) to determine if the newXMLFilter( ) methods are also supported.
An object that implements this interface can be used to receive method calls from some source of SAX events and process those events (as a XSL stylesheet) into a Templates object.
When parse( ) returns, call the getTemplates( ) method to obtain the Templates object.
Next, call the setResult( ) method to specify a Result object that describes the result document you’d like the transformation to produce.
You may also call getTransformer( ) to get the Transformer object associated with this TransformerHandler if you need to set output properties or parameter values for the transformation.
Now, register the TransformerHandler with the SAXReader or SAXFilter object by calling setContentHandler( ), setDTDHandler( ), and setProperty( )
Finally, invoke one of the parse( ) methods on your XMLReader or XMLFilter object.
This will cause the reader or filter to start parsing the source document and translating it into method calls on the TransformerHandler.
This package contains Source and Result implementations that work with files and streams.
This class is a Result implementation that writes a textual representation of a transformed document to stream or file.
Because XML documents define their own encoding, it is usually preferable to construct a StreamResult using a File or OutputStream instead of a character-based Writer which may use a different encoding than that specified within the document.
This class is a Source implementation that reads the textual format of an XML document from a file, byte stream, or character stream.
Because XML documents declare their own encoding, it is preferable to create a StreamSource object from an InputStream instead of from a Reader, so that the XML processor can correctly handle the declared encoding.
The system id is required if the XML file to be processed includes relative URLs to be resolved.
This package contains classes for validating XML documents against W3C XML Schema definitions.
Implementations may also support additional schema types, such as RELAX NG.
Typical usage begins with the SchemaFactory class, which parses schema specifications into immutable Schema objects.
Next, the Schema object is used to create a Validator with which a document may be validated.
A Schema is an immutable opaque parsed representation of a schema.
Schema objects don’t perform validation themselves; instead, they are factories for Validator and ValidatorHandler objects that can be used to validate individual documents.
A SchemaFactory parses the textual representation of a schema into a Schema object.
Obtain a SchemaFactory with the newInstance( ) method, passing a string that identifies the type of schema you want to parse.
For schemas in the W3C XML Schema language, you may also specify an array of Source objects that contain the schema definition.
If you call newSchema( ) with no arguments, a special Schema object is returned that expects the document to specify the location of its own W3C XML Schema.
This class is used by implementations of the validation API to produce a SchemaFactory object for a specified schema type.
A TypeInfoProvider provides information about the type of the element or attribute currently being processed by a ValidatorHandler.
This type information is obtained by validating document content against a schema and may be useful to the ContentHandler to which the ValidatorHandler dispatches its method calls.
A Validator object validates an XML document against the Schema from which the Validator was created.
The document validation process can also be used to augment the source document by adding the default values of unspecified attributes.
If you want to capture this augmented form of the document, pass a Result object to the two-argument version of validate( )
If the source is a SAXSource, the result must be a SAXResult, and if the source is a DOMSource, the result must be a DOMResult object.
If the document is valid, the validate( ) method returns normally.
Validation exceptions are first passed to the error handler methods, which may throw the exception or handle them in some other way, such as printing a message.
If the error handler does not throw an exception, the validate( ) method attempts to continue validation.
The default error handler ignores exceptions passed to its warn( ) method but throws exceptions passed to its error( ) and fatalError( ) methods.
The Validator class can be used to validate a SAXSource, but ValidatorHandler provides lower-level access to the SAX API.
If the document is not valid, one of the ContentHandler methods throws a SAXException that propagates up to your code.
ValidatorHandler can be used as a filter for SAX parsing events.
If you pass a ContentHandler to setContentHandler( ), the ValidatorHandler augments the source document with attribute defaults from the schema and invokes the appropriate callback methods on the ContentHandler you supply.
This package defines types for the evaluation of XPath expressions in the context of an XML document.
XPath is a language for describing a “path” to a node or set of nodes within an XML document.
Details of the XPath grammar are beyond the scope of this reference.
A typical use of this package begins with the XPathFactory, an instance of which is used to create an XPath object.
After configuring the XPath object as desired, you can use it to evaluate XPath expressions directly or to compile XPath expressions into XPathExpression objects for later use.
An XPath object is used to compile or evaluate an XPath expression.
After creating and configuring an XPath object, you can use the compile( ) method to compile an XPath expression for later evaluation, or you can use one of the evaluate( ) methods to compile and evaluate an expression directly.
All expect a String containing an XPath expression as their first argument.
The second argument is the document or portion of a document to evaluate the expression against.
These versions of the method first parse the document and build a DOM (or other object model) tree.
The other two versions of evaluate( ) expect an Object as the second argument.
The object passed should be a DOM (or other object model) object representing the document or some portion of it.
For the org.w3c.dom object model, this might be a Document, DocumentFragment, Node, or NodeList object.
The final difference between evaluate( ) methods is the presence or absence of a third argument.
The two-argument versions of evaluate( ) return the result of the expression.
The three-argument versions expect a third argument that specifies the desired return type and return an Object of an appropriate type.
This is the common superclass of all XPath-related exception types.
If an XPath expression is to be evaluated more than once, it is not efficient to call the XPath.evaluate( ) method repeatedly.
Instead, compile the expression to an XPathExpression using the XPath.compile( ) method and then evaluate it using one of the evaluate( ) methods of XPathExpression.
The evaluate( ) methods of XPathExpression behave just like the corresponding methods of XPath.
Exceptions of this type indicate an error while compiling or evaluating an XPath expression.
See the compile( ) and evaluate( ) methods of XPath and XPathExpression.
The XPathFactory class is a factory for creating XPath expression evaluators.
Call the noargument version of newInstance( ) to obtain an XPathFactory object that creates XPath object to work with DOM documents.
After creating and configuring an XPathFactory object, use the newXPath( ) method to create one or more XPath objects for actually evaluating XPath expressions.
This exception is thrown by methods of XPathFactory to indicate that a specified object model or feature is not supported.
This interface defines the invocation API for user-defined XPath functions.
Arguments are passed to the evaluate( ) method as a java.util.List and the return value should be an Object.
Exceptions of this type may be thrown by user-defined XPathFunction implementations.
This interface defines a single method to return the XPathFunction with the specified qualified name and specified arity (number of arguments)
Note that the function resolvers are invoked only for functions defined in an external namespace, so they cannot be used to override the meaning of XPath’s built-in functions or to add new core functions to the XPath language.
This interface defines a single method to return the Object value of a variable identified by a qualified name.
The value of a named variable is allowed to change between XPath evaluations, but implementations of this interface must ensure that no variable changes during the evaluation of an expression.
This package defines the Java binding to the core and XML modules of the DOM API defined by the World Wide Web Consortium (W3C)
This package includes methods that allow document trees to be traversed, examined, modified, and built from scratch.
All nodes in a document tree implement this interface, and it defines the basic methods for traversing and modifying the tree of nodes.
Most of the other interfaces in the package are extensions of Node that represent specific types of XML content.
The most important and commonly used of these subinterfaces are Document, Element, and Text.
A Document object serves as the root of the document tree and defines methods for searching the tree for elements with a specified tag name or ID attribute.
The Element interface represents an XML element or tag and has methods for manipulating the element’s attributes.
The Text interface represents a run of plain text within an Element and has methods for querying or altering that text.
NodeList and DOMImplementation do not extend Node but are also important interfaces.
This package is an endorsed standard, which means that it is defined outside of Sun Microsystems and the Java Community Process but has been adopted as part of the Java platform.
Note that Java 5.0 also adopts the bootstrap, events, and ls (load/save) subpackages.
Those subpackages are not documented in this book because they are only tangentially used by the rest of the Java platform.
An Attr object represents an attribute of an Element node.
Attr objects are associated with Element nodes, but are not directly part of the document tree: the getParentNode( ) method of an Attr object always returns null.
Use getOwnerElement( ) to deterine which Element an Attr is part of.
You can obtain an Attr object by calling the getAttributeNode( ) method of Element, or you can obtain a NamedNodeMap of all Attr objects for an element with the getAttributes( ) method of Node.
The getValue( ) method returns the attribute value as a single string.
If you want to know the precise composition of the attribute however, you can examine the children of the Attr node: they may consist of Text and/or EntityReference nodes.
In most cases the easiest way to work with attributes is with the getAttribute( ) and setAttribute( ) methods of the Element interface.
This interface represents a CDATA section in an XML document.
CDATASection is a subinterface of Text and does not define any methods of its own.
The content of the CDATA section is available through the getNodeValue( ) method inherited from Node, or through the getData( ) method inherited from CharacterData.
Although CDATASection nodes can often be treated in the same way as Text nodes, note that the Node.normalize( ) method does not merge adjacent CDATA sections.
This interface is a generic one that is extended by Text, CDATASection (which extends Text) and Comment.
Any node in a document tree that implements CharacterData also implements one of these more specific types.
This interface exists simply to group the string manipulation methods that these text-related node types all share.
The appendData( ), deleteData( ), insertData( ), and replaceData( ) methods mutate the data by appending a string to the end, deleting region, inserting a string at the specified location, and replacing a region with a specified string.
A Comment node represents a comment in an XML document.
This content may be manipulated using the various methods inherited from CharacterData.
This interface represents a DOM document, and an object that implements this interface serves as the root of a DOM document tree.
Most of the methods defined by the Document interface are “factory methods” that are used to create various types of nodes that can be inserted into this document.
Note that there are two versions of the methods for creating attributes and elements.
The methods with “NS” in their name are namespace-aware and require the attribute or element name to be specified as a combination of a namespace URI and a local name.
You’ll notice that throughout the DOM API, methods with “NS” in their names are namespace-aware.
The Element interface defines methods by the same names that search only within the subtree defined by an Element.
This is useful when you use an ID attribute to uniquely identify certain tags within an XML document.
Note that this method does not search for attributes that are named “id” or “ID”
It searches for attributes whose XML type (as declared in the document’s DTD) is ID.
Such attributes are often named “id”, but this is not required.
Note, however that this does not mean that a Document node has only one child.
The getDoctype( ) method returns the DocumentType object (or null if there isn’t one) that represents the document’s DTD.
More specifically, it represents one or more adjacent document nodes, and all of the descendants of each.
DocumentFragment nodes are never part of a document tree, and getParentNode( ) always returns null.
Although a DocumentFragment does not have a parent, it can have children, and you can use the inherited Node methods to add child nodes (or delete or replace them) to a DocumentFragment.
DocumentFragment nodes exhibit a special behavior that makes them quite useful: when a request is made to insert a DocumentFragment into a document tree, it is not the DocumentFragment node itself that is inserted, but each of the children of the DocumentFragment instead.
This makes DocumentFragment useful as a temporary placeholder for a sequence of nodes that you wish to insert, all at once, into a document.
Because the DTD is not part of the document itself, a DocumentType object is not part of DOM document tree, even though it extends the Node interface.
If a Document has a DTD, then you may obtain the DocumentType object that represents it by calling the getDoctype( ) method of the Document object.
You can use this NamedNodeMap to lookup an Entity object by name.
Similarly, getNotations( ) returns a read-only NamedNodeMap that allows you to look up a Notation object declared in the DTD by name.
DocumentType does not provide access to the bulk of a DTD, which usually consists of element and attribute delcarations.
Future versions of the DOM API may provide more details.
This Level 3 interface defines methods for querying and setting the values of named parameters.
Those configuration objects affect the way documents are loaded and saved, but the package is beyond the scope of this book.
See the DOM specification for details on the available parameters.
This Level 3 interface describes an error that occurs while processing a document (such as when loading, saving, validating or normalizing it)
An object that implements this interface is passed to the registered DOMErrorHandler, if any.
The constants defined by this interface represent error severity levels.
This Level 3 interface defines a handler for DOMError objects that represent errors while processing an XML document.
Register an object that implements this interface by setting it as the value of the “error-handler” property through the DOMConfiguration interface.
An instance of this class is thrown whenever an exception is raised by the DOM API.
Unlike many Java APIs, the DOM API does not define specialized subclasses to define different categories of exceptions.
The value of this field will be one of the constants defined by this class, which have the following meanings:
INDEX_SIZE_ERR Indicates an out-of-bounds error for an array or string index.
DOMSTRING_SIZE_ERR Indicates that a requested text is too big to fit into a String object.
Exceptions of this type are intended for DOM implementations for other languages and should not occur in Java.
WRONG_DOCUMENT_ERR Indicates an attempt to use a node with a document that is different than the document that created the node.
Entity, EntityReference, and Notation nodes, and all of their descendants are read-only.
NOT_FOUND_ERR Indicates that a node was not found where it was expected.
NOT_SUPPORTED_ERR Indicates that a method or property is not supported in the current DOM implementation.
INVALID_STATE_ERR Indicates an attempt to use an object that is not yet, or is no longer, in a state that allows such use.
SYNTAX_ERR Indicates that a specified string contains a syntax error.
Exceptions of this type are not raised by the core module of the DOM API described here.
INVALID_ACCESS_ERR Indicates an attempt to access an object in a way that is not supported by the implementation.
This interface defines methods that are global to an implementation of the DOM rather than specific to a particular Document object.
Obtain a reference to the DOMImplementation object that represents your implementation by calling the getImplementation( ) method of any Document object.
The DOM standard includes a number of optional modules, but the Java platform has not adopted the subpackages of this package that define the API for those optional modules, and therefore the DOM implementation bundled with a Java implementation is not likely to support those modules.
It also defines a shortcut newDocument( ) method for creating empty Document objects to populate.
This Level 3 interface represents a fixed-size, read-only list (or array) of DOMImplementation objects.
This Level 3 interface is designed for use by DOM implementors.
This Level 3 interface represents the location at which a DOMError occurred.
This Level 3 interface represents a fixed-size, read-only list of strings.
This interface represents an element (or tag) in an XML document.
When working with namespaces, you will probably prefer to use the namespace-aware methods defined by the Node interface.
Use getNamespaceURI( ) to get the namespace URI of the element, and use getLocalName( ) to the local name of the element within that namespace.
You can also use getPrefix( ) to query the namespace prefix, or setPrefix( ) to change the namespace prefix (this does not change the namespace URI)
The remaining methods of the Element interface are for querying and setting attribute values, testing the existence of an attribute, and removing an attribute from the Element.
There are a confusing number of methods to perform these four basic attribute operations.
If an attribute-related method has “NS” in its name, then it is namespace-aware.
If it has “Node” in its name, then it works with Attr objects rather than with the simpler string representation of the attribute value.
If your document may include entity references in attribute values, then you may need to use the Attr interface because the expansion of such an entity reference can result in a subtree of nodes beneath the Attr object.
Whenver possible, however, it is much easier to work with the methods that treat attribute values as plain strings.
Note also that in addition to the attribute methods defined by the Element interface you can also obtain a NamedNodeMap of Attr objects with the getAttributes( ) method of the Node interface.
Finally, note also that getAttribute( ) and related methods and hasAttribute( ) and related methods return the value of or test for the existance of both explicitly specified attributes, and also attributes for which a default value is specified in the document DTD.
If you need to determine whether an attribute was explicitly specified in the document, obtain its Attr object, and use its getSpecified( ) method.
This interface represents an entity defined in an XML DTD.
The name of the entity is specified by the getNodeName( ) method inherited from the Node interface.
The entity content is represented by the child nodes of the Entity node.
The methods defined by this interface return the public identifier and system identifier for external entities, and the notation name for unparsed entities.
Note that Entity nodes and their children are not part of the document tree (and the getParentNode( ) method of an Entity always returns null)
Instead a document may contain one or more references to an entity: see the EntityReference interface.
Entities are defined in the DTD (document type definition) of a document, either as part of an external DTD file, or as part of an “internal subset” that defines local entities that are specific to the current document.
The DocumentType interface has a getEntities( ) method that returns a NamedNodeMap mapping entity names to Entity nodes.
This is the only way to obtain an Entity object: because they are part of the DTD, Entity nodes never appear within the document tree itself.
Entity nodes and all descendants of an Entity node are read-only and cannot be edited or modified in any way.
This interface represents a reference from an XML document to an entity defined in the document’s DTD.
Character entities and predefined entities such as &lt; are always expanded in XML documents and do not create EntityReference nodes.
Note also that some XML parsers expand all entity references.
Documents created by such parsers do not contain EntityReference nodes.
The getNodeName( ) method of the Node interface provides the name of the referenced entity.
The getEntities( ) method of the DocumentType interface provides a way to look up the Entity object associated with that name.
In this case, the EntityReference is a reference to a named entity whose content is not known, and it has no children.
On the other hand, if the DocumentType does contain an Entity node with the specified name, then the child nodes of the EntityReference are a copy of the child nodes of the Entity, and represent the expansion of the entity.
The children of an EntityReference may not be an exact copy of the children of an Entity if the entity’s expansion includes namespace prefixes that are not bound to namespace URIs.
Like Entity nodes, EntityReference nodes and their descendants are read-only and cannot be edited or modified.
The NamedNodeMap interface defines a collection of nodes that may be looked up by name or by namespace URI and local name.
Use getNamedItem( ) to look for and return a node whose getNodeName( ) method returns the specified value.
Use getNamedItemNS( ) to look for and return a node whose getNamespaceURI( ) and getLocalName( ) methods return the specified values.
A NamedNodeMap is a mapping from names to nodes, and does not order the nodes in any particular way.
Nevertheless, it does impose an arbitrary ordering on the nodes and allow them to be looked up by index.
Use getLength( ) to find out how many nodes are contained in the NamedNodeMap, and use item( ) to obtain the Node object at a specified index.
If a NamedNodeMap is not read-only, you can use removeNamedItem( ) and removeNamedItemNS( ) to remove a named node from the map, and you can use setNamedItem( ) and setNamedItemNS( ) to add a node to the map, mapping to it from its name or its namespace URI and local name.
NamedNodeMap objects are “live,” which means that they immediately reflect any changes to the document tree.
For example, if you obtain a NamedNodeMap that represents the.
NamedNodeMap is returned only by relatively obscure methods of the DOM API.
The most notable use is as the return value of the getAttributes( ) method of Node.
It is usually easier to work with attributes through the methods of the Element interface, however.
This Level 3 interface represnts a fixed-size, read-only list of element or attribute names and their namespace URI.
All objects in a DOM document tree (including the Document object itself) implement the Node interface, which provides basic methods for traversing and manipulating the tree.
It is sometimes useful to call hasChildNodes( ) to determine whether a node has children or not.
It provides a quick way to jump to the root of the document tree.
Several methods allow you to add children to a tree or alter the list of children.
For all of these methods, if the node to be appended or inserted is already part of the document tree, it is first removed from its current parent.
Use cloneNode( ) to produce a copy of this node.
Pass true if you want all descendants of this node to be cloned as well.
Every object in a document tree implements the Node interface, but also implements a more specialized subinterface, such as Element or Text.
The getNodeType( ) method provides an easy way to determine which subinterface a node implements: the return value is one of the _NODE constants defined by this class.
You might use the return value of getNodeType( ) in a switch statement, for exmaple, to determine how to process a node of unknown type.
Note that subinterfaces typically define specialized methods (such as the getTagName( ) method of Element and the getData( ) method of Text) for obtaining this same information.
Note also that unless a node is read-only, you can use setNodeValue( ) to alter the value associated with the node.
In documents that use namespaces, the getNodeName( ) method of a Element or Attr node returns the qualified node name, which may include a namespace prefix.
In documents that use namespaces, you may prefer to use the namespace-aware methods getNamespaceURI( ), getLocalName( ) and getPrefix( )
Element nodes may have a list of attributes, and the Element interface defines a number of methods for working with these attributes.
In addition, however, Node defines the hasAttributes( ) method to determine if a node has any attributes.
If it does, they can be retrieved with getAttributes( )
Text content in an XML document is represented by Text nodes, which have methods for manipulating that textual content.
The Node interface defines a normalize( ) method which has the specialized purpose of normalizing all descendants of a node by deleting empty Text nodes and coalescing adjacent Text nodes into a single combined node.
Document trees usually start off in this normalized form, but modifications to the tree may result in non-normalized documents.
Most of the other interfaces in this package extend Node.
This interface represents a read-only ordered collection of nodes that can be interated through.
The elements of a NodeList are always valid Node objects: a NodeList never contains null elements.
For example, if you have a NodeList that represents the children of a specific node, and you then delete one of those children, the child will be removed from your NodeList.
Be careful when looping through the elements of a NodeList if the body of your loop makes changes to the document tree (such as deleting nodes) that may affect the contents of the NodeList!
This interface represents a notation declared in the DTD of an XML document.
In XML notations are used to specify the format of an unparsed entity or to formally declare a processing instruction target.
The getNodeName( ) method of the Node interface returns the name of the notation.
The getNotations( ) method of the DocumentType interface returns a NamedNodeMap of Notation objects declared in the DTD and provides a way to look up Notation objects by notation name.
Because notations appear in the DTD and not the document itself, Notation nodes are never part of the document tree, and the getParentNode( ) method always returns null.
Similarly, since XML notation declarations never have any content, a Notation node never has children and getChildNodes( ) always returns null.
Notation objects are read-only and cannot be modified in any way.
This interface represents an XML processing instruction (or PI) which specifies an arbitrary string of data to a named target processor.
The getTarget( ) and getData( ) methods return the target and data portions of a PI, and these values can also be obtained using the getNodeName( ) and getNodeValue( ) methods of the Node interface.
You can alter the data portion of a PI with setData( ) or with the setNodeValue( ) method of Node.
A Text node represents a run of plain text that does not contain any XML markup.
Plain text appears within XML elements and attributes, and Text nodes typically appear as children of Element and Attr nodes.
Text nodes inherit from CharacterData, and the textual content of a Text node is available through the getData( ) method inherited from CharacterData or through the getNodeValue( ) method inherited from Node.
Text nodes may be manipulated using any of the methods inherited from CharacterData.
The Text interface defines one method of its own: splitText( ) splits a Text node at the specified character position.
The method changes the original node so that it contains only the text up to the specified position.
Then it creates a new Text node that contains the text from the specified position on and inserts that new node into the document tree immediately after the original one.
The Node.normalize( ) method reverses this process by deleting emty Text nodes and merging adjacent Text nodes into a single node.
This Level 3 interface represents information about the type of an Element or Attr node.
Obtain a TypeInfo object by calling the getSchemaTypeInfo( ) method of an Element or Attr.
Note that TypeInfo information is only available if the document has been validated against a W3C XML Schema.
The methods of TypeInfo return the name and namespace of the element or attribute type.
The constants defined by the interface specify different derivation techniques for types.
This Level 3 interface defines a handler that is invoked when a node on which userspecified data has been registered is adopted, cloned, deleted, imported or renamed.
These packages were added in Java 1.4 as “endorsed standards.” This means that they are part of the Java platform, but are not defined by Sun, which is why they have the “org.xml” prefix.
This is the core package for SAX (Simple API for XML) parsing of XML documents.
These “events” are actually method calls made on one or more handler objects that the application has registered with the parser.
The XMLReader interface defines the API that must be implemented by a SAX parser.
ContentHandler, ErrorHandler, EntityResolver, and DTDHandler are interfaces that define handler objects.
An application registers objects that implement one or more of these interfaces with the XMLReader.
Interfaces public interface AttributeList; public interface Attributes; public interface ContentHandler; public interface DocumentHandler; public interface DTDHandler; public interface EntityResolver;
This interface represents a list of attributes of an XML element and includes information about the attribute names, types, and values.
If the SAX parser has read a DTD or schema for the document, this list of attributes will include attributes that are not explicitly specified in the document but which have a default value specified in the DTD or schema.
The most commonly used method is getValue( ) which returns the value of a named attribute (there is also a version of this method that returns the value of a numbered attribute; it is discussed later)
If the SAX parser is not processing namespaces, you can use the one-argument version of getValue( )
Otherwise, use the two argument version to specify the URI that uniquely identifies the namespace, and the “local name” of the desired attribute within that namespace.
The getType( ) methods are similar, except that they return the type of the named attribute, rather than its value.
In XML documents the attributes of a tag can appear in any order.
Attributes objects make no attempt to preserve the document source order of the tags.
Nevertheless, it does impose an ordering on the attributes so that you can loop through them.
There are versions of getValue( ) and getType( ) that return the value and type of the attribute at a specified position in the list.
You can also query the name of the attribute at a specified position, although the way you do this depends on whether the parser handles namespaces or not.
If it does not process namespaces, use getQName( ) to get the name at a specified position.
Otherwise, use getURI( ) and getLocalName( ) to obtain the URI and local name pair for the numbered attribute.
Note that getQName( ) may return the empty string when namespace processing is on, and getLocalName( ) may return the empty string if namespace processing is off.
This interface is the key one for XML parsing with the SAX API.
An XMLReader tells your application about the content of the XML document it is parsing by invoking the various methods of the ContentHandler interface.
In order to parse documents with SAX, you must implement this interface to define methods that take whatever actions are necessary when they are invoked by the parser.
Because this interface is so critical to the SAX API, the methods are explained individually below:
Locator defines methods that return the current line and column number of the document being parsed, and if the parser supplies a Locator object, it guarantees that its methods will return valid values during any other ContentHandler invocations that follow.
A ContentHandler can call the methods of this object when printing error messages, for example.
Both are passed three arguments describing the name of the tag: if the parser is doing namespace processing, then the first two arguments of both methods return the URI that uniquely identifies the namespace, and the local name of the tag within that namespace.
If the parser is not doing namespace parsing, then the third argument provides the full name of the tag.
In addition to these tag name arguments, startElement( ) is also passed an Attributes object that describes the attributes of the tag.
The text is contained within the specified character array, at the specified start position, and continuing for the specified number of characters.
An application can implement this interface to receive notification of DTD-related events from the parser.
It implements ContentHandler and three other interfaces that are commonly used with the XMLReader class and provides empty implementations of all their methods.
Applications can subclass DefaultHandler only need to override the methods they care about.
This is usually more convenient that implementing the interfaces directly.
This interface defines methods that an application can implement in order to receive notification from a XMLReader about notation and unparsed entity declarations in the DTD of an XML document.
Notations and unparsed entities are two of the most obscure features of XML, and they (and this interface) are not frequently used.
Unparsed entities can appear later in a document as the value of an attribute, so if your application cares about them, it should somehow make a note of the entity name and system id for use later.
An application can implement this interface to help the parser resolve external entities, if required.
If you pass an EntityResolver instance to the setEntityResolver( ) method of an XMLReader, then the parser will call the resolveEntity( ) method whenever it needs to read an external entity.
This method should use the public identifier or system identifier to return an InputSource that the parser can use to read the content of the external entity.
If the external entity includes a valid system identifier, then the parser can read it directly without the need for an EntityResolver, but this interface is still useful for mapping network URLs to locally cached copies, or for mapping public identifiers to local files, for example.
Before parsing an XML document, an application should provide an implementation of this interface to the XMLReader by calling the setErrorHandler( ) method of the XMLReader.
If the reader needs to issue a warning or report an error or fatal error, it will call the appropriate method of the ErrorHandler object you supplied.
The error( ) method is used to report recoverable errors, such as document validity problems.
The fatalError( ) method is used to report nonrecoverable errors, such as well-formedness problems.
An ErrorHandler object may respond to warnings, errors, and fatal errors however it likes, and may throw exceptions from these methods.
The warning( ) and error( ) methods of a DefaultHandler do nothing, and the fatalError( ) method throws the SAXParseException object that was passed to it.
This simple class describes a source of input for an XMLReader.
Create an InputSource( ) with one of the constructor methods, specifying the system identifier (a URL) of the file to be parsed, or specifying a byte or character stream that the parser should read the document from.
In addition to calling the constructor, you may also want to call setSystemId( ) to specify and/or setPublicId( ) to provide identifiers for the document being parsed.
Having a filename or URL is useful if an error arises, and your ErrorHandler object needs to print an error message, for example.
If you specify the document to parse as a URL or as a byte stream, you can also call setEncoding( ) to specify the character encoding of the document.
The parser will use this encoding value if you supply it, but XML documents are supposed to describe their own encoding in the <?xml?> declaration, so the parser ought to be able to determine the encoding of the document even if you do not call setEncoding( )
This class allows you to specify more than one input source.
If that method returns false, then it calls getByteStream( ) and uses the InputStream it returns.
Finally, if no character or byte stream is found, then the parser will call getSystemId( ) and will attempt to read an XML document from the returned URL.
An XMLReader will never use any of the set( ) methods to modify the state of an InputSource object.
The ContentHandler can use methods of this Locator object from within any of the other methods called by the parser in order to determine what document the parser is parsing and what line number and column number it is parsing at.
This information is particularly useful when displaying error or warning messages, for example.
The parser is allowed to return an approximate value from these methods, or to return -1 if it does not track line and column numbers.
This class serves as the general superclass for more specific types of SAX exceptions.
The parse( ) method of an XMLReader can throw an exception of this type.
The application can also throw a SAXException from any of the handler methods (of ContentHandler and ErrorHandler for example) invoked by the parser.
Signals that the parser does not recognize a feature or property name.
See the setFeature( ) and setProperty( ) methods of XMLReader.
Signals that the parser does recognizes, but does not support a named feature or property.
The property or feature may be entirely unsupported, or it may be read-only, in which case this exception will be thrown by the setFeature( ) or setProperty( ) method, but not by the corresponding getFeature( ) or getProperty( ) method of XMLReader.
An exception of this type signals an XML parsing error or warning.
SAXParseException includes methods to return the system and public identifiers of the document in which the error or warning occurred, as well as methods to return the approximate line number and column number at which it occurred.
A parser is not required to obtain or track all of this information, and the methods may return null or -1 if the information is not available.
Exceptions of this type are usually thrown by the application from the methods of the ErrorHandler interface.
The parser never throws a SAXParseException itself, but does pass an appropriately initialized instance of this class to each of the ErrorHandler methods.
It is up to the application’s ErrorHandler object to decide whether to actually throw the exception, however.
An XMLFilter extends XMLReader and behaves like an XMLReader except that instead of parsing a document itself, it filters the SAX events provided by a “parent” XMLReader object.
Use the setParent( ) method to link an XMLFilter object to the XMLReader that it is to serve as a filter for.
An XMLFilter serves as both a source of SAX events, and also as a receipient of those events, so an implementation must implement ContentHandler and related interfaces so that it can obtain events from the parent object, filter them, and then pass the filtered events on to the ContentHandler object that was registered on the filter.
XMLFilterImpl does no filtering—it simply passes passes all of its method invocations through.
You can subclass it and override only the methods that need filtering.
This interface defines the methods that must be implemented by a SAX2 XML parser.
Since it is an interface, XMLReader cannot define a constructor for creating an XMLReader.
Note that the XMLReader interface has no relationship to the java.io.Reader class or any other character stream classes.
Once you have obtained an XMLReader instance, you must register handler objects on it, so that it can invoke methods on those handlers to notify your application of the results of its parsing.
All applications should register a ContentHandler and an ErrorHandler with setContentHandler( ) and setErrorHandler( )
Some applications may also want to register an EntityResolver and/or a DTDHandler.
DeclHandler and LexicalHandler objects are registered with setProperty( ), as explained below.
In addition to registering handler objects for an XMLReader, you may also want to configure the behavior of the parser using setFeature( ) and setProperty( )
For uniqueness, the names of features and properties are expressed as URLs (the URLs usually do not have any web content associated with them: they are merely unique identifiers)
Features have boolean values, and properties have arbitrary object values.
This exception is also thrown by the set methods when the parser allows the feature or property to be queried but not set.
Their names are all URLs that begin with the prefix “http://www.xml.org/sax/features/”
Note that only two of these features must be supported by all parsers.
The others may or may not be supported in any given implementation:
Support for this feature is required in all parser implementations.
A qName consists of a namespace prefix, a colon, and the local name.
The default value of this feature is false, and support for the feature is required in all parser implementations.
This is always true if the validation feature is true.
This is always true if the validation feature is true.
If the application does the same, it can use = = equality testing for these strings rather than using the more expensive equals( ) method.
Like the features, their names are all URLs that begin with the prefix (omitted below) “http://www.xml.org/sax/properties/”
Note that support for all of these properties is optional.
The value of this property is a String that contains the document content that triggered the current handler invocation.
Finally, after you have obtained an XMLReader object, have queried and configured its features and properties, and have set a ContentHandler, ErrorHandler, and any other required handler objects, you are ready to parse an XML document.
Do this by calling one of the parse( ) methods, specifying the document to parse either as a system identifier (a URL) or as an InputSource object (which allows the use of streams as well)
Neither SAX parsers nor SAX applications are required to support these extensions, but when they do, the interfaces defined here provide a standard way for the parser to provide additional information about an XML document to the application.
DeclHandler defines methods for reporting the content of a DTD, and LexicalHandler defines methods for reporting the lexical structure of an XML document.
Each extends a similarly named interface from the core org.xml.sax package.
If the SAX implementation supports this interface, the Attributes object passed to the startElement( ) method of the ContentHandler implements this interface.
This extension interface defines methods that a SAX parser can call to notify an application about element, attribute, and entity declarations in a DTD.
It overrides the two-argument version of resolveEntity from the core EntityResolver interface to invoke the four-argument version from the EntityResolver2 interface.
If you register an entity resolver that implements this interface, if the SAX implementation supports this interface, and you set the feature “http://xml.org/sax/features/use-entity-resolver2” to true, then the implementation will use the methods defined by this interface instead of the method defined by the super-interface.
This extension interface defines methods that a SAX parser can call to notify an application about the lexical structure of an XML document.
If a LexicalHandler is successfully registered on an XMLReader, then the parser will call startDTD( ) and endDTD( ) to report the beginning and end of the document’s DTD.
It will call startCDATA( ) and endCDATA( ) to report the start and end of a CDATA section.
When the parser expands an entity, it first calls startEntity( ) to specify the name of the entity it is about to expand, and then calls endEntity( ) when the entity expansion is complete.
Finally, whenever the parser encounters an XML comment, it calls the comment( ) method.
This interface defines an extension to the core Locator interface.
You can also test for support by querying the feature named “http://xml.org/sax/features/use-locator2”
This package contains utility classes that are useful for programmers working with SAX parsers.
DefaultHandler is the most commonly used: it is a default implementation of the four standard handler interfaces, suitable for easy subclassing by an application.
XMLFilterImpl is a no-op implementation of the XMLFilter interface that also implements the various handler interfaces necessary to connect the filter to its “parent” XMLReader.
It does no filtering of its own, but is easy to subclass to add filtering.
This utility class is a general-purpose implementation of the Attributes interface.
In addition to implementing all the methods of Attributes, it also defines various set methods for setting attribute names, values, and types, an addAttribute( ) method for adding a new attribute to the end of the list, a removeAttribute( ) method for removing an attribute from the list, and a clear( ) method for removing all attributes.
Also, there is an AttributesImpl( ) constructor that initializes the new AttributesImpl object with a copy of a specified Attributes object.
This class is useful for XMLFilter implementations that want to filter the attributes of an element, or for ContentHandler implementations that need to make and save a copy of an Attributes object for later use.
This helper class implements the four commonly-used SAX handler interfaces from the org.xml.sax package and defines stub implementations for all of their methods.
It is usually easier to subclass DefaultHandler and override the desired methods than it is to implement all of the interfaces (and all of their methods) from scratch.
DefaultHandler implements ContentHandler, ErrorHandler, EntityResolver and DTDHandler, so you can pass an instance of this class, (or of a subclass you define) to the setContentHandler( ), setErrorHandler( ), setEntityResolver( ), and setDTDHandler( ) methods of an XMLReader.
The SAXParser will take care of calling the four relevant methods of its internal XMLReader.
All but two of the methods of DefaultHandler have empty bodies and do nothing.
The exceptions are resolveEntity( ) which simply returns null to tell the parser to resolve the entity itself, and fatalError( ) which throws the SAXParseException object that is passed to it.
This helper class is a very simple implementation of the Locator interface.
It defines a copy constructor that create a new LocatorImpl object that copies the state of a specified Locator object.
This constructor is useful because it allows applications to copy the state of a Locator and save it for later use.
This utility class exists to help SAX parser implementors handle XML namespaces.
In order to make this work, it implements the deprecated SAX1 DocumentHandler interface so that it can receive events from the Parser.
ParserAdapter provides its own layer of namespace processing to convert a namespace-unaware Parser into a namespace-aware XMLReader.
This class is useful when working you are working with a legacy API that supplies a SAX1 Parser object, but want to work with that parser using the SAX2 XMLReader API: to use it, simply pass the Parser object to the ParserAdapter( ) constructor and use the resulting object as you would use any other XMLReader object.
In particular, a ParserAdapter will never call the skippedEntity( ) handler method because the SAX1 Parser API does not provide notification of skipped entities.
Also, it does not attempt to determine whether two namespaceprefixed attributes of an element actually resolve to the same attribute.
This class is implements an XMLFilter that does no filtering.
You can subclass it to override whatever methods are required to perform the type of filtering you desire.
XMLFilterImpl implements ContentHandler, ErrorHandler, EntityResolver, and DTDHandler so that it can receive SAX events from the “parent” XMLReader object.
But it also implements the XMLFilter interface, which is an extension of XMLReader, so that it acts as an XMLReader itself, and can send SAX events to the handler objects that are registered on it.
Each of the handler methods of this class simply invoke the corresponding method of the corresponding handler that was registered on the filter.
The XMLReader methods for getting and setting features and properties simply invoke the corresponding method of the parent XMLReader object.
The parse( ) methods do the same thing: they pass their argument to the corresponding parse( ) method of the parent reader to start the parsing process.
It is useful when working with a legacy API that requires a deprecated Parser object.
Create an XMLReaderAdapter by passing an XMLReader to the XMLReaderAdapter( ) constructor.
Then use the resulting object exactly as you would use any other SAX1 Parser object.
This class implements ContentHandler so that it can receive SAX events from the XMLReader.
But it also implements the Parser interface so that it can have a SAX1 DocumentHandler registered on it.
The methods of ContentHandler are implemented to invoke the corresponding methods of the registered DocumentHandler.
This factory class defines two static factory methods for creating XMLReader objects.
One method takes the name of a class as its argument.
It dynamically loads and instantiates the class, then casts it to an XMLReader object.
An application that instantiates its SAX parser using the no-argument method of XMLReaderFactory gains a layer of independence from the underlying parser implementation.
The end user or system administrator of the system on which the application is deployed can change the parser implementation simply by setting a system property.
We’d like to hear your suggestions for improving our indexes.
David Flanagan is a computer programmer who spends most of his time writing about Java and JavaScript.
David has a degree in computer science and engineering from the Massachusetts Institute of Technology.
Our look is the result of reader comments, our own experimentation, and feedback from distribution channels.
Distinctive covers complement our distinctive approach to technical topics, breathing personality and life into potentially dry subjects.
The animal on the cover of Java in a Nutshell, Fifth Edition is a Javan tiger, a subspecies unique to the island of Java.
Although this tiger once offered unrivaled research opportunities due to its genetic isolation, these opportunities have been permanently lost due to human encroachment on the Javan tiger’s habitat: in a worst-case scenario for the tiger, Java developed into the most densely populated island on earth, and awareness of the subspecies’ precarious position came too late to secure the animals’ survival even in captivity.
The last known sighting of the tiger was in 1972, and it is now presumed extinct.
Jamie Peppard was the production editor and proofreader for Java in a Nutshell, Fifth Edition.
The cover image is a 19th-century engraving from the Dover Pictorial Archive.
An Example Program Compiling and Running the Program Analyzing the Program Comments Defining a class Defining a method Declaring a variable and parsing input Computing the result Displaying output The end of a method Blank lines Another method Checking for valid input An important variable Looping and computing the factorial Returning the result.
Nested Types Static Member Types Features of static member types Restrictions on static member types Syntax for static member types.
Nonstatic Member Classes Features of member classes Restrictions on member classes Syntax for member classes Scope versus inheritance.
Local Classes Features of local classes Restrictions on local classes Syntax for local classes Scope of a local class Local variables, lexical scoping, and closures.
Anonymous Classes Features of anonymous classes Restrictions on anonymous classes Syntax for anonymous classes When to use an anonymous class Anonymous class indentation and formatting.
Advanced Enum Syntax The class body of an enumerated type Implementing an interface Value-specific class bodies Restrictions on enum types.
