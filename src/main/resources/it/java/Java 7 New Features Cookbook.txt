No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the information presented.
However, the information contained in this book is sold without warranty, either express or implied.
Neither the authors, nor Packt Publishing, and its dealers and distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned in this book by the appropriate use of capitals.
However, Packt Publishing cannot guarantee the accuracy of this information.
Previously, he worked in the industry for over 16 years in the aerospace and telephone industries.
Outside of the classroom, he enjoys tending to his vegetable garden, maintaining his aquariums, and running with his dog, Zoey.
He also enjoys relaxing with an episode of Firefly and is ever hopeful for the return of the series.
He has written numerous publications and has also written the EJB 3.1 Cookbook.
She currently works as a software engineer for Local Government Solutions in Waxahachie, Texas, developing software for the county government.
Prior to graduation, she worked for the Center for Agribusiness Excellence at Tarleton, where she used Java in conjunction with GIS software to analyze crop and weather data.
In her free time, she enjoys reading, cooking, and traveling, especially to any destination with a beach.
She is also a musician and appreciates a variety of musical genres.
No book can be written without the help of others.
To this end we are thankful for the support of Karla, our wife and mother, whose patience and reviews have made this effort possible.
In addition, we would like to thank the editorial staff of Packt and our reviewers for their input which has resulted in a much better book than it might otherwise have been.
Jacek Laskowski has over 15 years of IT experience, focusing on software development and architecture design with open source and commercial product offerings.
He is a seasoned technology professional with a strong software development and advisory track record.
He is a founder and leader of Warszawa Java User Group, and has been a speaker at local and international conferences.
He contributes to open source projects—Apache OpenEJB and Apache Geronimo.
He envisages himself using functional languages in projects and the decision to learn Clojure (a little bit of JRuby, Scala, F#, and Dart lately) influences his current self-learning activities.
It's been quite recently that he's got into Android, too.
He mentors students, and is an author of IBM Redbooks publications and has also contributed to a few other books as a technical reviewer.
While supporting business partners and customers with their use of IBM WebSphere BPM products, he regularly runs courses and workshops.
He is a member of the NetBeans Dream Teamhighly-skilled and motivated NetBeans users.
I'd like to thank my family—my wife, Agata, and my three kids, Iweta, Patryk, and Maksym, for their constant support, encouragement, and patience.
Deepak Vohra is a consultant and a principal member of the NuBean.com software company.
Deepak is a Sun Certified Java Programmer and Web Component Developer and has worked in the fields of XML and Java programming and J2EE for over five years.
Get in touch with us at service@ packtpub.com for more details.
Do you need instant solutions to your IT questions? PacktLib is Packt's online digital book library.
Here, you can access, read and search across Packt's entire library of books.
Why Subscribe? f Fully searchable across every book published by Packt.
Preface With the release of Java 7, numerous new features have been added that significantly improve the developer's ability to create and maintain Java applications.
These include language improvements, such as better exception handling techniques, and additions to the Java core libraries, such as new threading mechanisms.
This cookbook covers these new features using a series of recipes.
Each recipe addresses one or more new features and provides a template for using these features.
This should make it easier to understand the features along with when and how they can be used.
Step-by-step instructions are provided to guide the reader through the recipes and are followed by an explanation of the resulting code.
The book starts with a discussion of the new language enhancements, which is followed by a series of chapters, each addressing a specific area such as file and directory management.
The book does not need to be read in sequential order, which enables the reader to choose the chapters and recipes that are of interest.
However, it is recommended that the reader cover the first chapter, as many of the features found there will be used in subsequent recipes.
If other new Java 7 features are used in a recipe, then cross references are provided to the related recipes.
What this book covers Chapter 1, Java Language Improvements: In this chapter, we examine the various language improvements introduced as part of Project Coin.
These features include simple improvements such as using underscores in literals and the use of strings with switch statements.
Also, more significant improvements such as the try-with-resources block and the introduction of the diamond operator are detailed.
Chapter 3, Obtaining File and Directory Information: Many applications need access to specific file and directory information.
How to access this file information is addressed here, including accessing such information as the basic file attributes, Posix attributes, and a file's access control list.
Chapter 4, Managing Files and Directories: In this chapter, the basic mechanisms for managing files and directories are covered, including such actions as creating and deleting files.
Also addressed are the use of temporary files and the management of symbolic links.
Chapter 5, Managing File Systems: Here a number of interesting topics, such as how to obtain the filesystem and file store information, the classes used to traverse a file structure, how to watch for file and directory events, and how to work with a ZIP file system are presented.
New techniques for performing asynchronous IO are detailed along with new approaches for performing random access IO and using a secure directory stream.
It is now possible to create windows with different shapes and windows that are transparent.
In addition, numerous enhancements are explained such as the use of the JLayer decorator, which improves the ability to overlay graphics on a window.
Chapter 8, Handling Events: In this chapter, new methods for working with various application events are examined.
Java 7 now supports extra mouse buttons and precision mouse wheels.
The ability to control a window's focus has been improved and secondary loops have been introduced to mimic the behavior of modal dialog boxes.
Chapter 9, Database, Security, and System Enhancements: Various database improvements such as the introduction of the new RowSetFactory class are illustrated along with how to take advantage of new SSL support.
In addition, other system improvements such as additional support for MXBeans are demonstrated.
Chapter 10, Concurrent Processing: Several new classes have been added to support the use of threads, including classes that support the fork/join paradigm, the phaser model, an improved dequeue class, and a transfer queue class.
The new ThreadLocalRandom class, used to generate random numbers, is explained.
Also included in this chapter is the improved support for dealing with null references.
What you need for this book The software required for this book includes the Java Development Kit (JDK) 1.7 or later.
Any integrated development environment that supports Java 7 can be used to create and execute the recipes.
The examples in this book were developed using NetBeans 7.0.1
Conventions In this book, you will find a number of styles of text that distinguish between different kinds of information.
Here are some examples of these styles, and an explanation of their meaning.
Code words in text are shown as follows: "We can include other contexts through the use of the include directive."
When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:
Words that you see on the screen, in menus or dialog boxes for example, appear in the text like this: "clicking the Next button moves you to the next screen"
Warnings or important notes appear in a box like this.
Let us know what you think about this book—what you liked or may have disliked.
Reader feedback is important for us to develop titles that you really get the most out of.
Customer support Now that you are the proud owner of a Packt book, we have a number of things to help you to get the most from your purchase.
Downloading the example code You can download the example code files for all Packt books you have purchased from your account at http://www.packtpub.com.
If you purchased this book elsewhere, you can visit http://www.packtpub.com/support and register to have the files e-mailed directly to you.
Errata Although we have taken every care to ensure the accuracy of our content, mistakes do happen.
If you find a mistake in one of our books—maybe a mistake in the text or the code—we would be grateful if you would report this to us.
By doing so, you can save other readers from frustration and help us improve subsequent versions of this book.
If you find any errata, please report them by visiting http://www.packtpub.com/support, selecting your book, clicking on the errata submission form link, and entering the details of your errata.
Once your errata are verified, your submission will be accepted and the errata will be uploaded to our website, or added to any list of existing errata, under the Errata section of that title.
Piracy Piracy of copyright material on the Internet is an ongoing problem across all media.
At Packt, we take the protection of our copyright and licenses very seriously.
If you come across any illegal copies of our works, in any form, on the Internet, please provide us with the location address or website name immediately so that we can pursue a remedy.
We appreciate your help in protecting our authors, and our ability to bring you valuable content.
In the Java SDK documentation, you may see it referred to as Java 1.7
Project Coin refers to the small language changes in Java 7 that are designed to make programs more readable by removing extra text when possible.
The changes to the language do not involve modifying the Java Virtual Machine (JVM)
Since the inception of Java, only integer values could be used to control a switch statement.
Strings can now be used and can provide a more convenient technique for controlling the execution flow that is based on a string.
The Using string literals in switch statements recipe illustrates this feature.
Underscores can now be used with literals as examined in the recipe Using underscores in literals to improve code readability.
Instead of using a hexadecimal literal, for example, the literal bit pattern can be used.
New to Java 7 are the improved try-catch block mechanisms.
These include the ability to catch more than one exception from a single catch block, and improvements in how exceptions can be thrown.
The Catching multiple exception types to improve type checking recipe looks into these enhancements.
Another improvement in exception handling involves the automatic closure of resources.
In earlier versions of Java, when multiple resources were opened in a try block, it could be difficult to effectively close the resources, when an exception occurs.
Java 7 provides a new technique as discussed in the Using the try-with-resources block to improve exception handling code recipe.
This interface consists of a single method, close which, when implemented, should release resources as needed.
Many core Java classes have been augmented to do this.
The recipe: Creating a resource that can be used with the try-with-resources technique illustrates how to do this for non-core classes.
Java 7 provides the capability to re-throw exceptions in a flexible manner.
It provides a more precise way of throwing exceptions, and more flexibility in how they can be handled in a try/ catch bock.
The Re-throwing exceptions in Java 7 recipe illustrates this capability.
When generics were introduced in Java 1.5, it became easier to write code to address a number of similar problems.
The introduction of the diamond operator has eased this burden, and is illustrated in the Using the diamond operator for constructor type inference recipe.
When a method uses a variable number of generic arguments, sometimes an invalid warning is generated.
The @SafeVarargs annotation has been introduced to flag a method as safe.
This issue is related to heap pollution and is discussed in the Using the @SafeVarargs Annotation recipe.
In this and the other chapters, most of the code examples will be written to execute from within a main method.
At minimum, a version of the Java Development Kit (JDK) 1.7 or later is needed.
Also, note that the code examples provided do not include import statements.
These are not shown here to reduce the number of lines of code.
Most IDEs make it easy to insert these imports, but you need to be careful that the correct imports are used.
Previously, only integer values were the valid arguments in a switch statement.
It is not uncommon to need to make a decision based on a string value, and the use of a switch statement to perform this task can simplify the series of if statements that would otherwise be needed.
Getting ready A selection based on a string value may occur in an application.
Create a String variable to be processed via the switch statement.
Create the switch block, using string literals for the case clauses.
The example demonstrated here will use a switch statement to process an application's command line arguments.
In the main method, we will use the args argument to process the application's command line arguments.
Many applications allow command line arguments to customize or otherwise affect the operation of the application.
In this example, our application will support a verbose mode, logging, and provide a help message regarding the valid command line arguments for the application.
Downloading the example code You can download the example code files for all Packt books you have purchased from your account at http://www.packtpub.com.
If you purchased this book elsewhere, you can visit http://www.packtpub.
If you are using an IDE, then there is usually a way to set the command line arguments.
For example, in NetBeans, right-clicking on the project name in the Project window, and selecting Properties menu will open a Project Properties dialog box.
In the Run category, the Arguments textbox allows you to set the command line arguments, as shown in the following screenshot:
When the application is executed, your output should appear as follows:
The switch statement uses a specific command line argument to turn on an application setting.
The switch statement behaves like the earlier Java switch statements.
It is interesting to note that the Java Virtual Machine (JVM) currently provides no direct support for switching with strings.
The Java compiler is responsible for converting strings in switch statements to the appropriate byte code.
This displays the current application setting, reflecting the configuration specified by the command line arguments.
It is important to note, however, while a String variable may be passed to the switch statements, as with the other data types used in switch statements, the strings used in the case clauses must be string literals.
The general rules regarding switch statements apply when using string literals.
Each statement within the switch block must have a valid non-null label, no two labels may be identical, and only one default label may be associated with each switch block.
When using strings, you need to be careful about the following two issues:
Using a string reference variable that is assigned a null value will result in a java.lang.
This is also true when used with a switch statement.
Also, the evaluation of a case expression is case sensitive in a switch statement.
In the previous example, if the command line argument is different from what appears in the case expression, then the case is skipped.
If we had used the following command line instead, where we capitalized the word verbose:
Then the verbose mode will no longer be used as indicated in the following output:
This is intended to improve the readability of code by separating digits of a literal into significant groups at almost any arbitrary place that meets the needs of the developer.
The underscore can be applied to primitive data types in any supported base (binary, octal, hexadecimal, or decimal), and to both integer and floating-point literals.
Getting ready The first step is to identify instances where it will be beneficial for the developer to format literals in such a manner.
Typically, you will want to identify longer numbers or numbers that would have significant parts in their external form, such as debit card numbers.
Insert underscores at appropriate places within the literal to make the literal more readable.
This example illustrates using underscores to clarify the inherent gaps found in most debit card numbers, and demonstrates their use with floating point numbers.
Notice that in the first output line the displayed number does not contain underscores, but our second line is formatted to use spaces where the underscores were.
This is to illustrate the difference between how the number looks internally, and how it needs to be formatted for external display.
The debit card example partitioned the number into four sections making it more readable.
A long variable was needed due to the length of the debit card number.
Next, a minimum limit was placed on the amount of money in a bank account.
The variable minAmount of type float was set to 5,000.00 using the underscores to denote the location of the comma.
The code then determined whether the withdrawalAmount could be subtracted from the currentAmount and still maintain a balance above the minAmount.
The previous example used floating point literals only to explain the usage of underscores.
The only purpose of the underscore is to make the code more readable to the developer.
The compiler ignores the underscores during code generation and during any subsequent variable manipulation.
Consecutive underscores are treated as one and also ignored by the compiler.
If the output format of a variable is important, it will have to be handled separately.
Underscores can be used for more than base 10 literals.
Simple underscore usage mistakes Underscores may generally be placed arbitrarily within the literals, but there are guidelines limiting their use.
It is invalid to place underscores at the beginning or end of a number, adjacent to a decimal point when used in a float or double, prior to the D, F, or L suffix, or where a string of digits is required.
Using underscores with hexadecimal literals Underscores can be particularly useful when dealing with binary data expressed in hexadecimal or binary.
In the following example, an integer value representing a command to be sent to a data port was expressed as a hexadecimal and as a binary literal:
The base 16 representation may be more readable in this example.
Base 2 literals will be discussed in more depth in the next section.
The underscores were used to more clearly identify parts of the command.
The assumption is that the first four bits of the command represent an operator, while the next 16 bits are an operand.
Using underscores with binary literals We can also use underscores with binary literals.
For example, to initialize a device we may need to send a specific 8 bit sequence to the data port.
This sequence may be organized such that the first two bits specify the operation (read, write, and so on), the next three bits may specify a device resource, and the last three bits could represent an operand.
We may encode this sequence using a binary literal with underscores as follows:
Another example defines a mask where, in this case, the first three bits are eliminated during an AND operation as follows:
In a bitwise AND operation, each bit of the operands are Anded with each other.
When this sequence is executed, we get the following output:
The byte cast operator was needed because binary literals default to type int.
Also, notice that the toBinaryString method does not display leading zeroes.
The try-with-resources block has been added in an effort to simplify error-handling and make the code more concise.
The use of the try-with-resources statement results in all of its resources being automatically closed when the try block exits.
This approach enables a better programming style as it avoids nested and excessive try-catch blocks.
It also ensures accurate resource management, which you may see referred to as Automated Resource Management (ARM) in literature.
Getting ready When working with resources that need to be opened and closed, the try-with-resource block is implemented by:
Creating the try block and declaring the resources to be managed.
The resources to be managed are declared and initialized inside a set of parentheses between the try keyword and the opening curly brace of the try block.
The first is a BufferedReader object associated with the users.
The first file is then read line by line and written to the second file.
When the try block is exited, the two IO streams are automatically closed.
A message is then displayed showing that the copy operation is complete.
Notice the use of the vertical bar in the catch block.
This is new to Java 7 and allows us to catch multiple exceptions in a single catch block.
The use of this operator is discussed in the Catching multiple exception types to improve type checking recipe.
Bear in mind that the resources declared with a try-with-resources block are separated by semicolons.
Failure to do so will result in a compile-time error.
Also, resources will be attempted to be closed, regardless of whether the try block completes normally or not.
If the resource cannot be closed, an exception is normally thrown.
Regardless of whether resources are closed or not, the catch and finally blocks are always executed.
This is discussed in more detail in the Creating a resource that can be used with the try-with-resources technique recipe.
To complete our understanding of the try-with-resources technique, we need to address two other topics as follows:
Suppressed exceptions are those exceptions that are not explicitly reported.
In the case of the try-with-resources try block, exceptions may be thrown from the try block itself or when the resources created by the try block are closed.
When more than one exception is thrown, exceptions may be suppressed.
In the case of the try-with-resources block, any exceptions associated with a close operation are suppressed when an exception is thrown from the block itself.
This is demonstrated in the Creating a resource that can be used with the try-with-resources technique recipe.
Programmer created exceptions can designate an exception as suppressed by using the addSuppressed method.
Structuring issues when using the try-with-resources technique It may not be desirable to use this technique when a single resource is used.
We will show three different implementations of a sequence of code to display the contents of the users.txt file.
The first, as shown in the following code, uses the try-with-resources block.
However, it is necessary to precede this block with a try block to capture the java.net.
This example is predicated upon the need to catch the URISyntaxException.
This can be avoided by creating the java.net.URI object inside of the get method as shown below.
Notice the use of the multiple catch block as discussed in the Catching multiple exception types to improve type checking recipe.
Another approach is to avoid the URI object altogether by using the get method with a String argument as follows:
The methods that are used and the structure of the code affect the readability and maintainability of the code.
It may or may not be feasible to eliminate the use of the URI object, or similar objects, in a code sequence.
However, careful consideration of alternative approaches can go a long way to improving an application.
Creating a resource that can be used with the try-with-resources technique.
There are many resources in Java libraries, which can be used as part of the try-withresource technique.
However, there may be times when you may wish to create your own resources that can be used with this technique.
An example of how to do this is illustrated in this recipe.
Getting ready To create a resource that can be used with the try-with-resources technique:
Any objects created with the try-with-resources block must implement the AutoCloseable interface.
Here, we will illustrate this approach by creating three classes:
Within the resource classes, the manipulateResource methods were created to perform some resource-specific operation.
The resource classes were declared as part of the try block, and the manipulateResource methods were called.
This was illustrated in the first part of the output.
When the try block terminated, the close methods were executed.
This is the result of how the application program stack works.
In addition, we used the getSuppressed method to return and display the suppressed methods.
These types of exceptions are discussed in the Using the try-withresource block to improve exception handling code recipe and later on in this recipe.
Within the close method, one of the following three actions is possible:
In the case of the last one, there are a few things to bear in mind.
This provides the user with more meaningful feedback concerning the underlying problem.
An idempotent method is the one where repeated execution of the method will not cause problems.
As an example, reading from the same file twice will not necessarily cause problems.
Whereas, writing the same data twice to the file may.
The close method does not have to be idempotent, however, it is recommended that it should be.
See also The Using the try-with-resources block to improve exception handling code recipe covers the use of this type of try block.
Within a try block, multiple exceptions can be generated and thrown.
A corresponding series of catch blocks are used to capture and then deal with the exceptions.
Frequently, the action needed to deal with one exception is the same for other exceptions.
An example of this is when the logging of an exception is performed.
In Java 7, it is now possible to handle more than one exception from within a single catch block.
In earlier versions of Java, there was often a temptation to address this issue by catching a higher-level exception class and handling multiple exceptions from that block.
Getting ready Using a single catch block to capture multiple exceptions is achieved by:
Including multiple exceptions within the catch blocks' parentheses, separated by a vertical bar.
In this example, we wish to deal with invalid input from the user by logging an exception.
This is a simple approach that will suffice to explain how multiple exceptions can be handled.
The InvalidParameter class is used to handle invalid user input, and the MultipleExceptions class contains the main method and example code.
Using a valid number, such as 12, results in the following output:
Using invalid input like a non-numeric value, such as cat, or a negative number, such as -5, will result in the following output:
The logger was created and when an exception occurred, an entry was made in the logger file.
The output created by using NetBeans also displayed these log messages as they occur.
When an exception was thrown, the catch block was entered.
Also, notice that there is only a single variable, e, used to represent the exception.
This approach is useful when we need to handle a few specific exceptions, and need to handle them in the same way.
When a catch block handles more than one exception, the catch block parameter is implicitly final.
This means that it is not possible to assign new values to the parameter.
The following is illegal and its use will result in a syntax error:
Besides being more readable and concise than using multiple catch blocks, the generated bytecode is also smaller and does not result in the generation of duplicate code.
The base class or classes of a set of exceptions impact when to use a catch block to capture multiple exceptions.
However, if the multiple exceptions share a common base exception class, then it may be simpler to catch the base class exception instead.
For example, the Files class' delete method may throw one of the following four different exceptions:
Thus, catching the IOException may be sufficient as illustrated in the following code:
In this example, notice that a URISyntaxException exception is potentially thrown by the URI constructor.
The recipe Deleting a file or directory, in Chapter 4, Managing Files and Directories, details the use of the delete method.
This exception class can ease the handling of reflection type exceptions.
The use of the multiple exceptions catching mechanism is more appropriate for those sets of exceptions which have no common base class.
As a general rule, it is better to catch the exception that is as specific to the problem as possible.
Using the AssertionError class in Java 7 Assertions are useful in building an application that is more robust.
In Java 7, a new constructor was added that allows a message to be attached to a user-generated assertion error.
The first is the message to be associated with the AssertionError and the second is a Throwable clause.
In the MultipleExceptions class developed earlier in this recipe, we tested to see if the number was less than zero, and if so we threw an exception.
Add the following code to the main method near the original test of the number:
Prior to Java 7, it was not possible to associate a message with a user-generated AssertionError.
Rethrowing exceptions in Java 7 When an exception is caught in a catch block, it is sometimes desirable to rethrow the exception.
This allows the exception to be processed by the current method and methods that called the current method.
However, prior to Java 7 only a base class exception could be rethrown.
When more than one exception needed to be rethrown, you were restricted to declaring a common base class in the method declaration.
Now, it is possible to be more restrictive on the exceptions which can be thrown for a method.
Getting ready In order to rethrow exceptions in Java, you must first catch them.
From within the catch block, use the throw keyword with the exception to be thrown.
The new rethrow technique in Java 7 requires that you:
Execute the application using a file that does not exist.
The main method called and handled exceptions generated by the deleteFile call.
Notice that the base class, IOException, was used to catch exceptions.
Within the catch block, a test was made to determine what caused the exception, using the File class' isDirectory method.
Once the root cause of the exception was determined, the appropriate exception was thrown.
The use of the Files class is detailed in Chapter 4, Managing Files and Directories.
By specifying precisely which exceptions can be thrown by the method, we can be clear about what callers of the method can expect.
In addition, it prevents the inadvertent throwing of other IOException derived exceptions from the method.
It will be caught in the deleteFile method, since it is derived from the IOException.
However, we have failed to handle it in the method or pass it to the calling method.
The use of the diamond operator simplifies the use of generics when creating an object.
It avoids unchecked warnings in a program, and it reduces generic verbosity by not requiring explicit duplicate specification of parameter types.
While Java is statically typed, the use of the diamond operator allows more inferences than before.
The compiler will infer the parameter types for the constructors.
This is an example of the convention over configuration (http://en.wikipedia.org/wiki/Convention_over_ configuration)
By letting the compiler infer the parameter type (convention), we avoid explicit specification (configuration) of the object.
Java also uses annotations in many areas to affect this approach.
Type inference is now available, whereas it was only available for methods before.
Use the diamond operator, <>, to specify the type inference that is to be used.
The identifier, list, is declared as a list of strings.
The diamond operator, <>, is used to infer the List type as String.
When an object is created without specifying the data type, it is called a raw type.
For example, the following uses a raw type when instantiating the identifier, list:
When the code is compiled, the following warnings are generated:
It is generally desirable to eliminate unchecked warnings in an application.
Before Java 7, we could address this warning by explicitly using a parameter type as follows:
With Java 7, the diamond operator makes this shorter and simpler.
This operator becomes even more useful with more complex data types, such as, a List of Map objects as follows:
There are several other aspects of type inference that should be discussed:
Using the diamond operator when the type is not obvious Type inference is supported in Java 7 and later, only if the parameter type for the constructor is obvious.
For example, if we use the diamond operator without specifying a type for the identifier shown as follows, we will get a series of warnings:
Compiling the program with –Xlint:unchecked, results in the following warnings:
These warnings will go away if the data type is specified as follows:
Suppressing unchecked warnings While not necessarily desirable, it is possible to use the @SuppressWarnings annotation to suppress unchecked exceptions generated by the failure to use the diamond operator.
The data type used in the declaration is not available at run-time.
This language design decision was made when Java 1.5 introduced generics, to make the code backwards compatible.
They differ only in the declaration of the arrayList variable:
When these methods are compiled, the type information available at compile-time is lost.
If we examine the compiled bytecode for these three methods, we will find that there is no difference between them.
Using the following command will display the byte codes for the program:
The @SuppressWarnings annotation, as its name implies, will suppress specific types of warnings.
Methods can be passed with a variable number of arguments.
If they are, then it may be desirable to suppress harmless warnings using the @SafeVarargs annotation.
Getting ready The @SafeVarargs annotation is used with constructors and methods.
To use the @SafeVarargs annotation, the following steps need to be followed:
Create a method or constructor that uses a variable number of generic parameters.
In Java 7, mandatory compiler warnings are generated with generic variable argument methods or constructors.
The use of the @SafeVarargs annotation suppresses warnings, when these methods or constructors are deemed to be harmless.
The method displays information about each parameter and its value: package packt;
Java implements a variable number of arguments as an array of objects, which only hold reifiable types.
A reifiable type is discussed in the How it works section.
Notice the use of the diamond operator, <>, in the declaration of the java.util.
This operator is new to Java 7, and is discussed in the recipe: Using the diamond operator for constructor type inference.
In Java, a method or constructor with a variable number of arguments is created using the ...
The basic problem is the inability of generics and arrays to play well together.
When generics were added to the Java language in 1.5, they were implemented to make them backwards compatible with earlier code.
That is, any type of information that was available at compile-time was removed at run-time.
Information about an array's element type is retained and can be used at run-time.
Note that it is not possible to declare an array of generics.
It is possible to create a simple array of strings as follows:
However, we cannot create an array of generics, such as the following:
A method that uses a variable number of arguments is implemented as an array of objects.
When a method using a variable number of arguments is invoked, an array is created to hold these parameters.
Since we used a method with variable number of generic arguments, a run-time problem can occur known as heap pollution.
Heap pollution occurs when a variable of a parameterized type is assigned a different type than that used to define it.
At run-time, this will manifest itself as an unchecked warning.
Use the @SafeVarargs annotation to designate a method as one that avoids heap pollution.
Methods that use a variable number of generic arguments will result in a compile-time warning.
However, not all methods that use a variable number of generic arguments will result in a run-time exception.
The @SafeVarargs is used to mark the safe methods as safe.
If it is possible for a run-time exception to occur, then the annotation should not be used.
Notice that if the @SafeVarargs annotation was not used then the following warnings will be generated:
The first warning is applied against the displayElements invocation and the second warning is applied against the actual method.
There is nothing wrong with the code, so suppression of these warnings is perfectly acceptable.
These methods were tagged with the @SafeVarargs annotation to indicate that they will not cause heap pollution.
A list of strings was passed to the method and assigned to the identifier stringList.
Next, an array of objects was declared and assigned to the same object referenced by stringList.
At this point, the stringList and array referenced the same object, a java.util.List of strings.
The following  illustrates the configuration of the memory at this point:
The first element of the array is reassigned to tmpList.
At this point, we have effectively assigned an Integer object to a String reference variable.
It has been assigned to the first element of the array referenced by both stringLists and array.
The dashed line shows the old reference, which has been replaced with the line.
When an attempt is made at run-time to assign this Integer object to a String reference variable, the ClassCastException occurs.
This method results in heap pollution and should not be annotated with @SafeVarargs as it is not safe.
The assignment of tmpList to the first element of the array is permitted, since we are simply assigning a List<Integer> object to an Object reference variable.
This is an example of upcasting, which is legal in Java.
See also The previous recipe Using the diamond operator for constructor type inference explains an improvement in the use of generics.
Introduction A filesystem is a way of organizing data on a computer.
Normally, it consists of one or more top-level directories, each of which contains a hierarchy of files.
The top-level directory is frequently referred to as the root.
In addition, the filesystem is stored on a media, which is referred to as the file store.
Java 7 introduces a number of new classes and interfaces to make working with filesystems easier and more efficient.
These have largely supplemented older classes found in the java.io package.
In this and subsequent chapters, we will demonstrate how a filesystem can be managed using the directory structure, as shown in the following diagram:
Unix-based systems and Windows systems differ in their support of a root node.
Unix systems support a single root node, while Windows systems permit more than one root node.
The location of a directory or file is described using a path.
The elements, directories and files of the path are separated by either a forward or backward slash.
The status.txt is intended to hold simple status information, while the users.txt is assumed to hold a list of users.
The users.txt file in the music directory is a symbolic link to the actual file in the docs directory as reflected with the red line.
These files will be used in various examples throughout this chapter.
Of course, you can use any file or file structure that you wish.
This chapter is concerned with the management of paths as represented by the java.nio.
A Path object is used extensively by classes in the java.nio package and is composed of several parts that are as follows:
These are discussed and illustrated in the Understanding paths recipe.
The following are the classes dealing with files and directories:
The last two classes are discussed in more depth in later chapters.
To gain access to a file or directory, we will typically use the FileSystems class' getDefault method to retrieve a reference to the filesystem accessible by the JVM.
To get access to a specific drive, we can use the getFileSystem method with a Uniform Resource Identifier (URI) object representing the drive or directory of interest.
The FileSystems class provides techniques to create or access a filesystem.
In this chapter, we are interested in how the class supports the creation of Path objects.
Once we have reference to a file system object, we can obtain a Path object using any one of several methods:
The Path object is used to locate and access the file.
The creation and general use of Path objects is introduced in the Understanding paths recipe.
This knowledge is used in subsequent recipes and other chapters, so be sure to understand the basic processes covered in this recipe.
These types of paths and techniques for dealing with them are discussed in the Working with relative and absolute paths recipe.
The Removing redundancies in a path by normalizing the path recipe examines the techniques available to simplify these types of paths.
Paths can be combined to form a new composite path.
This is known as resolving a path and is addressed in the Combining paths using path resolution recipe.
This technique can be useful for creating new paths, where parts of the path are available from different sources.
When a reference is needed for a file, that path is sometimes relative to the current location or some other location.
The Creating a path between two locations recipe illustrates the creation of such a path.
Not only are there relative and absolute paths, but there are also other ways of representing a path such as with a java.net.URI object.
When a Path object is created, it is not necessary that the actual path exists.
For example, the Path may be created to create a new filesystem element.
The Converting between path types recipe looks at methods used to convert between these different types of paths.
That is, a path on one system such as UNIX is different from one found on a Windows system.
Comparing two paths found on the same platform may or may not be the same.
This is examined in the Determining whether two paths are equivalent recipe.
Creating a Path object A path to a directory or file is needed to identify that resource.
The focus of this recipe is on how to obtain a Path object for typical file and directory operations.
Paths are used for most of the recipes in this and many of the subsequent chapters that deal with files and directories.
There are several methods that create or return a Path object.
Here, we will examine those methods used to create a Path object and how to use its methods to further our understanding of the path concept as used in Java.
Getting ready In order to create a Path object, we need to use either one of the following:
The get method is explained in the There's more section of this recipe.
While either approach will work for a Windows platform, the use of forward slashes is more portable.
The Path object was created using invocation chaining, starting with the FileSystems class' getDefault method.
This returns a FileSystem object representing the filesystem available to the JVM.
The FileSystem object normally refers to the working directory of the current user.
Next, the getPath method was executed using a string representing the file of interest.
The rest of the code used various methods to display information about the path.
As detailed in the introduction of this chapter, we can display information about the parts of the path using methods of the Path class.
The toString method is executed against the path to illustrate what you get by default.
The getFileName returned the file name of the Path object, and the getRoot returned the root.
The getNameCount method returned the number of intermediate directories plus one for the filename.
In this case, there were two directories and one file giving a count of three.
While a simple for loop was used to display these names, we could have also used the iterator method to list these names, as shown in the following code:
The first represents an initial index and the second argument specifies the last index exclusively.
In this example, the first argument was set to 0 indicating that the root level directory was to be retrieved.
The last index was set to 2, which means only the top two directories were listed.
The getParent method in this case also returned the identical path.
This represents the path from the top level element following each element except the last one.
Using the Paths class' get method The Paths class' get method can also be used to create a Path object.
This method uses a variable number of String arguments to construct a path.
In the following code sequence, a path is created starting at the root of the current filesystem:
The output using the toAbsolutePath method shows the path constructed.
The code was executed on a Windows system where the current drive was the E drive.
The toAbsolutePath method is discussed in the Working with relative and absolute paths recipe.
If we do not use the forward slash in the path's String, then the path is created based on the current working directory.
Your output should be similar to the following where, currentDirectory, is replaced with the one in use when the code is executed:
A more flexible approach is to use the resolve method as discussed in the Combining paths using path resolution recipe.
The conversion of the input arguments to a path is system-dependent.
If the characters used in the creation of the path are invalid for the filesystem, then a java.nio.file.
For example, in most filesystems a null value is an illegal character.
To illustrate this, add a back slash 0 to the path string as shown in the following code:
When executed, the output in part will appear as follows:
The getIndex method returns the position of the offending character, which in this case is the null character.
The meaning of the parent path The getParent method returns the parent path.
This means that for a given Path object, there may or may not be a parent.
This refers to the users.txt file found in the current working directory.
The getNameCount will return 1, and the getParent method will return null.
In reality, the file exists in a directory structure and has a root and a parent.
Thus, the results of this method may not be useful in some contexts.
The use of this method is roughly equivalent to the following use of the subpath method:
See also The toRealPath method is discussed in the Working with relative and absolute paths recipe and in the Removing redundancies in a path by normalizing the path recipe.
Prior to the introduction of the java.nio package the classes and interfaces of the java.io package were the only ones available to Java developers for working with files and directories.
While most of the capability of the java.io package has been supplemented by the newer packages, it is still possible to work with the older classes, in particular the java.io.File class.
Getting ready To obtain a Path object using a File class, the following steps need to be followed:
File object and a Path object representing the same file.
Next, we compare the two objects to determine whether they represent the same file or not:
When you execute the application, the output will be true.
The first Path object was declared using the Paths class' get method.
It created a Path object to the users.txt file using a java.net.URI object.
The second Path object, toPath, was created from a File object using the toPath method.
The Path's equals method was used to demonstrate that the paths are equivalent.
Notice the use of the forward and backward slashes for the strings used to represent the file.
The URI string uses forward slashes, which is operating system-independent.
Whereas, the back slash is used for a Windows path.
See also The creation of a Path object is illustrated in the Understanding paths recipe.
Also, the creation of a URI object is discussed in the Working with relative and absolute paths recipe.
A path can be expressed either as an absolute path or a relative path.
The Path class and related classes support the creation of both absolute and relative paths.
A relative path is useful for specifying the location of a file or directory in relationship to the current directory location.
Typically, a single dot or two dots are used to indicate the current directory or next higher level directory respectively.
However, the use of a dot is not required when creating a relative path.
An absolute path starts at the root level and lists each directory separated by either forward slashes or backward slashes, depending on the operating system, until the desired directory or file is reached.
In this recipe, we will determine the path separator used for the current system and learn how to convert a relative path to an absolute path.
Related to absolute and relative paths is the URI representation of a path.
We will learn how to use the Path class' toUri method to return this representation for a given path.
Getting ready The following methods are frequently used when dealing with absolute and relative paths:
On a Windows platform, the output should appear as follows:
The getDefault method returned a FileSystem object representing the filesystem currently accessible to the JVM.
The getSeparator method is executed against this object, returning a backslash character indicating that the code was executed on a Windows machine.
A Path object was created for the users.txt file and the subpath method was executed against it.
This method is discussed in more detail in the Understanding paths recipe.
Since the forward slash was used with the first argument, the path started at the root of the current filesystem.
The URI representation of a path is related to absolute and relative paths.
The Path class' toUri method returns this representation for a given path.
A URI object is used to represent a resource on the Internet.
In this case, it returned a string in the form of a URI scheme for files.
The absolute path can be obtained using the Path class' toAbsolutePath method.
An absolute path contains the root element and all of the intermediate elements for the path.
This can be useful when users are requested to enter the name of a file.
For example, if the user is asked to supply a filename to save results, the filename can be added to an existing path representing a working directory.
The absolute path can then be obtained and used as necessary.
Bear in mind that the toAbsolutePath method works regardless of whether the path references a valid file or directory.
The file used in the previous example does not need to exist.
Consider the use of a bogus file as shown in the following code.
The assumption is that the file, bogusfile.txt, does not exist in the specified directory:
When the program is executed, the output will appear as follows:
If we want to know whether this is a real path or not, we can use the toRealPath method as discussed in the Removing redundancies in a path by normalizing the path recipe.
See also Redundancies in a path can be removed using the normalize method as discussed in the Removing redundancies in a path by normalizing the path recipe.
When symbolic links are used for files, then the path may not be the real path for the file.
The Path class' toRealPath method will return the real absolute path for the file.
This is demonstrated in the Removing redundancies in a path by normalizing the path recipe.
When the "." or ".." notation is used in defining a path, their use may introduce redundancies.
That is, the path described may be simplified by removing or otherwise altering the path.
This recipe discusses the use of the normalize method to affect this type of conversion.
By simplifying a path, it avoids errors and can improve the performance of the application.
The toRealPath method also performs normalization and is explained in the There's more ...
Getting ready The basic steps used for removing redundancies in a path include the following:
The directory structure from the introduction is duplicated here for convenience:
In the first example, the path starts at home and then goes down a directory level to docs directory.
This then proceeds down the music directory and to the mp3 file.
In the second example, the path starts at home and then encounters a single period.
This represents the current directory, that is, the home directory.
Next, the path goes down the music directory and then encounters the mp3 file.
You should get the following output, though the root directory may differ depending on the configuration of your system:
Paths class' get method was used to create two paths using the redundant extraneous paths discussed previously.
The code that follows the get methods displayed the absolute path and the URI equivalent to illustrate the actual path created.
Next, the normalize method was used and was then chained with the toUri method to further illustrate the normalization process.
Notice that the redundancy and extraneous path elements are gone.
The toAbsolutePath and toUri methods are discussed in the Working with relative and absolute paths recipe.
The normalize method does not check to see if the files or path are valid.
The method simply performs a syntactic operation against the path.
If a symbolic link was part of the original path, then the normalized path may no longer be valid.
Symbolic links are discussed in the Managing symbolic links recipe.
The Path class' toRealPath will return a path representing the actual path to the file.
It does check to see if the path is valid and will return a java.nio.file.
Modify the previous example to use the toRealPath method with a non-existent file as shown in the following code:
It also resolves any symbolic links, though there were none in this example.
See also The creation of a Path object is discussed in the Understanding paths recipe.
Symbolic links are discussed in the Managing symbolic links recipe.
Combining paths using path resolution The resolve method is used to combine two paths, where one contains a root element and the other is a partial path.
This is useful when creating paths that can vary, such as those used in the installation of an application.
For example, there may be a default directory where an application is installed.
However, the user may be able to select a different directory or drive.
Using the resolve method to create a path allows the application to be configured independent of the actual installation directory.
Getting ready The use of the resolve method involves two basic steps:
A partial path is one where only a part of the full path is provided and does not contain a root element.
The resolved path was created by using the partialPath variable as an argument to the resolve method executed against the rootPath variable.
These paths along with the absolute path of the resolvedPath were then displayed.
The absolute path included the root directory, though this may differ on your system.
The resolve methods are overloaded, one using a String argument and the second using a Path argument.
Using a String argument with the resolve method The resolve method is overloaded with one that accepts a String argument.
The following statement will achieve the same results as in the previous example:
Using these statements with the earlier code results in the following output:
Notice that the resolved path is not necessarily a valid path as the backup directory may or may not exist.
The toRealPath method in the Removing redundancies in a path by normalizing the path recipe can be used to determine if it is valid or not.
Improper use of the resolve method There are three uses of the resolve method that can result in unexpected behavior:
If we reverse the order in which the resolve method is used, that is apply the root path to the partial path, only the root path is returned.
When the code is executed, we get the following results:
The partial path is not appended to the root path.
Using the partial path twice as shown in the following code:
Notice the resolved path is incorrect and that the absolute path uses the current working directory.
Whenever an absolute path is used as the argument of the resolve method, that absolute path is returned.
If an empty path is used as an argument to the method, the root path is returned.
Using the resolveSibling The resolveSibling method is overloaded taking either a String or a Path object.
With the resolve method, the partial path is appended to the end of the root path.
The resolveSibling method differs from the resolve method in that the last element of the root path is removed before the partial path is appended.
Notice the resolved path differs in the presence of the directory music.
When the resolve method is used, the directory is present.
If there is no parent path, or the argument of the method is an absolute path, then the argument passed to the method is returned.
If the argument is empty then the parent is returned.
See also The creation of a Path object is discussed in the Understanding paths recipe.
Also, the toRealPath method is explained in the Removing redundancies in a path by normalizing the path recipe.
Creating a path between two locations To relativize a path means to create a path based on two other paths such that the new path represents a way of navigating from one of the original paths to the other.
This technique finds a relative path from one location to another.
For example, the first path could represent an application default directory.
A relative path created from these directories could facilitate operations against the target.
Getting ready To use the relativize method to create a new path from one path to another, we need to do the following:
Apply the relativize method against the first path using the second path as its argument.
In the first example, a relative path was created from the Future Setting A.mp3 file to the docs directory.
The music and docs directories are assumed to be siblings.
This chapter's introduction illustrated the assumed directory structure for this example.
The second example demonstrates creating a path from within the same directory.
The path from firstpath to secondPath is actually a potential error.
Depending on how this is used, we could end up in the directory above the music directory since the path returned is ..
The third example is similar to the first example except both of the paths contain file names.
The relative path created by this method may not be a valid path.
This is illustrated by using the potentially non-existent tmp directory, shown as follows:
There are three other cases that we need to consider:
Both paths are equal When both paths are equal, the relativize method will return an empty path as illustrated with the following code sequence:
While this is not necessarily an error, note that it does not return a single dot which is frequently used to represent the current directory.
One path contains a root If only one of the paths contains a root element, then it may not be possible to construct a relative path.
In the following example, the first path contains the root element c:
When this code sequence is executed on Windows 7, we get the following output:
Both paths contain a root The ability of the relativize method to create a relative path when both paths contain a root element is also system-dependent.
When executed on Windows 7, we get the following output:
See also The creation of a Path object is discussed in the Understanding paths recipe.
Symbolic links results are system-dependent and are discussed in more depth in the Managing symbolic links recipe.
Converting between path types The Path interface represents a path within a filesystem.
This path may or may not be a valid path.
There are times when we may want to use an alternative representation of a path.
For example, a file can be loaded into most browsers using a URI for the file.
In this recipe we will also see how to obtain an absolute path and a real path for a Path object.
Getting ready There are three methods that provide alternative path representations:
If not already present, add a users.txt file in the working directory of your application.
Your output should be similar to the following, except the ...
A users.txt file was added to the working directory of the Java application.
The get method returned a Path object representing this file.
Each of the three methods were then executed against this object.
The toUri and toAbsolutePath methods returned paths as expected for that method type.
The path returned is dependent on the application's working directory.
The toRealPath method should have returned the same output as the toAbsolutePath method.
This is to be expected, since the users.txt file was not created as a symbolic link.
Had this been a symbolic link, then a different path representing the actual path to the file would have been displayed.
Notice that the toUri and toAbsolutePath work regardless of whether the specified file exists or not.
In situations where we want to use these methods, we can test whether the file exists or not using the Files class' exists method.
The previous code sequence has been modified to use the exists method shown as follows:
It is used to specify whether symbolic links should be followed or not.
The Path class allows you to test the paths for equality using the equals method.
You can also use the compareTo method to compare two paths lexicographically using an implementation of the Comparable interface.
Finally, the isSameFile method can be used to determine if two Path objects will locate the same file.
Getting ready In order to compare two paths, you must:
Apply either the equals, compareTo, or isSameFile methods to the paths as needed.
In the testEquals method, we determined whether the path objects were considered to be equal.
The equals method will return true if they are equal.
Some filesystems will use the case, among other factors, to determine if the paths are equal.
The testCompareTo method used the compareTo method to compare the paths alphabetically.
If the paths are identical, the method returns a zero.
The method returns an integer less than zero if the path is less than the argument and a value greater than zero if the path follows the argument lexicographically.
The testSameFile method determines whether the paths locate the same file.
The Path objects are first tested to see if they are the same object.
If the Path objects are not equal, the method then determines whether the paths locate the same file.
The method will return false if the Path objects were generated by different filesystem providers.
A try block was used since the method may throw an IOException.
The equals and compareTo methods will not successfully compare paths from different filesystems.
However, as long as the files are on the same filesystem, the files in question do not have to exist and the filesystem is not accessed.
The isSameFile method may require access to the files if the path objects being tested are not found to be equal.
In this case, the files must exist otherwise the method will return false.
See also The Files class' exists and notExists methods can be used to determine whether a file or directory exists or not.
This is covered in the Getting file and directory information recipe in Chapter 3, Obtaining File and Directory Information.
Managing symbolic links Symbolic links are used to create a reference to a file that actually exists in a different directory.
In the introduction, a file hierarchy was detailed that listed the file, users.txt, twice; once in the docs directory and a second time in the music directory.
The users.txt file in the music directory is a symbolic link to the real file.
Modification of either file results in the real file being changed.
From a programmer's perspective, we are often interested in knowing which files are symbolic links and which are not.
In this recipe we will discuss the methods available in Java 7 to work with symbolic links.
It is important to understand how a method behaves when used with a symbolic link.
Getting ready While several methods may behave differently based on whether a Path object represents a symbolic link or not, in this chapter only the toRealPath, exists, and notExists methods take an optional LinkOption enumeration argument.
If the argument is not used then the methods default to following symbolic links.
The behavior of these methods can differ based on the underlying operating system.
When the code is executed on a Windows platform, we get the following output:
The Files class' isSymbolicLink method was executed against these objects indicating which path referenced the real file.
The Path object was created using an extraneous dot notation.
The result of the normalize method executed against the symbolic link returns a normalized path to the symbolic link.
The use of the toAbsolutePath and toUri methods results in a path to the symbolic link and not the real file.
We used this to obtain a path to the real file.
This method is useful when you need the real path, which is often not returned by the other methods executed against a symbolic link.
The firstPath and secondPath objects were used to explore how the relativize method works with symbolic links.
The last set of examples used the exists and notExists methods.
The use of symbolic links did not affect the results of these methods.
See also The use of symbolic files as they affect other filesystem methods is discussed in subsequent chapters.
Introduction Many applications need access to file and directory information.
This information includes such attributes as whether the file can be executed or not, the size of the file, the owner of the file, and even its content type.
In this chapter, we examine the various techniques available for obtaining information regarding a file or directory.
We have organized the recipes according to the type of access desired.
There are five general approaches to obtaining file and directory information using the java.
This is detailed in the Getting file and directory information recipe.
This is detailed in the Obtaining a single attribute at a time using the getAttribute method recipe.
This is explained in the Obtaining a map of file attributes recipe.
Dynamic access to attributes is supported through several methods and allows the developer to specify an attribute using a String.
Java 7 introduces a number of interfaces that are based on a file view.
A view is simply a way of organizing information about a file or directory.
The FileAttributeView interface is the base interface for other interfaces that provide specific types of file information.
The readAttributes method's second parameter specifies the type of attributes to be returned.
Three attribute interfaces are supported and their relationship is illustrated in the following figure.
These interfaces provide a means of accessing their corresponding view interfaces:
There is a recipe devoted to each of these views.
Files and the directory structure used for examples in this chapter are described in the introduction to Chapter 2, Locating Files and Directories Using Paths.
Determining the file content type The type of a file can often be derived from its extension.
However this can be misleading, and files with the same extension may contain different types of data.
The Files class' probeContentType method is used to determine the content type of a file, if possible.
This is useful when the application needs some indication of what is in a file in order to process it.
Getting ready In order to determine the content type, the following steps need to be completed:
Use the Path object as the argument to the probeContentType method.
While you may use any files that you choose, this example uses a text file, a Word document, and an executable file as follows:
The type returned is dependent on the actual files you used:
The Files class' probeContentPath method was executed for each of these files.
The result returned was a String, which was displayed for illustration purposes.
In the files used for this example, the first file was a text file.
The other two were a Word document and the executable java.exe file.
This permits the String to be parsed using the RFC 2045 grammar specifications.
If the content type is not recognized, then null is returned.
A MIME type is composed of a type and a subtype with one or more optional parameters.
The type is separated from the subtype using a forward slash.
In the previous output, the text document type was text and its subtype was plain.
The other two types were both of the type application, but had different subtypes.
It may examine the filename or possibly access file attributes to determine the file content type.
Most operating systems will maintain a list of file detectors.
A detector from this list is loaded and used to determine the file type.
The FileTypeDetector class is not extended, and it is not currently possible to determine which file detectors are available.
Obtaining a single attribute at a time using the getAttribute method.
If you are interested in getting a single file attribute, and you know the name of the attribute, then the Files class' getAttribute method is simple and easy to use.
It will return information about the file based upon a String representing the attribute.
The first part of this recipe illustrates a simple use of the getAttribute method.
Use this object as the first argument of the getAttribute method.
Use a String containing the name of the attribute as the method's second argument.
The output will be as follows, and will depend upon the actual size of the file used:
This path was then used as the first argument of the Files class' getAttribute method.
When the code was executed the size of the file was displayed.
The Files class' getAttribute method possesses the following three arguments:
The following table lists the valid attribute names that can be used with this method:
If an invalid name is used then a runtime error occurs.
For example, if the name is misspelled, we will get a runtime error.
This approach is shown as follows, where the attribute specified has an extra s at the end of the attribute String:
When the application is executed, you should get results similar to the following:
A list of file attributes can be obtained as described in the Obtaining a map of file attributes recipe.
This can be used to avoid using an invalid name.
Obtaining a map of file attributes An alternative way of accessing file attributes is to use the Files class' readAttributes method.
There are two overloaded versions of this method, and they differ in their second argument and their return data types.
In this recipe, we will explore the version that returns a java.util.Map object as it allows more flexibility in what attributes it can return.
The second version of the method is discussed in a series of recipes, each devoted to a specific class of attributes.
Getting ready To obtain a list of attributes in the form of a Map object, the following steps need to be done:
An optional third argument specifying whether symbolic links should be followed or not.
The example used the users.txt file in the docs directory.
A Map object with a key type of String and a value type of Object was declared and then assigned a value from the readAttributes method.
A java.util.Set object was created using the Map interface's keySet method.
This gives us access to both the keys and the values of the Map.
In the for each loop, each member of the set was used as an argument to the getAttribute method.
This corresponding attribute and its value were displayed for the file.
The getAttribute method is explained in the Obtaining a single attribute at a time using the getAttribute method recipe.
In this example, we used the string literal, "*", as the second argument.
This value instructs the method to return all available attributes of the file.
As we will see shortly, other string values can be used to get different results.
The interesting aspect of this method is its second argument.
The syntax for the String argument consists of an optional viewName and a colon followed by an attribute list.
Each of these viewNames corresponds to the name of a view interface.
The attribute list is a comma delimited list of attributes.
If an invalid element name is used, it is ignored.
Using an asterisk will return all of the attributes associated with that viewName.
If a viewName is not included, then all of the basic file attributes are returned as illustrated earlier.
Using the basic view as an example, the following table illustrates how we can be selective about which attributes we return:
String Attributes returned "*" All of the basic file attributes.
The attribute String is used in the same way with views other than basic.
There cannot be any embedded spaces in the attribute String.
Getting file and directory information It is frequently necessary to retrieve basic information about a file or directory.
These methods provide only partial access to file and directory information and are typified by methods such as the isRegularFile method.
A list of such methods are found in the There's more...
Getting ready To use the methods of the Files class to display information is easy since most, if not all, of these methods are static.
This means that the methods can easily be executed against the Files class name.
Use the Path object as an argument to the appropriate Files class' method.
The methods that return these attributes are summarized in the following table:
Method Description exists Returns true if the files exist notExists Returns true if the file does not exist isDirectory Returns true if the Path represents a directory isRegularFile Returns true if the Path represents a regular file isExecutable Returns true if the file can be executed isReadable Returns true if the file can be read.
Method Description isWritable Returns true if the file can be written to isHidden Returns true if the file is hidden and not visible to the.
Several of these methods possess a second argument that specifies how to handle symbolic links.
If it is left out then symbolic links are not followed.
The following table summarizes the exceptions thrown, and whether the method is non-atomic.
Methods that may throw a SecurityException will do so if the calling thread is not permitted to read the file.
When a method is said to be non-atomic, it means that other filesystem operations may execute concurrently with that method.
That is, it is possible that concurrent operations against the method's target may result in possible modification of the state of the file while these methods are executing.
The results of these methods marked as outdated are not necessarily valid upon their return.
That is, there is no guarantee that any subsequent access will succeed as the file may have been deleted or otherwise modified.
Methods designated as Cannot be determined indicate that false may be returned if it is not possible to otherwise ascertain the results.
For example, the exists method will return false if it cannot determine whether the file exists.
It may exist, but the method was not able to determine definitively if it exists or not:
Note that the notExists method is not the inverse of the exists method.
With the use of either method, it may not be possible to determine if the file exists or not.
When this is the case, both methods will return false.
The isRegularFile determines if the file is a regular file.
Both the isDirectory, isSymbolicLink, and the isRegularFile methods may return false if:
The isExecutable method checks to see if the file exists and if the JVM has access rights to execute the file.
If the file is a directory, then the method determines whether the JVM has sufficient privileges to search the directory.
On UNIX systems, a file is hidden if its name begins with a period.
On Windows, a file is hidden if the DOS hidden attribute is set.
An operating system may not support all the attribute views found in Java.
There are three basic techniques for determining which views are supported.
Knowing which views are supported allows the developer to avoid exceptions that can occur when trying to use a view that is not supported.
If that class is supported, the method will return true.
If the class represented by that String is supported, the method will return true.
The first approach is the simplest and will be illustrated first.
Create a new console application with the following main method.
When the application is executed on a Windows 7 system, you should get the following output:
When the application is executed under Ubuntu, version 10.10, you should get the following output:
Notice that the acl view is not supported and a unix and posix view are supported.
However, this interface can be found as part of the JSR203-backport project.
The filesystem for this Path was obtained next using the getFileSystem method.
A for each loop was then used to display each string value.
There are two other methods that we can use to determine which views are supported:
They both allow you to test for a specific view.
Add the following code to the previous example's main method.
In this code, we determine which of the several views are supported:
When executed on a Windows 7 machine, you should get the following output:
Add the following code to the try block of the main method:
When executed on a Windows 7 platform, you should get the following output:
This view provides an alternative means of obtaining file information than that supported by the Files class.
The results of this method may be more reliable at times than those of the Files class.
Use a Path object representing the file of interest as the first argument.
This basic approach is used for the other views illustrated in this chapter.
First, we created a Path object representing the users.txt file.
The first argument of the method is a Path object.
The second argument specifies the type of object that we want returned.
This was followed by a series of print statements that display specific attribute information about the file.
The readAttributes method retrieves all of the basic file attributes for a file.
Since it can throw an IOException, the code sequence was enclosed in a try block.
First, if the isOther method returns true, it means that the file is not a regular file, directory, or a symbolic link.
Additionally, although the file size is in bytes, due to issues such as file compression and implementation of sparse files, the actual size may be different.
If the file is not a regular file, then the meaning of the return value is system-dependent.
The fileKey method returns an object that uniquely identifies that file.
In UNIX, the device id or inode is used for this purpose.
The file key will not necessarily be unique if the filesystem and its files are changed.
They can be compared using the equals method, and can be used in collections.
Again, the assumption is that the filesystem has not changed in a way that affects the file key.
The comparison of two files is covered in the Determining whether two paths are equivalent recipe in Chapter 2, Locating Files and Directories Using Paths.
It returns an AttributeView derived object based on its second parameter.
Use a Path object representing the file of interest as the first argument.
This approach is longer, but we now have access to three additional methods, which are shown as follows:
However, this does not provide us with much useful information.
The setTimes method is illustrated in the Setting time related attributes of a file or directory recipe in Chapter 4, Managing Files and Directories.
This provides a more portable way of writing applications that can be ported across operating systems.
The Determining operating system support for attribute views recipe illustrates how to determine whether a specific operating system supports POSIX or not.
Getting ready In order to obtain POSIX attributes for a file or directory, we need to do the following:
Create a Path object representing the file or directory of interest.
Use the readAttributes method to obtain a set of attributes.
The group and getName methods were used to display the group and owner of the file.
The permissions of the file can be maintained using the setPermissions method.
Maintaining file permissions is discussed in the Managing POSIX attributes recipe in Chapter 4, Managing Files and Directories.
To determine whether POSIX is supported by an operating system, look at the Determining operating system support for attribute views recipe.
However, this is the only interface that can be used to determine if a file is marked for archive or is a system file.
Create a new console application and add the following main method.
This was used to create an instance of the DosFileAttributes interface, which was used with the four methods of the interface.
The setting of file ownership is covered in the Setting file and directory owner recipe of Chapter 4, Managing Files and Directories.
Use its getOwner method to return a UserPrincipal object representing the owner.
Your output should be similar to the following, except the PC and usernames should be different.
The view's getOwner method was then invoked to return a UserPrincipal object.
Its getName method returns the name of the user, which was then displayed.
These attributes include the user principal, the type of attribute, and flags and permissions for the file.
The ability to use this interface allows the user to determine what permissions are available and to modify these attributes.
Getting ready To determine the attributes of a file or directory:
Create the method displayPermissions to display the list of permissions for the file as follows:
Create the method displayEntryFlags method to display the list of ACL flags for the file as follows:
For this example, only the getAcl method was used, which returned a list of AclEntry elements.
A for each loop was used to iterate through the list.
The user principal's name and the entry type were displayed.
Next the displayEntryFlags and displayPermissions methods were invoked to display more information about the entries.
A check was made to determine if there are any elements in the sets and the appropriate messages were displayed.
Next, each element of the sets was displayed on a single line to conserve vertical space on the output.
These methods either return or set a UserPrincipal object respectively for the file or directory.
As we saw in the earlier example, this represents the users who have access to the file.
There are two methods available to the service that can look for the users either by username or by group name.
In the previous code we used the Administrators group and the user Richard.
Add this code to the previous example and change the names to reflect groups and users on your system.
When the code executes, you should receive output similar to the following:
GroupPrincipal objects' methods provide little more information than the names of the users.
User or group names may or may not be case-sensitive depending on the operating system.
See also Managing file ownership and permissions is discussed in Chapter 4, Managing Files and Directories, in the Setting file and directory owner recipe.
Also covered in Chapter 4 is the setting of ACL attributes as illustrated in the Managing ACL file permissions recipe.
This data is not necessarily understood or used by the filesystem.
The name is a String and the value is stored as a ByteBuffer object.
Getting ready A user-defined attribute must first be attached to a file.
The process of reading a user-defined attribute is illustrated in the There's more...
First, we created a Path object representing the users.txt file.
The encode method took the String and returned a ByteBuffer for the attribute value.
We then displayed a simple message indicating the successful completion of the process.
To get a user-defined attribute associated with a file, the following steps need to be followed:
The following code sequence accomplishes this task for the previously attached publishable attribute:
Next, a ByteBuffer was created to hold the attribute value to be retrieved.
This method determines the size of the attached attribute and returns the size.
The read method is then executed against the view object.
The buffer is converted to a String object using the decode method, which uses the operating system's default character set.
Replace the user-defined attribute write sequence in the main method with this read sequence.
When the application is executed, you should get an output similar to the following:
There is also a delete method that is used to remove a user-defined attribute from a file or directory.
Introduction It is often necessary to perform file manipulations such as creating files, manipulating their attributes and contents, or removing them from the filesystem.
The methods of the class are all static in nature, and generally assign the actual file manipulation operations to the underlying filesystem.
Many of the operations described in this chapter are atomic in nature, such as those used to create and delete files or directories.
Atomic operations will either execute successfully to completion or fail and result in an effective cancellation of the operation.
During execution, they are not interrupted from the standpoint of a filesystem.
To execute many of the examples in this chapter, the application needs to run as administrator.
To run an application as administrator under Windows, right-click on the Command Prompt menu and choose Run as administrator.
Then navigate to the appropriate directory and execute using the java.exe command.
To run as administrator on a UNIX system, use the sudo command in a terminal window followed by the java command.
The methods required for the creation of files and directories are covered in the Creating Files and Directories recipe.
The creation of temporary files and directories is covered in the Managing temporary files and directories recipe, and the creation of linked files is covered in the Managing symbolic links recipe.
The options available for copying files and directories are found in the Controlling how a file is copied recipe.
The techniques illustrated there provide a powerful way of dealing with file replication.
Moving and deleting files and directories are covered in the Moving a file or directory and Deleting files and directories recipes, respectively.
The Setting time-related attributes of a file or directory recipe illustrates how to assign time attributes to a file.
Related to this effort are other attributes, such as file ownership and permissions.
File ownership is addressed in the Managing file ownership recipe.
File permissions are discussed in two recipes: Managing ACL file permissions and Managing POSIX file permissions.
The methods implemented by the Files class are relatively intuitive and easy to incorporate into your code.
In this recipe, we will cover how to create new files and directories using the createFile and createDirectory methods.
Getting ready In our example, we are going to use several different methods to create a Path object that represents a file or directory.
The FileSystem class' getPath method can be used to create a Path object as can the Paths class' get method.
The Paths class' static get method returns an instance of a Path based on a string sequence or a URI object.
The FileSystem class' getPath method also returns a Path object, but only uses a string sequence to identify the file.
When you execute the program again, your output should appear as follows:
The first Path object was created and then used by the createDirectory method to create a new directory.
After the second Path object was created, the createFile method was used to create a file within the directory, which had just been created.
It is important to note that the Path object used in the file creation could not be instantiated before the directory was created, because it would have referenced an invalid path.
When the createDirectory method is invoked, the system is directed to check for the existence of the directory first, and if it does not exist, create it.
Had we not caught that exception, an IOException would have been thrown.
The createDirectories method is available to create directories as discussed next.
All three methods provide the option to pass file attribute parameters for more specific file creation.
Using the createDirectories method to create a hierarchy of directories The createDirectories method is used to create a directory and potentially other intermediate directories.
In this example, we build upon the previous directory structure by adding a subtest and a subsubtest directory to the test directory.
Comment out the previous code that created the directory and file and add the following code sequence:
Verify that the operation succeeded by examining the resulting directory structure.
See also Creating temporary files and directories is covered in the Managing temporary files and directories recipe.
The creation of symbolic files is illustrated in the Managing symbolic links recipe.
Controlling how a file is copied The process of copying files is also simplified in Java 7, and allows for control over the manner in which they are copied.
The Files class' copy method supports this operation and is overloaded providing three techniques for copying which differ by their source or destination.
Getting ready In our example, we are going to create a new file and then copy it to another target file.
Specify two Path objects, one for your initial file and one for the location where it will be copied.
Then add the copy method to copy that file to the destination location as follows:
The createFile method created your initial file, and the copy method copied that file to the location specified by the copiedFile variable.
If you were to attempt to run that code sequence twice in a row, you would have encountered an IOException, because the copy method will not, by default, replace an existing file.
The three enumeration values for StandardCopyOption are listed in the following table:
Replace the copy method call in the previous example with the following:
Another example of the use of the copy options is found in the There's more...
If the source file and the destination file are the same, then the method completes, but no copy actually occurs.
In this section, we will examine, in more depth, the processes of:
Copying a symbolic link file When a symbolic link file is copied, the target of the symbolic link is copied.
To illustrate this, create a symbolic link file called users.txt in the music directory to the users.txt file in the docs directory.
This can be done either by using the process described in the Managing symbolic links recipe in Chapter 2, Locating Files and Directories Using Paths, or using the methods illustrated in the Managing symbolic links recipe in this chapter.
Use the following code sequence to perform the copy operation:
The user2.txt file has been added and is not connected to either the linked file or the original target file.
Copying a directory When a directory is copied, an empty directory is created.
When this sequence is executed, you should get the following output:
It should be empty as any files in the source directory are not copied.
Copying an input stream to a file The copy method has a convenient overloaded version that permits the creation of a new file based on the input from an InputStream.
The first argument of this method differs from the original copy method, in that it is an instance of an InputStream.
The following example uses this method to copy the jdk7.java.net website to a file:
When the code executes, you should get the following output:
The URL class' openStream method returns an InputStream which is used as the first parameter of the copy method.
The new file can now be opened with a browser or otherwise can be processed as needed.
Notice that the method returns a long value representing the number of bytes written.
Copying a file to an output stream The third overloaded version of the copy method will open a file and write its contents to an OutputStream.
This can be useful when the content of a file needs to be copied to a non-file object such as a PipedOutputStream.
It can also be useful when communicating to other threads or writing to an array of bytes as illustrated here.
Its toByteArray method is then used to populate an array as follows:
The output will depend on the contents of your file, but should be similar to the following:
Notice the use of the try-with-resources block that handles the opening and closing of the file.
It is always a good idea to close the OutputStream when the copy operation is complete or exceptions occur.
The method may block until the operation is complete in certain situations.
Also, the output stream may need to be flushed since it implements the Flushable interface.
Notice that the method returns a long value representing the number of bytes written.
See also See the Managing symbolic links recipe for more details on working with symbolic links.
Managing temporary files and directories The process of creating temporary files and directories can be an essential part of many applications.
Temporary files may be used for intermediate data or as a temporary store to be cleaned up later.
The process of managing temporary files and directories can be accomplished simply via the Files class.
Getting ready In our example, we are going to create a temporary directory and then create a temporary file within the directory as follows:
This code sequence will result in an output similar to the following:
Likewise, the createTempFile method creates an empty file and returns a Path object representing this new file.
In our previous example, we used the toString method to see the path where our directory and file were created.
The previous numeric directory and filenames are assigned by the system and are platform-specific.
However, if we had wanted to specify text to precede the filename assigned by the system, the second variable could have been populated with this prefix string.
The third parameter of this method could have also been used to specify a suffix, or file type, for our file, such as .txt.
It is important to note that, although in our example we specified the Path in which we wanted our directory and file created, there is another version of each method in which the initial argument, the Path object, could be omitted, and the directory and/or file would be created in the system's default temporary directory.
Additionally, these methods do not check for the file or directory's existence before creating them, and will overwrite any existing file or directory with the same temporary, system-assigned name.
These attributes are optional, but can be used to specify how the temporary files will be handled, such as whether the file should be deleted upon closing.
The creation of a file attribute is described in the There's more...
If it is desirable to delete these files or directories automatically, a shutdown hook or the java.io.File class' deleteOnExit method can be used.
These two techniques will result in the deletion of the element when the application or the JVM terminates.
The timestamp for a file can be critical for some applications.
For example, the order in which operations execute may be dependent on the time a file was last updated.
Getting ready In order to set the times using the setTimes method.
Obtain a Path object, which represents the file of interest.
Use these FileTime objects as arguments of the setTimes method.
Unless you have access to a time machine, or have otherwise manipulated your system's clock, your output should reflect a time later than the time shown as follows:
A try block was used to catch any IOExceptions that might be thrown by the readAttributes or setTimes methods.
Within the try block, FileTime objects were created for each of the three types of time.
The lastModifedTime and createTime times were not changed for the file.
The currentTime long variable was assigned the current time expressed in milliseconds.
Its value was obtained using the getTimeInMillis method executed against an instance of the Calendar class.
The three FileTime objects were then used as arguments to the setTimes method, effectively setting these time values.
There is more to the use of the FileTime class than presented so far.
In addition, the Files class provides alternative approaches for maintaining times.
To create a FileTime object, we need to use either of the following two static FileTime methods:
It represents a time duration as defined in the following table.
It is used in conjunction with another parameter whose combination represents a time duration:
Its value is computed by adding the first long argument, whose unit of measure is specified by the second TimeUnit argument, to the epoch.
For example, the from method can be used to present a point in time, which is 1000 days from the epoch using the following code sequence:
The fromMillis method is used to create a FileTime object, whose time is represented by adding its argument to the epoch where the argument is a long number representing a value in milliseconds.
If we used the following fromMillis method instead of the from method as follows:
Notice that the first argument is a long literal, which forces the result of the expression to be a long number.
If we did not promote our results to be long values, we would have received an integer value, which would have resulted in overflow and an incorrect date.
We could have this method to assign a value to the lastModifedTime variable as follows:
The method has an optional LinkOption argument that indicates whether symbolic links should be followed or not.
Using the Files class' setAttribute method to set individual attributes The setAttribute method provides a flexible and dynamic approach for setting certain file attributes.
To set the last modified time, we could have used the following code sequence:
The Obtaining a single attribute at a time using the getAttribute method recipe in Chapter 3, Obtaining File and Directory Information, details the other attributes that can be set.
See also The Managing symbolic links recipe discusses the use of symbolic links.
Managing file ownership The owner of a file or directory can be modified after the file has been created.
A Path object is used to represent a file or directory.
Using these two objects with the Files class' setOwner method enables us to maintain file ownerships.
Getting ready In order to change the owner of a file or directory:
Obtain a Path object, which represents the file or directory.
In order to modify the ownership of a file, we must have appropriate privileges.
The introduction to this chapter explains how to get administrator privileges.
When the application is executed using Windows 7, the output should reflect the PC name and the file's owners shown as follows.
The PC name is separated from the owner with a backslash:
The last step was to pass the UserPrincipal object to the setOwner method.
It then used the getOwner method to retrieve the current owner verifying the change.
In addition, the Files class' setOwner method can also be used to change ownership of a file.
It differs in that it has two arguments, a Path object representing the file and a UserPrincipal object.
The following sequence illustrates the process of setting the owner of the users.txt file to jennifer:
Managing ACL file permissions In this recipe, we will examine how ACL permissions can be set.
The ability to set these permissions is important for many applications.
For example, when we need to control who can modify or execute a file, we can affect this change programmatically.
What we can change is indicated by the AclEntryPermission enumeration values listed later.
Getting ready To set a new ACL permission for a file:
Create a Path object for the file whose attributes we want to change.
Obtain a list of ACL entries currently assigned to the file.
Create a new AclEntry.Builder object holding the permission that we want to add.
Use the setAcl method to replace the current ACL list with a new one.
To illustrate the process of adding and deleting ACL attributes, we will use a series of helper methods:
The ACL list contains the ACL entries for a file.
When the displayAclEntries method is executed, it will display the number of entries as a convenience and then each entry will be separated by a blank line.
The following illustrates a possible list for the users.txt file:
In order to modify some ACL attributes of a file, we must have the appropriate privileges.
The introduction to this chapter gives the details of how to run the application as the administrator.
Next, comment out the code that adds the ACL entry and verify that the ACL entry has been made.
You should see the following entry added to the list:
The file represented by the Path object was the users.txt file.
Here, we were only interested in using its getAcl method to return a list of the ACL attributes associated with the file.
We displayed the list of current ACLs only to see what they were, and to eventually verify that the attributes for the file have been changed.
In this example, we created a UserPrincipal object that represented users.
A new ACL entry can be created using the build method of the java.nio.file.
The static newBuilder method created an instance of an AclEntry.Builder class.
The setPrincipal method was executed to set users as the principal for the attribute.
The setPermissions method takes either a set of AclEntryPermission objects or a variable number of AclEntryPermission objects.
The AclEntry.Builder object was then added to the existing ACL for the file.
The entry was added at the beginning of the list.
The last step was to use the setAcl method to replace the old ACL list with this new one.
To remove an ACL attribute, we need to obtain the current list and then identify the position of the attribute that we want to remove.
We can use the java.util.List interface's remove method to remove that item.
The setAcl method can then be used to replace the old list with the new one.
The following tables provide additional information and insight into the ACL permissions that are available.
Value Meaning ALARM Results in an alarm being generated in a system-specific manner, when an attempt.
The AclEntryPermission enumeration values are summarized in the table that follows:
Value Meaning APPEND_DATA Ability to append data to a file.
DELETE_CHILD Ability to delete a file or directory within a directory.
READ_NAMED_ATTRS Ability to read the named attributes of a file.
WRITE_NAMED_ATTRS Ability to write the named attributes of a file.
Managing POSIX attributes The POSIX attributes available include a group owner, a user owner, and a set of permissions.
In this recipe, we will investigate how to maintain these attributes.
The management of these attributes makes it easier to develop applications designed to execute on multiple operating systems.
While the number of attributes is limited, they may be sufficient for many applications.
There are three approaches that can be used to manage POSIX attributes:
Getting ready To maintain POSIX permission attributes for a file we need to:
Create a Path object representing the file or directory of interest.
Get a set of permissions for that file using the permissions method.
Ubuntu 11.04 you should get results similar to the following:
The listPermissions method was used to list the permissions for the file.
This method was executed once before and once after the new permission was added to the file.
We did this simply to show the change in permissions.
In the next section, we will illustrate how to remove a permission.
Removing a file permission Removing a permission is simply a matter of:
Modifying the POSIX ownership of a file The POSIX owners are specified at the group and user level.
The setGroup and setOwner methods will set the corresponding memberships.
In the example that follows, the owners for the users.txt file are displayed and then changed.
The UserPrincipal objects are created to support the set methods:
You may need to execute the code as an administrator, as detailed in the introduction.
Its second argument is a LinkOption, which is used to determine how symbolic link files are handled.
We could use the following code sequence to list the permissions associated with a file:
The setAttribute method will set an attribute and has the following four arguments:
The first method returns a FileAttribute object, which can be used with the createFile or createDirectory method as discussed in the Creating files and directories recipe.
On Unix systems, file permissions are frequently expressed as a nine-character string.
The first set represents permission of the user, the second represents permission of the group, and the last set represents the permission of all others.
Each of the three character groups represent the read, write, or execute permissions granted for that set.
An r in the first position grants read permission, a w in the second position indicates write permission, and an x in the last position grants execute permission.
A - in any of these positions means that the permission is not set.
The first section of the code obtains a set of permissions for the users.txt file as detailed earlier in this recipe.
Next, the asFileAttribute method was executed to return the FileAttribute for the file.
The value method was used to obtain a set of the attributes, which were then displayed.
The two sets of permissions were displayed but in a different order.
Next, the toString method was used to display this same set of permissions as a string.
Notice each character reflects a permission granted for the users.txt file.
The last code segment created a new set of permissions using the fromString method.
Moving a file and a directory Moving a file or directory can be useful when reorganizing the structure of a user space.
This operation is supported by the Files class' move method.
When moving a file or directory there are several factors to consider.
These include whether the symbolic link files are present, whether the move should replace existing files, and whether the move should be atomic.
A move may result in the renaming of the resource if the move occurs on the same file store.
The use of this method will sometimes use the Path interface's resolveSibling method.
This method will replace the last part of a path with its argument.
Getting ready In order to move a file or directory:
Obtain a Path object, which represents the file or directory to move.
Obtain a Path object, which represents the destination of the move.
The users.txt file should be absent from the docs directory, but present in the music directory.
The move method used these two Path objects and did not use a third optional argument.
This argument is used to determine how the copy operation works.
When it is not used, the file copy operation defaults to a simple copy.
The StandardCopyOption enumeration implements the CopyOption interface and defines the types of copy operation supported.
The CopyOption interface is used with the Files class' copy and move methods.
These options are explained in more detail in the There's more...
When the source is a symbolic link, the link is copied and not the target of the link.
There are several variations and issues that need to be covered.
Trivial uses of the move method If the source file and the destination files are the same, the method will not have any effect.
No exception will be thrown and the file will not be moved.
The meaning of the StandardCopyOption enumeration values The StandardCopyOption enumeration values require a bit more explanation.
If the file is a symbolic link, then only the symbolic link file is replaced, not its target.
However, if the destination file already exists, then either the file will be replaced or an IOException will be thrown.
An atomic move may fail due to differences in the file store of the source and destination files.
If the following code sequence is executed on Windows 7:
If the file does not exist, its execution will result in the following error message:
Using the resolveSibling method with the move method to affect a rename operation The resolveSibling method will replace the last part of a path with a different string.
This can be used to affect a rename operation when using the move method.
In the following sequence, the users.txt file is effectively renamed:
To rename the file and replace its extension, we can use an explicit name as follows:
The substring method returned a new filename starting with the first character and ending with the character immediately preceding the period.
Moving a directory When a directory is moved on the same file store, then the directory and subdirectories are moved.
The following will move the docs directory, its files, and its subdirectories to the music directory as follows:
Moving a directory across file stores will result in an exception if the directory is not empty.
If the docs directory had been empty in the previous example, the move method would have executed successfully.
If you need to move a non-empty directory across file stores, then this will normally involve a copy operation followed by a delete operation.
Deleting files or directories Deleting files or directories when they are no longer needed is a common operation.
It will save space on a system and result in a cleaner filesystem.
There are two methods of the Files class that can be used to delete a file or directory: delete and deleteIfExists.
They both take a Path object as their argument and may throw an IOException.
Getting ready To delete a file or directory, the following needs to be done:
Obtain a Path object, which represents the file or directory.
Use either the delete or deleteIfExists methods to delete the element.
Create a new console application and use the following main method:
If the users.txt file existed in the directory when the program ran, it should not be there after the program executes.
If the file did not exist, then your program output should appear similar to the following:
We then used it as an argument to the delete method.
Since delete method may throw an IOException, the code was enclosed in a try-catch block.
To avoid an exception that would be thrown if the file did not exist, we could have used the deleteIfExists method instead.
Make sure that the file does not exist and then execute this code.
The program should terminate normally without any exceptions being thrown.
If we try to delete a directory, the directory must first be empty.
Execute the following code sequence in lieu of the previous example:
The definition of an empty directory is dependent on the filesystem implementation.
On some systems where the directory only contains special files or symbolic links, the directory may be considered to be empty.
If a directory is not empty and needs to be deleted, then it will be necessary to delete its entries first using the walkFileTree method as illustrated in the Using the SimpleFileVisitor class to traverse file systems recipe in Chapter 5, Managing File Systems.
If the file to be deleted is a symbolic link, only the link is deleted, not the target of the link.
Also, it may not be possible to delete a file if the file is open or in use by other applications.
Managing symbolic links Symbolic links are files, which are not real files, but rather links to or points to the real file typically called the target file.
These are useful when it is desirable to have a file appearing to be in more than one directory without actually having to duplicate the file.
This saves space and keeps all of the updates isolated to a single file.
The Files class possesses the following three methods for working with symbolic links:
Links are typically transparent to the users of the file.
Any access to the symbolic link is redirected to the referenced file.
Hard links are similar to symbolic links, but have more restrictions.
These types of links are discussed in more detail in the There's more...
Getting ready In order to create a symbolic link to a file:
Use these paths as the argument to the createSymbolicLink method.
If the application does not have sufficient privileges, then an exception will be thrown.
An example of this when executed on Windows 7 is shown as follows:
Verify that a new file called users.txt exists in the music directory.
Check the properties of the file to verify that it is a symbolic link.
On Windows 7, right-click on the filename and select Properties.
Notice that the target specified is the users.txt file in the docs directory.
The first represented the target file in the docs directory.
The second represented the link file to be created in the music directory.
Next, we used the createSymbolicLink method to actually create the symbolic link.
The entire code sequence was enclosed in a try block to catch any IOExceptions that may be thrown.
The third argument of the createSymbolicLink method can be one or more FileAttribute values.
These are intended to be used to set attributes of the link file when it is created.
A FileAttribute can be created as detailed in the There's more...
Here we will look more carefully at the following issues:
Creating a hard link Hard links have more restrictions placed upon them as opposed to symbolic links.
There are no overt properties of the file that indicate that it is a link file, as opposed to a symbolic link file which has a shortcut tab.
All of the attributes of the hard link are identical to that of the target file.
Hard links are not used as frequently as soft links.
Path class methods work with hard links and do not require any special considerations.
It accepts two arguments: a Path object for the link file and for the target file.
In the following example, we create a hard link in the music directory instead of a symbolic link:
If you examine the properties of the link file, you observe that it is not displayed as a symbolic link.
However, modifying the contents of either file will cause the other file to be modified also.
Creating a symbolic link to a directory Creating a symbolic link to a directory uses the same methods as it did for files.
In the following example, a new directory tmp is created, which is a symbolic link to the docs directory:
All of the files in the tmp directory are effectively the symbolic links to the corresponding files in the docs directory.
Determining the target of a link file The isSymbolicLink method, as discussed in the Managing symbolic links recipe in Chapter 2, Locating Files and Directories Using Paths determines whether a file is a symbolic link or not.
The readSymbolicLink method accepts a Path object representing the link file and returns a Path object representing the target of the link.
The following code sequence illustrates this, where the users.txt file in the music directory is a symbolic link:
However, if the users.txt link file is a hard link, as created with the createLink method, we get the following exception when the code is executed:
A reparse point is an NTFS filesystem object that associates specific data to an application with a file or directory.
A filesystem filter can be associated with the reparse point type.
When the filesystem opens the file, it will pass this information to the filesystem filter for processing.
This approach is a way of extending the functionality of the filesystem.
Introduction A filesystem is one or more top-level root directories containing a hierarchy of files.
A filesystem is supported by a file store that is the provider for the storage of the files.
This chapter is concerned with obtaining information about these entities and typical filesystem tasks, such as determining the contents of a directory or monitoring filesystem events.
For example, it might represent a device, such as a C drive, a partition of a drive, or a volume.
The Getting FileStore information recipe covers how to obtain basic information about a specific file store.
A filesystem supports access to a hierarchy of directories and files.
Obtaining general information about a filesystem is covered in the Getting FileSystem information recipe.
This includes how to obtain a list of root directories for a filesystem and the underlying file stores.
The Using the SimpleFileVisitor class to traverse filesystems recipe details the basic approach.
This approach is used in the Deleting a directory using the SimpleFileVisitor class and Copying a directory using the SimpleFileVisitor class recipes.
When an operation is restricted to a single directory, the java.nio.file.
It is very easy to use a for each loop to process these paths.
This approach is explored in the Using the DirectoryStream interface to process the contents of a directory recipe.
Sometimes we don't need the entire contents of a directory, but rather a subset of its elements.
Java 7 provides a few approaches to filtering the contents of a directory as described in the Filtering a directory using globbing and Writing your own directory filter recipes.
Globbing is a pattern-matching technique that is similar to regular expressions but is easier to use.
In the Monitoring file events using WatchEvents recipe we learn how Java 7 supports the detection of file creation, modification, and deletion within a directory by external processes.
This can be very useful when it is necessary to know when changes to a directory are made.
With Java 7, it is now possible to treat the contents of a ZIP file as a filesystem.
This makes it easier to manage the contents of a ZIP file and to manipulate the files contained within the ZIP file.
This technique is demonstrated in the Understanding the zip filesystem provider recipe.
Getting FileStore information Each filesystem supports a file storage mechanism.
This may be a device, such as a C drive, a partition of a drive, a volume, or some other way of organizing a filesystem's space.
This recipe details the methods available to obtain information about the file store.
Use the FileSystem class' getFileStores method to return the available file stores.
Let's start by adding the first part of the main method, where we display an initial header and get a FileSystem object.
Also, define a long variable called kiloByte: static final long kiloByte = 1024;
Your output will differ from the following, but should reflect the drives on your system:
A format string was created to simplify the display of the file store information.
This string was used in both of the printf methods.
Using the same string twice ensures consistent spacing of the output.
A FileSystem object was obtained using the FileSystems class' getDefault method.
The getFileStores method was executed against this object to obtain a list of FileStore objects.
Within the loop, a try block was used to catch exceptions that might have been thrown.
Several methods were invoked as detailed in the following table.
An instance of the NumberFormat class was created to format file store size information.
The last printf method displayed the file store information for each file store:
Method Meaning getTotalSpace The total space available on the file store in bytes.
Getting Filesystem information A filesystem is composed of a hierarchy of directories and files.
There is a limited amount of information regarding a filesystem that is normally useful.
For example, we may want to know whether the filesystem is read-only or who the provider is.
In this recipe we will examine the methods available to retrieve filesystem attributes.
Getting ready To access the method of a filesystem we need to:
Use the methods of this object to access filesystem information.
This sequence displays several fileSystem attributes, including the filesystem provider, file open status, whether the file is available to be read-only, the root directories, and the names of the file stores:
Your output will depend upon the configuration of your system.
The getDefault method returned the default filesystem used by the JVM.
In this case, it was a Windows filesystem provider that came bundled with the JVM.
While we do not normally need to close a filesystem, the close method can be used to close the filesystem.
Any open channels, directory streams, and watch services associated with the filesystem will also be closed.
The FileSystems class' getFileSystem method can be used to access a specific filesystem.
In addition, the overloaded newFileSystem method will create new filesystems.
However, if one thread attempts to close the filesystem while another thread is accessing the filesystem object, the close operation may be blocked until the access is complete.
When working with directory systems, a common need is to traverse the filesystem examining each subdirectory within a file hierarchy.
This class implements methods that execute before and after a directory is visited.
In addition, callback methods are invoked for each instance a file is visited in a directory and if an exception occurs.
The SimpleFileVisitor class or a derived class is used in conjunction with the java.
It performs a depth first traversal, starting at a specific root directory.
Use these objects as arguments to the Files class' walkFileTree method.
Depending on the structure of your home directory, you may get results different from the following:
Examine the backup directory to verify that it was created successfully.
In the main method, we created a Path object for the home directory.
These objects were used as the arguments of the walkFileTree method.
This method affected the traversal of the home directory and invoked the methods of the ListFiles class as required.
The walkFileTree method started at a root directory, and performed a depth first traversal of the directory hierarchy.
Before a directory was traversed, the preVisitDirectory method was invoked.
If it was a file, then the visitFile method was invoked.
Once all of the elements of the directory had been processed, the postVisitDirectory method was invoked.
If an exception had occurred, then the visitFileFailed method would have been invoked.
Private helper methods were added, which made the output more readable.
The indentionLevel variable was incremented and decremented as each subdirectory was visited.
One takes a Path and a FileVisitor object, which was illustrated previously.
It will not follow links and will visit all levels of the directory.
The second method takes two additional arguments: one that specifies the number of directory levels to be visited and a second one to configure the traversal.
If they are followed when specified by an argument of the walkFileTree method, then care is taken to detect circular links.
If a circular link is detected, it is treated as an error condition.
The number of levels of directories to visit is controlled by an integer argument.
A value of 0 will result in only the top-level directory being visited.
A value of two means only the first two directory levels are traversed.
The traversal will terminate when one of the following conditions occurs:
Any unsuccessful action will generally result in the visitFileFailed method being invoked and an IOException being thrown.
If successful, the attribute is passed to the visitFile method.
If unsuccessful, the visitFileFailed method is invoked, and it will throw an IOException unless it is dealt with.
If the file is a directory and the directory can be opened, then the preVisitDirectory is invoked and the elements of the directory and their descendants are visited.
If the file is a directory and the directory could not be opened, the visitFileFailed method is invoked and it will throw an IOException.
However, the depth-first search will continue with the next sibling.
Element encountered Can be opened Fails to open File visitFile is invoked visitFileFailed is.
For convenience, the enumeration constants for the enumeration FileVisitResult are listed as follows:
Value Meaning CONTINUE Continue the traversal SKIP_SIBLINGS Continue without visiting the siblings of this file or directory.
SKIP_SUBTREE Continue without visiting the entries in this directory TERMINATE Terminate.
See also The Deleting a directory using the SimpleFileVisitor class and Copying a directory using the SimpleFileVisitor class recipes utilize the approach described in this recipe to delete and copy a directory respectively.
The ability to delete a directory is a requirement of some applications.
This recipe builds on the foundation provided in the Using the SimpleFileVisitor class to traverse filesystems recipe.
Create an instance of a class derived from SimpleFileVisitor as follows:
Use these objects as arguments to the Files class' walkFileTree method.
Back up the home directory and then execute the application.
You should get the following output depending on the actual directory structure:
In the main method, we created a Path object representing the home directory.
These two objects were used as arguments to the walkFileTree method, which started the traversal process.
When a file is encountered, the visitFile method was executed.
In this method, we displayed a message indicating that the file was being deleted, and then used the Files class' delete method to delete the file.
When a directory was encountered, the postVisitDirectory method was invoked.
A test was made to ensure that no errors had occurred, and then a message was displayed indicating that the directory was being deleted followed by the invocation of the delete method for that directory.
See also The Using the SimpleFileVisitor class to traverse filesystems recipe provides more detail on the use of the walkFileTree method and the SimpleFileVisitor class.
The Copying a directory using the SimpleFileVisitor class recipe also provides a variation of the use of this approach.
The ability to copy a directory is a requirement of some applications.
This recipe builds on the foundation provided in the Using the SimpleFileVisitor class to traverse filesystems recipe.
Create an instance of a class derived from the SimpleFileVisitor as follows:
Use these objects as arguments to the Files class' walkFileTree method.
The exact output is dependent on the source file structure you used, but should be similar to the following:
In the main method, we created Path objects for the home and backup directories.
We used a two-argument CopyDirectory constructor, so that its methods would have direct access to the two paths.
It was also passed as the second argument, an EnumSet, which specified that symbolic links were not to be followed.
The third argument of the walkFileTree method was a value indicating how many levels to follow.
The last argument was an instance of the CopyDirectory object.
When a file was encountered during the traversal, the CopyDirectory class' visitFile method was invoked.
A message was displayed indicating that the file was being copied, followed by the use of the copy method to copy the source file to the target directory.
The relativize method was used to obtain a relative path to the source, which was used as the argument of the resolve method.
The result is a Path object representing the target directory with the source filename.
These methods are discussed in the Combining paths using path resolution and Creating a path between two locations recipes in Chapter 2, Locating Files and Directories Using Paths.
When a directory was encountered during the traversal, the preVisitDirectory method was invoked.
It works the same way as the visitFile method, except we copied a directory instead of a file.
It is still necessary to copy the individual files of a directory, since the copy method only copies a single file.
Notice that the CopyDirectory class extended the SimpleFileVisitor class using Path as the generic value.
The walkFileTree method requires an object that implements the Path interface.
Thus we had to use Path or an interface that extended Path.
See also The Using the SimpleFileVisitor class to traverse filesystems recipe provides more detail on the use of the walkFileTree method and the SimpleFileVisitor class.
The Deleting a directory using the SimpleFileVisitor class recipe also provides a variation on the use of this approach.
Processing the contents of a directory by using the DirectoryStream interface.
Determining the contents of a directory is a fairly common requirement.
In this recipe, we will examine the use of the java.nio.file.
These files may be regular files or possibly linked or hidden.
The DirectoryStream interface will return all of these element types.
The versions used to filter the contents of the directory are shown in the Filtering a directory using globbing recipe and the Writing your own directory filter recipe.
Getting ready In order to use the DirectoryStream, we need to:
Your output should reflect the contents of your home directory and should be similar to the following:
This object was used with the newDirectoryStream method, which returned a DirectoryStream object for the directory.
This allowed the DirectoryStream object to be used with a for each statement, which simply printed the name of each element of the home directory.
In this case, there were only two subdirectories: docs and music.
If this type of try block was not used, then it is important to close the stream after it is no longer needed.
The DirectoryStream interface has a single method, iterator, which returns an Iterator type object.
The first time the method is invoked, an Iterator object is returned.
The hasNext method will read ahead by at least one element.
If the method returns true, then the next invocation of its next method is guaranteed to return an element.
Also, many operating systems have links to themselves and/or their parent as represented by a "." or ".." in many shells.
The iterator returned is sometimes referred to as weakly consistent.
This means that while the iterator is thread-safe, any updates to the directory after the iterator has returned will not result in a change to the iterator.
A globbing pattern is a string containing a series of characters that define a pattern.
The pattern is used to determine which directory elements to return.
Filter interface has a single method, accept, which returns a Boolean value indicating whether the directory element should be returned or not.
See also The Filtering a directory using globbing recipe illustrates the use of the globbing pattern.
The Writing your own directory filter recipe shows how to create and use a DirectoryStream.
Filtering a directory using globbing A globbing pattern is similar to a regular expression but it is simpler.
Like a regular expression it can be used to match specific character sequences.
We can use globbing in conjunction with the newDirectoryStream method to filter the contents of a directory.
The use of this method is demonstrated in the Using the DirectoryStream interface to process the contents of a directory recipe.
Use these two objects as arguments to the newDirectoryStream method.
First, a Path object representing the bin directory was created.
It was then used as the first argument to the newDirectoryStream method.
In this case, it matched a directory element which started with java and ended with .exe.
A for each loop was then used to display the filtered files.
Globbing strings are based on patterns, which use special characters to match string sequences.
These are defined in the documentation for the Files class' getPathMatcher method.
There are several special characters summarized in the following table:
Special Symbols Meaning * Matches zero or more characters of a name component without.
The ** symbol is not applicable here, since the newDirectoryStream method returns individual elements.
There is no opportunity here to match sequences that cross directory boundaries.
The following table presents several examples of potentially useful globbing patterns:
It has a single method matches, which accepts a Path argument.
If the file matches the glob pattern, then it returns true.
In the following code sequence, we modify the previous example by creating a PathMatcher object using the glob pattern: glob:java?.exe.
Within the for loop, we use the matches method to further filter a subset of the file that starts with java and is followed by a single character and then ends with .exe:
When you execute this sequence, you should get the following output:
Notice the use of the glob: prefix used with the matches method.
Its use is required with this method, but not with the newDirectoryStream method.
However, notice that we used the String returned from the Path class' getFileName method.
Using the Path object only or using a String literal does not work.
Instead of using the glob: prefix, we can use regular expressions instead.
To do this, use a reg: prefix followed by a regular expression.
Normally, for a simple filtering of a directory, we would use the more restrictive glob pattern as part of the newDirectoryStream method.
However, if we wanted to perform more than one filtering operation as part of a loop, then using a pattern as part of the newDirectoryStream method, and later with the use of one or more matches method invocations is a viable strategy.
See also The Writing your own directory filter recipe explores how to create more powerful filters to match filenames based on attributes other than the filename.
This is useful when we need to limit the stream's output.
For example, we may only be interested in those files that exceed a certain size or were last modified after a certain date.
It is more powerful than using globbing as described in the Filtering a directory using globbing recipe because decisions can be based on factors other than the filename.
Use these two objects as arguments to the newDirectoryStream method.
When executed, your output should list only those files that are hidden.
In the accept method, the isHidden method was used to determine whether the element file was hidden or not.
Filter interface used its accept method to determine whether a directory element should be returned or not.
This method returned either a true or a false indicating whether the element should or should not be returned by the newDirectoryStream method, respectively.
Thus, it filters out the undesirables, which in this case were non-hidden elements.
A for each loop was used to display the hidden elements.
When the filter variable was declared, it was declared using Path as its generic value.
Interfaces that extended the Path interface could also be used.
If more than one directory needs to be filtered, then the example used in the Using the SimpleFileVisitor class to traverse filesystems recipe can be adapted to address multiple directories.
Monitoring file events using WatchEvents When an application needs to be aware of changes in a directory, a watch service can listen to the changes and then inform the application of these changes.
The service will register a directory to be monitored based on the type of event that is of interest.
When the event occurs, a watch event is queued and can subsequently be processed as dictated by the needs of the application.
Getting ready To monitor a directory for events, we need to do the following:
Next, create an array of watch events to monitor for file creation, deletion, and modification as follows:
Using a text editor, create a new file called temp.txt and save it in the docs directory.
The application should then display output similar to the following.
Your output may differ if this is the first time you created the file in the directory.
These entries indicate that the file has been created and its contents are then saved:
This was acquired by obtaining the default filesystem and then applying the newWatchService method to it.
Next, we created a Path object representing the docs directory and an array of events that cover creation, deletion, and modification type events.
An infinite loop was then entered to monitor and handle file events that occur in the docs directory.
The loop started by displaying a message indicating that it was waiting for events.
When an event occurred, it returned with a WatchKey object, which contained information about the event.
Its watchable method returned the object being watched, which was then displayed for informational purposes.
The watch key was verified to be valid using the isValid method, and its pollEvents method was used as part of a for each loop.
The pollEvents method returned a list of all pending events.
The type, context, and count value associated with the event were displayed.
The context for the events that we monitored was the relative path between the target directory and the entry that caused the event.
The count value depends on the event and is addressed in the next section.
This was needed to put the key back into a ready state until it is needed again.
If the method returned false, then the key is no longer valid.
The WatchService interface possesses methods to get a watch key and to close the service.
The poll and take methods retrieve the next watch key as we saw earlier.
The poll method will return null if there are none present.
However, the take method will block until a watch key is available.
There is an overloaded poll method that takes additional arguments to specify how long to wait for an event before returning.
These arguments include a time out value and a TimeUnit value.
The use of the TimeUnit enumeration is discussed in the Understanding the FileTime class section of the Setting time related attributes of a file or directory recipe in Chapter 4, Managing Files and Directories.
The Path class' register method will register a file specified by the Path object that it is executing against.
In this release of Java, there are no defined modifiers.
The fields of this interface are summarized in the following table:
When an event occurs, the watch service will return a WatchKey object representing the event.
This key is reused for multiple occurrences of the same event type.
When an event of that type occurs, the count associated with the event is incremented.
If multiple events of that type occur before the events are processed, the count value is incremented each time by some amount.
The use of the reset method in the previous example will re-queue the watch key and reset the count to zero.
Each directory entry will have its own watch key for that event type.
An event can be canceled using the WatchKey interface's cancel method.
Any pending events in the queue will remain in the queue until removed.
Watch events are also canceled if the watch service is closed.
This implies that if multiple threads are accessing events, then care should be taken when using the reset method.
The method should not be used until all of the threads using that event have completed processing the event.
The watch service can be closed using the close method.
A filesystem may be able to report events faster than the watch service can handle them.
Some implementations of a watch service may impose a limit of the number of events queued.
When events are intentionally ignored, then an event of the type OVERFLOW is used to report this problem.
The ZIP filesystem provider introduced in this release handles ZIP and JAR files as though they were filesystems and, as a result, you can easily access the contents of the file.
You can manipulate the file as you would do ordinary files, including copying, deleting, moving, and renaming the file.
You also have the ability to modify certain attributes of the file.
This recipe will show you how to create an instance of a ZIP filesystem and add directories to the system.
Create a HashMap object to specify the create property as true.
The URI object specifies the location of your ZIP file by using a HashMap object, we specified that if the ZIP file does not exist, it should be created.
The FileSystem object, zipFileSys, was created in the try-with-resources block, so the resource will automatically be closed, but if you do not wish to use the nested try-with-resources block you must use the FileSystem class' close method to close the resource manually.
The try-with-resources block is detailed in Chapter 1, Java Language Improvements, recipe: Using the try-with-resources block to improve exception handling code.
To demonstrate how ZIP files can be manipulated as FileSystem objects, we invoked the createDirectory method to add a folder within our ZIP file.
At this point, we also had the option to perform other FileSystem operations, such as copying files, renaming files, and deleting files.
See also See the Using the DirectoryStream interface to process the contents of a directory recipe for more information on the DirectoryStream class.
Introduction In Java 7, we found that there are numerous improvements to its IO capabilities.
Most of these are found in the java.nio package, which has been dubbed as NIO2
In this chapter, we will focus on the new support for streaming and channel-based IO.
Stream IO acts on a single character at a time, while channel IO works with a buffer for each operation.
We start with the new techniques used to work with simple files.
These are supported by the Files class and are discussed in the Managing simple files recipe.
Buffered IO is usually more efficient and is explained in the Using buffered IO for files recipe.
The position can be changed using seek type random IO operations.
The asynchronous nature of these operations is that they do not block.
An asynchronous application can continue executing without the need to wait for an IO operation to complete.
When the IO completes, a method of the application is called.
However, the underlying operating system must provide local support for this class.
The users.txt file is used for several examples found in this chapter.
The contents of the users.txt file are assumed to initially contain the following:
Should your file's content differ, then the output of the examples will vary accordingly.
Several of the recipes in this chapter open a file.
Some of these open methods that will use an enumeration argument to specify how the file should be opened.
The values of the enumeration are summarized in the following table:
Enumeration Meaning APPEND Bytes are written to the end of the file.
CREATE_NEW Creates a new file only if the file does not exist.
It has a bind method that binds a socket to a local address, allowing the retrieval and setting of various query socket options.
It permits the use of operating system-specific options, which could be used for high performance servers.
It is used to support multicast operations for a group.
Methods of this interface support the joining and leaving of members from a group.
The Sockets Direct Protocol (SDP) is a network protocol, which supports stream connections using InfiniBand (IB)
The IB technology supports point-to-point bi-directional serial links between high-speed peripherals, such as disks.
A significant part of IB is its ability to move data from the memory of one computer directly to the memory of another computer.
However, SDP must be enabled before it can be used.
Managing simple files Some files are small and contain simple data.
When it is feasible to read or write the entire contents of the file at one time, there are a few Files class methods that will work quite well.
In this recipe, we will examine techniques for processing simple files.
Initially, we will examine how to read the contents of these types of files.
In the There's more section, we will demonstrate how to write to them.
Getting ready To read the entire contents of a file at once:
We started by creating a Path object, which represents the users.txt file.
The Files class' readAllBytes method was executed using the path object as its argument.
Next, a for statement was used to iterate through the array.
Each byte was cast to a char and then displayed.
The method will automatically close the file once all of the bytes have been read or should an exception occur.
In addition to an IOException that might occur, an OutOfMemoryError may be thrown, if it is not possible to create an array of sufficient size to hold the contents of the file.
Should this happen, then an alternative approach should be used.
Writing to a simple file In the following example, we are going to take the contents of the users.txt file and add a new name to the list.
Using the previous code, comment out the for loop that prints out the values of contents.
Then, after invoking the readAllBytes method on the Path object, create a new path object directed to a new, non-existent text file.
Then declare a String variable called name and invoke the getBytes method on the string to return a new byte array.
Next, we are going to use the Files class write method to create a new file with the same contents as our users.txt file, and then append our String name to this list.
If you open the newUsers.txt file, you will see the list of names from your users.txt file, appended by the name you specified using the newContents byte array.
There is also an overloaded write method that uses the same Path object for its first parameter and uses the Iterable interface to iterate over a CharSequence as its second parameter.
The third parameter of this method defines the Charset to use.
The open options were listed in the introduction to this chapter.
Reading all of the lines of a file returned as a list In instances where you have a simple file you wish to read from, it can be efficient to use the readAllLines method.
The method takes two arguments, namely, a Path object and a Charset.
In the following example, we use the path to our users.txt file and the Charset class' defaultCharset method to execute the readAllLines method.
The method returns a list of strings, which we print out within a for loop.
Notice that the strings returned from the readAllLines method does not include the end of line character.
Using buffered IO for files Buffered IO provides a more efficient technique for accessing files.
These classes provide an easy to use and efficient technique for working with text files.
In the There's more section, we will demonstrate how to write to a file.
Getting ready To read from a file using a BufferedReader object:
Create a new console application using the following main method.
Your output should reflect the contents of the users.txt file, which should be similar to the following:
A Path object representing the users.txt file was created followed by the creation of a Charset.
Other character sets can be used, depending on the platform used.
A try-with-resource block was used to create the BufferedReader object.
This will result in the BufferedReader object automatically being closed when the block completes.
When a byte is stored in a file, its meaning can differ depending upon the intended encoding scheme.
The second argument of the newBufferedReader method specifies the encoding to use.
There is a standard set of character sets supported by the JVM, as detailed in the Java documentation for the Charset class.
Writing to a file using the BufferedWriter class The newBufferedWriter method opens or creates a file for writing and returns a BufferedWriter object.
The method requires two arguments, a Path object and a specified Charset, and can use an optional third argument.
The third argument specifies an OpenOption as detailed in the table found in the Introduction.
If no option is specified, the method will behave as though the CREATE, TRUNCATE_EXISTING, and WRITE options were specified, and will either create a new file or truncate an existing file.
In the following example, we specify a new String object containing a name to add to our users.txt file.
After declaring our Path object, we use a try-with-resource block to open a new BufferedWriter.
Within the try block, we first invoke the newline method against our BufferedWriter object to ensure that our name goes on a new line.
Then we invoke the write method against our BufferedWriter object, using our String as the first argument, a zero to denote the beginning character of the String, and the length of our String to denote that the entire String should be written.
If you examine the contents of the users.txt file, the new name should be appended to the end of the other names in the file.
Un-buffered IO support in the Files class While un-buffered IO is not as efficient as buffered IO, it is still useful at times.
The Files class provides support for the InputStream and OutputStream classes through its newInputStream and newOutputStream methods.
These methods are useful in instances where you need to access very small files or where a method or constructor requires an InputStream or OutputStream as an argument.
In the following example, we are going to perform a simple copy operation where we copy the contents of the users.txt file to a newUsers.txt file.
We first declare two Path objects, one referencing the source file, users.txt, and one specifying our destination file, newUsers.txt.
Then, within a try-with-resource block, we open both an InputStream and an OutputStream, using the newInputStream and newOutputStream methods.
Within the block, we read in the data from our source file and write it to the destination file.
Upon examining the newUsers.txt file, you should see that the content matches that of the users.txt file.
Random access to a file is useful for more complex files.
It allows access to specific positions within the file in a non-sequential fashion.
The output should display the first two names in reverse order: Mary Bob.
We created a bufferSize variable to control the size of the buffer, used by the channel.
Next, a Path object was created for the users.txt file.
We moved the read position in the file to the fourth position.
This placed us at the beginning of the second name in the file.
The read method was then used, which read approximately eight bytes into buffer.
The first five bytes of the buffer were then displayed.
We repeated this sequence, but moved the position to zero, that is, the beginning of the file.
A read operation was performed again, and then we displayed the first four characters, which were the first name in the file.
This example used explicit knowledge of the size of the names in the file.
Normally, this knowledge is not available unless obtained by some other technique.
The read method will start reading from the current position in the file.
It will read until either the buffer is filled or the end of file is reached.
The method returns an integer, indicating how many bytes were read.
A -1 is returned when the end of stream is reached.
There is a size method that returns the size of the stream.
A truncate method is available that discards all bytes past a specific position in the file.
This position is passed as a long argument to the method.
The Files class' static newByteChannel method can take a second argument, which specifies the option used when opening the file.
These are detailed in the There's more section, Writing to a file using the BufferedWriter class, of the Using buffered IO for files recipe.
Processing the contents of the entire file Add the following code to the application.
We started by repositioning the read to the beginning of the file, using the position method.
The encoding string for the system was determined for the system by accessing the system property: file.encoding.
We kept track of how many bytes are read with each read operation and displayed this count.
In the while loop, we displayed the contents of the buffer by enclosing it in a set of brackets.
This made it easier to see what was read in.
This is not to be confused with the position within the file.
To display the actual buffer, we need to apply the forName method to obtain a Charset object, and then use the decode method against it to convert the bytes in the buffer into Unicode characters.
You may want to adjust the bufferSize value to see how the application behaves with different values.
The operation starts at the current position in the file.
For example, if the file was opened with an append option, the first write will be at the end of the file.
In the following example, we will append three names to the end of the users.txt file.
This will move the cursor to the end of the file and begin writing at that position.
A ByteBuffer is created with three names separated by the system line separator property.
Add the code sequence to the application and execute the program.
Query the position The overloaded position method returns a long value indicating the position within the file.
This is complemented by a position method that takes a long argument and sets the position to that value.
If the value exceeds the size of the stream, then the position is set to the end of the stream.
The size method will return the size of the file used by the channel.
To demonstrate the use of these methods, we will duplicate the example in the previous section.
This means we will position the file cursor to the end of the users.txt file and then write three different names on separate lines.
In the following code sequence, we use the size method to determine how big the file is, and then use this value as the argument to the position method.
This moves the cursor to the end of the file.
Next, a ByteBuffer is created thrice, and written to the file each time using a different name.
Add this sequence to the application and execute the program.
Java 7 supports asynchronous communications between a server and a client.
Together we can use these classes to build a server/client application that communicates in an asynchronous fashion.
Getting ready Both a server and a client need to be created.
We will create two applications: one on the server and one on the client.
Create a new console application that will be on the server and add the following main method.
The server will simply display any messages sent to it.
It opens a server socket and binds it to an address.
It will then use the accept method with a CompletionHandler to process any requests from a client.
Depending on your environment, you may need to execute one of the applications in a command window and the second in your IDE.
This will be the case if you can have only one instance of your IDE running at a time.
It should prompt you for a message and then send the message to the server where it will be displayed.
The client and the server output are shown in separate columns in the following table:
Notice that when the client application was terminated, an ExecutionException occurred in the server.
Normally, we would handle this exception more gracefully in a production application.
Next, the accept method was invoked to accept a connection.
The first argument specified a null value, which was used for attachments.
This object was created as an anonymous inner class, and its methods will be called when a communication request made by a client makes a communication request.
In the completed method, we displayed a message indicating that the method is executing.
We then entered an infinite while loop where we allocated 32 bytes to a buffer, and then attempted to read from a client.
The read method returned a Future object that we subsequently used the get method against.
This effectively blocked the execution until the client sent a message.
Notice that the get method returned a generic Future object of type Integer.
We could have used this to determine how many bytes were actually read.
It was used here simply to block until the IO was complete.
The failed method would have been called if an exception had occurred with the channel communication.
The infinite while loop at the end of the try block prevents the server from terminating.
This is acceptable here for simplicity's sake, but normally, we would handle this in a more graceful fashion.
A network address corresponding to the server was created and then used with the connect method to connect to the server.
We used this object with the get method to block until a connection with the server was established.
Notice that the connect method returned a Future object of the type Void.
The Void class is found in the java.lang package and is a wrapper class for void.
It was used here as nothing was effectively returned by the connect method.
A while loop was entered, which terminated when the user entered quit.
The user was prompted for a message, and then a ByteBuffer object was created using the message.
Notice the use of multiple exceptions in the catch blocks of both applications.
Both versions' first argument is a SocketAddress object, corresponding to a local address.
A null value can be used, which will automatically assign a socket address.
The second bind method accepts an integer value for the second argument.
There are two aspects of this communication technique that we should address:
There is a no argument method that accepts a connection and returns a Future object for the channel.
Instead of using the accept method, which uses a CompletionHandler, we can use the following sequence to do the same thing.
Comment out the previous accept method and add the following code:
The getOption method will return the value of the option.
Add the following code after the use of the bind method in the previous example:
The default values will be displayed and should be similar to the following:
This method takes the name of the option and a value.
The following illustrates how to set the receive buffer size to 16,384 bytes:
See also f In this chapter: There's more section, of the Reading from a file using the.
When an IO method is invoked, it will return immediately.
The actual operation may occur at some other time (and potentially using a different thread)
Create a Path object representing the file to be read from.
Use this path with the open method to open a file channel.
Use the write method to write data to the file, optionally using a completion handler.
In this example, we will perform a series of write operations against a file.
Both take as their initial arguments a java.nio package's ByteBuffer, containing the data to be written and a second argument specifying the position to write to in the file.
The second write method has a third argument, an attachment, and a fourth argument, a CompletionHandler object.
The completion handler is executed when the write operation completes.
Due to the asynchronous nature of the operations, the order of execution of the various elements may vary from execution to execution.
Re-executing the application may give a different order of execution.
The file was opened for read and write operations, and was supposed to be created if it did not already exist.
This was used in this example to confirm the execution of the write operations.
The first time the string, Sample, was written to the file, starting at position 0 in the file.
This resulted in an overwrite, with the contents of the file containing the string, Boxple.
This was intentional, and illustrates the use of the position argument of the write method.
The ID of the current thread was displayed at various points in the code.
It shows one thread used for the main method, and two other threads used for the content handlers.
When the write method was executed, it was performed in an asynchronous fashion.
Upon completion of the write operation, a successful completion results in the content handler's completed method executing.
This displays the ID for its thread, and a message showing the attachment and the number of bytes written.
If an exception occurs, the failed method will be executed.
As you can see from the output, a separate thread was used to execute the completion handler.
The completion handler was defined to return an Integer value.
In this case, we used it to show which write method has completed.
The asynchronous nature of the write operations resulted in an unpredictable execution order of the content handlers.
However, the write methods did execute in the anticipated order.
Later, in the program, we can use its get method, which blocks until the write operation has completed.
Comment out the previous example's write operations, and replace them with the following code sequence:
The get method was blocked until the write operation was completed.
We used the result to display a message indicating which write operation executed and how many bytes were written.
There are considerably more aspects of asynchronous file channel IO that could be addressed.
Asynchronous read operations are also possible using either of two overloaded read methods.
Create a Path object representing the file to be read from.
Use this path with the open method to open a file channel.
Use the read method to read data from the file.
In the main method, create an instance of a java.
Next, add code to create an array of ByteBuffer objects.
Allocate 10 bytes for each buffer, and then use a buffer as the first argument of the read method and as the attachment.
Using it as the attachment, allows us to access the result of the read operation in the completion handler.
The starting read position is specified in the second argument, and is set up to read every 10-byte segment of the file.
Notice the use of three IDs for the completion handler threads.
These correspond to the three threads created as part of the thread pool.
In the content handler, upon successful completion, the completed method was executed.
The attachment contained the buffer read, which was then displayed along with the content handler's thread ID.
Notice the use of the synchronized keyword for the completed method.
While not always required for the method, it was used here, so that the output would be more readable.
The removal of the keyword would result in an interleaving of the buffer's output, making it unreadable.
They did not execute in the order that the corresponding read methods were executed.
The read method was executed five times using a different buffer.
The awaitTermination method was executed, which effectively paused the application for a second.
The buffers were then displayed a second time to verify the operation.
Whenever an asynchronous channel is created, it is assigned to a channel group.
By defining your own group, you can exercise better control over the threads used in the group.
When a channel is created using an open method, it belongs to a global channel group.
An asynchronous channel group provides techniques needed for the completion of asynchronous IO operations that are bound to a group.
These threads are used for the IO operations and CompletionHandler objects.
In the previous example, we used the open method to associate a thread pool with the asynchronous operations.
The size of the pool is specified by its first argument.
The second argument specifies a suggested number of initial threads for the pool.
An asynchronous channel group provides the ability to perform an orderly shutdown of a group.
All channels are closed but content handlers are not interrupted.
It supports race-free (sequentially consistent) operations on a directory, where the operations are performed concurrently with other applications.
If the cast fails, then the underlying operating system does not support this type of stream.
The following output was obtained by running the application on an Ubuntu system:
A Path object for the docs directory was obtained and then used as the argument of the Files class' newDirectoryStream method.
Some of these are minor improvements and are discussed in this introduction.
It is now possible to mix heavyweight and lightweight components in an application without adding special code to make it work as desired.
However, the essence of this approach, and special situations that might arise from their use, are detailed in the Mixing heavyweight and lightweight components recipe.
To ease the development of applications, three basic window types have been introduced.
These should simplify the creation of certain types of applications and are discussed in the Managing window types recipe.
The overall appearance of an application may include such characteristics as its opacity and shape.
The Managing the opacity of a window recipe illustrates how to control a window's opacity and the Creating a varying gradient translucent window recipe looks into creating gradients for such windows.
Controlling the shape of a window, such as making it round or some irregular shape, is detailed in the Managing the shape of a window recipe.
However, they were implemented as part of the private com.sun.awt.
These are illustrated in the Using the new border types in Java 7 recipe.
Improvements have also been made in the use of the file dialog and print dialog boxes.
These enhancements are discussed in the Handling multiple file selection in the FileDialog class and Controlling the print dialog box type recipes, respectively.
The ability to draw over a JComponent has been added.
This allows the use of special effects, which were not easily achieved in earlier versions of Java.
The Using the new JLayer decorator for a password field recipe illustrates this process and also demonstrates how to create a watermark for windows.
All the recipes of this chapter use a JFrame-based application.
The following is the code used to develop a minimal window-based application, upon which the recipe's examples are based.
An ApplicationDriver class is used to start and display the JFrame-derived ApplicationWindow class.
The invokeLater method uses an inner class to create and then display the ApplicationWindow.
It is a simple window that has an Exit button, which we will use to close the application and enhance in later recipes:
When this code is executed, the output should appear as shown in the following screenshot:
This method takes an integer argument and returns a Cursor object.
Also in Java 7, it is possible to customize a dragged JApplet's title and to specify whether it should be decorated or not.
The title of the window is specified using the java_applet_title parameter.
More details on how to create draggable applets can be found at that site.
The isValidateRoot method has been added to the Applet class to indicate that the container is a valid root.
Java provides two basic sets of components for developing GUI applications: Abstract Window Toolkit (AWT) and Swing.
Swing components, on the other hand, operate fully independent of the native system, are completely implemented in Java code, and are thus referred to as lightweight components.
In previous versions of Java, it was inefficient and troublesome to mix heavyweight and lightweight components.
Getting ready If you are working with code that implements both heavyweight and lightweight components, there is no need to make any changes to the code, as Java 7 automatically handles the components.
We are going to modify code from the beginning of this chapter to demonstrate this:
Create a new application using the code examples from the introduction section.
Modify the code to use both heavyweight and lightweight examples.
Create a new window application as specified in the introduction to this chapter.
When the window opens, click on the menu and notice that, although the menu item overlaps the Exit button, the button shows through and covers the menu text.
When you click on the menu this time, you should notice the overlapping issue has been resolved, as shown in the following screenshot:
In this example, we created a scenario to illustrate the overlapping problem, and then showed how it was resolved in the latest Java releases.
However, it is a good practice to call the validate method on the top-level frame to ensure that all shapes are redrawn properly.
There is also the potential that previous work-arounds for mixing components may need to be removed.
The following are some specific areas to consider, when using mixed components with Java 7:
The heavyweight items will not be displayed beneath translucent pixels.
Managing window types The JFrame class supports a setType method, which configures the general appearance of a window to one of the three types.
In this recipe we will examine these types and their appearance on Windows and Linux platforms.
Create a new window application as specified in the introduction to this chapter.
On a Windows system, the window should appear as follows:
On Windows, the windows appear as shown in the following screenshots.
The utility type is missing the minimize and maximize buttons:
The following screenshot shows an example of the window type Type.NORMAL:
The following screenshot shows an example of the window type Type.POPUP:
The following screenshot shows an example of the window type Type.UTILITY:
On Ubuntu, the windows appear as shown in the following screenshots.
The normal and utility have the same appearance, while the popup type is missing its buttons:
The following screenshot shows an example of the window type Type.NORMAL:
The following screenshot shows an example of the window type Type.POPUP:
The following screenshot shows an example of the window type Type.UTILITY:
Managing the opacity of a window The opacity of a window refers to how transparent the window is.
When a window is completely opaque, then nothing behind the window on the screen can be seen.
A partially opaque window allows the background to bleed through.
In this recipe we will learn how to control the opacity of a window.
Getting ready To control the opacity of a window, use the JFrame class' setOpacity method with a float value representing how opaque the window should be.
Create a new standard GUI application as described in the chapter's introduction.
Notice how the window behind this application can be seen.
In this case, the background is the code for the application.
The setOpacity used 0.75f to set the opacity of the window.
This results in it being 75 percent transparent, as can be seen by the code bleed through.
If the opacity is set to 0.0f, the mouse may or may not be enabled.
To determine whether translucency is supported or not is covered in the next section.
The getOpacity method can be used to determine what the current level of opacity is.
To determine if the platform supports opacity, we need to use an instance of the java.awt.
A GraphicsDevice normally refers to the screens available, but can include printers or image buffers.
See also The Using the new JLayer Decorator for a password field recipe addresses how to draw over the top of a JComponent.
There are instances when an application window can be aesthetically enhanced by the addition of special graphics features.
Java 7 supports the use of gradient translucent windows, and the translucency can be both visually interesting as well as functional.
This recipe will demonstrate using both the transparency feature as well as a color gradient on a window.
Getting ready In order to create a translucent, gradient color window, you need to:
Perform a check to ensure that the system environment supports per-pixel translucency.
Set the background color, such that the window initially is completely transparent.
Create a new standard GUI application as described in the chapter's introduction.
First, we added code to the ApplicationDriver class to test whether per-pixel translucency was supported by the system.
In our example, if it were not supported, the application would exit.
This is discussed in more detail in the There's more...
When executed on Windows 7, this results in an undecorated window.
In the ApplicationDriver class, we first set the background color of the window.
The alpha value of zero means our window will be completely transparent.
Within the JPanel, we overrode the paintComponent method and created a new GradientPaint object.
We chose to use the one requiring floating numbers for the X and Y coordinates of the points referenced in the gradient, and the Color objects to specify the color of the gradient.
You also have the option of passing Point2D objects rather than floating point numbers.
The first points specified, either by floating point number or Point2D objects, represent the start of the gradient.
The second two, in our example, determined by the getWidth and getHeight methods, determine the ending points of the gradient.
The result in our example was a gradient that started out light in the upper-left-hand corner, and became progressively darker as it moved down and to the right.
Finally, we cast the gradient as a Graphics2D object and called the setPaint and fillRect method to paint our gradient across the window.
See also The use of the GraphicsDevice object to determine the level of transparency support is discussed in more detail in the There's more...
Managing the shape of a window There are times in application development when it can be fun and useful to create specially-shaped windows.
In this recipe we will develop a stop sign shape window to ensure that the user wants to continue some operation.
Verify that per-pixel translucency is supported on the given system.
Create an instance of a shape and pass it to the setShape method.
Create a new standard GUI application as described in the chapter's introduction.
When the application is executed, you should see an octagonal window formatted like the following one:
Our initial test to verify per-pixel translucency allowed us to tailor the application to the needs of the system it is running on.
In our example, if the property was not supported we simply exited the application, though in a real-world environment you would probably want to open a less sophisticated window.
Detecting the operating system support is discussed in more detail in the There's more...
The StopPanel class implemented the JPanel interface and allowed us to add the custom text and buttons we used in our window.
Because we were using a special shape for our window, we chose to call the setLayout method with a null argument, which in turn allowed us to use the setBounds methods to explicitly place our buttons where we wanted them on the window.
It is important to note that although the window is displayed as an octagon, or whatever other shape you choose, in actuality the window is still a rectangle, as specified by the setSize method.
Therefore, buttons and other objects may be placed on the window, but not visible if they are outside the bounds set by your shape.
The paintComponent method was used to customize the text on the window.
Within this method, we set the size, style, and location of the text, and called the drawString method to actually paint it to the screen.
To actually create an octagonal window, we created our getPolygon method and manually drew the polygon.
However, if you wanted to use a window with a shape already defined by a class implementing the Shape interface, you would not need to create a separate method.
You simply pass the Shape object to the setShape method.
If the setShape method's argument is null, the window will resize to the default for the given system, typically a rectangle.
It is important to execute the setShape method within a componentResized event.
This ensures that anytime the window is redrawn, the setShape method will be called and the shape will be maintained.
It is also important to call the setUndecorated method because, at the present time, decorations will be lost with specially-shaped windows.
See also The use of the GraphicsDevice object to determine the level of transparency support is discussed in more detail in the There's more...
Using the new border types in Java 7 Borders are used for the outline of swing components.
In this recipe we will develop a simple application to demonstrate how to create borders and how these borders appear.
Use the border object as an argument of the setBorder method applied against a JComponent object.
Create a new standard GUI application as described in the chapter's introduction.
The setBorder method changed the border of the JPanel to a raised soft-beveled border.
The BorderFactory method possesses a number of static methods to create borders.
The following table summarizes the new borders available in Java 7:
The second is its thickness, while the third argument specifies whether the corners should be rounded or not.
The first argument is the type of border: RAISED or LOWERED.
The second argument is the color of the outer highlighted area.
The third argument is the color of the inner edge.
The arguments are used for the inner and outer edges of the highlighted and shadowed areas of the border.
A second overloaded method takes a Paint object as a second argument, and is used to generate a color.
The second argument is the relative length of a dash line and the third parameter is the relative length of a space.
The third and fourth parameters specify the length and spacing respectively, while the last Boolean parameter determines whether the ends are rounded or not.
As we did in this example, it is sometimes better to change the border on an enclosing JPanel object.
The ability to select two or more files or directories in a file dialog box is achieved using the Ctrl and/or Shift keys in conjunction with the mouse.
Getting ready To enable or disable the selection of multiple files in a print dialog box:
Use the return value to determine which files were selected.
Create a new standard GUI application as described in the chapter's introduction.
Select the File Dialog button and the following dialog box should appear.
In the window that follows, two files of the /home/ music directory have been selected:
The fileDialog class' setMultipleMode method was executed with an argument of true.
An anonymous inner class was created to handle the selection of the file button event.
In the actionPerformed method, the dialog box was made visible.
To determine which files were selected, we can use the fileDialog class' getFiles method.
Add the following code after the fileDialog class' setVisible method:
Using a for each loop, we can display the name of each file selected.
The output for the selected music files should appear as follows:
This provides the ability to better tailor the application to a platform.
Getting ready To specify the print dialog type and to use the print dialog, the following steps need to be followed:
Create a new standard GUI application as described in the chapter's introduction.
The dialog box that appears should use the common appearance type, as shown in the following screenshot:
A new Print button was created allowing the user to display a print dialog box.
Next, we created a PrinterJob object and executed the printDialog method against this object.
If we had used the NATIVE type instead, shown as follows:
Then the print dialog would appear as follows on a Windows platform:
Java 7 supports the decoration of GUI components, such as textboxes and panels.
Decoration is the process of drawing on top of the component to give it a special appearance.
For example, we may want to watermark an interface to show that it is a beta version, or possibly to provide an indication of an error with a graphical X in a text field that is not otherwise possible.
When an event occurs, a method to handle the event will be executed.
When the component is drawn, the LayerUI derived object's paint method will be executed displaying graphics as needed.
In this recipe we will learn how Java supports this capability.
In the first section, we will demonstrate how to display an error message for a password field.
Create a LayerUI derived class that implements the decoration graphics operations.
Create a JLayer object based on the component and the LayerUI derived class.
In the ApplicationWindow, we created an instance of the PasswordLayerUI class.
We used this object along with the JPanel returned by the getPanel method to create JLayer object.
Notice the use of generics for the LayerUI and JLayer objects.
This was used to ensure that the elements are all compatible.
We used JPanel because that was the composite component we were decorating.
The JLayer class provided a way of tying the password box, the display of the error message, and the interception of the key events together.
The handling of the key events and the display of the error message was delegated to the PasswordLayerUI object.
When a key was pressed, the processKeyEvent method was executed.
When the component was drawn, the paint method was executed displaying the error message by the password box.
In the PasswordLayerUI class, we declared a private String variable to hold our error message.
It was declared at this level, because it was used in more than one method.
It was passed a Graphics object representing the area that we can draw to, and a JComponent component, which in this case was a JPanel.
In the paint method, we used both the component's font and we also created a new font for the error message.
The height and width of the component and the error string were calculated and used to position the error string that was displayed.
The installUI and uninstallUI methods were concerned with performing any initialization required to perform decoration.
In this case, they were used to enable keyboard events to be intercepted and processed by the class.
The processKeyEvent method performed the actual processing of keyboard events.
In this method, the length of the password text field contents was used to determine which error message was to be displayed.
This example could conceivably be performed using a label instead.
However, this example was intended to provide a simple demonstration of how to use decorations.
The creation of other decorations, such as a watermark is not as easily performed without the use of JLayer and LayerUI classes.
This sequence will add a watermark to the window indicating that this is a beta version of the interface.
The Castellar font is used to provide a more stenciled look to the text.
A Composite object is used to change the alpha value for the string.
The getComposite method is used to get the current composite for the window, and is then used to determine the rule being used.
The rule along with an alpha value of 0.25f is used to allow the watermark to fade into the background as follows:
When executed, your application should appear similar to the following screenshot.
This is the result of using the Castellar font, which is an all-capital letter font patterned after the letters used on a Roman column dedicated to Augustus.
Introduction There have been several additions to Java 7 that address events or are related to events.
This includes the handling of mouse events where enhanced support is provided for the detection of mouse buttons and for using high resolution mouse wheels, as we will see in the Managing extra mouse buttons and high resolution mouse wheels recipe.
When a window is made visible with either the setVisible or toFront methods, we now have the ability to control whether they should gain focus or not.
Some windows may be displayed for informational or status purposes and do not necessarily need or warrant focus.
How to control this behavior is explained in the Controlling AutoRequestFocus recipe.
The reader should be familiar with the behavior of modal dialog boxes.
Essentially, the modal dialog box will not return focus to the main window until it is closed.
There are times when it is desirable to mimic this behavior without using a dialog box.
For example, the selection of a button that performs a relatively long running calculation may benefit from this behavior.
The Using secondary loops to mimic modal dialog boxes recipe examines how this can be done.
While not common, spurious interrupts can occur when using the wait method.
Applets have also been enhanced with regards to their ability to communicate with JavaScript code.
The Handling Applet initialization status with event handlers recipe describes how JavaScript code can be made aware of and take advantage of knowing when an applet loads.
Other minor event-related improvements in Java 7 that don't warrant recipes include the availability of accessing extended key codes and the implementation of the java.awt.
The first method returns a unique integer for a key, but unlike the getKeyCode method, its value depends on how the keyboard is currently configured.
The second method returns the extended key code for a given Unicode character.
The imageUpdate method has been added to the JSlider class.
This permits the class to monitor the status of an image being loaded, though this capability is probably best used with classes that are derived from JSlider.
Java 7 has provided more options for handling mouse events.
In this recipe we will write a simple application to determine the number of mouse buttons enabled and test the mouse wheel rotation.
Getting ready First, create a new application using the starter classes ApplicationWindow and ApplicationDriver found in the introduction of Chapter 7, Graphical User Interface Improvements:
Implement the MouseListener and MouseWheelListener interfaces to capture mouse events.
You should see a JFrame window similar to the following:
When you click in the window, you will see varying output in your console depending upon your mouse, which button you click, and in which direction you move your mouse wheel.
The getNumberOfButtons method returned the total number of buttons on our mouse.
In the previous example, there were five buttons, but if the application was executed on a system with no mouse, it would have returned a -1
In our mousePressed method, we printed the name of the button clicked, as returned by the getButton method.
If you want to change the value of this, you must do so before the Toolkit class is initialized as explained in the There's more...
Because multiple mouse buttons were enabled, our output displayed the number for all five mouse buttons.
In most instances, the mouse wheel is also considered a button and is included in the count.
The last several lines of the previous console output are indications of movement of the mouse wheel.
This is indicated by a negative return value by both methods.
This application was executed using a high resolution mouse wheel.
A lower resolution mouse wheel will only return integer values.
There are two ways of controlling whether extra mouse buttons are enabled or not.
The first technique is to start the application with the following command line and set the sun.awt.
The –D option used a false value specifying that the extra mouse buttons were not to be enabled.
The second approach is to set the same property before the Toolkit class is initialized.
There may be times when a window is made visible, but we don't want the window to have focus.
For example, if the window being displayed contains status information, making it visible will be sufficient.
Giving it focus may not make sense and may frustrate the user by forcing them to change focus back to the original window.
Start by creating a new project with the following driver.
In the driver, we will create the first window as follows:
Both windows should appear with the focus on the first window, as shown in the following screenshot:
The second window should reappear and should not have focus.
Re-execute the application and hide and then reveal the second window.
When it is revealed, the second window should receive focus.
In the ApplicationWindow class, the second window was created and displayed.
Also, the three buttons were created and inner classes were created to affect each of their operations.
This approach may be useful for applications that run from the system tray.
Please note that the isAutoRequestFocus method is available to determine the value of the autoRequestFocus value.
The user is not permitted to interact with the main window, until the dialog box is complete.
The thread in which the dialog box is called is blocked until the dialog box is closed.
A SecondaryLoop permits the execution of some task while blocking the current thread, until the secondary loop is complete.
It may not have a user interface associated with it.
This can be useful when the user selects a button that, while it does not display a dialog box, does involve a long running calculation.
In this recipe we will demonstrate how to use a secondary loop and examine its behavior.
Getting ready To create and use a secondary loop, the following steps need to be followed:
Use this to obtain a reference to the system event queue.
Use the SecondaryLoop interface's enter method to start the loop.
Use the SecondaryLoop interface's exit method to terminate the loop.
The following console output should illustrate the execution of the secondary loop.
The number following First- will probably differ from your output: First-433 Loop Sleeping ...
While a secondary loop blocks the current thread, it does not prevent the window from continuing to execute.
To demonstrate this, restart the application and select the First button.
The first is that the application can still interact with the user, and the second is the behavior of two secondary loops executing at the same time.
Specifically, if a second secondary loop is started before the first one is complete, the first one will not resume until the nested (second) one is terminated.
We will witness the same behavior if the First button is selected twice within two seconds.
The buttons were added to the application and then associated with the application's implementation of the ActionListener interface.
We used the First button to illustrate the execution of a secondary loop.
In order to keep track of potential multiple secondary loops, we created an instance of the Calendar class and created a unique name derived from either First- or Second- suffixed with the current time in milliseconds.
While this technique would not guarantee unique names, it is unlikely that two loops will have the same name and this is sufficient for our example.
Depending on which button was pressed, an instance of WorkerThread was created using secondaryLoop object and a unique name.
The worker thread was then started and the enter method was executed against secondaryLoop.
At this point, the secondary loop will execute and the current thread will be blocked.
In the WorkerThread class, a message was displayed indicating which secondary loop was executed.
It was then suspended for two seconds followed by a second message indicating that the secondary loop completed along with the exit method return value.
The actionPerformed method's thread was then unblocked and a last message was displayed indicating that the secondary loop completed Notice that this thread blocked until the secondary loop completed.
This mimicked the behavior of a modal dialog box from the application's perspective.
The thread where the secondary loop was created is blocked until the loop is completed.
While other threading approaches could have been used to achieve a similar result, this approach is convenient and easy to use.
It is not possible to use the same SecondaryLoop object to start a new loop if one is already active.
Any attempt to do so will result in the enter method returning a value of false.
However, once the loop has completed, the loop can be reused for other loops.
This means the enter method can subsequently be executed against the same SecondaryLoop object.
This recipe can be useful if you need to create a timer-hour hourglass type animation that could be displayed over the button indicating a long running process.
Handling spurious thread wakeups When multiple threads are used, one thread may need to wait until the completion of one or more other threads.
When this is necessary, one approach is to use the Object class' wait method to wait for the other threads to complete.
These other threads need to use either the Object class' notify or notifyAll methods to permit the thread that is waiting to continue.
Use the wait method in the body of the loop.
First, we used a synchronized block for the object we are working with.
This could be simply a Boolean variable indicating that a queue is ready to be processed.
The loop will continue executing while the condition is true and the isDispatched method returns false.
This means if the method returns true, then the event was actually dispatched from the event queue.
A thread may wake up from a wait method for no reason at all.
The notify or notifyAll methods may not have been called.
This can occur due to conditions external to the JVM that are usually low-level and subtle.
In earlier versions of the Java Language Specification, this issue was not mentioned.
However, in Java 5 the wait method documentation included a discussion of this issue.
However, this is not possible until the applet has been initialized.
Any attempt to communicate with the applet will be blocked until the applet is loaded.
In order to determine when the applet has been loaded, Java 7 has introduced a load status variable, which is accessible from JavaScript code.
We will explore how to set up an HTML file to detect and respond to these events.
Getting ready To use the loading status of an applet:
This is followed by a header field and two division tags.
The init method created a BufferedImage object, which it used to display a blue square whose size is determined by the area allocated to the applet.
Initially, the load was delayed for two seconds using the sleep method to simulate a slow loading applet.
When the status is loading, the onLoadHandler was specified as the function to invoke when the applet completes loading.
When this function is executed, a message to that effect was displayed in the loadeddiv division element.
This ensured that the load status was checked when the HTML file was loaded.
The variable and attributes associated the sampleApplet ID with the SampleApplet class.
The archive file containing the class and the size of the applet were also specified.
In order to take advantage of this capability, the applet needed to be deployed with the java_status_ events parameter set to true.
Messages displayed in HTML division elements showed the sequence of operations.
The deployJava.js is part of the Java Deployment Toolkit and is used to detect the presence of a JRE, install one if necessary, and then run an applet.
It can also be used for other Web Start programs.
There are three applet status values as detailed in the following table:
Some of these enhancements are minor and will be addressed in this introduction.
Others are more significant and are detailed in this chapter's recipes.
Due to the rather specialized nature of some topics, such as those typified by some of the security enhancements, they will be mentioned but not explained here.
Some of the improvements depend on third party driver support not available in early driver versions.
When testing the database recipes for this chapter, ensure that you are working with a driver that supports the JDBC 4.1 functionality.
These are addressed in the Java 7 database enhancements recipe, and include such issues as determining the name of the current schema and providing access to hidden columns.
The Derby database engine will be used for the database examples.
If you prefer to use other databases and tables, you can do so by adjusting the code for the different databases.
In addition to these database recipes, the try-with-resource statement can be used with any object that implements the java.sql package's Connection, ResultSet, or Statement interfaces.
This language improvement simplifies the process of opening and closing resources.
The general use of the try-with-resource statement is detailed in the Using the try-with-resource block to improve exception handling code recipe, in Chapter 1, Java Language Improvements.
An example of using this with a ResultSet-derived class is shown in the Using the RowSetFactory class recipe.
The Statement interface has been enhanced with two new methods.
The first method, closeOnCompletion, is executed to specify that the Statement object will be closed when result sets that use the connection are closed.
Network enhancements to Java 7 include the addition of two methods to the java.net.
Assistance is also provided to support stream connections using the InfiniBand (IB)
This technology uses Remote Direct Memory Access (RDMA) to move data directly between the memories of different computers.
This support is provided through the Sockets Direct Protocol (SDP) network protocol.
The Using the platform MXBeans for JVM or system process load monitoring recipe, examines the improvements made in the support of MXBeans.
This includes different methods for accessing these management type beans.
This topic is explored in the Redirecting input and output from operating systems processes recipe.
Java 7 has also improved the way applets can be embedded in an HTML page.
The Embedding a JNLP file in an HTML page recipe provides a demonstration of this technique.
The Using the ExtendedSSLSession interface recipe uses SSL, and is used to illustrate the use of the ExtendedSSLSession interface and new security features.
Security enhancements include the incorporation of Elliptic Curve Cryptography (ECC) algorithms.
This class of encryption algorithms is more resistant to brute force attacks.
New exception classes have been added or enhanced to enhance security.
These include support to protect against cipher block chaining attacks and new cryptographic algorithms.
It is also possible to specify not only the algorithm, but restrictions on the key size.
Algorithm restrictions can also be placed at the TLS level.
Currently, this property is specific to the Oracle JSSE implementation and may not be recognized by other implementations.
The Server Name Indication (SNI) JSSE extension (RFC 4366) enables TLS clients to connect to virtual servers, that is, multiple servers with different network names that use the same supporting network address.
This is enabled to true by default, but can be set to false for systems where the extension is not supported.
It can be set using the –D java command option shown as follows:
It is also possible to set this property using the setProperty method shown as follows:
Note that the property name may change in the future.
This permits the creation of any type of row set supported by JDBC.
We will use the Derby database to illustrate the process of creating row sets.
A description of how to create this table is found at http://netbeans.org/kb/docs/ide/java-db.html.
The SQL code to create the table is as follows:
Use one of the several create methods to create a RowSet object.
String variables were created for the database URL, username, and password.
The RowSetFactory object was created using the static newFactory method.
Any exceptions generated will result in the termination of the application.
In the try-with-resources block, the createJdbcRowSet method was used to create an instance of the JdbcRowSet class.
The URL, username, and password were then assigned to the row set.
The select command retrieved all of the fields from the COLLEAGUES table.
Next, a while loop was used to display the ID and the first name for each row of the row set.
The newFactory method will look for a RowSetFactory class in the following order:
In addition to the creation of a JdbcRowSet row set, other methods are available to create different types of row sets as listed in the following table:
A RowSetFactory can also be created using the overloaded newFactory method that takes two arguments, shown as follows:
This approach provides more control to the application, enabling it to specify the provider to use.
When there are multiple providers found in the class path, this can be useful.
The first argument specifies the class name of the provider and the second argument specifies the class loader to use.
Using null as the second argument specifies that the context class loader is to be used.
This recipe addresses these enhancements and provides examples where practical.
Due to the immaturity of many JDBC 4.1 drives, not all of the code examples will be completely functional.
When executed, your output should appear similar to the following:
The Statement interface's getGeneratedKeys method was introduced in Java 1.4 and returns any auto-generated keys for that statement.
It is possible to set and get the schema for a connection using the Connection interface's setSchema and getSchema methods.
The getSchema method was executed, which returned the schema name.
Retrieving pseudo-columns Databases will often use hidden columns to represent a unique key for every row of a table.
In Java 7, two new methods have been added to address pseudo-columns.
If no catalog is used, then use an empty string.
A null value means that the catalog name will not be used when searching for the columns.
If no schema is used then use an empty string.
A null value means that the schema name will not be used when searching for the columns.
The ResultSet returned will have the following organization as shown in the following table:
The hidden columns represent a unique key, which provides a fast way of accessing a row.
However, the following code sequence illustrates how this can be accomplished:
Derby will return an empty ResultSet consisting of the columns listed previously.
The query string contains a call to a stored procedure.
This procedure is assumed to use an integer value as the first parameter to identify a record in a table.
The second argument is to be returned and is of the type Date.
Once the query is executed, the getObject method will return the specified column using the data type specified.
The method will convert the SQL type to the Java data type.
Other database enhancements The java.sql package's Driver interface has a new method, which returns the parent logger for the driver.
However, when executed, the current version of the driver will generate the following exception:
In addition, when a series of database operations are performed in conjunction with an Executor, three methods are available to support those operations, which are as follows:
The last two methods are optional and are not supported by Derby.
Using the ExtendedSSLSession interface The javax.net.ssl package provides a series of classes used to effect secure socket communication.
Improvements introduced in Java 7 include the addition of the ExtendedSSLSession interface, which can be used to determine the specific local and peer supported signature algorithms that are used.
In addition, when an SSLSession is created, an endpoint identification algorithm can be used to ensure that the host computer's address matches that of the certificate.
Getting ready To demonstrate the use of the ExtendedSSLSession interface, we will:
Create a client application, which uses a SSLSocket instance to communicate with the server.
Use a SimpleConstraints class to demonstrate the use of algorithm constraints.
To execute the server, we need to create key store.
This is accomplished from the command prompt by executing the following command: keytool -genkey -keystore mySrvKeystore -keyalg RSA.
Provide a password and other information requested by the program.
The password above, is the password that you used to create the key store, and package, is your EchoServer's package, if any.
Copy the key store file to the client application's directory.
The password above, is the password that you used to create the key store, and package, is your EchoServer's package, if any.
When the program executes, enter the word cat, and then press the Enter key.
In the server command window, you should see an end point name, which may be null, a list of local supported signature algorithms, and cat similar to the following:
As you enter more input lines, they should be reflected in the server command window.
To terminate the program, enter a Ctrl + C in the client command window.
The SimpleConstraints class allows only RSA algorithms and then with keys that use 2048 bits or more.
The accept method was executed against the socket, which blocks until a client connects to it.
The remaining code was concerned with reading and then displaying the string sent by a client.
It created an instance of the SSLSocket class and then used its getOutputStream method to write the user's input to the echo server.
Using the platform MXBeans for JVM or system process load monitoring.
Java Management Extensions (JMX) is a standard way of adding a management interface to an application.
These can then be used to access process and load monitoring.
Use the getPlatformMXBean method with the MXBean type needed for the application.
Specific methods of this instance were then applied and their values were displayed.
Using the getPlatformMXBeans method The getPlatformMXBeans method is passed the MXBean type and returns a list of the platform MXBeans that implements the MXBean type.
When executed, you should get an output similar to the following.
The exact output is dependent on the operating system and hardware used to execute the application:
The jconsole application that is available as part of the JDK, provides an alternative technique for determining which MXBeans are available.
The following is the console displaying the attributes for the operating system, specifically the ProcessCpuLoad attribute:
To demonstrate this process, we are going to send command-line arguments from a text file to a DOS prompt and record the output in another text file.
Getting ready In order to control input and output from external processes, you must:
Direct the input and output of the process to the appropriate locations.
Make sure that there is a carriage return after the last line.
Execute the program again and examine the contents of your error log.
Because your test directory had already been created with the first process execution, you should now see the following error message:
We created three files to handle the input and output of our process.
When we created the instance of the ProcessBuilder object, we specified the application to launch to be the command window.
The information required to perform actions within the application was stored in our input file.
When we first called the redirectInput, redirectOutput, and redirectError methods, we did not pass any arguments.
A pipe takes the output of one source and sends it to another.
The second form of the methods that we used involved passing a java.io.File instance to the redirectInput, redirectOutput, and redirectError methods.
These methods return a ProcessBuilder object as well, but they also have the function of setting the IO source.
In our example, we then called the no argument form of each method once more to verify that the IO had been redirected.
The first time the program was executed, your error log should have been empty, assuming you used valid file paths for each File object, and you have write permissions on your computer.
The second execution was intended to display how the capture of errors can be directed to a separate file.
If the redirectError method is not invoked, the errors will inherit the standard location and will be displayed in your IDE's output window.
It is important to note that the start method must be called after the redirect methods.
Starting the process before redirecting input or output will cause the process to disregard your redirects and the application will execute using the standard IO locations.
Using the previous example, add a new line prior to calling the start method:
This form of the redirectError method allows you to specify that the errors should be appended to the error log text file rather than overwritten.
If you execute the application with this change, you will see two instances of the error when the process tries to create the Test Directory directory again:
All three methods, redirectError, redirectInput, and redirectOutput, have this overloaded form.
Redirect.PIPE is the default way external process IO is handled, and simply means that the Java process will be connected to the external process via a pipe.
The Redirect.INHERIT value means that the external process will have the same input or output location as the current Java process.
You can also redirect the input or output of data using the Redirect.to and Redirect.from methods.
Using the inheritIO method to inherit the default IO locations If you execute an external process from a Java application, you can set the location of the source and destination data to be the same as that of the current Java process.
The ProcessBuilder class' inheritIO method is a convenient way to accomplish this.
If you have a ProcessBuilder object pb, executing the following code:
Then it has the same effect as executing the following three statements together:
In both cases, the input, output, and error data will be located in the same places as the current Java process' input, output, and error data.
Embedding a JNLP file in an HTML page Java 7 provides a new option to speed up the deployment of an applet in a web page.
Prior to 7, when applets were launched using the Java Network Launch Protocol (JNLP), the JNLP file must first be downloaded from the network before the applet can be launched.
With the new release, the JNLP file can be embedded directly into the HTML code, reducing the amount of time the applet needs to launch.
In this example, we are going to build a basic applet and launch it using a JNLP-embedded HTML page.
Getting ready To speed up applet launch in Java 7, you must:
Add the reference to the JNLP file to an HTML page.
The following is a sample JNLP file to accompany our previous applet.
Notice that within the resources tag a JAR file is referenced.
This JAR file, containing your applet, must be in the same location as your JNLP file and the HTML file, which we will create in a moment:
To avoid using a codebase attribute, we are utilizing another new feature of Java 7 by using a Development Toolkit script.
You may need to enable JavaScript depending upon your current browser settings.
Your applet should load quickly and appear similar to the following screenshot:
Embedding the JNLP file in the HTML page allowed the applet to be loaded immediately, rather than having to be downloaded from the server first.
The JNLP file had to have a relative path in the href attribute and the codebase should not be specified.
By leaving the codebase attribute blank, it was determined by the URL of the applet's web page.
The resources tag specified the location of your JAR file and the version of Java to use.
The path for your JAR file was assumed to be the default working directory as was the location of your JNLP file.
Also included in your JNLP file was a description of your applet, surrounded by the applet-desc tag.
The name of your applet and the name of your main class file was specified in this tag.
The HTML file contained information necessary to load the applet without having to download the applet information from a server.
We first specified that we are going to load the application using a JavaScript call.
Then, in our first script tag, we added a section to allow us to call the applet without a codebase.
This is advantageous because the application can be loaded and tested in different environments without changing the codebase attribute.
It is, instead, inherited from the web page that the application is running from.
In both instances, the client must have the Java SE 7 release to launch the applet, and if they do not, they will be directed to the Java website to download the most recent version.
Within the script tag, the jnlpFile variable specified the name of the JNLP file and was relative to the applet's web page.
The function is invoked within an href tag, shown as follows:
The second script tag within your HTML file contained information about your JNLP file.
The jnlp_href variable stored the name of the JNLP file.
The JNLP file's encoded form was specified by the jnlp_embedded parameter.
The BASE64 encoder encoded binary data for instances where the data needs to be stored and transferred across textual mediums, such as e-mail and XML files.
Several new classes have been introduced that support the parallel execution of tasks.
The ForkJoinPool class is used for applications, which use the divide-and-conquer technique to solve a problem.
Each subproblem is forked (split) as a separate thread and later joined, if necessary to provide a solution.
The threads used by this class are normally subclasses of the java.util.
The use of this approach is illustrated in the Using join/fork framework in Java recipe.
A group of threads are synchronized, so that they all execute and then wait for the completion of the others.
Once they have all completed, they can be re-executed for a second phase or subsequent phase.
The Using the reusable synchronization barrier Phaser recipe illustrates the use of this class in a game engine setting.
Examples of their use in support of the producer/consumer framework are illustrated.
It is discussed in the Supporting multiple threads using the ThreadLocalRandom class recipe.
They both accept a Throwable object used to specify the cause of the exception.
One of the constructors also accepts a string that provides a detail message regarding the exception.
Java 7 has improved the use of class loaders by modifying the locking mechanism to avoid deadlocks.
In multi-threaded custom class loaders prior to Java 7, certain custom class loaders were prone to deadlocks, when they used a cyclic delegation model.
Since both class loaders are locked and both the threads need both loaders, a deadlock situation occurs.
The desired behavior of a concurrent class loader is to load different classes from the same instance of the class loader concurrently.
This requires locking at a finer level of granularity, such as locking a class loader by the name of the class being loaded.
Synchronization should not be done at the class loader level.
Instead, a lock should be made on a class level, where the class loader allows only a single instance of the class to be loaded at a time by that class loader.
This type of class loader is called parallel capable class loaders.
If the custom class loader uses an acyclic hierarchal delegation model, no changes are needed in Java.
In a hierarchal delegation model, delegation is first made to its parent class loader.
Class loaders that do not use the hierarchical delegation model should be constructed as parallel capable class loaders in Java.
This indicates that all instances of the class loader are multi-thread safe.
Using join/fork framework in Java The join/fork framework is an approach that supports breaking a problem into smaller and smaller pieces, solving them in parallel, and then combining the results.
It is designed to work with multi-core systems, ideally with dozens or hundreds of processors.
Currently, few desktop platforms support this type of concurrency, but future machines will.
With fewer than four processors, there will be little performance improvement.
It is designed to work with ForkJoinTasks, though it can be used with normal threads.
The ForkJoinPool class differs from other executors, in that its threads attempt to find and execute subtasks created by other currently running tasks.
The ForkJoinPool class can be used for problems where the computation on the subproblems is either modified or returns a value.
In this recipe we will illustrate the use of the RecursiveTask derived class.
Getting ready To use the fork/join framework for a task that returns a result for each subtask:
Create a subclass of RecursiveTask that implements the computation needed.
Use the ForkJoinPool class' invoke method with the instance of the subclass of the RecursiveTask class.
This application is not intended to be implemented in the most efficient manner, but is used to illustrate the fork/join task.
As a result, on systems with a small number of processors, there may be little or no performance improvement.
RecursiveTask to compute the sum of squares of the integers in the numbers array.
First, declare the numbers array as follows: private static int numbers[] = new int[100000];
However, you should observe different execution times depending on your hardware configuration:
Notice that the iterative solution is faster than the one using the fork/join strategy.
As mentioned earlier, this approach is not always more efficient, unless there are a large number of processors.
A more aggressive testing approach would be to execute the solution repeatedly under possibly different processor loading conditions and then take the average of the result.
The size of the threshold will also affect its performance.
The numbers array was declared as a 100,000 element integer array.
The SumOfSquaresTask class was derived from the RecursiveTask class using the generic type Long.
Any subarray smaller than this threshold was solved using iteration.
Otherwise the segment was divided in half and two new tasks were created, one for each half.
This was strictly not needed and actually slows down the computation.
However, it would be useful if we decided to partition the array into more than two segments.
It provides a convenient way of recombining the elements when the subtasks are joined.
The fork method was used to split up the subtasks.
They entered the thread pool and will eventually be executed.
The join method returned the results when the subtask completed.
The sum of the subtasks was added together and then returned.
In the main method, the first code segment computed the sum of squares using a for loop.
The start and stop time were based on the current time measured in milliseconds.
The second segment created an instance of the ForkJoinPool class, and then used its invoke method with a new instance of the SumOfSquaresTask object.
The arguments passed to the SumOfSquaresTask constructor, instructed it to start with the first element of the array and end with the last.
The ForkJoinPool class has several methods that report on the state of the pool, including:
The ForkJoinPool class' toString method returns several aspects of the pool.
Add the following statement immediately after the invoke method is executed:
When the program executes, you will get an output similar to the following:
See also The Using the reusable synchronization barrier Phaser recipe offers a different approach for executing multiple threads.
The threads will execute and then wait for the completion of the other threads in the group.
When all of the threads are completed, one phase is done.
The Phaser can then be used to coordinate the execution of the same set of threads again.
However, it is not possible to advance to the next phase.
This is useful when a problem is characterized by a series of steps/phases that advance from one phase to the next based on some criteria.
With the introduction of the Phaser class in Java 7, we now have a concurrency abstraction that combines the features of CountDownLatch and CyclicBarrier and adds support of a dynamic number of threads.
The term, phase, refers to the idea that the threads can be coordinated to execute in distinct phases, or steps.
All of the threads will execute and then wait for the others to complete.
Once they have completed, they will then begin anew and complete a second or subsequent phase of operation.
A barrier is a type of block that prevents a task from proceeding further until some condition is met.
A common condition is when all of the related threads have completed.
The Phaser class provides several features, which makes it useful:
The register method increments the number of parties that are participating.
The termination of a phaser occurs when the internal count reaches zero or as determined by some other criteria set.
Getting ready We will develop an application that mimics the operation of a game engine.
The first version will create a series of tasks representing participants in a game.
We will use the Phaser class to coordinate their interaction.
To use the Phaser class to synchronize the start of a set of tasks:
Create a collection of Runnable objects that will participate in the phaser.
The output is non-deterministic, but should be similar to the following:
Notice that the Phaser object waits until all of the participants have joined the game.
The sleep method was used to simulate the work involved by that entity.
Its nextInt method returned a random number between the values specified in its parameters.
When using concurrent threads, this is the preferred way of generating random numbers as detailed in the Supporting multiple threads using the ThreadLocalRandom class recipe.
An instance of the AtomicInteger class was used to assign unique IDs to each object created.
This is a safe way of generating numbers in threads.
The toString method returns a simple string representation of the entity.
In the execute method, we created an ArrayList to hold the participants.
Notice the use of the diamond operator in the creation of the ArrayList.
A Phaser object was created with an argument of one and that represented the first participant.
It is not an entity and simply served as a mechanism to help control the phaser.
In the for each loop, the number of parties in the phaser was incremented by one using the register method.
A new thread was created using an anonymous inner class.
In its run method, the entity was not started until all of the participants arrived.
At the start of each iteration of the while loop, the number of registered participants was one larger than the number of participants who have arrived.
The internal count was then two more than the number that had arrived.
After the loop terminated, there was still one more registered party than participants who had arrived.
In addition, the number of registered parties was decreased by one.
It is possible to register a group of parties using the bulkRegister method.
This method takes a single integer argument specifying the number of parties to register.
Under some conditions, it may be desirable to force the termination of the phaser.
During the execution of a phaser, there are several methods that will return information about the state of the phaser as detailed in the following table.
If the phaser has terminated, then these methods will have no effect:
A tree of phasers can be constructed, where a phaser is created as a branch of the task.
Using a phaser to repeat a series of tasks We can also use the Phaser class to support a series of phases where tasks are executed, a possible intermediate action is performed, and then the series of tasks are repeated again.
To support this behavior, we will modify the gameEngine method.
This is used to specify how many phases we will use.
A call to the onAdvance passes the current phase number and the current number of parties registered to the phaser.
The default implementation of this method returns true when the number of registered parties becomes zero.
The implementation of this method resulted in the method returning true only if the phase number exceeded the iterations value, that is, minus 1, or there are no registered parties using the phaser.
Modify the run method as highlighted in the following code:
The entity is allowed to run first, and then it waits for the other participants to complete and arrive.
As long as the phaser has not been terminated as determined by the isTerminated method, the next phase will be executed when everyone is ready.
Again, as long as the phaser has not terminated, the phaser will advance to the next phase when every participant has arrived.
Execute the program using only one player and one zombie.
This will reduce the amount of output and should be similar to the following:
See also See the Using a random number generator isolated to the current thread recipe for further information about generating random numbers for multiple threads.
The class implements a double-ended queue, known as a deque, and allows for the insertion and removal of elements from both ends of the deque.
It is also known as a head-tail linked list and, like other concurrent collections, does not allow the usage of null elements.
Implement a producer thread to generate elements to be placed in the deque.
Implement a consumer thread to remove elements from the deque.
Then create a producer class to generate elements of the type Item.
For this recipe's purposes, we are only going to generate seven items and then print out a statement to demonstrate that the item has been added to the deque.
When you execute the program, you should see output similar to the following:
When we started both threads, we gave the producer thread a head start to populate our deque with items.
In our example, we made use of the methods add and pollFirst to add and remove elements of the deque.
There are a number of methods available, many of which operate in essentially the same fashion.
Problems with asynchronous concurrent threads Due to the fact that multiple threads may be accessing the collection at any given moment, the size method is not always going to return an accurate result.
This is also true when using the iterator or descendingIterator methods.
Additionally, any bulk data operations, such as addAll or removeAll, are not always going to achieve the desired results.
If one thread is accessing an item in the collection and another thread tries to pull all items, the bulk action is not guaranteed to function atomically.
There are two toArray methods available for retrieving all elements of the deque and storing them in an array.
The first returns an array of objects representing all of the elements of the deque and can be cast to the appropriate data type.
This is useful when the elements of the deque are of different data types.
The following is an example of how to use the first form of the toArray method using our previous thread example:
The other toArray method requires an initialized array of a specific data type as an argument and returns an array of elements of that data type.
Adding elements to the deque The following table lists some of the methods available for adding elements to the deque.
The methods that are grouped together in the following table perform essentially the same function.
Method name Adds an element to add(Element e) offer(Element e) offerLast(Element e) addLast(Element e)
Retrieving elements from the deque The following are some of the methods available for retrieving elements from the deque:
Method name Error action Function element() Throws exception if deque is empty Retrieves but does not remove the.
Accessing a specific element of the deque The following are some of the methods available for accessing specific elements of a deque:
If the element does not exist in the deque, the deque is unchanged.
This class provides blocking methods and non-blocking methods for retrieving elements and is an appropriate choice for concurrent access by multiple threads.
Define a type of element to place into the queue.
Implement a producer thread to generate elements to be placed in the queue.
Implement a consumer thread to remove elements from the queue.
When you execute the program, you should see output similar to the following:
When we started both threads, we gave the producer thread a head start to populate our queue with items by sleeping for one second in the ItemConsumer class.
Notice that the hasWaitingConsumer method returned false initially because the take method had not yet been executed by the consumer thread.
With each retrieval, the generateOrder method printed out information about the element retrieved.
After all elements in the queue were retrieved, notice a final Hurry up! statement, indicating there is still a consumer waiting.
In this example, because the consumer is using a blocking method within a while loop, the thread will never terminate.
In a real life situation, the thread should be terminated in a more graceful manner, such as sending a terminate message to the consumer thread.
In our example, we used the methods offer and take to add and remove elements of the queue.
There are other methods available and these are discussed in the There's more...
Problems with asynchronous concurrent threads Due to the fact that multiple threads may be accessing the collection at any given moment, the size method is not always going to return an accurate result.
Additionally, any bulk data operations, such as addAll or removeAll, are not always going to achieve the desired results.
If one thread is accessing an item in the collection and another thread tries to pull all items, the bulk action is not guaranteed to function atomically.
Adding elements to the queue The following are some of the methods available for adding elements to the queue:
Method name Adds element to the Comments add(Element e) End of the queue Queue is unbounded, so the method will.
Wait for t time units of type u before giving up.
Queue is unbounded, so the method will always return true.
Retrieving elements from the deque The following are some of the methods available for retrieving elements from the deque:
Returns null if the time limit is up before an element is available.
Will insert an element at the end of the queue and wait for the consumer thread to retrieve it.
Transfers an element to the consumer immediately, or within time specified by t (in units u)
Returns false if the consumer is not available when the time limit has elapsed.
However, the use of this new class, with multiple threads, will result in less contention and better performance as compared to their use with the Random class.
When multiple threads need to use random numbers, the ThreadLocalRandom class should be used.
The random number generator is local to the current thread.
Getting ready The recommended way of using this class is to:
Use the static current method to return an instance of the ThreadLocalRandom class.
The nextInt method was executed five times with its return value being displayed.
The nextLong method was executed five times using two parameters, which specified its starting (inclusive) and ending (exclusive) range values.
When a range is specified, the start value is inclusive and the end value is exclusive.
An integer in the range specified by the number of bits.
See also Examples of its use are found in the Using the reusable synchronization barrier Phaser recipe.
Introduction This chapter will address many new additions to Java 7 that do not fit into the previous chapters.
There have been a number of improvements in the handling of weeks and currency.
The calculation of the current week and the number of weeks per year is impacted by the locale.
In addition, it is now possible to determine the currencies available on a platform.
A new enumeration has been added that eases the display of digits in different languages.
Improvements in the support of JavaBeans are discussed in the JavaBean improvements in Java 7 recipe.
There are also a number of enhancements, which do not warrant separate recipes.
The rest of this introduction is devoted to these topics.
Java 7 supports this release with the addition of thousands of more characters and numerous new methods.
Since the character is not a Unicode surrogate code, the highSurrogate and lowSurrogate method results are not useful.
Primitive types and the compare method Java 7 introduced new static methods for comparing primitive data types Boolean, byte, long, short, and int.
Each wrapper class now has a compare method, which takes two instances of the data type as arguments and returns an integer representing the result of the comparison.
For example, you would have previously needed to use the compareTo method to compare two Boolean variables, x and y as follows:
While this is new to Java for the Boolean data type, the compare method was previously available for doubles and floats.
Additionally in 7, the parse, valueof, and decode methods, used for converting strings to numeric values, will accept a leading plus (+) sign with data types Byte, Short, Integer, Long, and BigInteger, in addition to Float, Double, and BigDecimal, which previously accepted the sign.
The static field global of the Logger class is prone to deadlocks when the Logger class is used in conjunction with the LogManager class, as both classes will wait on each other to complete initialization.
The getGlobal method is the preferred way to access the global logger object, in order to prevent such deadlock.
From a structural standpoint, the generation of the HTML pages is now accomplished by using the HTMLTree classes to create a document tree, which results in more accurate HTML generation and fewer invalid pages.
There have also been external changes to the JavaDocs, some of which were in order to comply with the new Section 508 accessibility guidelines.
These are developed to ensure screen readers, used for translating web-based text into audible output, are able to accurately translate an HTML page.
Primarily, this has resulted in the addition of more captions and headings on the tables.
JavaDocs now also use a CSS stylesheet to simplify changes to the appearance of the pages.
The performance of the Java HotSpotTM virtual machine has been improved.
Most of these improvements are not under the control of the developer and are specialized in nature.
The interested reader will find more details about these enhancements at http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performanceenhancements-7.html.
Handling weeks in Java 7 Some applications are concerned with the number of weeks in a year and the current week of the year.
A week number is used to refer to the week of the year.
But how is that calculated? Java 7 has introduced several methods to support determining the week of the year.
In this recipe we will examine these methods, and see how week-related values are calculated.
The ISO 8601 standard provides methods for representing dates and time.
Getting ready To use these week-based methods we need to:
To return the number of weeks for the current calendar year, use the getWeeksInWeekYear method.
To determine the week for the current date, use the get method with the WEEK_OF_YEAR as its argument.
Your output should appear as follows, but the values will be dependent upon the date the application was executed:
It returned true, which resulted in the execution of the getWeeksInWeekYear and get methods.
The get method was passed in the field WEEK_OF_YEAR, which returned the current week number.
This method has three arguments specifying the year, week, and day.
It provides a convenient technique for setting the date based on weeks.
When this code is executed, we get the following output:
The way that the first and last week of the year is calculated is locale-dependent.
For example, the getFirstDayOfWeek method returns an integer representing the first day of the week for a locale.
The first and last week of a week year may have different calendar years.
The calendar is set to the first day of the first week of 2022:
This shows that the week actually starts in the previous year.
The following code sequence creates an instance of a SimpleTimeZone class and then determines if daylight saving time is supported.
The time zone used is for Central Standard Time (CST):
When this sequence is executed, you should get the following output:
The other methods execute against an instance of the Currency class.
When the application is executed, you should get output similar to the following.
However, the first part of each may differ depending on the current locale.
The code sequence begins with the generation of a Set of the Currency objects representing the current system's configuration.
The overloaded getDisplayName methods were executed against each element of the set.
The Locale.GERMAN argument was used to illustrate the use of this method.
The last value displayed was the numeric code for the currency.
Sometimes it is desirable to display numeric digits using a different language than is currently being used.
For example, in an English language tutorial regarding the Mongolian language, we may want to explain the numeric system in English, but display numbers using the Mongolian digits.
Create a Font object to define the font to use.
Specify the range of Unicode characters to display the text.
Create a FontRenderContext object to hold information about how to measure the text to be displayed.
Create an instance of TextLayout and use it in the paintComponent method to render the text.
This is a simplified version of the example found at http://download.oracle.
Within its constructor, an instance of the NumericShaperPanel class was created and added to the center of the window.
The title, default close operation, and size of the window were set.
In the constructor of the NumericShaperPanel class, a text string was created along with a HashMap to hold the essential features of the display.
This map was used as an argument to the TextLayout constructor along with the string to be displayed and the map.
The text was displayed in Mongolian using the Mongolian Baiti font and with the MONGOLIAN range.
We used this font to demonstrate the new methods of the NumericShaper class.
The NumericShaper class has added new methods to make it easier to display numeric values in a different language.
In the paintComponent method, the Graphics2D object was used as an argument of the draw method to render the string to the window.
This means if Japanese script is used before digits, then Japanese digits are displayed.
The shape method also uses a range to specify the script to use for an array of char given a start and an end index in the array.
JavaBean enhancements in Java 7 JavaBean is a way of building reusable components for Java applications.
The execute method has been added to facilitate this capability.
Getting ready To use the Expression class to execute a method:
Create an array of arguments for the method, if needed.
Create an instance of the Expression class specifying the object that the method is to be executed against, the method name, and any arguments needed.
Use the getValue method to obtain the results of the method execution, if necessary.
The Person class contains a single field for a name along with constructors, a getter method, and a setter method:
The getName and setName methods were used from the main method, where a Person instance was created.
The first argument was not used in this example, but can be used to define a return value for the method executed.
The second argument was the object that the method would be executed against.
The third argument is a string containing the name of the method, and the last argument was an array containing the parameters used by the method.
In the first sequence, the setName method was executed using an argument of Peter.
The output of the application shows that the name was initially Jane, but was changed to Peter after the execute method was executed.
The getValue method returns the results of the execution of the method.
There have been other enhancements to the classes of the java.bean package.
The Introspector class provides a way of learning about the properties, methods, and events of a Java Bean without using the Reflection API, which can be tedious.
The class has added a getBeanInfo method, which uses the Inspector class' control flags to affect the BeanInfo object returned.
The Transient annotation has been added to control what is included.
A true value for the attribute means that the annotated feature should be ignored.
A new constructor has been added to the XMLDecoder class that accepts an InputSource object.
Also, the createHandler method has been added, which returns a DefaultHandler object.
This handler is used to parse XML archives created by the XMLEncoder class.
A new constructor has been added to the XMLEncoder class.
This permits writing out JavaBeans to an OutputStream using a specific charset with a specific indention.
The Locale.Category enumeration is also new and makes using different locales for display and formatting purposes easy.
We will first look at the use of the Locale.Builder class and then examine other locale improvements and the use of the Locale.Category enumeration in the There's more...
Getting ready To build and use a new Locale object:
Use the relevant methods of the class to set up the attributes needed.
Using this object, we applied methods to set the language, script, and region for the locale.
The build method was then executed and a Locale object was returned.
We used this locale to display the date and the display language for the locale.
It is important to be able to label a piece of information to indicate the language being used.
A standard set of tags is defined by the IETF BCP 47 standard.
Java 7 conforms to this standard and has added several methods to handle tags.
The standard supports the concept of extensions to a tag.
These extensions can be used to provide more information about the locale.
These extensions are concerned with non-language information, such as currency and dates.
Private use extensions are used to specify platform-specific information, such as that related to operating systems or programming languages.
The key is a single character and the value follows the following format:
For Unicode locale extensions, the value must be at least two characters, but not more than 8 characters in length.
The key for Unicode locale extension is u, and for private use extensions it is x.
These extensions can be added to a locale to provide additional information, such as the calendar number types to use.
The keys that can be used are listed in the following table:
Key code Description ca Calendar algorithm for determining dates co Collation type—the ordering used in a language ka Collation parameters—used to specify the ordering cu Currency type information nu Numbering system va Common variant type.
Examples of key and types are found in the following table:
The getExtensionKeys method returns a set of Character objects of all keys used with the locale.
The methods return an empty set if there are no extensions available.
For a given locale, the getScript, getDisplayScript, and toLanguageTag methods return the script, a displayable name for the script, and a well-formed BCP 47 tag for the locale respectively.
The getDisplayScript method will also return a displayable name for the script, given a locale as an argument.
The next section discusses the use of the setDefault method to control the display of information using two different locales at the same time.
This permits the default locale to be set for format type resources (dates, numbers, and currency) and for display resources (GUI aspects of an application)
For example, part of an application may set the format to accommodate one locale, such as JAPANESE while displaying related information in another, such as GERMAN.
When this code sequence is executed, you should get output similar to the following.
The initial date and display language may differ depending on your default locale.
The default locale was retrieved and the setWeekDate method was used to set a date.
This method is discussed in more detail in the Using Weeks in Java 7 recipe.
The display was repeated, except that the default locale is changed using the setDefault method.
The display resources were changed to use Locale.JAPANESE, and the format type resources were changed to Locale.GERMAN.
This occurs when an attempt is made to execute a method against a reference variable, which contains a value of null.
In this recipe we will examine various techniques that are available to address this type of exception.
The use of this class simplifies the testing for null values.
Getting ready To use the Objects class to override the equals and hashCode methods:
Use the Objects class' equals method to avoid explicit code to check for null values in the equals method.
Use the Objects class' hashCode method to avoid the need for explicit code to check for null values in the hashCode method.
In the equals method, a test was first made to determine if the object passed was null.
A test was made to ensure that the classes were of the same type.
The equals method was then used to see if the two name fields were equal to each other.
The Objects class' equals method behaves as summarized in the following table.
The meaning of equality is determined by the equals method of the first argument:
First argument Second argument Returns Not null Not null true if they are the same object, otherwise false.
The last test compared the two integer partNumber fields for equality.
In the Item class' hashCode method, the Objects class' hashCode method was applied to the name field.
This method will return 0 if its argument is null otherwise it returns the hash code for the argument.
The partNumber was then used to compute the final value for the hash code.
Notice the use of the requireNonNull method in the two argument constructors and the setName method.
This effectively catches a potential error earlier in the application.
The requireNonNull method is overloaded with a second version accepting a second string argument.
This argument changes the message generated, when an exception occurs.
Replace the body of the setName method with the following code:
There are several other Objects class methods that may be of interest.
In addition, the second section will examine the use of empty iterators to avoid null pointer exceptions.
Additional Objects class methods The Objects class' hashCode method is overloaded.
A second version takes a variable number of objects as arguments.
The method will generate a hash code using this sequence of objects.
For example, the Item class' hashCode method could have been written as:
This means it compares more than just the reference values.
If both arguments are arrays, then the Arrays.deepEqual method is invoked.
Equality of objects is determined by the equals method of the first argument.
The compare method is used to compare the first two arguments returning either a negative value, a zero, or a positive value depending on the relationship between the arguments.
Typically, returning a 0 indicates that the arguments are the same.
A negative value means that the first argument is less than the second argument.
A positive value indicates that the first argument is greater than the second argument.
The method will return a zero if its arguments are identical, or if both arguments are null.
Otherwise, the return value is determined using the Comparator interface's compare method.
The Objects class' toString method is used to guarantee that a string is returned even if the object is null.
The following sequence illustrates the use of this overloaded method:
When executed, the first use of the method displays the word null.
In the second version, the string argument is displayed as follows:
It could be beneficial to return an empty Iterator instead.
In Java 7, the Collections class has added three new methods that return an Iterator, a ListIterator, or an Enumeration, all of which are empty.
By returning empty, they can be used without incurring a null pointer exception.
An if statement is used to return either a ListIterator or an empty ListIterator:
Use the following main method to test the behavior of the iterator:
The Collections class' static emptyListIterator method returns a ListIterator, whose methods work as listed in the following table:
The emptyIterator method will return an empty iterator with the following behavior:
These are designed to simplify the manipulation of large sets of bits and provide easier access to information about bit location.
Bit sets can be used for priority queues or compressed data structures.
After creating our BitSet object, we created an array containing three long numbers, which serve as a representation of the sequence of bits that we wish to use in our BitSet.
The valueOf method takes this representation and converts it to the sequence of bits.
In our example, we used an array of long numbers.
Similar valueOf methods exist for byte, LongBuffer, and ByteBuffer arrays.
When using a LongBuffer or ByteBuffer array, the buffers are not modified by the valueOf method, and the BitSet cannot be converted back to the buffer.
Instead, the BitSet must be converted by using the toLongArray method, or the similar toByteArray method that converts a BitSet into an array of bytes.
If we were to execute the following code in our previous example:
Both methods will return a -1 if no such bit exists in the BitSet.
About Packt Publishing Packt, pronounced 'packed', published its first book "Mastering phpMyAdmin for Effective MySQL Management" in April 2004 and subsequently continued to specialize in publishing highly focused books on specific technologies and solutions.
Our books and publications share the experiences of your fellow IT professionals in adapting and customizing today's systems, applications, and frameworks.
Our solution-based books give you the knowledge and power to customize the software and technologies you're using to get the job done.
Packt books are more specific and less general than the IT books you have seen in the past.
Our unique business model allows us to bring you more focused information, giving you more of what you need to know, and less of what you don't.
Packt is a modern, yet unique publishing company, which focuses on producing quality, cutting-edge books for communities of developers, administrators, and newbies alike.
This book is part of the Packt Enterprise brand, home to books published on enterprise software – software created by major vendors, including (but not limited to) IBM, Microsoft and Oracle, often for use in other corporations.
Its titles will offer information relevant to a range of users of this software, including administrators, developers, architects, and end users.
Writing for Packt We welcome all inquiries from people who are interested in authoring.
If your book idea is still at an early stage and you would like to discuss it first before writing a formal book proposal, contact us; one of our commissioning editors will get in touch with you.
We're not just looking for published authors; if you have strong technical skills but no writing experience, our experienced editors can help you develop a writing career, or simply get some additional reward for your expertise.
Create better interaction, design, and web development with simple JavaScript techniques.
Full of diagrams, illustrations, and step-by-step instructions to develop real word applications.
Develop your own service-based applications, from simple deployments through to complex legacy integrations.
Learn how services can communicate with each other and the benefits to be gained from loose coupling.
Contains clear, practical instructions for service development, highlighted through the use of numerous working examples.
Build dynamic, content-rich, and social systems on top of Liferay.
Use Liferay tools (CMS, WCM, collaborative API and social API) to create your own Web sites and WAP sites with hands-on examples.
Customize Liferay portal using JSR-286 portlets, hooks, themes, layout templates, webs plugins, and diverse portlet bridges.
Build your own websites with kernel features such as indexing, workflow, staging, scheduling, messaging, polling, tracking, auditing, reporting and more.
Chapter 4: Managing Files and Directories Introduction Creating files and directories Controlling how a file is copied Managing temporary files and directories Setting time-related attributes of a file or directory Managing file ownership Managing ACL file permissions Managing POSIX attributes Moving a file and a directory Deleting files or directories Managing symbolic links.
Chapter 5: Managing Filesystems Introduction Getting FileStore information Getting Filesystem information Using the SimpleFileVisitor class to traverse filesystems Deleting a directory using the SimpleFileVisitor class Copying a directory using the SimpleFileVisitor class Processing the contents of a directory by using the DirectoryStream interface Filtering a directory using globbing Writing your own directory filter Monitoring file events using WatchEvents Understanding the ZIP filesystem provider.
Chapter 7: Graphical User Interface Improvements Introduction Mixing heavyweight and lightweight components Managing window types Managing the opacity of a window Creating a varying gradient translucent window Managing the shape of a window Using the new border types in Java 7 Handling multiple file selection in the FileDialog class Controlling the print dialog box type Using the new JLayer decorator for a password field.
Chapter 8: Handling Events Introduction Managing extra mouse buttons and high resolution mouse wheels Controlling focus when displaying a window Using secondary loops to mimic modal dialog boxes Handling spurious thread wakeups Handling applet initialization status with event handlers.
