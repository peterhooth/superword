As always, all chapters have been completely revised for the latest version of Java.
Outdated material has been removed, and the new APIs of Java SE 7 are covered in detail.
Notes are tagged with “note” icons that look like this.
Tips are tagged with “tip” icons that look like this.
When there is danger ahead, we warn you with a “caution” icon.
There are a number of C++ notes that explain the difference between the Java programming language and C++
You can skip them if you aren’t interested in C++
Java comes with a large programming library, or Application Programming Interface (API)
When using an API call for the first time, we add a short summary description at the end of the section.
These descriptions are a bit more informal but, we hope, also a little more informative than those in the official online API documentation.
The names of interfaces are in italics, just like in the official documentation.
The number after a class, interface, or method name is the JDK version in which the feature was introduced.
Programs whose source code is included in the companion code for this book are listed as examples; for instance, Listing 1.1
Writing a book is always a monumental effort, and rewriting doesn’t seem to be much easier, especially with such a rapid rate of change in Java technology.
Making a book a reality takes many dedicated people, and it is my great pleasure to acknowledge the contributions of the entire Core Java team.
A large number of individuals at Prentice Hall provided valuable assistance, but they managed to stay behind the scenes.
I’d like them all to know how much I appreciate their efforts.
As always, my warm thanks go to my editor, Greg Doench, for steering the book through the writing and production process, and for allowing me to be blissfully unaware of the existence of all those folks behind the scenes.
I am very grateful to Julie Nahil for production support, and to Dmitry Kirsanov and Alina Kirsanova for copyediting and typesetting the manuscript.
Thanks to the many readers of earlier editions who reported embarrassing errors and made lots of thoughtful suggestions for improvement.
I am particularly grateful to the excellent reviewing team that went over the manuscript with an amazing eye for detail and saved me from many more embarrassing errors.
In this chapter, we will cover the Java Application Programming Interfaces (APIs) for input and output.
You will learn how to access files and directories and how to read and write data in binary and text format.
This chapter also shows you the object serialization mechanism that lets you store objects as easily as you can store text or numeric data.
We finish the chapter with a discussion of regular expressions, even though they are not actually related to streams and files.
We couldn’t find a better place to handle that topic, and apparently neither could the Java team—the regular expression API specification was attached to the specification request for the “new I/O” features.
In the Java API, an object from which we can read a sequence of bytes is called an input stream.
An object to which we can write a sequence of bytes is called an output stream.
These sources and destinations of byte sequences can be—and often are —files, but they can also be network connections and even blocks of memory.
The abstract classes InputStream and OutputStream form the basis for a hierarchy of input/output (I/O) classes.
Byte-oriented streams are inconvenient for processing information stored in Unicode (recall that Unicode uses multiple bytes per character)
Therefore, a separate hierarchy provides classes for processing Unicode characters that inherit from the abstract Reader and Writer classes.
These classes have read and write operations that are based on two-byte Unicode code units rather than on single-byte characters.
This method reads one byte and returns the byte that was read, or -1 if it encounters the end of the input source.
The designer of a concrete input stream class overrides this method to provide useful functionality.
For example, in the FileInputStream class, this method reads one byte from a file.
System.in is a predefined object of a subclass of InputStream that allows you to read information from the keyboard.
The InputStream class also has nonabstract methods to read an array of bytes or to skip a number of bytes.
These methods call the abstract read method, so subclasses need to override only one method.
Both the read and write methods block until the byte is actually read or written.
This means that if the stream cannot immediately be accessed (usually because of a busy network connection), the current thread blocks.
This gives other threads the chance to do useful work while the method is waiting for the stream to become available again.
The available method lets you check the number of bytes that are currently available for reading.
This means a fragment like the following is unlikely to block:
When you have finished reading or writing to a stream, close it by calling the close method.
This call frees up the operating system resources that are in limited supply.
If an application opens too many streams without closing them, system resources can become depleted.
Closing an output stream also flushes the buffer used for the output stream: Any characters that were temporarily placed in a buffer so that they could be delivered as a larger packet are sent off.
In particular, if you do not close a file, the last packet of bytes might never be delivered.
You can also manually flush the output with the flush method.
Even if a stream class provides concrete methods to work with the raw read and write functions, application programmers rarely use them.
The data that you are interested in probably contain numbers, strings, and objects, not raw bytes.
Java gives you many stream classes derived from the basic InputStream and OutputStream classes that let you work with data in the forms that you usually use, not with bytes.
If more than readlimit bytes have been read from the input stream, the stream is allowed to forget the marker.
If there is no current marker, the stream is not reset.
Let’s divide the animals in the stream class zoo by how they are used.
There are separate hierarchies for classes that process bytes and characters.
As you saw, the InputStream and OutputStream classes let you read and write individual bytes and arrays of bytes.
These classes form the basis of the hierarchy shown in Figure 1.1
To read and write strings and numbers, you need more capable subclasses.
For example, DataInputStream and DataOutputStream let you read and write all the primitive Java types in binary format.
Finally, there are streams that do useful stuff; for example, the ZipInputStream and ZipOutputStream let you read and write files in the familiar ZIP compression format.
Input and output stream hierarchy For Unicode text, on the other hand, you can use subclasses of the abstract classes Reader and Writer (see Figure 1.2)
The basic methods of the Reader and Writer classes are similar to those for InputStream and OutputStream.
Reader and writer hierarchy abstract int read() abstract void write(int c)
The write method is called with a Unicode code unit.
Therefore, you can use the try-with-resources statement with any Closeable.
The CharBuffer class has methods for sequential and random read/write access.
The Appendable interface has two methods for appending single characters and character sequences:
The CharSequence interface describes basic properties of a sequence of char values.
Returns the number of values read, or -1 if no further values are available from this Readable.
String toString() returns a string consisting of the code units of this sequence.
FileInputStream and FileOutputStream give you input and output streams attached to a disk file.
You need to pass the file name or full path name of the file to the constructor.
All the classes in java.io interpret relative path names as starting from the user’s working directory.
However, this is not recommended—the behavior of the Windows system functions is subject to change.
Instead, for portable programs, use the file separator character for the platform on which your program runs.
Like the abstract InputStream and OutputStream classes, these classes support only reading and writing at the byte level.
That is, we can only read bytes and byte arrays from the object fin.
But just as the FileInputStream has no methods to read numeric types, the DataInputStream has no method to get data from a file.
Java uses a clever mechanism to separate two kinds of responsibilities.
Some streams (such as the FileInputStream and the input stream returned by the openStream method of the URL class) can retrieve bytes from files and other more exotic locations.
Other streams (such as the DataInputStream and the PrintWriter) can assemble bytes into more useful data types.
For example, to be able to read numbers from a file, first create a FileInputStream and then pass it to the constructor of a DataInputStream.
Click here to view code imageClick here to view code image.
If you look at Figure 1.1 again, you can see the classes FilterInputStream and FilterOutputStream.
The subclasses of these classes are used to add capabilities to raw byte streams.
That is, every call to read asks the operating system to dole out yet another byte.
It is more efficient to request blocks of data instead and store them in a buffer.
If you want buffering and the data input methods for a file, you need to use the following rather monstrous sequence of constructors:
Notice that we put the DataInputStream last in the chain of constructors because we want to use the DataInputStream methods, and we want them to use the buffered read method.
Sometimes you’ll need to keep track of the intermediate streams when chaining them together.
For example, when reading input, you often need to peek at the next byte to see if it is the value that you expect.
Click here to view code imageClick here to view code image.
However, reading and unreading are the only methods that apply to a pushback input stream.
If you want to look ahead and also read numbers, then you need both a pushback input stream and a data input stream reference.
Of course, in the stream libraries of other programming languages, niceties such as buffering and lookahead are automatically taken care of, so it is a bit of a hassle to resort, in Java, to combining stream filters.
However, the ability to mix and match filter classes to construct truly useful sequences of streams does give you an immense amount of flexibility.
For example, you can read numbers from a compressed ZIP file by using the following sequence of streams (see Figure 1.4): Click here to view code imageClick here to view code image.
The File class is described at the end of this chapter.
Path names that are not absolute are resolved relative to the working directory that was set when the VM started.
The File class is described at the end of this chapter.
If the append parameter is true, an existing file with the same name will not be deleted and data will be added at the end of the file.
Otherwise, this method deletes any existing file with the same name.
A buffered input stream reads bytes from a stream without causing a device access every time.
When the buffer is empty, a new block of data is read into the buffer.
A buffered output stream collects bytes to be written without causing a device access every time.
When the buffer fills up or when the stream is flushed, the data are written.
When saving data, you have the choice between binary and text formats.
In text format, it is saved as the string "1234"
Although binary I/O is fast and efficient, it is not easily readable by humans.
We first discuss text I/O and cover binary I/O in Section 1.3, “Reading and Writing Binary Data,” on p.
When saving text strings, you need to consider the character encoding.
However, many programs expect that text files are encoded in a different encoding.
The OutputStreamWriter class turns a stream of Unicode code units into a stream of bytes, using a chosen character encoding.
Conversely, the InputStreamReader class turns an input stream that contains bytes (specifying characters in some character encoding) into a reader that emits Unicode code units.
For example, here is how you make an input reader that reads keystrokes from the console and converts them to Unicode:
This input stream reader assumes the default character encoding used by the host system, such as the ISO 8859-1 encoding in Western Europe.
You can choose a different encoding by specifying it in the constructor for the InputStreamReader, for example:
That class has methods to print strings and numbers in text format.
There is even a convenience constructor to link a PrintWriter to a FileWriter.
To write to a print writer, use the same print, println, and printf methods that you used with System.out.
You can use these methods to print numbers (int, short, long, float, double), characters, boolean values, strings, and objects.
The characters are then converted to bytes and end up in the file employee.txt.
If the writer is set to autoflush mode, all characters in the buffer are sent to their destination whenever println is called.
You can enable or disable autoflushing by using the PrintWriter(Writer out, boolean autoFlush) constructor:
You can call the checkError method to see if something went wrong with the stream.
Java veterans might wonder whatever happened to the PrintStream class and to System.out.
In Java 1.0, the PrintStream class simply truncated all Unicode characters to ASCII characters by dropping the top byte.
Clearly, that was not a clean or portable approach, and it was fixed with the introduction of readers and writers in Java 1.1
For compatibility with existing code, System.in, System.out, and System.err are still streams, not readers and writers.
But now the PrintStream class internally converts Unicode characters to the default host encoding in the same way as the PrintWriter does.
Objects of type PrintStream act exactly like print writers when you use the print and println methods, but unlike print writers they allow you to output raw bytes with the write(int) and write(byte[]) methods.
PrintWriter(File file) creates a new PrintWriter that writes to the given file by creating the necessary intermediate FileWriter.
Flushes the stream if the stream is in autoflush mode.
See Volume I, Chapter 3 for the specification of the format string.
Once the stream has encountered an error, it is tainted and all calls to checkError return true.
To write data in binary format, you use a DataOutputStream.
Therefore, you might expect that there is an analog to the DataInputStream that lets you read data in text format.
The closest analog is the Scanner class that we used extensively in Volume I.
However, before Java SE 5.0, the only game in town for processing text input was the BufferedReader class with the readLine method that lets you read a line of text.
You need to combine a buffered reader with an input source.
Click here to view code imageClick here to view code image.
We suggest that you use a Scanner for reading text input.
In this section, we walk you through an example program that stores an array of Employee records in a text file.
Part of the fun is that everyone uses a different delimiter.
Naturally, we punt on the issue of what might happen if a | actually occurred in one of the strings we save.
Since we write to a text file, we use the PrintWriter class.
This work is done in the following writeData method that we add to.
To read records, we read in a line at a time and separate the fields.
We use a scanner to read each line and then split the line into tokens with the String.split method.
Click here to view code imageClick here to view code image.
The parameter of the split method is a regular expression describing the separator.
We discuss regular expressions in more detail at the end of this chapter.
As it happens, the vertical bar character has a special meaning in regular expressions, so it needs to be escaped with a \ character.
The call to nextInt reads the array length but not the trailing newline character.
We must consume the newline so that the readData method can get the next input line when it calls the nextLine method.
To obtain a Charset, call the static forName method with either the official name or one of its aliases:
To find out which character sets are available in a particular implementation, call the static availableCharsets method.
Use this code to find out the names of all available character sets: Click here to view code imageClick here to view code image.
Table 1.1 lists the character encodings that every Java implementation is required to have.
Table 1.2 lists the encoding schemes that the Java Development Kit (JDK) installs by default.
The character sets in Table 1.3 are installed only on operating systems that use non-European languages.
If a character cannot be represented, it is transformed to a ?
Once you have a character set, you can use it to convert between Java strings (which contain Unicode code units) and encoded.
Once you have a character set, you can use it to convert between Java strings (which contain Unicode code units) and encoded byte sequences.
Conversely, to decode a byte sequence, you need a byte buffer.
Use the static wrap method of the ByteBuffer class to turn a byte array into a byte buffer.
Click here to view code imageClick here to view code image.
Returns a map whose keys are character set names and whose values are character sets.
Set aliases() returns the set of alias names for this character set.
ByteBuffer encode(String str) encodes the given string into a sequence of bytes.
Unrecognized inputs are converted to the Unicode “replacement character” ('\uFFFD')
String toString() returns a string consisting of the code units that this buffer manages.
The DataOutput interface defines the following methods for writing a number, a character, a boolean value, or a string in binary format:
The resulting output is not human-readable, but the space needed will be the same for each value of a given type and reading it back in will be faster than parsing text.
The writeUTF method writes string data using a modified version of 8-bit Unicode Transformation Format.
This modified encoding is different for characters with codes higher than 0xFFFF.
It is used for backward compatibility with virtual machines that were built when Unicode had not yet grown beyond 16 bits.
Since nobody else uses this modification of UTF-8, you should only use the writeUTF method to write strings intended for a Java virtual machine—for example, in a program that generates bytecodes.
To read the data back in, use the following methods defined in the DataInput interface: readInt readShort readLong readFloat readDouble readChar readBoolean readUTF.
To read binary data from a file, combine a DataInputStream with a source of bytes such as a FileInputStream:
String readUTF() reads a string of characters in the “modified UTF-8” format.
The RandomAccessFile class lets you read or write data anywhere in a file.
Disk files are random-access, but streams of data from a network are not.
You can open a random-access file either for reading only or for both reading and writing; specify the option by using the string "r" (for read access) or "rw" (for read/write access) as the second argument in the constructor.
Click here to view code imageClick here to view code image.
When you open an existing file as a RandomAccessFile, it does not get deleted.
A random-access file has a file pointer that indicates the position of the next byte to be read or written.
The seek method sets the file pointer to an arbitrary byte position within the file.
The argument to seek is a long integer between zero and the length of the file in bytes.
The getFilePointer method returns the current position of the file pointer.
The RandomAccessFile class implements both the DataInput and DataOutput interfaces.
To read and write from a randomaccess file, use methods such as readInt/writeInt and readChar/writeChar that we discussed in the preceding section.
Let’s walk through an example program that stores employee records in a random-access file.
Suppose you want to position the file pointer to the third record.
Simply set the file pointer to the appropriate byte position and start reading.
If you want to modify the record and save it back into the same location, remember to set the file pointer back to the beginning of the record:
To determine the total number of bytes in a file, use the length method.
The total number of records is the length divided by the size of each record.
Click here to view code imageClick here to view code image.
Integers and floating-point values have a fixed size in binary format, but we have to work harder for strings.
We provide two helper methods to write and read strings of a fixed size.
The writeFixedString writes the specified number of code units, starting at the beginning of the string.
If there are too few code units, the method pads the string, using zero values.
Click here to view code imageClick here to view code image.
The readFixedString method reads characters from the input stream until it has consumed size code units or until it encounters a character with a zero value.
Then, it skips past the remaining zero values in the input field.
For added efficiency, this method uses the StringBuilder class to read in a string.
Click here to view code imageClick here to view code image.
We placed the writeFixedString and readFixedString methods inside the DataIO helper class.
To write a fixed-size record, we simply write all fields in binary.
Click here to view code imageClick here to view code image.
Click here to view code imageClick here to view code image.
The program shown in Listing 1.2 writes three records into a data file and then reads them from the file in reverse order.
To do this efficiently requires random access—we need to get at the last record first.
Each ZIP archive has a header with information such as the name of each file and the compression method that was used.
In Java, you can use a ZipInputStream to read a ZIP archive.
You need to look at the individual entries in the archive.
The getNextEntry method returns an object of type ZipEntry that describes the entry.
The read method of the ZipInputStream is modified to return -1 at the end of the current entry (instead of just at the end of the ZIP file)
You must then call closeEntry to read the next entry.
Here is a typical code sequence to read through a ZIP file: Click here to view code imageClick here to view code image.
To read the contents of a ZIP entry, you will rarely want to use the raw read method; usually, you will use the methods of a more competent stream filter.
For example, to read a text file inside a ZIP file, use the following loop:
Do not close the ZIP input stream after reading a single ZIP entry, and don’t pass it to a method that would close it.
For each entry that you want to place into the ZIP file, create a ZipEntry object.
Pass the file name to the ZipEntry constructor; it sets the other parameters such as file date and decompression method.
Then, call the putNextEntry method of the ZipOutputStream to begin writing a new file.
Here is a code skeleton: Click here to view code imageClick here to view code image.
Use the JarInputStream and JarOutputStream classes to read and write the manifest entry.
When you read data stored in compressed form, you don’t need to worry that the data are being decompressed as they are being requested.
Moreover, the source of the bytes in a ZIP stream need not be a file—the ZIP data can come from a network connection.
In fact, whenever the class loader of an applet reads a JAR file, it reads and decompresses data from the network.
ZipEntry getNextEntry() returns a ZipEntry object for the next entry, or null if there are no more entries.
You can then read the next entry by using getNextEntry()
The data can then be written to the stream by write()
ZipEntry(String name) constructs a zip entry with a given name.
ZipFile(File file) creates a ZipFile for reading from the given string or File object.
Enumeration entries() returns an Enumeration object that enumerates the ZipEntry objects that describe the entries of the ZipFile.
ZipEntry getEntry(String name) returns the entry corresponding to the given name, or null if there is no such entry.
Using a fixed-length record format is a good choice if you need to store data of the same type.
However, objects that you create in an object-oriented program are rarely all of the same type.
For example, you might have an array called staff that is nominally an array of Employee records but contains objects that are actually instances of a subclass such as Manager.
It is certainly possible to come up with a data format that allows you to store such polymorphic collections—but fortunately, we don’t have to.
The Java language supports a very general mechanism, called object serialization, that makes it possible to write any object to a stream and read it again later.
You will see later in this chapter where the term “serialization” comes from.
To save object data, you first need to open an ObjectOutputStream object:
Now, to save an object, simply use the writeObject method of the ObjectOutputStream class as in the following fragment: Click here to view code imageClick here to view code image.
There is, however, one change you need to make to any class that you want to save to and restore from an object stream.
The Serializable interface has no methods, so you don’t need to change your classes in any way.
However, to make a class cloneable, you still had to override the clone method of the Object class.
To make a class serializable, you do not need to do anything else.
Behind the scenes, an ObjectOutputStream looks at all the fields of the objects and saves their contents.
For example, when writing an Employee object, the name, date, and salary fields are written to the output stream.
However, there is one important situation that we need to consider: What happens when one object is shared by several objects as part of its state? To illustrate the problem, let us make a slight modification to the Manager class.
Each Manager object now contains a reference to the Employee object that describes the secretary.
Of course, two managers can share the same secretary, as is the case in Figure 1.5 and the following code:
Click here to view code imageClick here to view code image.
Of course, we cannot save and restore the memory addresses for the secretary objects.
When an object is reloaded, it will likely occupy a completely different memory address than it originally did.
Instead, each object is saved with a serial number, hence the name object serialization for this mechanism.
Associate a serial number with each object reference that you encounter (as shown in Figure 1.6)
When encountering an object reference for the first time, save the object data to the stream.
If it has been saved previously, just write “same as the previously saved object with serial number x.”
In this chapter, we will use serialization to save a collection of objects to a disk file and retrieve it exactly as we stored it.
Another very important application is the transmittal of a collection of objects across a network connection to another computer.
Just as raw memory addresses are meaningless in a file, they are also meaningless when communicating with a different processor.
By replacing memory addresses with serial numbers, serialization permits the transport of object collections from one machine to another.
Listing 1.3 is a program that saves and reloads a network of Employee and Manager objects (some of which share the same employee as a secretary)
Note that the secretary object is unique after reloading—when newStaff[1] gets a raise, that is reflected in the secretary fields of the managers.
This method saves the class of the object, the signature of the class, and the values of any nonstatic, nontransient fields of the class and its superclasses.
In particular, this method reads back the class of the object, the signature of the class, and the values of the nontransient and nonstatic fields of the class and all its superclasses.
It does deserializing to allow multiple object references to be recovered.
Object serialization saves object data in a particular file format.
Nonetheless, we found studying the data format extremely helpful for gaining insight into the object streaming process.
As the details are somewhat technical, feel free to skip this section if you are not interested in the implementation.
We use hexadecimal numbers throughout this section to denote bytes.
Then, it contains a sequence of objects, in the order in which they were saved.
The Unicode characters of the string are saved in the “modified UTF-8” format.
When an object is saved, the class of that object must be saved as well.
The serial version unique ID, which is a fingerprint of the data field types and method signatures.
The fingerprint is obtained by ordering the descriptions of the class, superclass, interfaces, field types, and method signatures in a canonical way, and then applying the so-called Secure Hash Algorithm (SHA) to that data.
This fingerprint is always a 20-byte data packet, regardless of the size of the original data.
It is created by a clever sequence of bit operations on the data that makes it essentially 100 percent certain that the fingerprint will change if the information is altered in any way.
However, the serialization mechanism uses only the first eight bytes of the SHA code as a class fingerprint.
It is still very likely that the class fingerprint will change if the data fields or methods change.
When reading an object, its fingerprint is compared against the current fingerprint of the class.
If they don’t match, it means the class definition has changed after the object was written, and an exception is generated.
Of course, in practice, classes do evolve, and it might be necessary for a program to read in older versions of objects.
We will discuss this in Section 1.5.4, “Versioning,” on p.
Externalizable classes supply custom read and write methods that take over the output of their instance fields.
Field name Class name (if the field is an object)
When the type code is L, the field name is followed by the field type.
Class and field name strings do not start with the string code 74, but field types do.
Field types use a slightly different encoding of their names—namely, the format used by native methods.
For example, the salary field of the Employee class is encoded as:
Here is the complete class descriptor of the Employee class:
If the same class descriptor is needed again in the file, an abbreviated form is used:
The serial number refers to the previous explicit class descriptor.
For example, here is how an Employee object is stored:
As you can see, the data file contains enough information to restore the Employee object.
The array class name in the class descriptor is in the same format as that used by native methods (which is slightly different from the format used by class names in other class descriptors)
In this format, class names start with an L and end with a semicolon.
For example, an array of three Employee objects starts out like this:
Note that the fingerprint for an array of Employee objects is different from a finger-print of the Employee class itself.
All objects (including arrays and strings) and all class descriptors are given serial numbers as they are saved in the output file.
We already saw that a full class descriptor for any given class occurs only once.
For example, in our previous example, a repeated reference to the Date class was coded as.
If a reference to a previously saved object is written, it is saved in exactly the same way; that is, 71 followed by the serial number.
It is always clear from the context whether the particular serial reference denotes a class descriptor or an object.
Here is the commented output of the ObjectRefTest program of the preceding section.
Run the program, look at a hex dump of its data file employee.dat, and compare it with the commented listing.
The important lines toward the end of the output show a reference to a previously saved object.
Of course, studying these codes can be about as exciting as reading the average phone book.
It is not important to know the exact file format (unless you are trying to create an evil effect by modifying the data), but it is still instructive to know that the object stream has a detailed description of all the objects that it contains, with sufficient detail to allow reconstruction of both objects and arrays of objects.
The object stream output contains the types and data fields of all objects.
Repeated occurrences of the same object are stored as references to that serial number.
Certain data fields should never be serialized—for example, integer values that store file handles or handles of windows that are only meaningful to native methods.
Such information is guaranteed to be useless when you reload an object at a later time or transport it to a different machine.
In fact, improper values for such fields can actually cause native methods to crash.
Java has an easy mechanism to prevent such fields from ever being serialized.
You also need to tag fields as transient if they belong to nonserializable classes.
The serialization mechanism provides a way for individual classes to add validation or any other desired action to the default read and write behavior.
A serializable class can define methods with the signature Click here to view code imageClick here to view code image.
Then, the data fields are no longer automatically serialized, and these methods are called instead.
A number of classes in the java.awt.geom package, such as Point2D.Double, are not serializable.
Now, suppose you want to serialize a class LabeledPoint that stores a String and a Point2D.Double.
Click here to view code imageClick here to view code image.
In the writeObject method, we first write the object descriptor and the String field, label, by calling the defaultWriteObject method.
This is a special method of the ObjectOutputStream class that can only be called from within a writeObject method of a serializable class.
Then we write the point coordinates, using the standard DataOutput calls.
Click here to view code imageClick here to view code image.
Another example is the java.util.Date class that supplies its own readObject and writeObject methods.
The Date class has a complex internal representation that stores both a Calendar object and a millisecond count to optimize lookups.
The state of the Calendar is redundant and does not have to be saved.
The readObject and writeObject methods only need to save and load their data fields.
They should not concern themselves with superclass data or any other class information.
Instead of letting the serialization mechanism save and restore object data, a class can define its own mechanism.
To do this, a class must implement the Externalizable interface.
This, in turn, requires it to define two methods: Click here to view code imageClick here to view code image.
Unlike the readObject and writeObject methods that were described in the preceding section, these methods are fully responsible for saving and restoring the entire object, including the superclass data.
The serialization mechanism merely records the class of the object in the stream.
When reading an externalizable object, the object stream creates an object with the no-argument constructor and then calls the readExternal method.
Here is how you can implement these methods for the Employee class:
Unlike the readObject and writeObject methods, which are private and can only be called by the serialization mechanism, the readExternal and writeExternal methods are public.
In particular, readExternal potentially permits modification of the state of an existing object.
You have to pay particular attention to serializing and deserializing objects that are assumed to be unique.
This commonly happens when you are implementing singletons and typesafe enumerations.
If you use the enum construct of the Java language, you need not worry about serialization—it just works.
However, suppose you maintain legacy code that contains an enumerated type such as Click here to view code imageClick here to view code image.
This idiom was common before enumerations were added to the Java language.
In particular, you can use the == operator to test for object equality:
There is an important twist that you need to remember when a typesafe enumeration implements the Serializable interface.
Suppose we write a value of type Orientation and read it in again: Click here to view code imageClick here to view code image.
In fact, the saved value is a completely new object of the Orientation type that is not equal to any of the predefined constants.
Even though the constructor is private, the serialization mechanism can create new objects! To solve this problem, you need to define another special serialization method, called readResolve.
If the readResolve method is defined, it is called after the object is deserialized.
It must return an object which then becomes the return value of the readObject method.
In our case, the readResolve method will inspect the value field and return the appropriate enumerated constant: Click here to view code imageClick here to view code image.
Remember to add a readResolve method to all typesafe enumerations in your legacy code and to all classes that follow the singleton design pattern.
If you use serialization to save objects, you will need to consider what happens when your program evolves.
At first glance, it seems that this would not be possible.
When a class definition changes in any way, its SHA fingerprint also changes, and you know that object streams will refuse to read in objects with different fingerprints.
However, a class can indicate that it is compatible with an earlier version of itself.
To do this, you must first obtain the fingerprint of the earlier version of the class.
Use the stand-alone serialver program that is part of the JDK to obtain this number.
If you start the serialver program with the -show option, the program brings up a graphical dialog box (see Figure 1.7)
The graphical version of the serialver program All later versions of the class must define the serialVersionUID constant to the same fingerprint as the original.
Click here to view code imageClick here to view code image.
When a class has a static data member named serialVersionUID, it will not compute the fingerprint manually but will use that value instead.
Once that static data member has been placed inside a class, the serialization system is now willing to read in different versions of objects of that class.
If only the methods of the class change, there is no problem with reading the new object data.
However, if the data fields change, you may have problems.
For example, the old file object may have more or fewer data fields than the one in the program, or the types of the data fields may be different.
In that case, the object stream makes an effort to convert the stream object to the current version of the class.
The object stream compares the data fields of the current version of the class with those of the version in the stream.
Of course, the object stream considers only the nontransient and nonstatic data fields.
If two fields have matching names but different types, the object stream makes no effort to convert one type to the other—the objects are incompatible.
If the object in the stream has data fields that are not present in the current version, the object stream ignores the additional data.
If the current version has data fields that are not present in the streamed object, the added fields are set to their default (null for objects, zero for numbers, and false for boolean values)
Suppose we have saved a number of employee records on disk, using the original version (1.0) of the class.
Now we change the Employee class to version 2.0 by adding a data field called department.
Reading an object with more data fields Is this process safe? It depends.
Dropping a data field seems harmless—the recipient still has all the data that it knew how to manipulate.
Setting a data field to null might not be so safe.
Many classes work hard to initialize all data fields in all constructors to non-null values, so that the methods don’t have to be prepared to handle null data.
It is up to the class designer to implement additional code in the readObject method to fix version incompatibilities or to make sure the methods are robust enough to handle null data.
There is an amusing use for the serialization mechanism: It gives you an easy way to clone an object, provided the class is serializable.
Simply serialize it to an output stream and then read it back in.
The result is a new object that is a deep copy of the existing object.
As Listing 1.4 shows, to get clone for free, simply extend the SerialCloneable class, and you are done.
You should be aware that this method, although clever, will usually be much slower than a clone method that explicitly constructs a new object and copies or clones the data fields.
You have learned how to read and write data from a file.
However, there is more to file management than reading and writing.
The Path and Files classes encapsulate the functionality required to work with the file system on the user’s machine.
For example, use the Files class to remove or rename the file, or to find out when a file was last modified.
In other words, the stream classes are concerned with the contents of files, whereas the classes that we discuss here are concerned with the storage of files on a disk.
They are much more convenient to use than the File class which dates back all the way to JDK 1.0
We expect them to be very popular with Java programmers and discuss them in-depth.
A Path is a sequence of directory names, optionally followed by a file name.
The first component of a path may be a root component such as / or C:\
A path that starts with a root component is absolute.
For example, here we construct an absolute and a relative path.
For the absolute path, we assume a computer running a UNIX-like file system.
Click here to view code imageClick here to view code image.
The static Paths.get method receives one or more strings, which it joins with the path separator of the default file system (/ for a UNIX-like file system, \ for Windows)
The get method can get a single string containing multiple components.
For example, you can read a path from a configuration file like this: Click here to view code imageClick here to view code image.
A path does not have to correspond to a file that actually exists.
It is merely an abstract sequence of names.As you will see in the next section, when you want to create a file, you first make a path and then call a method to create the corresponding file.
The call p.resolve(q) returns a path according to these rules:
Otherwise, the result is “p then q”, according to the rules of the file system.
For example, suppose your application needs to find its working directory relative to a given base directory that is read from a configuration file, as in the preceding example.
Click here to view code imageClick here to view code image.
There is a convenience method resolveSibling that resolves against a path’s parent, yielding a sibling path.
The call p.relativize(r) yields the path q which, when resolved with q, yields r.
The toAbsolutePath method yields the absolute path of a given path, starting at a root component.
The Path class has many useful methods for taking paths apart and combining them with other paths.
This code sample shows some of the most useful ones: Click here to view code imageClick here to view code image.
Occasionally, you may need to interoperate with legacy APIs that use the File class instead of the Path class.
The Path class has a toFile method, and the File class has a toPath method.
Path resolve(String other) if other is absolute, returns other; otherwise, returns the path obtained from joining this and other.
Path relativize(Path other) returns the relative path that, when resolved with this, yields other.
Path toAbsolutePath() returns an absolute path that is equivalent to this path.
Path getParent() returns the parent, or null if this path has no parent.
Path getFileName() returns the last component of this path, or null if this path has no components.
Path getRoot() returns the root component of this path, or null if this path has no root components.
The Files class makes quick work of common file operations.
For example, you can easily read the entire contents of a file:
These simple methods are intended for dealing with text files of moderate length.
If your files are large or binary, you can still use the familiar streams or readers/writers: Click here to view code imageClick here to view code image.
These convenience methods save you from dealing with FileInputStream, FileOutputStream, BufferedReader, or BufferedWriter.
The copy or move will fail if the target exists.
If you want to overwrite an existing target, use the REPLACE_EXISTING option.
If you want to copy all file attributes, use the COPY_ATTRIBUTES option.
You can supply both like this: Click here to view code imageClick here to view code image.
Then you are assured that either the move completed successfully, or the source continues to be present.
The deletion methods can also be used to remove an empty directory.
The first method throws an exception if the file or directory doesn’t exist.
The call throws an exception if the file already exists.
If the file doesn’t exist, it is created before anyone else has a chance to do the same.
There are convenience methods for creating a temporary file or directory in a given or system-specific location.
Click here to view code imageClick here to view code image.
Here, dir is a Path, and prefix/suffix are strings which may be null.
When you create a file or directory, you can specify attributes, such as owners or permissions.
However, the details depend on the file system, and we won’t cover them here.
The following static methods return a boolean value to check a property of a path:
Whether the file is a regular file, a directory, a symbolic link, or none of these.
The file key—an object of some class, specific to the file system, that may or may not uniquely identify a file.
Then you can find out the group owner and the owner, group, and world access permissions.
We won’t dwell on the details since so much of this information is not portable across operating systems.
The old File class had a method for getting an array of all files in a directory, but that led to poor performance with directories holding huge numbers of files.
For that reason, the Files class has a method that yields an Iterable object instead.
Here is how you use it: Click here to view code imageClick here to view code image.
The try-with-resources block ensures that the directory stream is properly closed.
There is no specific order in which the directory entries are visited.
If you want to visit all descendants of a directory, call the walkFileTree method instead and supply an object of type FileVisitor.
When an error occurred trying to visit a file or directory, such as trying to open a directory without the necessary permissions: FileVisitResult visitFileFailed(T path, IOException ex)
In each case, you can specify whether you want to.
If any of the methods throws an exception, the walk is also terminated, and that exception is thrown from the walkFileTree method.
The FileVisitor interface is a generic type, but it isn’t likely that you’ll ever want something other than a FileVisitor<Path>
The visitFileFailed method throws the exception that caused the failure, thereby terminating the visit.
For example, here is how you can print out all subdirectories of a given directory.
Click here to view code imageClick here to view code image.
Otherwise, the visit would fail as soon as it encounters a directory that it’s not allowed to open.
Also note that the attributes of the path are passed as a parameter.
The walkFileTree already had to make an OS call to get the attributes, since it needs to distinguish between files and directories.
The other methods of the FileVisitor interface are useful if you need to do some work when entering or leaving a directory.
For example, when you make a copy of a directory tree, you need to copy the current directory before you add file copies to it.
When you delete a directory tree, you need to remove the current directory after you have removed all of its files.
The second method only accepts those entries matching the given glob pattern.
FileVisitResult visitFileFailed(T path, IOException exc) is called if an exception was thrown in an attempt to get information about the given file.
The default implementation rethrows the exception, which causes the visit to terminate with that exception.
The Paths class looks up paths in the default file system—the files on the user’s local disk.
One of the more useful ones is a ZIP file system.
If zipname is the name of a ZIP file, then the call.
It’s an easy matter to copy a file out of that archive if you know its name:
Here, fs.getPath is the analog of Paths.get for an arbitrary file system.
To list all files in a ZIP archive, walk the file tree: Click here to view code imageClick here to view code image.
That is nicer than the API described in Section 1.4, “ZIP Archives,” on p.
Returns the file system that is created by the first file system provider that accepts the given path.
By default, there is a provider for ZIP file systems that accepts files whose names end in .zip or .jar.
Most operating systems can take advantage of the virtual memory implementation to “map” a file, or a region of a file, into memory.
Then the file can be accessed as if it were an in-memory array, which is much faster than the traditional file operations.
At the end of this section, you can find a program that computes the CRC32 checksum of a file using traditional file input and a memory-mapped file.
As you can see, on this particular machine, memory mapping is a bit faster than using buffered sequential input and dramatically faster than using a RandomAccessFile.
Of course, the exact values will differ greatly from one machine to another, but it is obvious that the performance gain, compared to random access, can be substantial.
For sequential reading of files of moderate size, on the other hand, there is no reason to use memory mapping.
A channel is an abstraction for a disk file that lets you access operating system features such as memory mapping, file locking, and fast data transfers between files.
Then, get a ByteBuffer from the channel by calling the map method of the FileChannel class.
Specify the area of the file that you want to map and a mapping mode.
Note that other programs that have mapped the same file might not see those changes immediately.
The exact behavior of simultaneous file mapping by multiple programs depends on the operating system.
Once you have the buffer, you can read and write data using the methods of the ByteBuffer class and the Buffer superclass.
A buffer has a position that is advanced by get and put operations.
For example, you can sequentially traverse all bytes in the buffer as.
You can also read and write arrays of bytes with the methods get(byte[] bytes) get(byte[], int offset, int length)
Finally, there are methods getInt getLong getShort getChar getFloat getDouble.
As we already mentioned, Java uses big-endian ordering for binary data.
However, if you need to process a file containing binary numbers in little-endian order, simply call.
To find out the current byte order of a buffer, call ByteOrder b = buffer.order()
This pair of methods does not use the set/get naming convention.
To write numbers to a buffer, use one of the methods putInt putLong putShort putChar putFloat putDouble.
At some point, and certainly when the channel is closed, these changes are written back to the file.
That quantity is a checksum that is often used to determine whether a file has been corrupted.
Corruption of a file makes it very likely that the checksum has changed.
The java.util.zip package contains a class CRC32 that computes the checksum of a sequence of bytes, using the following loop:
We just use it as an example of a useful file operation.
FileChannel getChannel() 1.41.4 returns a channel for accessing this stream.
FileChannel getChannel() 1.41.4 returns a channel for accessing this stream.
FileChannel getChannel() 1.41.4 returns a channel for accessing this file.
ByteBuffer put(byte b) puts a byte at the current position and advances the current position to the next byte.
ByteBuffer put(int index, byte b) puts a byte at the specified index.
ByteBuffer get(byte[] destination, int offset, int length) fills a byte array, or a region of a byte array, with bytes from the buffer, and advances the current position by the number of bytes read.
ByteBuffer put(byte[] source, int offset, int length) puts all bytes from a byte array, or the bytes from a region of a byte array, into the buffer, and advances the current position by the number of bytes read.
ByteBuffer putXxx(int index, Xxx value) gets or puts a binary number.
CharBuffer asCharBuffer() constructs a character buffer that is backed by this buffer.
Changes to the character buffer will show up in this buffer, but the character buffer has its own position, limit, and mark.
CharBuffer get(char[] destination, int offset, int length) gets one char value, or a range of char values, starting at the buffer’s position and moving the position past the characters that were read.
CharBuffer put(CharBuffer source) puts one char value, or a range of char values, starting at the buffer’s position and advancing the position past the characters that were written.
When reading from a CharBuffer, all remaining characters are read.
When you use memory mapping, you make a single buffer that spans the entire file or the area of the file that you’re interested in.
You can also use buffers to read and write more modest chunks of information.
In this section, we briefly describe the basic operations on Buffer objects.
A buffer is an array of values of the same type.
In practice, you will most commonly use ByteBuffer and CharBuffer.
A position at which the next value is read or written.
Optionally, a mark for repeating a read or write operation.
The principal purpose of a buffer is a “write, then read” cycle.
At the outset, the buffer’s position is 0 and the limit is the capacity.
When you run out of data or reach the capacity, it is time to switch to reading.
Now keep calling get while the remaining method (which returns limit – position) is positive.
When you have read all values in the buffer, call clear to prepare the buffer for the next writing cycle.
The clear method resets the position to 0 and the limit to the capacity.
If you want to reread the buffer, use rewind or mark/reset (see the API notes for details)
Then, you can fill a buffer from a channel, or write its contents to a channel.
For example, Click here to view code imageClick here to view code image.
This can be a useful alternative to using a random-access file.
Buffer clear() prepares this buffer for writing by setting the position to 0 and the limit to the capacity; returns this.
Buffer flip() prepares this buffer for reading after writing, by setting the limit to the position and the position to 0; returns this.
Buffer rewind() prepares this buffer for rereading the same values by setting the position to 0 and leaving the limit unchanged; returns this.
Buffer mark() sets the mark of this buffer to the position; returns this.
Buffer reset() sets the position of this buffer to the mark, thus allowing the marked portion to be read or written again; returns this.
When multiple simultaneously executing programs need to modify the same file, they need to communicate in some way, or the file can easily become damaged.
A file lock controls access to a file or a range of bytes within a file.
Suppose your application saves a configuration file with user preferences.
If a user invokes two instances of the application, it could happen that both of them want to write the configuration file at the same time.
In that situation, the first instance should lock the file.
When the second instance finds the file locked, it can decide to wait until the file is.
To lock a file, call either the lock or tryLock methods of the FileChannel class.
The second call returns immediately, either with the lock or with null if the lock is not available.
The file remains locked until the channel is closed or the release method is invoked on the lock.
You can also lock a portion of the file with the call.
The shared flag is false to lock the file for both reading and writing.
It is true for a shared lock, which allows multiple processes to read from the file, while preventing any process from acquiring an exclusive lock.
You may get an exclusive lock even if you just asked for a shared one.
Call the isShared method of the FileLock class to find out which kind you have.
If you lock the tail portion of a file and the file subsequently grows beyond the locked portion, the additional area is not locked.
If an application fails to get a lock, it may still write to a file that another application has currently locked.
On some systems, you cannot simultaneously lock a file and map it into memory.
File locks are held by the entire Java virtual machine.
If two programs are launched by the same virtual machine (such as an applet or application launcher), they can’t each acquire a lock on the same file.
On some systems, closing a channel releases all locks on the underlying file held by the Java virtual machine.
You should therefore avoid multiple channels on the same locked file.
Locking files on a networked file system is highly system-dependent and should probably be avoided.
FileLock lock() acquires an exclusive lock on the entire file.
FileLock tryLock() acquires an exclusive lock on the entire file, or returns null if the lock cannot be acquired.
FileLock tryLock(long position, long size, boolean shared) acquires a lock on a region of the file.
The first method blocks until the lock is acquired, and the second method returns null if the lock cannot be acquired.
You can use regular expressions whenever you need to locate strings that match a particular pattern.
You need to specify exactly what sequence of characters is a legal match, using a special syntax to describe a pattern.
The remainder of the string consists of one or more arbitrary characters.
For example, the string "javanese" matches this particular regular expression, but the string "Core Java" does not.
As you can see, you need to know a bit of syntax to understand the meaning of a regular expression.
Fortunately, for most purposes, a few straightforward constructs are sufficient.
Here the - denotes a range (all characters whose Unicode values fall between the two bounds), and ^ denotes the complement (all characters except those specified)
To include a - inside a character class, make it the first or last item.
To include a ^, put it anywhere but the beginning.
Most characters match themselves, such as the ava characters in the preceding example.
If X and Y are regular expressions, then XY means “any match for X followed by a match for Y”
By default, a quantifier matches the largest possible repetition that makes the overall match succeed.
You can modify that behavior with suffixes ? (reluctant, or stingy, match: match the smallest repetition count) and + (possessive, or greedy, match: match the largest count even if that makes the overall match fail)
In the first case, the expression [a-z]* only matches the character c, so that the characters ab match the remainder of the pattern.
But the greedy version [az]*+ matches the characters cab, leaving the remainder of the pattern unmatched.
For example, here is a somewhat complex but potentially useful regular expression that describes decimal or hexadecimal integers:
Unfortunately, the regular expression syntax is not completely standardized between various programs and libraries; there is a consensus on the basic constructs but many maddening differences in the details.
The Java regular expression classes use a syntax that is similar to, but not quite the same as, the one used in the Perl language.
For more information on the regular expression syntax, consult the API documentation for the Pattern class or the book Mastering Regular Expressions by Jeffrey E.
The simplest use for a regular expression is to test whether a particular string matches it.
First, construct a Pattern object from a string containing the regular expression.
Then, get a Matcher object from the pattern and call its matches method: Click here to view code imageClick here to view code image.
The input of the matcher is an object of any class that implements the CharSequence interface, such as a String, StringBuilder, or CharBuffer.
When compiling the pattern, you can set one or more flags, for example: Click here to view code imageClick here to view code image.
By default, this flag takes only US ASCII characters into account.
If the regular expression contains groups, the Matcher object can reveal the group boundaries.
Call the groupCount method to get the total group count.
Listing 1.6 prompts for a pattern, then for strings to match.
It prints out whether or not the input matches the pattern.
If the input matches and the pattern contains groups, the program prints the group boundaries as parentheses, such as.
Usually, you don’t want to match the entire input against a regular expression, but to find one or more matching substrings in the input.
Use the find method of the Matcher class to find the next match.
If it returns true, use the start and end methods to find the extent of the match.
Click here to view code imageClick here to view code image.
It locates all hypertext references in a web page and prints them.
To run the program, supply a URL on the command line, such as.
The replaceAll method of the Matcher class replaces all occurrences of a regular expression with a replacement string.
For example, the following instructions replace all sequences of digits with a # character.
The replacement string can contain references to the groups in the pattern: $n is replaced with the nth group.
The replaceFirst method replaces only the first occurrence of the pattern.
Finally, the Pattern class has a split method that splits an input into an array of strings, using the regular expression matches as boundaries.
For example, the following instructions split the input into tokens, where the delimiters are punctuation marks surrounded by optional whitespace.
Click here to view code imageClick here to view code image.
String[] split(CharSequence input, int limit) splits the input string into tokens, where the pattern specifies the form of the delimiters.
String group(int groupIndex) returns the string matching a given group.
The second method makes the matcher work on a different input.
You have now seen how to carry out input and output operations in Java, and had an overview of the regular expression package that was a part of the “new I/O” specification.
In the next chapter, we turn to the processing of XML data.
You need domain-specific standards and code libraries to use it effectively.
Moreover, far from making Java technology obsolete, XML works very well with Java.
Since the late 1990s, IBM, Apache, and others have been instrumental in producing high-quality Java libraries for XML processing.
Many of these libraries have now been integrated into the Java platform.
This chapter introduces XML and covers the XML features of the Java library.
As always, we’ll point out along the way when the hype surrounding XML is justified—and when you have to take it with a grain of salt and try solving your problems the old-fashioned way, through good design and code.
In Chapter 10 of Volume I, you have seen the use of property files to describe the configuration of a program.
A property file contains a set of name/value pairs, such as.
You can use the Properties class to read in such a file with a single method call.
That’s a nice feature, but it doesn’t really go far enough.
In many cases, the information you want to describe has more structure than the property file format can comfortably handle.
It would be more object-oriented to have a single entry:
But then, parsing the font description gets ugly as you have to figure out when the font name ends and the font size starts.
You can often see programmers work around that limitation with key names, such as.
Another shortcoming of the property file format is the requirement that keys must be unique.
To store a sequence of values, you need another workaround, such as.
It can express hierarchical structures and is thus more flexible than the flat table structure of a property file.
An XML file for describing a program configuration might look like this:
The XML format allows you to express the hierarchy and record repeated elements without contortions.
There is a good reason for that—both the XML and HTML formats are descendants of the venerable Standard Generalized Markup Language (SGML)
It has been used with success in some industries that require ongoing maintenance of massive documentation—in particular, the aircraft industry.
However, SGML is quite complex, so it has never caught on in a big way.
Much of that complexity arises because SGML has two conflicting goals.
As is often true, simpler is better, and XML has enjoyed the immediate and enthusiastic reception that has eluded SGML for so long.
Even though XML and HTML have common roots, there are important differences between the two.
That way, the parser knows not to look for a </img> tag.
In XML, attribute values must be enclosed in quotation marks.
In XML, all attributes must have values, such as checked="true" or (ugh) checked="checked"
An XML document should start with a header such as.
Strictly speaking, a header is optional, but it is highly recommended.
Since SGML was created for processing of real documents, XML files are called documents even though many of them describe data sets that one would not normally call documents.
The header can be followed by a document type definition (DTD), such as Click here to view code imageClick here to view code image.
DTDs are an important mechanism to ensure the correctness of a document, but they are not required.
Finally, the body of the XML document contains the root element, which can contain other elements.
In the preceding example, the font element has two child elements, name and size.
It is best to structure your XML documents so that an element contains either child elements or text.
As you will see later in this chapter, you can simplify parsing if you avoid mixed content.
There is some disagreement among XML designers about when to use elements and when to use attributes.
For example, it would seem easier to describe a font as.
Suppose you want to add units to the size value.
If you use attributes, you will have to add the unit to the attribute value:
Ugh! Now you have to parse the string "36 pt", just the kind of hassle that XML was designed to avoid.
Adding an attribute to the size element is much cleaner:
A commonly used rule of thumb is that attributes should be used only to modify the interpretation of a value, not to specify values.
If you find yourself engaged in metaphysical discussions about whether a particular setting is a modification of the interpretation of a value or not, just say “no” to attributes and use elements throughout.
In HTML, the rule for attribute usage is simple: If it isn’t displayed on the web page, it’s an attribute.
The string Java Technology is displayed on the web page, but the URL of the link is not a part of the displayed page.
However, the rule isn’t all that helpful for most XML files because the data in an XML file aren’t normally meant to be viewed by humans.
Elements and text are the “bread and butter” of XML documents.
Here are a few other markup instructions that you might encounter:
Use this feature with caution! It is too often used as a back door for smuggling legacy data into XML documents.
Processing instructions are instructions for applications that process XML documents.
They should never contain hidden commands; use processing instructions for commands.
To process an XML document, you need to parse it.
A parser is a program that reads a file, confirms that the file has the correct format, breaks it up into the constituent elements, and lets a programmer access those elements.
Tree parsers, such as the Document Object Model (DOM) parser, that read an XML document into a tree structure.
Streaming parsers, such as the Simple API for XML (SAX) parser, that generate events as they read an XML document.
The DOM parser is easier to use for most purposes, and we explain it first.
You may consider a streaming parser if you process very long documents whose tree structures would use up a lot of memory, or if you are only interested in a few elements and don’t care about their context.
For more information, see Section 2.6, “Streaming Parsers,” on p.
The org.w3c.dom package contains the definitions of interface types such as Document and Element.
Different suppliers, such as the Apache Organization and IBM, have written DOM parsers whose classes implement these interfaces.
The Java API for XML Processing (JAXP) library actually makes it possible to plug in any of these parsers.
If you use an input stream as an input source, the parser will not be able to locate other files that are referenced relative to the location of the document, such as a DTD in the same directory.
You can install an “entity resolver” to overcome that problem.
The Document object is an in-memory representation of the tree structure of the XML document.
It is composed of objects whose classes implement the Node interface and its various subinterfaces.
The NodeNode interface and its subinterfaces interface and its subinterfaces Start analyzing the contents of a document by calling the getDocumentElement method.
The getTagName method returns the tag name of an element.
To get the element’s children (which may be subelements, text, comments, or other nodes), use the getChildNodes method.
That type was invented before the standard Java collections, and it has a different access protocol.
The item method gets the item with a given index, and the getLength method gives the total count of the items.
Therefore, you can enumerate all children like this: Click here to view code imageClick here to view code image.
You would expect the font element to have two children, but the parser reports five:
A simple DOM tree If you expect only subelements, you can ignore the whitespace:
Now you look at only two elements, with tag names name and size.
As you will see in the next section, you can do even better if your document has a DTD.
Then the parser knows which elements don’t have text nodes as children, and it can suppress the whitespace for you.
When analyzing the name and size elements, you want to retrieve the text strings that they contain.
Those text strings are themselves contained in child nodes of type Text.
You know that these Text nodes are the only children, so you can use the getFirstChild method without having to traverse another NodeList.
Then, use the getData method to retrieve the string stored in the Text node.
Click here to view code imageClick here to view code image.
It is a good idea to call trim on the return value of the getData method.
If the author of an XML file puts the beginning and the ending tags on separate lines, such as.
Calling the trim method removes the whitespace surrounding the actual data.
You can also get the last child with the getLastChild method, and the next sibling of a node with getNextSibling.
Therefore, another way of traversing a set of child nodes is Click here to view code imageClick here to view code image.
To enumerate the attributes of a node, call the getAttributes method.
It returns a NamedNodeMap object that contains Node objects describing the attributes.
You can traverse the nodes in a NamedNodeMap in the same way as a NodeList.
Then, call the getNodeName and getNodeValue methods to get the attribute names and values.
Click here to view code imageClick here to view code image.
You have now seen how to analyze a DOM tree.
The program in Listing 2.1 puts these techniques to work.
You can use the File> Open menu option to read in an XML file.
A DocumentBuilder object parses the XML file and produces a Document object.
The program displays the Document object as a tree (see Figure 2.3)
A parse tree of an XML document The tree display shows clearly how child elements are surrounded by text containing whitespace and comments.
Otherwise, they would show up as hollow boxesthe default symbol for a character that Swing cannot draw in a string.
In Chapter 6, you will learn the techniques that this program uses to display the tree and the attribute tables.
The getRoot method returns the root element of the document.
The getChild method gets the node list of children and returns the item with the requested index.
For elements, the element tag name and a table of all attributes.
For all other node types, the class name followed by the result of toString Listing 2.1
Document parse(InputStream in) parses an XML document from the given file, URL, or input stream and returns the parsed document.
NodeList getChildNodes() returns a node list that contains all children of this node.
Node getLastChild() gets the first or last child node of this node, or null if this node has no children.
Node getParentNode() gets the parent of this node, or null if this node is the document node.
NamedNodeMap getAttributes() returns a node map that contains Attr nodes that describe all attributes of this node.
If the node is an Attr node, the name is the attribute name.
If the node is an Attr node, the value is the attribute value.
Node item(int index) returns the node with the given index.
Node item(int index) returns the node with the given index.
In the preceding section, you saw how to traverse the tree structure of a DOM document.
However, if you simply follow that approach, you’ll find that you will have to perform quite a bit of tedious programming and error checking.
Not only do you have to deal with whitespace between elements, but you also need to check whether the document contains the nodes that you expect.
You skip text nodes and find the first element node.
Then, you need to check that its tag name is "name" and that it has one child node of type Text.
You move on to the next nonwhitespace child and make the same check.
What if the author of the document switched the order of the children or added another child element? It is tedious to code all this error checking, but reckless to skip the checks.
Fortunately, one of the major benefits of an XML parser is that it can automatically verify that a document has the correct structure.
For example, if you know that the font fragment has passed validation, you can simply get the two grandchildren, cast them as Text nodes, and get the text data, without any further checking.
To specify the document structure, you can supply a DTD or an XML Schema definition.
A DTD or schema contains rules that explain how a document should be formed, by specifying the legal child elements and attributes for each element.
This rule expresses that a font element must always have two children, which are name and size elements.
The XML Schema language expresses the same constraint as Click here to view code imageClick here to view code image.
Unlike the DTD syntax, the XML Schema syntax uses XML, which is a benefit if you need to process schema files.
However, as we write this chapter, DTDs are still very much alive.
In fact, some XML users are so annoyed by the complexity of XML Schema that they use alternative validation languages.
In the next section, we will discuss DTDs in detail, then briefly cover the basics of XML Schema support.
Finally, we will present a complete application that demonstrates how validation simplifies XML programming.
You can include a DTD in an XML document like this:
The document type must match the name of the root element, such as configuration in our example.
Supplying a DTD inside an XML document is somewhat uncommon because DTDs can grow lengthy.
The SYSTEM declaration can be used for that purpose; specify a URL that contains the DTD, for example:
If you use a relative URL for the DTD (such as "config.dtd"), give the parser a File or URL object, not an InputStream.
If you must parse from an input stream, supply an entity resolver (see the following note)
Finally, the mechanism for identifying well-known DTDs has its origin in SGML.
Here is an example: Click here to view code imageClick here to view code image.
If an XML processor knows how to locate the DTD with the public identifier, it need not go to the URL.
If you use a DOM parser and would like to support a PUBLIC identifier, call the setEntityResolver method of the DocumentBuilder class to install an object of a class that implements the EntityResolver interface.
You can construct the input source from an InputStream, a Reader, or a string.
Now that you have seen how the parser locates the DTD, let us consider the various kinds of rules.
The ELEMENT rule specifies what children an element can have.
Specify a regular expression, made up of the components shown in Table 2.1
The following rule states that a menu element contains 0 or more item elements:
An element specification can contain regular expressions that are nested and complex.
For example, here is a rule that describes the makeup of a chapter in this book:
Each chapter starts with an introduction, which is followed by one or more sections consisting of a heading and one or more paragraphs, images, tables, or notes.
However, in one common case you can’t define the rules to be as flexible as you might like.
Whenever an element can contain text, there are only two valid cases.
It is not legal to specify any other types of rules that contain #PCDATA.
You have to rewrite such a rule, either by introducing another caption element or by allowing any combination of image elements and text.
This restriction simplifies the job of the XML parser when parsing mixed content (a mixture of tags and text)
Since you lose some control by allowing mixed content, it is best to design DTDs so that all elements contain either other elements or nothing but text.
Actually, it isn’t quite true that you can specify arbitrary regular expressions of elements in a DTD rule.
An XML parser may reject certain complex rule sets that lead to nondeterministic parsing.
When the parser sees x, it doesn’t know which of the two alternatives to take.This expression can be rewritten in a deterministic form as (x,(y|z))
The Sun parser gives no warnings when presented with an ambiguous DTD; it simply picks the first matching alternative when parsing, which causes it to reject some correct inputs.
Of course, the parser is well within its rights to do so because the XML standard allows a parser to assume that the DTD is unambiguous.
In practice, this isn’t an issue over which you should lose sleep, because most DTDs are so simple that you will never run into ambiguity problems.
You can also specify rules to describe the legal attributes of elements.
Here are two typical attribute specifications: Click here to view code imageClick here to view code image.
The first specification describes the style attribute of a font element.
There are four legal attribute values, and the default value is plain.
The second specification expresses that the unit attribute of the size element can contain any character data sequence.
We generally recommend the use of elements, not attributes, to describe data.
However, attributes have an undeniable advantage for enumerated types because the parser can verify that the values are legal.
For example, if the font style is an attribute, the parser checks that it is one of the four allowed values, and supplies a default if no value was given.
An NMTOKEN (or name token) is similar to CDATA, but most nonalphanumeric characters and internal whitespace are disallowed, and the parser removes leading and trailing whitespace.
An ID is a name token that must be unique in the document—the parser checks the uniqueness.
You will see an application in the next sample program.
An IDREF is a reference to an ID that exists in the same document, which the parser also checks.
An ENTITY attribute value refers to an “unparsed external entity.” That is a holdover from SGML that is rarely used in practice.
A DTD can also define entities, or abbreviations that are replaced during parsing.
You can find a good example for the use of entities in the user interface descriptions for the Mozilla/Netscape 6 browser.
Those descriptions are formatted in XML and contain entity definitions such as.
The parser replaces the entity reference with the replacement string.
To internationalize the application, only the string in the entity definition needs to be changed.
Other uses of entities are more complex and less commonly used; look at the XML specification for details.
Now that you have seen how to use DTDs, you can configure your parser to take advantage of them.
First, tell the document builder factory to turn on validation:
All builders produced by this factory validate their input against a DTD.
The most useful benefit of validation is ignoring whitespace in element content.
A nonvalidating parser reports the whitespace between the font, name, and size elements because it has no way of knowing if the children of font are.
Once the DTD specifies that the children are (name,size), the parser knows that the whitespace between them is not text.
That means you can now rely on the fact that a font node has two children.
You no longer need to program a tedious loop: Click here to view code imageClick here to view code image.
Instead, you can simply access the first and second child:
You don’t overload your program with rule checking code—the parser has already done that work by the time you get the document.
Many programmers who start using XML are uncomfortable with validation and end up analyzing the DOM tree on the fly.
If you need to convince colleagues of the benefit of using validated documents, show them the two coding alternatives —it should win them over.
When the parser reports an error, your application will want to do something about it—log it, show it to the user, or throw an exception to abandon the parsing.
Therefore, you should install an error handler whenever you use validation.
The publicID parameter may be null if no public ID was supplied.
InputSource(String systemID) constructs an input source from a stream, reader, or system ID (usually a relative or absolute URL)
If set to true, the parsers that this factory generates validate their input.
If set to true, the parsers that this factory generates ignore whitespace between element nodes that don’t have mixed content (i.e., a mixture of elements and #PCDATA)
To reference a Schema file in a document, add attributes to the root element, for example: Click here to view code imageClick here to view code image.
This declaration states that the schema file config.xsd should be used to validate the document.
If your document uses namespaces, the syntax is a bit more complex—see the XML Schema tutorial for details.
The prefix xsi is a namespace alias; see Section 2.5, “Using Namespaces,” on p.
The type can be a simple type—a string with formatting restrictions—or a complex type.
We use the prefix xsd: to denote the XML Schema Definition namespace.
A FontType is a sequence of name, size, and style elements.
In this type definition, we use the ref attribute and refer to definitions that are located elsewhere in the schema.
You can also nest definitions, like this: Click here to view code imageClick here to view code image.
The xsd:sequence construct is the equivalent of the concatenation notation in DTDs.
The xsd:choice construct is the equivalent of the | operator.
To allow repeated elements, use the minoccurs and maxoccurs attributes.
For example, the equivalent of the DTD type item* is.
To specify attributes, add xsd:attribute elements to complexType definitions: Click here to view code imageClick here to view code image.
Enclose element and type definitions of your schema inside an xsd:schema element: Click here to view code imageClick here to view code image.
Parsing an XML file with a schema is similar to parsing a file with a DTD, but with three differences: 1.1
You need to turn on support for namespaces, even if you don’t use them in your XML files.
You need to prepare the factory for handling schemas, with the following magic incantation: Click here to view code imageClick here to view code image.
This is a definite annoyance, and there is disagreement whether or not it is an actual bug.
In this section, we work through a practical example that shows the use of XML in a realistic setting.
Recall from Volume I, Chapter 9 that the GridBagLayout is the most useful layout manager for Swing components.
However, it is feared not just for its complexity but also for the programming tedium.
It would be much more convenient to put the layout description into a text file instead of producing large amounts of repetitive code.
In this section, you will see how to use XML to describe a grid bag layout and how to parse the layout files.
A grid bag is made up of rows and columns, very similar to an HTML table.
Similar to an HTML table, we describe it as a sequence of rows, each of which contains cells:
Similarly, we can use attributes for the other grid bag constraints fill, anchor, gridx, gridy, weightx, weighty, ipadx, and ipady.
We don’t handle the insets constraint because its value is not a simple type, but it would be straightforward to support it.
For most of these attributes, we provide the same defaults as the no-argument constructor of the GridBagConstraints class: Click here to view code imageClick here to view code image.
The gridx and gridy values get special treatment because it would be tedious and somewhat error-prone to specify them by hand.
Otherwise, it is the preceding gridx plus the preceding gridwidth.
The default gridy is always the same as the row number.
Thus, you don’t have to specify gridx and gridy in the most common cases where a component spans multiple rows.
However, if a component spans multiple columns, you must specify gridx whenever you skip over that component.
Grid bag experts might wonder why we don’t use the RELATIVE and REMAINDER mechanism to let the grid bag layout automatically determine the gridx and gridy positions.
We tried, but no amount of fussing would produce the layout of the font dialog example of Figure 2.4
Reading through the GridBagLayout source code, it is apparent that the algorithm just won’t do the heavy lifting required to recover the absolute positions.
The program parses the attributes and sets the grid bag constraints.
For example, to read the grid width, the program contains a single statement:
The program need not worry about a missing attribute because the parser automatically supplies the default value if no other value was specified in the document.
To test whether a gridx or gridy attribute was specified, we call the getAttribute method and check if it returns the empty string: Click here to view code imageClick here to view code image.
We found it convenient to allow arbitrary objects inside cells.
We only require that the objects belong to a class that follows the JavaBeans convention to have a no-argument constructor and to have properties that are given by getter/setter pairs.
A bean is defined by a class name and zero or more properties:
It seems like a bother to surround a string with the <string> tag.
Why not just use #PCDATA for strings and leave the tags for the other types? Because then we would need to use mixed content and weaken the rule for the value element to.
However, that rule would allow an arbitrary mixture of text and tags.
The program sets a property by using the BeanInfo class.
We search for the property with the matching name, and then call its setter method with the supplied value.
When our program reads in a user interface description, it has enough information to construct and arrange the user interface components.
But, of course, the interface is not alive—no event listeners have been attached.
To add event listeners, we have to locate the components.
For that reason, we support an optional attribute of type ID for each bean:
In this example, we only use XML to describe the component layout and leave it to programmers to attach the event handlers in the Java code.
You could go a step further and add the code to the XML description.
The most promising approach is to use a scripting language such as JavaScript for the code.
The program in Listing 2.2 shows how to use the GridBagPane class to do all the boring work of setting up the grid bag layout.
The program only initializes the combo boxes (which are too complex for the bean property-setting mechanism that the GridBagPane sup-ports) and attaches event listeners.
The GridBagPane class in Listing 2.3 parses the XML file, constructs the components, and lays them out.
The program can also process a schema instead of a DTD if you choose a file that contains the string -schema.
The XML format is robust enough to express complex relationships.
The XML parser adds value by taking over the routine job of validity checking and supplying defaults.
If you want to locate a specific piece of information in an XML document, it can be a bit of a hassle to navigate the nodes of the DOM tree.
The XPath language makes it simple to access tree nodes.
That’s a lot simpler than the plain DOM approach: 1.1
An XPath can describe a set of nodes in an XML document.
You can select a particular element with the [] operator:
Java SE 5.0 added an API to evaluate XPath expressions.
First, create an XPath object from an XPathFactory: Click here to view code imageClick here to view code image.
You can use the same XPath object to evaluate multiple expressions.
This form of the evaluate method returns a string result.
It is suitable for retrieving text, such as the text of the username node in the preceding example.
If an XPath expression yields a node set, make a call such as the following:
You don’t have to start the search at the document root; you can start at any node or node list.
For example, if you have a node from a previous evaluation, you can call.
The program in Listing 2.7 demonstrates the evaluation of XPath expressions.
The result of the expression is displayed at the bottom of the frame (see Figure 2.5)
XPath newXpath() constructs an XPath object for evaluating XPath expressions.
String evaluate(String expression, Object startingPoint) evaluates an expression, beginning at the given starting point.
The starting point can be a node or node list.
If the result is a node or node set, the returned string consists of the data of all text node children.
Object evaluate(String expression, Object startingPoint, QName resultType) evaluates an expression, beginning at the given starting point.
The starting point can be a node or node list.
Programmers can use the same name for different classes as long as they aren’t in the same package.
A namespace is identified by a Uniform Resource Identifier (URI), such as.
Note that the URL is just used as an identifier string, not as a locator for a document.
There need not be any document at a namespace URL—the XML parser doesn’t attempt to find anything at that location.
However, as a help to programmers who encounter a possibly unfamiliar namespace, it is customary to place a document explaining the purpose of the namespace at the URL location.
For example, if you point your browser to the namespace URL for the XML Schema namespace (http://www.w3.org/2001/XMLSchema), you will find a document describing the XML Schema standard.
Why use HTTP URLs for namespace identifiers? It is easy to ensure that they are unique.
If you choose a real URL, the host part’s uniqueness is guaranteed by the domain name system.
Your organization can then arrange for the uniqueness of the remainder of the URL.
This is the same rationale that underlies the use of reversed domain names in Java package names.
Of course, although long namespace identifiers are good for uniqueness, you don’t want to deal with long identifiers any more than you have to.
In the Java programming language, you use the import mechanism to specify the long names of packages, and then use just the short class names.
The element and its children are now part of the given namespace.
Then the first child and the grandchildren are part of the second namespace.
This simple mechanism works well if you need only a single namespace or if the namespaces are naturally nested.
Otherwise, you will want to use a second mechanism that has no analog in Java.
You can have a prefix for a namespace—a short identifier that you choose for a particular document.
Here is a typical example—the xsd prefix in an XML Schema file: Click here to view code imageClick here to view code image.
Attributes without an explicit prefix are never part of a namespace.
In this example, the elements configuration and size are part of the namespace with URI http://www.horstmann.com/corejava.
However, the attribute value is not part of any namespace.
The qualified name, with a prefix, returned by getNodeName, getTagName, and so on.
The local name, without a prefix or a namespace, returned by the getLocalName method.
If namespace awareness is turned off, getNamespaceURI and getLocalName return null.
String getLocalName() returns the local name (without prefix), or null if the parser is not namespace-aware.
String getNamespaceURI() returns the namespace URI, or null if the node is not part of a namespace or if the parser is not namespace-aware.
If set to true, the parsers that this factory generates are namespace-aware.
The DOM parser reads an XML document in its entirety into a tree data structure.
However, it can be inefficient if the document is large and if your processing algorithm is simple enough that you can analyze nodes on the fly, without having to see all of the tree structure.
The SAX parser uses event callbacks, and the StAX parser provides an iterator through the parsing events.
The SAX parser reports events as it parses the components of the XML input, but it does not store the document in any way—it is up to the event handlers to build a data structure.
In fact, the DOM parser is built on top of the SAX parser.
It builds the DOM tree as it receives the parser events.
Whenever you use a SAX parser, you need a handler that defines the event actions for the various parse events.
The ContentHandler interface defines several callback methods that the parser executes as it parses the document.
Your handler needs to override these methods and have them carry out whatever action you want to carry out as you parse the file.
It simply overrides the startElement method of the handler to check for links with name a and an attribute with name href.
This is potentially useful for implementing a “web crawler”—a program that reaches more and more web pages by following links.
However, most pages authored by the W3C are written in XHTML (an HTML dialect that is proper XML)
You can use those pages to test the example program.
The sample program is a good example for the use of SAX.
We don’t care at all in which context the a elements occur, and there is no need to store a tree structure.
Here is how you get a SAX parser: Click here to view code imageClick here to view code image.
Here, source can be a file, URL string, or input stream.
The DefaultHandler class defines do-nothing methods for the four interfaces:
The example program defines a handler that overrides the startElement method of the ContentHandler interface to watch out for a elements with an href attribute: Click here to view code imageClick here to view code image.
The startElement method has three parameters that describe the element name.
The qname parameter reports the qualified name of the form prefix:localname.
If namespace processing is turned on, then the namespaceURI and lname parameters provide the namespace and local (unqualified) name.
As with the DOM parser, namespace processing is turned off by default.
To activate namespace processing, call the setNamespaceAware method of the factory class: Click here to view code imageClick here to view code image.
An XHTML file starts with a tag that contains a DTD reference, and the parser will want to load it.
At one point, they refused altogether, but at the time of this writing, they serve the DTD at a glacial pace.
If you don’t need to validate the document, just call.
Listing 2.8 contains the code for the web crawler program.
Later in this chapter, you will see another interesting use of SAX.
An easy way of turning a non-XML data source into XML is to report the SAX events that an XML parser would report.
If set to true, the parsers that this factory generates are namespace-aware.
If set to true, the parsers that this factory generates validate their input.
String getLocalName(int index) returns the local name (without prefix) of the attribute with the given index, or the empty string if the parser is not namespace-aware.
String getURI(int index) returns the namespace URI of the attribute with the given index, or the empty string if the node is not part of a namespace or if the parser is not namespace-aware.
String getQName(int index) returns the qualified name (with prefix) of the attribute with the given index, or the empty string if the qualified name is not reported by the parser.
String getValue(String uri, String lname) returns the attribute value from a given index, qualified name, or namespace URI + local name.
The StAX parser is a “pull parser.” Instead of installing an event handler, you simply iterate through the events, using this basic loop: Click here to view code imageClick here to view code image.
You can deactivate it by modifying the factory: Click here to view code imageClick here to view code image.
Listing 2.9 contains the code for the web crawler program implemented with the StAX parser.
As you can see, the code is simpler than the equivalent SAX code because you don’t have to worry about event handling.
String getText() returns the characters of a CHARACTERS, COMMENT, or CDATA event, the replacement value for an ENTITY_REFERENCE, or the internal subset of a DTD.
You now know how to write Java programs that read XML.
Let us now turn to the opposite process: producing XML output.
Of course, you could write an XML file simply by making a sequence of print calls, printing the elements, attributes, and text content, but that would not be a good idea.
A better approach is to build up a DOM tree with the contents of the document and then write out the tree contents.
To build a DOM tree, you start out with an empty document.
You can get an empty document by calling the newDocument method of the DocumentBuilder class:
Use the createElement method of the Document class to construct the elements of your document: Click here to view code imageClick here to view code image.
As you build up the DOM tree, you may also need to set element attributes.
If you use namespaces, the procedure for creating a document is slightly different.
First, set the builder factory to be namespace-aware, then create the builder: Click here to view code imageClick here to view code image.
Then use createElementNS instead of createElement to create any nodes: Click here to view code imageClick here to view code image.
If your node has a qualified name, with a namespace prefix, then any necessary xmlns-prefixed attributes are created automatically.
For example, if you need SVG inside XHTML, you can construct an element like this:
If you need to set element attributes whose names are in a namespace, use the setAttributeNS method of the Element class:
Somewhat curiously, it is not so easy to write a DOM tree to an output stream.
For more information about XSLT, turn to Section 2.8, “XSL Transformations,” on p.
Right now, consider the code that follows a magic incantation to produce XML output.
We apply the do-nothing transformation to the document and capture its output.
To include a DOCTYPE node in the output, we also need to set the SYSTEM and PUBLIC identifiers as output properties.
Click here to view code imageClick here to view code image.
To get an instance, you have to use the following magic incantation: Click here to view code imageClick here to view code image.
The program draws a modernist painting—a random set of colored rectangles (see Figure 2.6)
To save a masterpiece, we use the Scalable Vector Graphics (SVG) format.
We don’t need to go into details about SVG; for our purposes, we just need to know how to express a set of colored rectangles.
Here is a sample: Click here to view code imageClick here to view code image.
As you can see, each rectangle is described as a rect node.
Apparently, the designers of this data format didn’t have much confidence in using XML for structured data.
In your own XML formats, you might want to use elements instead of complex attributes.
Node appendChild(Node child) appends a node to the list of children of this node.
Transformer newTransformer() returns an instance of the Transformer class that carries out an identity (do-nothing) transformation.
In the preceding section, you saw how to produce an XML document by writing a DOM tree.
If you have no other use for the DOM tree, that approach is not very efficient.
The StAX API lets you write an XML tree directly.
Construct an XMLStreamWriter from an OutputStream: Click here to view code imageClick here to view code image.
As with the DOM/XSLT approach, you don’t have to worry about escaping characters in attribute values and character data.
However, it is possible to produce malformed XML, such as a document with multiple root nodes.
Also, the current version of StAX has no support for producing indented output.
The program in Listing 2.10 shows you both approaches for writing XML.
Note that the encoding parameter is only used to write the attribute.
It does not set the character encoding of the output.
The declaration is scoped to the current element or, if no element has been written, to the document root.
The XSL Transformations (XSLT) mechanism allows you to specify rules for transforming XML documents into other formats, such as plain text, XHTML, or any other XML format.
You need to provide an XSLT stylesheet that describes the conversion of XML documents into some other format.
An XSLT processor reads an XML document and the stylesheet and produces the desired output (see Figure 2.7)
We want to transform XML files with employee records into HTML documents.
Consider this input file: Click here to view code imageClick here to view code image.
The desired output is an HTML table: Click here to view code imageClick here to view code image.
The XSLT specification is quite complex, and entire books have been written on the subject.
We can’t possibly discuss all the features of XSLT, so we will just work through a representative example.
You can find more information in the book Essential XML by Don Box et al.
In our example, the xsl:output element specifies the method as HTML.
The value of the match attribute is an XPath expression.
The template states: Whenever you see a node in the XPath set /staff/employee, do the following:
Emit the string </tr> after you are done with all children.
In other words, this template generates the HTML table row markers around every employee record.
The XSLT processor starts processing by examining the root element.
Whenever a node matches one of the templates, it applies the template.
If no template matches, the processor carries out a default action.
For text nodes, the default is to include the contents in the output.
For elements, the default action is to create no output but to keep processing the children.
Here is a template for transforming name nodes in an employee file:
When the processor visits that node, it emits the text contents (provided, of course, that there is no other matching template)
You have to work a little harder if you want to copy attribute values into the output.
Here is an example: Click here to view code imageClick here to view code image.
The xsl:value-of statement computes the string value of a node set.
The node set is specified by the XPath value of the select attribute.
In this case, the path is relative to the currently processed node.
The node set is converted to a string by concatenation of the string values of all nodes.
The string value of an attribute node is its value.
The string value of a text node is its contents.
The string value of an element node is the concatenation of the string values of its child nodes (but not its attributes)
Listing 2.13 contains the stylesheet for turning an XML file with employee records into an HTML table.
The input is the same XML file, and the output is plain text in the familiar property file format:
That example uses the position() function which yields the position of the current node as seen from its parent.
We thus get an entirely different output simply by switching the stylesheet.
This means you can safely use XML to describe your data; if some applications need the data in another format, just use XSLT to generate the alternative format.
It is extremely simple to generate XSL transformations in the Java platform.
Then, get a transformer object and tell it to transform a source to a result: Click here to view code imageClick here to view code image.
The parameters of the transform method are objects of classes that implement the Source and Result interfaces.
You can construct a StreamSource from a file, stream, reader, or URL, and a DOMSource from the node of a DOM tree.
For example, in the preceding section, we invoked the identity transformation as.
In our example program, we do something slightly more interesting.
Instead of starting out with an existing XML file, we produce a SAX XML reader that gives the illusion of parsing an XML file by emitting appropriate SAX events.
Our XML reader generates SAX events as it processes the input.
Here is a part of the parse method of the EmployeeReader class that implements the XMLReader interface: Click here to view code imageClick here to view code image.
The SAXSource for the transformer is constructed from the XML reader: Click here to view code imageClick here to view code image.
This is an ingenious trick to convert non-XML legacy data into XML.
Of course, most XSLT applications will already have XML input data, and you can simply invoke the transform method on a StreamSource:
The transformation result is an object of a class that implements the Result interface.
This example concludes our discussion of XML support in the Java library.
You should now have a good perspective on the major strengths of XML—in particular, for automated parsing and validation and as a powerful transformation mechanism.
Of course, all this technology is only going to work for you if you design your XML formats well.
You need to make sure that the formats are rich enough to express all your business needs, that they are stable over time, and that your business partners are willing to accept your XML documents.
Those issues can be far more challenging than dealing with parsers, DTDs, or transformations.
In the next chapter, we will discuss network programming on the Java platform, starting with the basics of network sockets and moving on to higher level protocols for e-mail and the World Wide Web.
We begin this chapter by reviewing basic networking concepts, then move on to writing Java programs that connect to network services.
We will show you how network clients and servers are implemented.
Finally, you will see how to send e-mail from a Java program and how to harvest information from a web server.
Before writing our first network program, let’s discuss a great debugging tool for network programming that you already have —namely, telnet.
You should be able to launch it by typing telnet from a command shell.
In Windows Vista, telnet is installed but deactivated by default.
To activate it, go to the Control Panel, select Programs, click “Turn Windows Features On or Off”, and select the “Telnet client” checkbox.
The Windows firewall also blocks quite a few network ports that we use in this chapter; you might need an administrator account to unblock them.
You may have used telnet to connect to a remote computer, but you can use it to communicate with other services provided by Internet hosts as well.
Output of the “time of day” service What is going on? You have connected to the “time of day” service that most UNIX machines constantly run.
The particular server that you connected to is operated by the National Institute of Standards and Technology in Boulder, Colorado, and gives the measurement of a Cesium atomic clock.
Of course, the reported time is not completely accurate due to network delays.
In network parlance, a port is not a physical device, but an abstraction facilitating communication between a server and a client (see Figure 3.2)
When the operating system on the remote computer receives a network package that contains a request to connect to port number 13, it wakes up the listening server process and establishes the connection.
The connection stays up until it is terminated by one of the parties.
Once the connection was established, the remote program sent back a line of data and closed the connection.
In general, of course, clients and servers engage in a more extensive dialog before one or the other closes the connection.
Here is another experiment along the same lines—but a bit more interesting.
Then type very carefully the following: GET / HTTP/1.1 Host: horstmann.com blank line.
That is, hit the Enter key twice at the end.
It should look eerily familiar—you got a page of HTML-formatted text, namely Cay Horstmann’s home page.
Using telnet to access an HTTP port This is exactly the same process that your web browser goes through to get a web page.
Of course, the browser displays the HTML code more nicely.
The Host key/value pair is required when you connect to a web server that hosts multiple domains with the same IP address.
You can omit it if the server hosts a single domain.
Our first network program in Listing 3.1 will do the same thing we did using telnet—connect to a port and print out what it finds.
The key statements of this simple program are as follows: Click here to view code imageClick here to view code image.
The first line opens a socket, which is a network software abstraction that enables communication out of and into this program.
We pass the remote address and the port number to the socket constructor.
Once you have grabbed the stream, this program simply prints each input line to standard output.
This process continues until the stream is finished and the server disconnects.
This program works only with very simple servers, such as a “time of day” service.
In more complex networking programs, the client sends request data to the server, and the server might not immediately disconnect at the end of a response.
You will see how to implement that behavior in several examples throughout this chapter.
The Socket class is pleasant and easy to use because the Java library hides the complexities of establishing a networking connection and sending data across it.
The java.net package essentially gives you the same programming interface you would use to work with a file.
In this book, we cover only the Transmission Control Protocol (TCP).The Java platform also supports the User Datagram Protocol (UDP), which can be used to send packets (also called datagrams) with much less overhead than that of TCP.
The drawback is that packets need not be delivered in sequential order to the receiving application and can even be dropped altogether.
It is up to the recipient to put the packets in order and to request retransmission of missing packets.
Socket(String host, int port) constructs a socket to connect to the given host and port.
OutputStream getOutputStream() gets the stream to read data from the socket or write data to the socket.
If the host is unreachable, your application waits for a long time and you are at the mercy of the underlying operating system to eventually time out.
You can decide what timeout value is reasonable for your particular application.
Then, call the setSoTimeout method to set a timeout value (in milliseconds)
You can catch that exception and react to the timeout.
Click here to view code imageClick here to view code image.
There is one additional timeout issue that you need to address.
You can overcome this problem by first constructing an unconnected socket and then connecting it with a timeout: Click here to view code imageClick here to view code image.
Socket() 1.11.1 creates a socket that has not yet been connected.
However, you can use the InetAddress class if you need to convert between host names and Internet addresses.
The java.net package supports IPv6 Internet addresses, provided the host operating system does.
The static getByName method returns an InetAddress object of a host.
Some host names with a lot of traffic correspond to multiple Internet addresses, to facilitate load balancing.
For example, at the time of this writing, the host name google.com corresponds to twelve different Internet addresses.
One of them is picked at random when the host is accessed.
Finally, you sometimes need the address of the local host.
If you simply ask for the address of localhost, you always get the local loopback address 127.0.0.1, which cannot be used by others to connect to your computer.
Instead, use the static getLocalHost method to get the address of your local host.
Listing 3.2 is a simple program that prints the Internet address of your local host if you do not specify any command-line parameters, or all Internet addresses of another host if you specify the host name on the command line, such as.
Now that we have implemented a basic network client that receives data from the Internet, let’s program a simple server that can send information to clients.
Once you start the server program, it waits for a client to attach to its port.
We chose port number 8189, which is not used by any of the standard services.
Once someone connects to this port by sending the correct request over the network, this method returns a Socket object that represents the connection that was made.
You can use this object to get input and output streams, as is shown in the following code: Click here to view code imageClick here to view code image.
Everything that the server sends to the server output stream becomes the input of the client program, and all the output from the client program ends up in the server input stream.
In all the examples in this chapter, we transmit text through sockets.
Click here to view code imageClick here to view code image.
When you use telnet to connect to this server program at port 8189, you will see the preceding greeting on the terminal screen.
In this simple server, we just read the client input, a line at a time, and echo it.
An actual server would obviously compute and return an answer depending on the input.
Every server program, such as an HTTP web server, continues performing this loop: 1.1
It receives a command from the client (“get me this information”) through an incoming data stream.
It sends the information to the client through the outgoing data stream.
If you are connected directly to the Internet, anyone in the world can access your echo server, provided they know your IP address and the magic port number.
When you connect to the port, you will see the message shown in Figure 3.4:
Accessing an echo server Type anything and watch the input echo on your screen.
ServerSocket(int port) creates a server socket that monitors a port.
This method blocks (i.e., idles) the current thread until the connection is made.
The method returns a Socket object through which the program can communicate with the connecting client.
There is one problem with the simple server in the preceding example.
Suppose we want to allow multiple clients to connect to our server at the same time.
Typically, a server runs constantly on a server computer, and clients from all over the Internet might want to use it at the same time.
Rejecting multiple connections allows any one client to monopolize the service by connecting to it for a long time.
We can do much better through the magic of threads.
Every time we know the program has established a new socket connection—that is, every time the call to accept() returns a socket—we will launch a new thread to take care of the connection between the server and that client.
The main program will just go back and wait for the next connection.
For this to happen, the main loop of the server should look like this: Click here to view code imageClick here to view code image.
Click here to view code imageClick here to view code image.
When each connection starts a new thread, multiple clients can connect to the server at the same time.
Open several telnet windows as we have in Figure 3.5
Note that you can communicate through all of them simultaneously.
When you are done, switch to the window from which you launched the server program and use Ctrl+C to kill it.
In this program, we spawn a separate thread for each connection.
You can achieve greater server throughput by using features of the java.nio package.
The half-close provides the ability for one end of a socket connection to terminate its output while still receiving data from the other end.
Suppose you transmit data to the server but you don’t know at the outset how much data you have.
With a file, you’d just close the file at the end of the data.
However, if you close a socket, you immediately disconnect from the server and cannot read the response.
You can close the output stream of a socket, thereby indicating to the server the end of the requested data, but keep the input stream open.
The client side looks like this: Click here to view code imageClick here to view code image.
The server side simply reads input until the end of the input stream is reached.
Of course, this protocol is only useful for one-shot services such as HTTP where the client connects, issues a request, catches the response, and then disconnects.
When you connect to a socket, the current thread blocks until the connection has been established or a timeout has elapsed.
Similarly, when you read or write data through a socket, the current thread blocks until the operation is successful or has timed out.
In interactive applications, you would like to give users an option to simply cancel a socket connection that does not appear to produce results.
However, if a thread blocks on an unresponsive socket, you cannot unblock it by calling interrupt.
To interrupt a socket operation, use a SocketChannel, a feature of the java.nio package.
Instead, it has read and write methods that make use of Buffer objects.
Whenever a thread is interrupted during an open, read, or write operation, the operation does not block, but is terminated with an exception.
The program in Listing 3.5 contrasts interruptible and blocking sockets.
A server sends numbers and pretends to be stuck after the tenth number.
Click on either button, and a thread is started that connects to the server and prints the output.
The first thread uses an interruptible socket; the second thread uses a blocking socket.
If you click the Cancel button within the first ten numbers, you can interrupt either thread.
However, after the first ten numbers, you can only interrupt the first thread.
If the host name cannot be resolved, the address object’s unresolved property is set to true.
To access web servers in a Java program, you will want to work at a higher level than making a socket connection and issuing.
In the following sections, we discuss the classes that the Java library provides for this purpose.
The URL and URLConnection classes encapsulate much of the complexity of retrieving information from a remote site.
The java.net package makes a useful distinction between URLs (uniform resource locators) and URIs (uniform resource identifiers)
A URI is a purely syntactical construct that contains the various parts of the string specifying a web resource.
A URL is a special kind of URI, namely, one with sufficient information to locate a resource.
Such a URI is called a URN (uniform resource name)
In the Java library, the URI class has no methods for accessing the resource that the identifier specifies—its sole purpose is parsing.
In contrast, the URL class can open a stream to the resource.
For that reason, the URL class only works with schemes that the Java library knows how to handle, such as http:, https:, ftp:, the local file system (file:), and JAR files (jar:)
To see why parsing is not trivial, consider how complex URIs can be.
For example, Click here to view code imageClick here to view code image.
The URI specification gives the rules for the makeup of these identifiers.
If the scheme: part is present, the URI is called absolute.
An absolute URI is opaque if the schemeSpecificPart does not begin with a / such as.
All absolute nonopaque URIs and all relative URIs are hierarchical.
One of the purposes of the URI class is to parse an identifier and break it up into its components.
The other purpose of the URI class is the handling of absolute and relative identifiers.
If you want additional information about a web resource, then you should use the URLConnection class, which gives you much more control than the basic URL class.
When working with a URLConnection object, you must carefully schedule your steps:
We discuss these methods later in this section and in the API notes.
Connect to the remote resource by calling the connect method.
Besides making a socket connection to the server, this method also queries the server for header information.
After connecting to the server, you can query the header information.
Two methods, getHeaderFieldKey and getHeaderField, enumerate all fields of the header.
The method getHeaderFields gets a standard Map object containing the header fields.
For your convenience, the following methods query standard fields: getContentType getContentLength getContentEncoding getDate getExpiration getLastModified.
Use the getInputStream method to obtain an input stream for reading the information.
This is the same input stream that the openStream method of the URL class returns.
The objects that are returned by standard content types such as text/plain and image/gif require classes in the com.sun hierarchy for processing.
You could register your own content handlers, but we do not discuss that technique in this book.
Some programmers form the wrong mental image when using the URLConnection class, thinking that the getInputStream and getOutputStream methods are similar to those of the Socket class.
The URLConnection class does quite a bit of magic behind the scenes, in particular, the handling of request and response headers.
For that reason, it is important that you follow the setup steps for the connection.
Let us now look at some of the URLConnection methods in detail.
Several methods set properties of the connection before connecting to the server.
By default, the connection yields an input stream for reading from the server but no output stream for writing.
If you want an output stream (for example, for posting data to a web server), you need to call.
Next, you may want to set some of the request headers.
The request headers are sent together with the request command to the server.
Here is an example: Click here to view code imageClick here to view code image.
The setIfModifiedSince method tells the connection that you are only interested in data that have been modified since a certain date.
The setUseCaches method directs the browser to first check the browser cache.
A network password dialog box Finally, you can use the catch-all setRequestProperty method to set any name/value pair that is meaningful for the particular protocol.
Some of these parameters are not welldocumented and are passed around by word of mouth from one programmer to the next.
For example, if you want to access a password-protected web page, you must do the following:
You just saw how to access a password-protected web page.
To access a password-protected file by FTP, use an entirely different method: Simply construct a URL of the form.
Once you call the connect method, you can query the response header information.
First, let’s see how to enumerate all response header fields.
The implementors of this class felt a need to express their individuality by introducing yet another iteration protocol.
There is no method to return the number of fields; you simply keep calling getHeaderFieldKey.
The method getHeaderFields returns a Map of response header fields.
As a convenience, six methods query the values of the most common header types and convert them to numeric types when appropriate.
The program in Listing 3.6 lets you experiment with URL connections.
Supply a URL and an optional user name and password on the command line when running the program, for example:
The return values of the six convenience methods in Table 3.1
The program is straightforward, except for the computation of the Base64 encoding.
However, we supplied our own class because we do not like to rely on undocumented classes.
InputStream openStream() opens an input stream for reading the resource data.
Note that the URLConnection itself does not maintain such a cache.
The cache must be supplied by an external program such as a browser.
Note that the URLConnection itself has no facilities for executing such a query.
The query must be carried out by an external program such as a browser or browser plug-in.
All values for the same key are placed in a list.
All values for the same key are placed in a list.
String getContentType() gets the content type, such as text/plain or image/gif.
This value is not commonly used, because the default identity encoding is not supposed to be specified with a Content-Encoding header.
OutputStream getOutputStream() returns a stream for reading from the resource or writing to the resource.
Object getContent() selects the appropriate content handler to read the resource data and convert it into an object.
This method is not useful for reading standard types such as text/plain or image/gif unless you install your own content handler.
In the preceding section, you saw how to read data from a web server.
Now we will show you how your programs can send data.
To send information from a web browser to the web server, a user fills out a form, like the one in Figure 3.8
An HTML form When the user clicks the Submit button, the text in the text fields and the settings of the checkboxes and radio buttons are sent back to the web server.
The web server invokes a program that processes the user input.
For simplicity, we use the generic term script for a server-side program, no matter what technology is used.
The server-side script processes the form data and produces another HTML page that the web server sends back to the browser.
The response page can contain new information (for example, in an informationsearch program) or just an acknowledgment.
Data flow during execution of a server-side script We do not discuss the implementation of server-side scripts in this book.
Our interest is merely in writing client programs that interact with existing server-side scripts.
When form data are sent to a web server, it does not matter whether the data are interpreted by a servlet, a CGI script, or some other server-side technology.
The client sends the data to the web server in a standard format, and the web server takes care of passing it on to the program that generates the response.
Two commands, called GET and POST, are commonly used to send information to a web server.
In the GET command, you simply attach parameters to the end of the URL.
Parameter values are encoded using the URL encoding scheme, following these rules:
Encode all other characters into UTF-8 and encode each byte by a %, followed by a two-digit hexadecimal number.
This encoding keeps any intermediate programs from messing with spaces and interpreting other special characters.
For example, at the time of this writing the Yahoo! web site has a script, py/maps.py, at the host maps.yahoo.com.
The script requires two parameters with names addr and csz.
The GET command is simple, but it has a major limitation that makes it relatively unpopular: Most browsers have a limit on the number of characters that you can include in a GET request.
In the POST command, you do not attach parameters to a URL.
Instead, you get an output stream from the URLConnection and write name/value pairs to the output stream.
You still have to URL-encode the values and separate them with & characters.
To post data to a script, first establish a URLConnection:
Next, call getOutputStream to get a stream through which you can send data to the server.
If you are sending text to the server, it is convenient to wrap that stream into a PrintWriter.
Now you are ready to send data to the server: Click here to view code imageClick here to view code image.
If you look at the HTML source, you will see the following HTML tag:
When you look inside the JavaScript code of the checksubmit function, you will see that the CSV download causes the following:
This tells us the name of the script that processes the POST action.
Next, you need to find out the field names that the script expects.
This tells you that the name of the field is Variable.
If you specify the table type "12;", you will get a table of the total population estimates.
There are several other fields that need to be set.
The script sends back the following reply: Click here to view code imageClick here to view code image.
As you can see, this particular script sends back a comma-separated data file.
That is the reason we picked it as an example —it is easy to see what happens with this script, whereas the complex sets of HTML tags that other scripts produce might be confusing to decipher.
The program in Listing 3.7 sends POST data to any script.
Place the data into a .properties file such as the following: Click here to view code imageClick here to view code image.
The program removes the url entry and sends all others to the doPost method.
In the doPost method, we first open the connection, call setDoOutput(true), and open the output stream.
For each of them, we send the key, = character, value, and & separator character:
However, the server still sends an error page back to the browser (such as the ubiquitous “Error 404 — page not found”)
To capture this error page, cast the URLConnection object to the HttpURLConnection class and call its getErrorStream method:
More for curiosity’s sake than for practical use, you might like to know exactly what information the URLConnection sends to the server in addition to the data that you supply.
The URLConnection object first sends a request header to the server.
The end of the header is indicated by a blank line.
The web server strips off the header and routes the data portion to the server-side script.
Note that the URLConnection object buffers all data that you send to the output stream because it must first determine the total content length.
The technique that this program displays is useful whenever you need to query information from an existing web site.
Simply find out the parameters that you need to send (usually by inspecting the HTML source of a web page that carries out the same query), and then strip out the HTML tags and other unnecessary information from the reply.
InputStream getErrorStream() returns a stream from which you can read web server error messages.
Space is encoded into '+', and all other characters are encoded into sequences of encoded bytes of the form "%XY", where 0xXY is the hexadecimal value of the byte.
In the past, it was simple to write a program that sends e-mail by making a socket connection to port 25, the SMTP port.
Once you are connected to the server, send a mail header (in the SMTP format, which is easy to generate), followed by the mail message.
Click here to view code imageClick here to view code image.
Send the following information to the print stream: HELO sending host MAIL FROM: sender e-mail address RCPT TO: recipient e-mail address DATA Subject: subject (blank line) mail message (any number of lines)
It used to be that SMTP servers were routinely willing to route e-mail from anyone.
However, in these days of spam floods, most servers have built-in checks and only accept requests from users or IP address ranges that they trust.
Instead, we will show you how to use the JavaMail API to send e-mail from a Java program.
To use JavaMail, you need to set up some properties that depend on your mail server.
For security reasons, we don’t put the password into the property file but instead prompt for it.
Read in the property file, then get a mail session like this:
Make a message with the desired sender, recipient, subject, and message text: Click here to view code imageClick here to view code image.
Then send it off: Click here to view code imageClick here to view code image.
The program in Listing 3.8 reads the message from a text file of the format Sender Recipient Subject Message text (any number of lines)
Here, mail.jar is the JAR file that came with the JavaMail distribution.
Windows users: Remember to type a semicolon instead of a colon in the classpath.
At the time of this writing, GMail does not check the veracity of the information—you can supply any sender you like.
In this chapter, you have seen how to write network clients and servers in Java and how to harvest information from web servers.
You will learn how to work with relational databases in Java, using the JDBC API.
The chapter also has a brief introduction to hierarchical databases (such as LDAP directories) and the JNDI API.
In 1996, Sun released the first version of the JDBC API.
This API lets programmers connect to a database to query or update it using the Structured Query Language (SQL)
SQL, usually pronounced “sequel,” is an industry standard for relational database access.
In this chapter, we will explain the key ideas behind JDBC.
We will introduce you to (or refresh your memory of) SQL, the industry-standard Structured Query Language for relational databases.
We will then provide enough details and examples to let you start using JDBC for common programming situations.
According to Oracle, JDBC is a trademarked term and not an acronym for Java Database Connectivity.
It was named to be reminiscent of ODBC, a standard database API pioneered by Microsoft and since incorporated into the SQL standard.
From the start, the developers of the Java technology were aware of the potential that Java showed for working with databases.
In 1995, they began working on extending the standard Java library to deal with SQL access to databases.
What they first hoped to do was to extend Java so that a program could talk to any random database using only “pure” Java.
It didn’t take them long to realize that this is an impossible task: There are simply too many databases out there, using too many protocols.
Moreover, although database vendors were all in favor of Java providing a standard network protocol for database access, they were only in favor of it if Java used their network protocol.
What all the database vendors and tool vendors did agree on was that it would be useful for Java to provide a pure Java API for SQL access along with a driver manager to allow third-party drivers to connect to specific databases.
Database vendors could provide their own drivers to plug in to the driver manager.
There would then be a simple mechanism for registering third-party drivers with the driver manager.
This organization follows the very successful model of Microsoft’s ODBC which provided a C programming language interface for database access.
Both JDBC and ODBC are based on the same idea: Programs written according to the API talk to the driver manager, which, in turn, uses a driver to talk to the actual database.
This means the JDBC API is all that most programmers will ever have to deal with.
A type 1 driver translates JDBC to ODBC and relies on an ODBC driver to communicate with the database.
Early versions of Java included one such driver, the JDBC/ODBC bridge.
However, the bridge requires deployment and proper configuration of an ODBC driver.
When JDBC was first released, the bridge was handy for testing, but it was never intended for production use.
At this point, many better drivers are available, and we advise against using the JDBC/ODBC bridge.
A type 2 driver is written partly in Java and partly in native code; it communicates with the client API of a database.
When using such a driver, you must install some platform-specific code onto the client in addition to a Java library.
This simplifies deployment because the platform-specific code is located only on the server.
A type 4 driver is a pure Java library that translates JDBC requests directly to a database-specific protocol.
Furthermore, a number of third-party companies specialize in producing drivers with better standards conformance, support for more platforms, better performance, or, in some cases, simply better reliability than the drivers provided by the database vendors.
In summary, the ultimate goal of JDBC is to make possible the following:
Programmers can write applications in the Java programming language to access any database, using standard SQL statements (or even specialized extensions of SQL) while still following Java language conventions.
Database vendors and database tool vendors can supply the low-level drivers.
Thus, they can optimize their drivers for their specific products.
If you are curious as to why Java just didn’t adopt the ODBC model, the reason, as given at the JavaOne conference in 1996, was this:
The preferred style in the Java programming language is to have simple and intuitive methods, but to have lots of them.
An ODBC-based solution is inherently less safe and harder to deploy than a pure Java solution.
The traditional client/server model has a rich GUI on the client and a database on the server (see Figure 4.1)
In this model, a JDBC driver is deployed on the client.
A traditional client/server application However, the world is moving away from client/server and toward a three-tier model or even more advanced n-tier models.
In the three-tier model, the client does not make database calls.
Instead, it calls on a middleware layer on the server that in turn makes the database queries.
It separates visual presentation (on the client) from the business logic (in the middle tier) and the raw data (in the database)
Therefore, it becomes possible to access the same data and the same business rules from multiple clients, such as a Java application, an applet, or a web form.
Communication between the client and the middle tier can occur through HTTP (when you use a web browser as the client) or another mechanism such as remote method invocation (RMI, see Chapter 11)
In particular, the Java Enterprise Edition defines a structure for application servers that manage code modules called Enterprise JavaBeans, and provides valuable services such as load balancing, request caching, security, and object-relational mapping.
In that architecture, JDBC still plays an important role for issuing complex database queries.
You can use JDBC in applets and Web Start applications, but you probably don’t want to.
By default, the security manager permits a network connection only to the server from which the applet is downloaded.
That means the web server and the database server (or the relay component of a type 3 driver) must be on the same machine, which is not a typical setup.
You would need to use code signing to overcome this problem.
Desktop databases usually have a GUI that lets users manipulate the data directly, but server-based databases are accessed purely through SQL.
The JDBC package can be thought of as nothing more than an API for communicating SQL statements to databases.
If you have never seen SQL before, you might not find this material sufficient.
If so, turn to one of the many books on the topic; we recommend Learning SQL by Alan Beaulieu (O’Reilly, 2005) or the opinionated classic, A Guide to the SQL Standard, Fourth Edition, by C.
You can think of a database as a bunch of named tables with rows and columns.
Figure 4.4 shows the result of joining this table with the Publishers table.
The Books and the Publishers tables each contain an identifier for the publisher.
When we join both tables on the publisher code, we obtain a query result made up of values from the joined tables.
Each row in the result contains the information about a book, together with the publisher name and web page URL.
Note that the publisher names and URLs are duplicated across several rows because we have several rows with the same publisher.
Two tables joined together The benefit of joining tables is avoiding unnecessary duplication of data in the database tables.
For example, a naive database design might have had columns for the publisher name and URL right in the Books table.
But then the database itself, and not just the query result, would have many duplicates of these entries.
If a publisher’s web address changed, all entries would need to be updated.
In the relational model, we distribute data into multiple tables so that no information is ever unnecessarily duplicated.
For example, each publisher’s URL is contained only once in the publisher table.
If the information needs to be combined, the tables are joined.
In the figures, you can see a graphical tool to inspect and link the tables.
Many vendors have tools to express queries in a simple form by connecting column names and filling information into forms.
Such tools are often called query by example (QBE) tools.
In contrast, a query that uses SQL is written out in text, using SQL syntax, for example: Click here to view code imageClick here to view code image.
In the remainder of this section, you will learn how to write such queries.
If you are already familiar with SQL, just skip this section.
By convention, SQL keywords are written in capital letters, although this is not necessary.
You can simply select all rows in the Books table with the following query:
The FROM clause is required in every SQL SELECT statement.
It tells the database which tables to examine to find the data.
Some database vendors support the use of != for inequality testing.
This is not standard SQL, so we recommend against such use.
The WHERE clause can also use pattern matching by means of the LIKE operator.
The wildcard characters are not the usual * and ?, however.
Use a % for zero or more characters and an underscore for a single character.
Note that strings are enclosed in single quotes, not double quotes.
A single quote inside a string is represented by a pair of single quotes.
This query result has 20 rows, one for each book, because each book has one publisher in the Publisher table.
Whenever you have multiple tables in a query, the same column name can occur in two different places.
There is a column called Publisher_Id in both the Books and the Publishers tables.
You can use SQL to change the data inside a database as well.
For example, suppose you want to reduce by $5.00 the current price of all books that have “C++” in their title:
Moreover, SQL comes with built-in functions for taking averages, finding maximums and minimums in a column, and much more.
Typically, to insert values into a table, you can use the INSERT statement: Click here to view code imageClick here to view code image.
You need a separate INSERT statement for every row being inserted in the table.
Of course, before you can query, modify, and insert data, you must have a place to store data.
Use the CREATE TABLE statement to make a new table.
In this book, we do not discuss the additional clauses, such as keys and constraints, that you can use with the CREATE TABLE statement.
Of course, you need a database program for which a JDBC driver is available.
You must also create a database for your experimental use.
Create a new database, or have your database administrator create one with the appropriate permissions.
You need to be able to create, update, and drop tables in the database.
If you have never installed a client/server database before, you might find that setting up the database is somewhat complex and that diagnosing the cause for failure can be difficult.
It might be best to seek expert help if your setup is not working correctly.
If you use a JDK that doesn’t include it, download Apache Derby from http://db.apache.org/derby.
The version of Apache Derby that is included in the JDK is officially called JavaDB.
We don’t think that’s particularly helpful, and we will call it Derby in this chapter.
You need to gather a number of items before you can write your first database program.
When connecting to a database, you must use various database-specific parameters such as host names, port numbers, and database names.
The format for the other stuff parameter depends on the subprotocol used.
You will need to look up your vendor’s documentation for the specific format.
You need to obtain the JAR file in which the driver for your database is located.
With another database, you need to locate the appropriate driver.
Include the driver JAR file on the class path when running a program that accesses the database.
When you launch programs from the command line, simply use the command.
The database server needs to be started before you can connect to it.
Open a command shell and change to a directory that will hold the database files.
With some versions of the JDK, it is contained in the jdk /db/lib directory, with others in a separate JavaDB installation directory.
Note that each command must be terminated by a semicolon.
If you use another database, you need to consult the documentation to find out how to start and stop your database server, and how to connect to it and issue SQL commands.
Many JDBC JAR files (such as the Derby driver included with Java SE 7) automatically register the driver class.
In that case, you can skip the manual registration step that we describe in this section.
You can simply unzip your driver’s JAR file to check.
This registration mechanism uses a little-known part of the JAR specification; see http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider.
If your driver’s JAR file doesn’t support automatic registration, you need to find out the name of the JDBC driver classes used by your vendor.
There are two ways to register the driver with the DriverManager.
One way is to load the driver class in your Java program.
This statement causes the driver class to be loaded, thereby executing a static initializer that registers the driver.
You can specify the property with a command-line argument, such as.
In your Java program, you can open a database connection like this: Click here to view code imageClick here to view code image.
The driver manager iterates through the registered drivers to find a driver that can use the subprotocol specified in the database URL.
In the following sections, you will see how to use the Connection object to execute SQL statements.
To connect to the database, you will need to have a user name and password for your database.
By default, Derby lets you connect with any user name, and it does not check passwords.A separate set of tables is generated for each user.The default user name is app.
The test program in Listing 4.1 puts these steps to work.
If you use a different database, put your database-specific connection information into that file.
Here is an example for connecting to a PostgreSQL database:
The result of the SELECT statement is printed, and you should see an output of Hello, World!
Then the table is removed by executing the statement DROP TABLE Greetings.
To run this test, start your database, as described previously, and launch the program as java -classpath .:driverJAR test.TestDB.
As always, Windows users need to use ; instead of : to separate the path elements.
One way to debug JDBC-related problems is to enable JDBC tracing.
The trace output contains a detailed listing of the JDBC activity.
Click here to view code imageClick here to view code image.
To execute a SQL statement, you first create a Statement object.
Next, place the statement that you want to execute into a string, for example String command = "UPDATE Books" + " SET Price = Price - 5.00" + " WHERE Title NOT LIKE '%Introduction%'";
The executeUpdate method returns a count of the rows that were affected by the SQL statement, or zero for statements that do not return a row count.
For example, the call to executeUpdate in the preceding example returns the number of rows whose price was lowered by $5.00
The executeUpdate method can execute actions such as INSERT, UPDATE, and DELETE, as well as data definition statements such as CREATE TABLE and DROP TABLE.
However, you need to use the executeQuery method to execute SELECT queries.
There is also a catch-all execute statement to execute arbitrary SQL statements.
It’s commonly used only for queries that a user supplies interactively.
When you execute a query, you are interested in the result.
The executeQuery object returns an object of type ResultSet that you can use to walk through the result one row at a time.
Here, the iterator is initialized to a position before the first row.
You must call the next method once to move the iterator to the first row.
Also, there is no hasNext method; keep calling next until it returns false.
The order of the rows in a result set is completely arbitrary.
Unless you specifically ordered the result with an ORDER BY clause, you should not attach any significance to the row order.
When inspecting an individual row, you will want to know the contents of the fields.
A large number of accessor methods give you this information.
There are accessors for various types, such as getString and getDouble.
Each accessor has two forms: one that takes a numeric argument and one that takes a string argument.
When you supply a numeric argument, you refer to the column with that number.
For example, rs.getString(1) returns the value of the first column in the current row.
When you supply a string argument, you refer to the column in the result set with that name.
Using the numeric argument is a bit more efficient, but the string arguments make the code easier to read and maintain.
Each get method makes reasonable type conversions when the type of the method doesn’t match the type of the column.
Statement createStatement() creates a Statement object that can be used to execute SQL queries and updates without parameters.
Returns the number of rows affected, or 0 for a statement without an update count.
Returns true if the first result is a result set, false other-wise.
See Section 4.5.4, “Multiple Results,” for details on processing multiple results.
ResultSet getResultSet() returns the result set of the preceding query statement, or null if the preceding statement did not have a result set.
Note that you must call this method to advance to the first row.
The column label is the label specified in the SQL AS clause or the column name if AS is not used.
Every Connection object can create one or more Statement objects.
You can use the same Statement object for multiple, unrelated commands and queries.
However, a statement has at most one open result set.
If you issue multiple queries whose results you analyze concurrently, you need multiple Statement objects.
Be forewarned, though, that at least one commonly used database (Microsoft SQL Server) has a JDBC driver that allows only one active statement at a time.
Use the getMaxStatements method of the DatabaseMetaData interface to find out the number of concurrently open statements that your JDBC driver supports.
This sounds restrictive, but in practice, you should probably not fuss with multiple concurrent result sets.
If the result sets are related, you should be able to issue a combined query and analyze a single result.
It is much more efficient to let the database combine queries than it is for a Java program to iterate through multiple result sets.
When you are done using a ResultSet, Statement, or Connection, you should call the close method immediately.
These objects use large data structures and finite resources on the database server.
The close method of a Statement object automatically closes the associated result set if the statement has an open result set.
Similarly, the close method of the Connection class closes all statements of the connection.
Conversely, as of Java SE 7, you can call the closeOnCompletion method on a Statement, and it will close automatically as soon as all its result sets have closed.
If your connections are short-lived, you don’t have to worry about closing statements and result sets.
To make absolutely sure that a connection object cannot possibly remain open, use a try-with-resources statement:
Use the try-with-resources block just to close the connection, and use a separate try/catch block to handle exceptions.
Separating the try blocks makes your code easier to read and maintain.
Each SQLException has a chain of SQLException objects that are retrieved with the getNextException method.
This exception chain is in addition to the “cause” chain of Throwable objects that every exception has.
One would need two nested loops to fully enumerate all these exceptions.
You can call getSQLState and getErrorCode on an SQLException to analyze it further.
The first method yields a string that is standardized by either X/Open or SQL:2003
Call the getSQLStateType method of the DatabaseMetaData interface to find out which standard is used by your driver.
The SQL exceptions are organized into an inheritance tree (shown in Figure 4.5)
This allows you to catch specific error types in a vendor-independent way.
You can retrieve warnings from connections, statements, and result sets.
The SQLWarning class is a subclass of SQLException (even though a SQLWarning is not thrown as an exception)
Call getSQLState and getErrorCode to get further information about the warnings.
The DataTruncation subclass of SQLWarning is used when data are read from the database and unexpectedly truncated.
SQLException getNextException() gets the next SQL exception chained to this one, or null at the end of the chain.
String getSQLState() gets the “SQL state,” a standardized error code.
SQLWarning getNextWarning() returns the next warning chained to this one, or null at the end of the chain.
SQLWarning getWarnings() returns the first of the pending warnings, or null if no warnings are pending.
We now want to write our first real JDBC program.
Of course, it would be nice if we could execute some of the fancy queries that we discussed earlier.
Unfortunately, we have a problem: Right now, there are no data in the database.
We need to populate the database, and there is a simple way of doing that with a set of SQL instructions to create tables and insert data into them.
Most database programs can process a set of SQL instructions from a text file, but there are pesky differences about statement terminators and other syntactical issues.
For that reason, we will use JDBC to create a simple program that reads a file with SQL instructions, one instruction per line, and executes them.
Specifically, the program reads data from a text file in a format such as Click here to view code imageClick here to view code image.
Listing 4.2 contains the code for the program that reads the SQL statement file and executes the statements.
It is not important that you read through the code; we merely provide the program so that you can populate your database and run the examples in the remainder of this chapter.
Make sure that your database server is running, and run the program as follows: Click here to view code imageClick here to view code image.
Your database may also have a utility to read the SQL files directly.
The ij.properties file is described in Section 4.3.3, “Starting the Database,” on p.
In the data format for the ExecSQL command, we allow an optional semicolon at the end of each line because most database utilities expect this format.
The driver manager uses the jdbc.drivers property to load the appropriate database driver.
The getConnection method uses the jdbc.url, jdbc.username, and jdbc.password properties to open the database connection.
If no file name was supplied, prompt the user to enter the statements on the console.
If it returns true, the statement had a result set.
The four SQL files that we provide for the book database all end in a SELECT * statement so that you can see that the data were successfully inserted.
If there was a result set, print out the result.
Since this is a generic result set, we need to use metadata to find out how many columns the result has.
If there is any SQL exception, print the exception and any chained exceptions that may be contained in it.
In this section, we write a program that executes queries against the COREJAVA database.
For this program to work, you must have populated the COREJAVA database with tables, as described in the preceding section.
When querying the database, you can select the author and the publisher or leave either of them as Any.
All prices of that publisher are adjusted by the amount you entered, and the program displays how many rows were changed.
After a price change, you might want to run a query to verify the new prices.
In this program, we use one new feature, prepared statements.
Consider the query for all books by a particular publisher, independent of the author.
Instead of building a separate query statement every time the user launches such a query, we can prepare a query with a host variable and use it many times, each time filling in a different string for the variable.
Whenever the database executes a query, it first computes a strategy of how to do it efficiently.
By preparing the query and reusing it, you ensure that the planning step is done only once.
Each host variable in a prepared query is indicated with a ?
If there is more than one variable, you must keep track of the positions of the ? when setting the values.
For example, our prepared query becomes Click here to view code imageClick here to view code image.
Before executing the prepared statement, you must bind the host variables to actual values with a set method.
As with the get methods of the ResultSet inter-face, there are different set methods for the various types.
Here, we want to set a string to a publisher name.
The first argument is the position number of the host variable that we want to set.
The second argument is the value that we want to assign to the host variable.
If you reuse a prepared query that you have already executed, all host variables stay bound unless you change them with a set method or call the clearParameters method.
That means you only need to call a setXxx method on those host variables that change from one query to the next.
Once all variables have been bound to values, you can execute the prepared statement:
Building a query manually, by concatenating strings, is tedious and potentially dangerous.
You have to worry about special characters such as quotes, and, if your query involves user input, you have to guard against injection attacks.
Therefore, you should use prepared statements whenever your query involves variables.
The price update feature is implemented as an UPDATE statement.
Note that we call executeUpdate, not executeQuery, because the UPDATE statement does not return a result set.
The return value of executeUpdate is the count of changed rows.
A PreparedStatement object becomes invalid after the associated Connection object is closed.
If the same query is prepared twice, the database simply reuses the query strategy.
The following list briefly describes the structure of the example program.
The author and publisher array lists are populated by running two queries that return all author and publisher names in the database.
A book can have multiple authors, so the BooksAuthors table stores the correspondence between authors and books.
For example, the book with ISBN 0-201-96426-0 has two authors with codes DATE and DARW.
We can’t just use the position of the rows in the table.
There is no fixed row ordering in a relational table.
Thus, the query has to join the Books, BooksAuthors, and Authors tables to compare the author name with the one selected by the user.
Some Java programmers avoid complex SQL statements such as this one.
A surprisingly common, but very inefficient, workaround is to write lots of Java code that iterates through multiple result sets.
But the database is a lot better at executing query code than a Java program can be—that’s the core competency of a database.
A rule of thumb: If you can do it in SQL, don’t do it in Java.
Note that the WHERE clause of the UPDATE statement needs the publisher code and we know only the publisher name.
The string sql contains a SQL statement that can contain one or more parameter placeholders denoted by ? characters.
ResultSet executeQuery() executes a prepared SQL query and returns a ResultSet object.
Returns the number of rows affected, or 0 for DDL statements such as CREATE TABLE.
In addition to numbers, strings, and dates, many databases can store large objects (LOBs) such as images or other data.
In SQL, binary large objects are called BLOBs, and character large objects are called CLOBs.
To read a LOB, execute a SELECT statement and call the getBlob or getClob method on the ResultSet.
You will get an object of type Blob or Clob.
To get the binary data from a Blob, call the getBytes or getBinaryStream.
For example, if you have a table with book cover images, you can retrieve an image like this: Click here to view code imageClick here to view code image.
Similarly, if you retrieve a Clob object, you can get character data by calling the getSubString or getCharacterStream method.
To place a LOB into a database, call createBlob or createClob on your Connection object, get an output stream or writer to the LOB, write the data, and store the object in the database.
For example, here is how you store an image: Click here to view code imageClick here to view code image.
Clob getClob(String columnLabel) 1.21.2 gets the BLOB or CLOB at the given column.
String getSubString(long startPosition, long length) gets the characters in the given range from this BLOB.
The “escape” syntax supports features that are commonly supported by databases but use database-specific syntax variations.
It is the job of the JDBC driver to translate the escape syntax to the syntax of a particular database.
The driver will then translate it into the native format.
Use d, t, ts for DATE, TIME, or TIMESTAMP values:
A scalar function is a function that returns a single value.
Many functions are widely available in databases, but with varying names.
The JDBC specification provides standard names and translates them into the database-specific names.
To call a function, embed the standard function name and arguments like this:
You can find a complete list of supported function names in the JDBC specification.
A stored procedure is a procedure that executes in the database, written in a database-specific language.
You need not supply parentheses if the procedure has no parameters.
An outer join of two tables does not require that the rows of each table match according to the join condition.
You would need a RIGHT OUTER JOIN to include publishers without matching books, or a FULL OUTER JOIN to return both.
The escape syntax is needed because not all databases use a standard notation for these joins.
Finally, the _ and % characters have special meanings in a LIKE clause—to match a single character or a sequence of characters.
If you want to match all strings containing a _, use this construct:
It is possible for a query to return multiple results.
This can happen when executing a stored procedure, or with databases that also allow submission of multiple SELECT statements in a single query.
Repeatedly call the getMoreResults method to move on to the next result set.
Finish when there are no more result sets or update counts.
The execute and getMoreResults methods return true if the next item in the chain is a result set.
The getUpdateCount method returns -1 if the next item in the chain is not an update count.
The following loop traverses all results: Click here to view code imageClick here to view code image.
Returns true if the next result exists and is a result set.
Most databases support some mechanism for autonumbering rows in a database.
Although JDBC doesn’t offer a vendor-independent solution for generating keys, it does provide an efficient way of retrieving them.
When you insert a new row into a table and a key is automatically generated, you can retrieve it with the following code:
As you have seen, the next method of the ResultSet interface iterates over the rows in a result set.
That is certainly adequate for a program that needs to analyze the data.
You usually want the user to be able to move both forward and backward in the result set.
In a scrollable result, you can move forward and backward through a result set and even jump to any position.
Furthermore, once users see the contents of a result set displayed, they may be tempted to edit it.
In an updatable result set, you can programmatically update entries so that the database is automatically updated.
To obtain scrollable result sets from your queries, you must obtain a different Statement object with the method.
This assumes that the result set does not “sense” database changes that occurred after execution of the query.
For example, if you simply want to be able to scroll through a result set but don’t want to edit its data, use: Click here to view code imageClick here to view code image.
A scrollable result set has a cursor that indicates the current position.
Not all database drivers support scrollable or updatable result sets.
Even if a database supports all result set modes, a particular query might not be able to yield a result set with all the properties that you requested.
For example, the result set of a complex query might not be updatable.
In that case, the executeQuery method returns a ResultSet of lesser capabilities and adds an SQLWarning to the connection object.
Alternatively, you can use the getType and getConcurrency methods of the ResultSet interface to find out what mode a result set actually has.
If you do not check the result set capabilities and issue an unsupported operation, such as previous on a result set that is not scrollable, the operation will throw a SQLException.
The method returns true if the cursor is positioned on an actual row, or false if it is now positioned before the first row.
You can move the cursor backward or forward by a number of rows with the call.
If the return value is 0, the cursor is not currently on a row—it is either before the first row or after the last row.
The convenience methods first, last, beforeFirst, and afterLast move the cursor to the first, to the last, before the first, or after the last position.
Finally, the methods isFirst, isLast, isBeforeFirst, and isAfterLast test whether the cursor is at one of these special positions.
The hard work of caching the query data is carried out behind the scenes by the database driver.
If you want to edit the result set data and have the changes automatically reflected in the database, create an updatable result set.
Updatable result sets don’t have to be scrollable, but if you present data to a user for editing, you usually want to allow scrolling as well.
To obtain updatable result sets, create a statement as follows: Click here to view code imageClick here to view code image.
The result sets returned by a call to executeQuery are then updatable.
If your query is a join that involves multiple tables, the result might not be updatable.
However, if your query involves only a single table or if it joins multiple tables by their primary keys, you should expect the result set to be updatable.
Call the getConcurrency method of the ResultSet interface to find out for sure.
For example, suppose you want to raise the prices of some books, but you don’t have a simple criterion for issuing an UPDATE statement.
Then, you can iterate through all books and update prices, based on arbitrary conditions.
Click here to view code imageClick here to view code image.
There are updateXxx methods for all data types that correspond to SQL types, such as updateDouble, updateString, and so on; specify the name or the number of the column (as with the getXxx methods), then the new value for the field.
If you use the updateXxx method whose first parameter is the column number, be aware that this is the column number in the result set.
It could well be different from the column number in the database.
The updateXxx method changes only the row values, not the database.
When you are done with the field updates in a row, you must call the updateRow method.
That method sends all updates in the current row to the database.
If you move the cursor to another row without calling updateRow, this row’s updates are discarded from the row set and never communicated to the database.
You can also call the cancelRowUpdates method to cancel the updates to the current row.
The preceding example shows how to modify an existing row.
If you want to add a new row to the database, first use the moveToInsertRow method to move the cursor to a special position, called the insert row.
Then, build up a new row in the insert row position by issuing updateXxx instructions.
When you are done, call the insertRow method to deliver the new row to the database.
When you are done inserting, call moveToCurrentRow to move the cursor back to the position before the call to moveToInsertRow.
Note that you cannot influence where the new data is added in the result set or the database.
If you don’t specify a column value in the insert row, it is set to a SQL NULL.
However, if the column has a NOT NULL constraint, an exception is thrown and the row is not inserted.
The deleteRow method immediately removes the row from both the result set and the database.
The updateRow, insertRow, and deleteRow methods of the ResultSet interface give you the same power as executing UPDATE, INSERT, and DELETE SQL statements.
However, Java programmers might find it more natural to manipulate the database contents through result sets than by constructing SQL statements.
If you are not careful, you can write staggeringly inefficient code with updatable result sets.
It is much more efficient to execute an UPDATE statement than to make a query and iterate through the result, changing data along the way.
Updatable result sets make sense for interactive programs in which a user can make arbitrary changes, but for most programmatic changes, a SQL UPDATE is more appropriate.
Returns true if the cursor is positioned on a row, or false if the cursor is positioned before the first row.
Returns true if the cursor is positioned on a row.
Returns true if the cursor is positioned on a row.
Returns true if the cursor is positioned on a row.
The insert row is a special row for inserting new data with the updateXxx and insertRow methods.
Scrollable result sets are powerful, but they have a major drawback.
You need to keep the database connection open during the.
However, a user can walk away from the computer for a long time, leaving the connection occupied.
The RowSet interface extends the ResultSet interface, but row sets don’t have to be tied to a database connection.
Row sets are also suitable if you need to move a query result to a different tier of a complex application, or to another device such as a cell phone.
You would never want to move a result set—its data structures can be huge, and it is tethered to the database connection.
We will discuss cached row sets in the following section.
A WebRowSet is a cached row set that can be saved to an XML file.
The XML file can be moved to another tier of a web application where it is opened by another WebRowSet object.
The FilteredRowSet and JoinRowSet interfaces support lightweight operations on row sets that are equivalent to SQL SELECT and JOIN operations.
These operations are carried out on the data stored in row sets, without having to make a database connection.
As of Java 7, there is a standard way for obtaining a row set: Click here to view code imageClick here to view code image.
There are similar methods for obtaining the other row set types.
Before Java 7, there were vendor-specific methods for creating row sets.
In addition, the JDK supplies reference implementations in the package com.sun.rowset.
If you can’t use the RowSetProvider, you can instead use those classes:
A cached row set contains all data from a result set.
Since CachedRowSet is a subinter-face of the ResultSet interface, you can use a cached row set exactly as you would use a result set.
Cached row sets confer an important benefit: You can close the connection and still use the row set.
As you will see in our sample program in Listing 4.4, this greatly simplifies the implementation of interactive applications.
Each user command simply opens the database connection, issues a query, puts the result in a cached row set, and then closes the database connection.
It is even possible to modify the data in a cached row set.
Of course, the modifications are not immediately reflected in the database.
Instead, you need to make an explicit request to accept the accumulated changes.
The CachedRowSet then reconnects to the database and issues SQL statements to write the accumulated changes.
You can populate a CachedRowSet from a result set: Click here to view code imageClick here to view code image.
Click here to view code imageClick here to view code image.
This call establishes a database connection, issues the query, populates the row set, and disconnects.
If your query result is very large, you would not want to put it into the row set in its entirety.
After all, your users will probably only look at a few rows.
You can inspect and modify the row set with the same methods you use for result sets.
The second call works only if you configured the row set with the information required to connect to a database (such as URL, user name, and password)
Similarly, a row set that contains the result of a complex query will not be able to write its changes back to the database.
You should be safe if your row set contains data from a single table.
If you populated the row set from a result set, the row set does not know the name of the table to update.
You need to call setTableName to set the table name.
Another complexity arises if the data in the database have changed after you populated the row set.
This is clearly a sign of trouble that could lead to inconsistent data.
The reference implementation checks whether the original row set values (that is, the values before editing) are identical to the current values in the database.
For the driver manager to obtain a connection, the URL, user name, and password must be set.
Returns true if there is a next or previous page.
WebRowSet createWebRowSet() creates a row set of the specified type.
In the preceding sections, you saw how to populate, query, and update database tables.
However, JDBC can give you additional information about the structure of a database and its tables.
For example, you can get a list of the tables in a particular database or the column names and types of a table.
This information is not useful when you are implementing a business application with a predefined database.
After all, if you design the tables, you know their structure.
Structural information is, however, extremely useful for programmers who write tools that work with any database.
In SQL, data that describe the database or one of its parts are called metadata (to distinguish them from the actual data stored in the database)
You can get three kinds of metadata: about a database, about a result set, and about parameters of prepared statements.
To find out more about the database, request an object of type DatabaseMetaData from the database connection.
See the API note at the end of this section for other parameters to this method.
Each row in the result set contains information about a table in the database.
Databases are complex, and the SQL standard leaves plenty of room for variability.
Well over a hundred methods in the DatabaseMetaData interface can inquire about the database, including calls with such exotic names as.
Clearly, these are geared toward advanced users with special needs—in particular, those who need to write highly portable code that works with multiple databases.
A second metadata interface, ResultSetMetaData, reports information about a result set.
Whenever you have a result set from a query, you can inquire about the number of columns and each column’s name, type, and field width.
Here is a typical loop: Click here to view code imageClick here to view code image.
In this section, we will show you how to write such a simple tool.
The program in Listing 4.4 uses metadata to let you browse all tables in a database.
The program also illustrates the use of a cached row set.
The combo box on top displays all tables in the database.
Select one of them, and the center of the frame is filled with the field names of that table and the values of the first row, as shown in Figure 4.6
Click Next and Previous to scroll through the rows in the table.
You can also delete a row and edit the row values.
Click the Save button to save the changes to the database.
Many databases come with much more sophisticated tools for viewing and editing tables.
If your database doesn’t, check out iSQL-Viewer (http://isql.sourceforge.net) or SQuirreL (http://squirrel-sql.sourceforge.net)
These programs can view the tables in any JDBC database.
Our example program is not intended as a replacement for these tools, but it shows you how to implement a tool for working with arbitrary tables.
DatabaseMetaData getMetaData() returns the metadata for the connection as a DatabaseMetaData object.
ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String types[]) returns a description of all tables in a catalog that match the schema and table name patterns and the type criteria.
A schema describes a group of related tables and access permissions.
The catalog and schemaPattern parameters can be "" to retrieve those tables without a catalog or schema, or null to return tables regardless of catalog or schema.
The types array contains the names of the table types to include.
If types is null, tables of all types are returned.
The result set has five columns, all of which are of type String.
ResultSetMetaData getMetaData() returns the metadata associated with the current ResultSet columns.
String getColumnLabel(int column) returns the suggested title for the column.
String getColumnName(int column) returns the column name associated with the column index specified.
You can group a set of statements to form a transaction.
The transaction can be committed when all has gone well.
Or, if an error has occurred in one of them, it can be rolled back as if none of the statements had been issued.
The major reason for grouping statements into transactions is database integrity.
For example, suppose we want to transfer money from one bank account to another.
Then, it is important that we simultaneously debit one account and credit another.
If the system fails after debiting the first account but before crediting the other account, the debit needs to be undone.
If you group update statements into a transaction, the transaction either succeeds in its entirety and can be committed, or it fails somewhere in the middle.
In that case, you can carry out a rollback and the database automatically undoes the effect of all updates that occurred since the last committed transaction.
By default, a database connection is in autocommit mode, and each SQL statement is committed to the database as soon as it is executed.
Once a statement is committed, you cannot roll it back.
Then, all statements since the last commit are automatically reversed.
You typically issue a rollback when your transaction was interrupted by a SQLException.
With some drivers, you can gain finer-grained control over the rollback process by using save points.
Creating a save point marks a point to which you can later return without having to abandon the entire transaction.
For example, Click here to view code imageClick here to view code image.
Suppose a program needs to execute many INSERT statements to populate a database table.
You can improve the performance of the program by using a batch update.
In a batch update, a sequence of statements is collected and submitted as a batch.
The statements in a batch can be actions such as INSERT, UPDATE, or DELETE as well as data definition statements such as CREATE TABLE or DROP TABLE.
An exception is thrown if you add a SELECT statement to a batch.
Conceptually, a SELECT statement makes no sense in a batch because it returns a result set without updating the database.
To execute a batch, first create a Statement object in the usual way:
Now, instead of calling executeUpdate, call the addBatch method: Click here to view code imageClick here to view code image.
The call to executeBatch returns an array of the row counts for all submitted statements.
For proper error handling in batch mode, treat the batch execution as a single transaction.
If a batch fails in the middle, you want to roll back to the state before the beginning of the batch.
First, turn the autocommit mode off, then collect the batch, execute it, commit it, and finally restore the original autocommit mode:
If autocommit is true, all statements are committed as soon as their execution is completed.
String getSavepointName() gets the name of this save point, or throws a SQLException if this is an unnamed save point.
Each value in the returned array corresponds to one of the batch statements.
If it is the value SUCCESS_NO_INFO, the statement succeeded, but no row count is available.
Table 4.8 lists the SQL data types supported by JDBC and their equivalents in the Java programming language.
For example, in a Student table, you can have a Scores column that is an ARRAY OF INTEGER.
The getArray method returns an object of the interface type java.sql.Array.
When you get a LOB or an array from a database, the actual contents are fetched from the database only when you request individual values.
This is a useful performance enhancement, as the data can be quite voluminous.
Some databases support ROWID values that describe the location of a row so that it can be retrieved very rapidly.
A national character string (NCHAR and its variants) stores strings in a local character encoding and sorts them using a local sorting convention.
See the API documentation for the SQLXML class for details.
We do not discuss these advanced SQL types any further.
You can find more information on these topics in the JDBC API Tutorial and Reference and the JDBC 4 specifications.
When a JDBC application is deployed in a web or enterprise environment, the management of database connections is integrated with the JNDI.
The properties of data sources across the enterprise can be stored in a directory.
Using a directory allows for centralized management of user names, passwords, database names, and JDBC URLs.
In such an environment, you can use the following code to establish a database connection: Click here to view code imageClick here to view code image.
A data source is an interface that allows for simple JDBC connections as well as more advanced services, such as executing distributed transactions that involve multiple databases.
The DataSource interface is defined in the javax.sql standard extension package.
In a Java EE container, you don’t even have to program the JNDI lookup.
Simply use the Resource annotation on a DataSource field, and the data source reference will be set when your application is loaded:
Of course, the data source needs to be configured somewhere.
If you write database programs that execute in a servlet container such as Apache Tomcat or in an application server such as GlassFish, then you place the database configu-ration (including the JNDI name, JDBC URL, user name, and password) in a configuration file, or you set it in an admin GUI.
Management of user names and logins is just one of the issues that require special attention.
Our sample database programs used two strategies for obtaining a database connection.
The QueryDB program in Listing 4.3 established a single database connection at the start of the program and closed it at the end of the program.
The ViewDB program in Listing 4.4 opened a new connection whenever one was needed.
If a user walks away from an application for some time, the connection should not be left open.
Conversely, obtaining a connection for each query and closing it afterward is very costly.
This means that database connections are not physically closed but are kept in a queue and reused.
Connection pooling is an important service, and the JDBC specification provides hooks for implementors to supply it.
However, the JDK itself does not provide any implementation, and database vendors don’t usually include one with their JDBC drivers either.
Instead, vendors of web containers and application servers supply connection pool implementations.
Using a connection pool is completely transparent to the programmer.
Acquire a connection from a source of pooled connections by obtaining a data source and calling getConnection.
That doesn’t close the physical connection but tells the pool that you are done using it.
The connection pool typically makes an effort to pool prepared statements as well.
You have now learned about the JDBC fundamentals and know enough to implement simple database applications.
However, as we mentioned at the beginning of this chapter, databases are complex and quite a few advanced topics are beyond the scope of this introductory chapter.
For an overview of advanced JDBC capabilities, refer to the JDBC API Tutorial and Reference or the JDBC specifications.
In this chapter, you have learned how to work with relational databases in Java.
There’s a big world out there; we hope that lots of its inhabitants will be interested in your software.
The Internet, after all, effortlessly spans the barriers between countries.
On the other hand, when you pay no attention to an international audience, you are putting up a barrier.
Unicode support makes it easy to write Java programs that manipulate strings in any one of multiple languages.
Many programmers believe that all they need to do to internationalize their application is to support Unicode and to translate the messages in the user interface.
However, as this chapter demonstrates, there is a lot more to internationalizing programs than just Unicode support.
Dates, times, currencies, even numbers are formatted differently in different parts of the world.
You need an easy way to configure menu and button names, message strings, and keyboard shortcuts for different languages.
In this chapter, we will show you how to write internationalized Java programs and how to localize dates, times, numbers, text, and GUIs.
We will show you the tools that Java offers for writing internationalized programs.
We will close this chapter with a complete example—a retirement calculator with a user interface in English, German, and Chinese.
When you look at an application that is adapted to an international market, the most obvious difference you notice is the language.
As Oscar Wilde famously said: “We have really everything in common with America nowadays, except, of course, language.” In all cases, menus, button labels, and program messages will need to be translated to the local language; they might also need to be rendered in a different script.
There are many more subtle differences; for example, numbers are formatted quite differently in English and in German.
In the United States, dates are somewhat irrationally displayed as month/day/year.
Germany uses the more sensible order of day/month/year, whereas in China, the usage is year/month/day.
Of course, if the month names are written out explicitly, then the difference in languages becomes apparent.
There are several formatter classes that take these differences into account.
Optionally, a variant, specifying miscellaneous features such as dialects or spelling rules.
For example, in the United States, you use a locale with language=English, location=United States.
A German speaker in Switzerland would want to use a locale with.
To express the language and location in a concise and standardized manner, the Java programming language uses codes that were defined by the International Organization for Standardization (ISO)
These codes do seem a bit random, in part because some of them are derived from local languages (German = Deutsch = de, Chinese = zhongwen = zh), but at least they are standardized.
Given a language code, or a language and country code, you can construct a Locale object: Click here to view code imageClick here to view code image.
Java SE also predefines a number of language locales that specify just a language without a location: Locale.CHINESE Locale.ENGLISH Locale.FRENCH Locale.GERMAN Locale.ITALIAN Locale.JAPANESE.
For example, you can construct a locale from a language tag with the call.
Besides constructing a locale or using a predefined one, you have two other methods for obtaining a locale object.
The static getDefault method of the Locale class initially gets the default locale as stored by the local operating system.
You can change the default Java locale by calling setDefault; however, that change only affects your program, not the operating system.
Finally, all locale-dependent utility classes can return an array of the locales they support.
For testing, you might want to switch the default locale of your program.
Supply the language and region properties when you launch your program.
For example, here we set the default locale to German (Switzerland):
Once you have a locale, what can you do with it? Not much, as it turns out.
The only useful methods in the Locale class are those for identifying the language and country codes.
This string does not contain the cryptic two-letter codes, but is in a form that can be presented to a user, such as.
If your user already selected German as the preferred language, you probably want to present the string in German.
You can do just that by giving the German locale as a parameter.
The code Click here to view code imageClick here to view code image.
You feed them to locale-aware methods that produce text that is presented to users in different locations.
Locale(String language, String country, String variant) constructs a locale with the given language, country, and variant.
Don’t use variants in new code—use the IETF BCP 47 language tags instead.
String getDisplayName() returns a name describing the locale, expressed in the current locale.
String getLanguage() returns the language code, a lowercase two-letter ISO 639 code.
String getCountry() returns the country code as an uppercase two-letter ISO 3166 code.
String toString() returns a description of the locale, with the language and country separated by underscores (e.g., "de_CH")
We already mentioned how number and currency formatting is highly locale-dependent.
The Java library supplies a collection of formatter objects that can format and parse numeric values in the java.text package.
Go through the following steps to format a number for a particular locale:
Get the locale object, as described in the preceding section.
The factory methods are static methods of the NumberFormat class that take a Locale argument.
These methods return objects that can format and parse numbers, currency amounts, and percentages, respectively.
For example, here is how you can format a currency value in German: Click here to view code imageClick here to view code image.
The return type of parse is the abstract type Number.
The returned object is either a Double or a Long wrapper object, depending on whether the parsed number was a floating-point number.
If you don’t care about the distinction, you can simply use the doubleValue method of the Number class to retrieve the wrapped number.
Objects of type Number are not automatically unboxed—you cannot simply assign a Number object to a primitive type.
If the text for the number is not in the correct form, the method throws a ParseException.
For example, leading whitespace in the string is not allowed.
However, any characters that follow the number in the string are simply ignored, so no exception is thrown.
Note that the classes returned by the getXxxInstance factory methods are not actually of type NumberFormat.
The NumberFormat type is an abstract class, and the actual formatters belong to one of its subclasses.
The factory methods merely know how to locate the object that belongs to a particular locale.
That method returns an array of the locales for which number formatter objects can be obtained.
The sample program for this section lets you experiment with number formatters (see Figure 5.1)
The combo box at the top of the figure contains all locales with number formatters.
Each time you make another choice, the number in the text field is reformatted.
If you go through a few locales, you can get a good impression of how many ways a number or currency value can be formatted.
You can also type a different number and click the Parse button to call the parse method, which tries to parse what you entered.
If your input is successfully parsed, it is passed to format and the result is displayed.
If parsing fails, then a “Parse error” message is displayed in the text field.
For each locale, we call getDisplayName and fill a combo box with the strings that the getDisplayName method returns.
The strings are not sorted; we tackle this issue in Section 5.4, “Collation,” on p.
Whenever the user selects another locale or clicks one of the radio buttons, we create a new formatter object and update the text field.
When the user clicks the Parse button, we call the parse method to do the actual parsing, based on the locale selected.
String format(long x) returns the string resulting from formatting the given floating-point number or integer.
Number parse(String s) parses the given string and returns the number value, as a Double if the input string described a floating-point number and as a Long otherwise.
The beginning of the string must contain a number; no leading whitespace is allowed.
The number can be followed by other characters, which are ignored.
However, that method is not very flexible—it returns a formatter for a single currency.
Suppose you prepare an invoice for an American customer in which some amounts are in dollars and others are in Euros.
You can’t just use two formatters Click here to view code imageClick here to view code image.
String getCurrencyCode() gets the ISO 4217 currency code of this currency.
String getSymbol(Locale locale) gets the formatting symbol of this currency for the default locale or the given locale.
When you are formatting date and time, you should be concerned with four locale-dependent issues:
The names of months and weekdays should be presented in the local language.
There will be local preferences for the order of year, month, and day.
The Gregorian calendar might not be the local preference for expressing dates.
The time zone of the location must be taken into account.
It is easy to use and quite similar to the NumberFormat class.
Then, call one of the three factory methods: Click here to view code imageClick here to view code image.
To specify the desired style, these factory methods have a parameter that is one of the following constants: 2.2
Just as with the NumberFormat class, you can use the parse method to parse a date that the user typed.
For example, the following code parses the value that the user typed into a text field, using the default locale: Click here to view code imageClick here to view code image.
Unfortunately, the user must type the date exactly in the expected format.
For example, if the format is set to MEDIUM in the U.S.
You can select a locale and see how the date and time are formatted in different places around the world.
If you see question mark characters in the output, then you don’t have the fonts installed for displaying characters in the local language.
For example, if you pick a Chinese locale, the date might be expressed as.
Figure 5.2 shows the program (after Chinese fonts were installed)
Enter a date or time, click the “Parse lenient” checkbox if desired, and click the “Parse date” or “Parse time” button.
We use a helper class EnumCombo to solve a technical problem (see Listing 5.3)
Instead of writing repetitive code, we use reflection: We convert the user’s choice to upper case, replace all spaces with underscores, and then find the value of the static field with that name.
See Volume I, Chapter 5 for more details about reflection.
String format(Date d) returns the string resulting from formatting the given date/time.
Date parse(String s) parses the given string and returns the date/time described in it.
The beginning of the string must contain a date or time; no leading whitespace is allowed.
The date can be followed by other characters, which are ignored.
Calendar getCalendar() sets or gets the calendar object used for extracting year, month, day, hour, minute, and second from the Date object.
Use this method if you do not want to use the default calendar for the locale (usually the Gregorian calendar)
TimeZone getTimeZone() sets or gets the time zone object used for formatting the time.
Use this method if you do not want to use the default time zone for the locale.
The default time zone is the time zone of the default locale, as obtained from the operating system.
For the other locales, it is the preferred time zone in the geographical location.
NumberFormat getNumberFormat() sets or gets the number format used for formatting the numbers used for representing year, month, day, hour, minute, and second.
If the daylight parameter is true, the daylight savings name is returned.
Most programmers know how to compare strings with the compareTo method of the String class.
Unfortunately, this method is useless unless all your words are in uppercase ASCII characters.
The problem is that the compareTo method in the Java programming language uses the values of the Unicode character to determine the ordering.
For example, lowercase characters have a higher Unicode value than uppercase characters, and accented characters have even higher values.
This leads to absurd results; for example, the following five strings are ordered according to the compareTo method:
For dictionary ordering, you would want to consider upper case and lower case to be equivalent.
To an English speaker, the sample list of words would be ordered as.
Fortunately, once you are aware of the problem, collation is quite easy.
Then, call the getInstance factory method to obtain a Collator object.
Finally, use the compare method of the collator, not the compareTo method of the String class, whenever you want to sort strings.
Therefore, you can pass a Collator object to the Collections.sort method to sort a list of strings:
It is wasteful to have the collator decompose a string many times.
If one string is compared many times against other strings, you can save the decomposition in a collation key object.
The getCollationKey method returns a CollationKey object that you can use for further, faster comparisons.
Here is an example: Click here to view code imageClick here to view code image.
Finally, you might want to convert strings into their normalized forms even when you don’t do collation—for example, when storing strings in a database or communicating with another program.
For example, Click here to view code imageClick here to view code image.
The more a collator decomposes a string, the more strict it will be in deciding whether two strings should be considered identical.
The Java library has a MessageFormat class that formats text with variable parts, like this:
The numbers in braces are placeholders for actual names and values.
As of JDK 5.0, it is a “varargs” method, so you can simply supply the parameters as follows: Click here to view code imageClick here to view code image.
We don’t want to display the time “12:00 AM,” and we want the damage amount printed as a currency value.
The way we do this is by supplying an optional format for some of the placeholders:
In general, the placeholder index can be followed by a type and a style.
If the type is number, then the style can be integer currency percent.
See the documentation of the DecimalFormat class for more information about the possible formats.
If the type is either time or date, then the style can be.
See the documentation of the SimpleDateFormat class for more information about the possible formats.
Choice formats are more complex, and we will take them up in the next section.
Locale getLocale() sets or gets the locale to be used for the placeholders in the message.
The locale is only used for subsequent patterns that you set by calling the applyPattern method.
String format(Object obj) formats the given object, according to the rules of this formatter.
Let’s look closer at the pattern of the preceding section:
Ideally, we would like the message to vary according to the placeholder value, so it would read no houses one house 2 houses.
A choice format is a sequence of pairs, each containing.
This example shows that the designer of the choice format was a bit muddleheaded.
If you have three format strings, you need two limits to separate them.
In general, you need one fewer limit than you have format strings.
As you saw in Table 5.6, the MessageFormat class ignores the first limit.
The syntax would have been a lot clearer if the designer of this class realized that the limits belong between the choices, such as.
If we put the choice string inside the original message string, we get the following format instruction: Click here to view code imageClick here to view code image.
Or, in German, Click here to view code imageClick here to view code image.
Note that the ordering of the words is different in German, but the array of objects you pass to the format method is the same.
The order of the placeholders in the format string takes care of the changes in the word ordering.
As you know, the Java programming language itself is fully Unicode-based.
When you save data to a text file, you should respect the local character encoding so that the users of your program can open the text file in their other applications.
You can find a complete list of the supported encodings in Table 1.1 on p.
Unfortunately, there is currently no connection between locales and character encodings.
For example, if your user has selected the Taiwanese locale zh-TW, no method in the Java programming language tells you that the Big5 character encoding would be the most appropriate.
It is worth keeping in mind that you, the programmer, will need to communicate with the Java compiler.
And you do that with tools on your local system.
For example, you can use the Chinese version of Notepad to write your Java source code files.
The resulting source code files are not portable because they use the local character encoding (GB or Big5, depending on which Chinese operating system you use)
Only the compiled class files are portable—they will automatically use the “modified UTF-8” encoding for identifiers and strings.
That means that when a program is compiling and running, three character encodings are involved:
You can specify the character encoding of your source files with the -encoding flag, for example, javac -encoding Big5 Myfile.java.
You can convert the other way with the -reverse option: native2ascii -reverse Myfile.temp Myfile.java.
The encoding name must be one of those listed in Table 1.1 on p.
When localizing an application, you’ll probably have a dauntingly large number of message strings, button labels, and so on, that all need to be translated.
To make this task feasible, you’ll want to define the message strings in an external location, usually called a resource.
The person carrying out the translation can then simply edit the resource files without having to touch the source code of the program.
In Java, you can use property files to specify string resources, and you can implement classes for resources of other types.
Java technology resources are not the same as Windows or Macintosh resources.
A Macintosh or Windows executable program stores resources, such as menus, dialog boxes, icons, and messages, in a section separate from the program code.A resource editor can inspect and update these resources without affecting the program code.
Volume I, Chapter 10 describes a concept of JAR file resources, whereby data files, sounds, and images can be placed in a JAR file.
The getResource method of the class Class finds the file, opens it, and returns a URL to the resource.
By placing the files into the JAR file, you leave the job of finding the files to the class loader, which already knows how to locate items in a JAR file.
When localizing an application, you produce a set of resource bundles.
Each bundle is a property file or a class that describes locale-specific items (such as messages, labels, and so on)
For each bundle, you have to provide versions for all locales that you want to support.
You need to use a specific naming convention for these bundles.
Finally, as a fallback, you can put defaults into a file without any suffix.
If these bundles exist, they become the parents of the bundleName_de_DE bundle in a resource hierarchy.
Later, when looking up a resource, the parents are searched if a lookup was not successful in the current bundle.
This is clearly a very useful service—and one that would be tedious to program by hand.
The resource bundle mechanism of the Java programming language automatically locates the items that are the best match for a given locale.
It is easy to add more and more localizations to an existing program—all you have to do is create additional resource bundles.
If a locale has a script or variant, the lookup is quite a bit more complex.
You need not place all resources for your application into a single bundle.
You could have one bundle for button labels, one for error messages, and so on.
This is simply a text file with one key/value pair per line.
You can use the native2ascii tool to generate these files.
To provide resources that are not strings, define classes that extend the ResourceBundle class.
Use the standard naming convention to name your classes, for example.
When searching for bundles, a bundle in a class is given preference over a property file when the two bundles have the same base names.
You need to provide a key string for each setting you want to localize, and use that key string to retrieve the setting.
For example, Click here to view code imageClick here to view code image.
The simplest way of implementing resource bundle classes is to extend the ListResourceBundle class.
The ListResourceBundle lets you place all your resources into an object array and then does the lookup for you.
Follow this code outline: Click here to view code imageClick here to view code image.
For example, Click here to view code imageClick here to view code image.
Everyone on the planet, with the exception of the United States and Canada, uses ISO 216 paper sizes.
Metric Association (http://lamar.colostate.edu/~hillger), only three countries in the world have not yet officially adopted the metric system: Liberia, Myanmar (Burma), and the United States of America.
Alternatively, your resource bundle classes can extend the ResourceBundle class.
Then you need to implement two methods, to enumerate all keys and to look up the value for a given key:
The getObject method of the ResourceBundle class calls the handleGetObject method that you supply.
The resource bundle classes must be public so that the getBundle method can access them.
Object getObject(String name) looks up an object from the resource bundle or its parents.
String getString(String name) looks up an object from the resource bundle or its parents and casts it as a string.
It enumerates the keys in the parent bundles as well.
In this section, we apply the material of this chapter to localize a retirement calculator.
The program calculates whether or not you are saving enough money for your retirement.
You enter your age, how much money you save every month, and so on (see Figure 5.4)
The retirement calculator in English The text area and the graph show the balance of the retirement account for every year.
If the numbers turn negative toward the later part of your life and the bars in the graph appear below the x axis, you need to do something—for example, save more money, postpone your retirement, die earlier, or be younger.
The retirement calculator works in three locales (English, German, and Chinese)
The labels, buttons, and messages are translated into German and Chinese.
To generate the Chinese messages, we first typed the file, using Notepad running in Chinese Windows, and then we used the native2ascii utility to convert the characters to Unicode.
Whenever the locale changes, we reset the labels and reformat the contents of the text fields.
The text fields handle numbers, currency amounts, and percentages in the local format.
The format string is stored in the resource bundle of each language.
Just to show that it can be done, we use different colors for the bar graph, depending on the language chosen by the user.
Otherwise, all Chinese characters will show up as “missing character” icons.
You can now use resource bundles to provide translations into multiple languages, and use formatters and collators for locale-specific text processing.
In the next chapter, we will delve into advanced Swing programming.
In this chapter, we continue our discussion of the Swing user interface toolkit from Volume I.
Swing is a rich toolkit, and Volume I covered only the basic and commonly used components.
That leaves us with three significantly more complex components for lists, tables, and trees, the exploration of which occupies a large part of this chapter.
We will then turn to text components and go beyond the simple text fields and text areas that you have seen in Volume I.
We will show you how to add validations and spinners to text fields and how you can display structured text such as HTML.
Next, you will see a number of components for displaying progress of a slow activity.
We will finish the chapter by covering component organizers, such as tabbed panes and desktop panes with internal frames.
If you want to present a set of choices to a user, and a radio button or checkbox set consumes too much space, you can use a combo box or a list.
Combo boxes were covered in Volume I because they are relatively simple.
The JList component has many more features, and its design is similar to that of the tree and table components.
For that reason, it is our starting point for the discussion of complex Swing components.
You can have lists of strings, of course, but you can also have lists of arbitrary objects, with full control of how they appear.
The internal architecture of the list component that makes this generality possible is rather elegant.
Unfortunately, the designers at Sun felt that they needed to show off that elegance, instead of hiding it from the programmer who just wants to use the component.
You will find that the list control is somewhat awkward to use for common cases because you need to manipulate some of the machinery that makes the general cases possible.
We will walk you through the simple and most common case—a list box of strings—and then give a more complex example that shows off the flexibility of the list component.
The JList component shows a number of items inside a single box.
The user can select the attributes for the fox, such as “quick,” “brown,” “hungry,” “wild,” and, because we ran out of attributes, “static,” “private,” and “final.” You can thus have the private static final fox jump over the lazy dog.
A list box As of Java SE 7, JList is a generic type.
The type parameter is the type of the values the user can select.
To construct this list component, start out with an array of strings and pass that array to the JList constructor: Click here to view code imageClick here to view code image.
Then, add the scroll pane, not the list, into the surrounding panel.
We have to admit that the separation of the list display and the scrolling mechanism is elegant in theory, but a pain in practice.
It seems cruel to force programmers to go through the hoops in the default case just so they can appreciate that elegance.
By default, the list component displays eight items; use the setVisibleRowCount method to change that value:
You can set the layout orientation to one of three values:
Look at the placement of the words “quick,” “brown,” and “hungry” in Figure 6.2 to see the difference between vertical and horizontal wrap.
To add more items to a selection, press the Ctrl key while clicking on each item.
To select a contiguous range of items, click on the first one, then hold down the Shift key and click on the last one.
You can also restrict the user to a more limited selection mode with the setSelectionMode method: Click here to view code imageClick here to view code image.
You might recall from Volume I that the basic user interface components send out action events when the user activates them.
Rather than listening to action events, you need to listen to list selection events.
Add a list selection listener to the list component, and implement the method.
When the user selects items, a flurry of list selection events is generated.
For example, suppose the user clicks on a new item.
When the mouse button goes down, an event reports a change in selection.
However, if you want to give the user instant feedback as soon as the mouse button is clicked, you need to process all events.
Once you are notified that an event has happened, you will want to find out what items are currently selected.
If your list is in single-selection mode, call getSelectedValue to get the value as the list element type.
List components do not react to double clicks from a mouse.
As envisioned by the designers of Swing, you use a list to select an item, then click a button to make something happen.
However, some interfaces allow a user to double-click on a list item as a shortcut for selecting the item and invoking the default action.
If you want to implement this behavior, you have to add a mouse listener to the list box, then trap the mouse event as follows:
Listing 6.1 is the listing of the frame containing a list box filled with strings.
Notice how the valueChanged method builds up the message string from the selected items.
In the preceding section, you saw the most common method for using a list component:
Specify a fixed set of strings for display in the list.
In the remainder of the section on lists, we cover more complex situations that require a bit more finesse:
In the first example, we constructed a JList component that held a fixed collection of strings.
However, the collection of choices in a list box is not always fixed.
How do we add or remove items in the list box? Somewhat surprisingly, there are no methods in the JList class to achieve this.
Instead, you have to understand a little more about the internal design of the list component.
The JList class is responsible for the visual appearance of the data.
It actually knows very little about how the data are stored—all it knows is that it can retrieve the data through some object that implements the ListModel interface:
Through this interface, the JList can get a count of elements and retrieve any of them.
Also, the JList object can add itself as a ListDataListener.
That way, if the collection of elements changes, the JList gets notified so it can repaint itself.
Why is this generality useful? Why doesn’t the JList object simply store an array of objects? Note that the interface doesn’t specify how the objects are stored.
In particular, it doesn’t force them to be stored at all! The getElementAt method is free to recompute each value whenever it is called.
This is potentially useful if you want to show a very large collection without having to store the values.
Here is a somewhat silly example: We let the user choose among all three-letter words in a list box (see Figure 6.3)
The computation of the nth string is a bit technical—you’ll find the details in Listing 6.3
Now that we have a model, we can simply build a list that lets the user scroll through the elements supplied by the model: Click here to view code imageClick here to view code image.
Only those strings that the user actually requests to see are generated.
We must make one other setting: tell the list component that all items have a fixed width and height.
The easiest way to set the cell dimensions is to specify a prototype cell value:
The prototype cell value is used to determine the size for all cells.
We use the string “www” because “w” is the widest lowercase letter in most fonts.
If you don’t set a prototype value or a fixed cell size, the list component computes the width and height of each item.
Listing 6.2 shows the frame class of the example program.
As a practical matter, very long lists are rarely useful.
It is extremely cumbersome for a user to scroll through a huge selection.
For that reason, we believe that the list control has been overengineered.
A selection that can be comfortably managed on the screen is certainly small enough to be stored directly in the list component.
That arrangement would have saved programmers from the pain of having to deal with the list model as a separate entity.
On the other hand, the JList class is consistent with the JTree and JTable classes where this generality is useful.
JList(ListModel<E> dataModel) constructs a list that displays the elements in the specified model.
The default is null, which forces the size of each cell to be measured.
The default value is -1, which forces the size of each cell to be measured.
Instead, you must access the model and then add or remove elements.
Suppose you want to add more values to a list.
But that does you no good—as you saw in the preceding section, the ListModel interface has no methods to insert or remove elements because, after all, the whole point of having a list model is that it does not need to store the elements.
One of the constructors of JList takes a vector of objects:
You can now edit the vector and add or remove elements, but the list does not know that this is happening, so it cannot react to the changes.
In particular, the list does not update its view when you add the values.
Instead, you should construct a DefaultListModel object, fill it with the initial values, and associate it with the list.
The DefaultListModel class implements the ListModel interface and manages a collection of objects.
The DefaultListModel class implements the ListModel interface and manages a collection of objects.
Click here to view code imageClick here to view code image.
Now you can add or remove values from the model object.
The model object then notifies the list of the changes, and the list repaints itself.
For historical reasons, the DefaultListModel class doesn’t use the same method names as the collection classes.
Internally, the default list model uses a vector to store the values.
There are JList constructors that construct a list from an array or vector of objects or strings.
You might think that these constructors use a DefaultListModel to store these values.That is not the case—the constructors build a trivial model that can access the values without any provisions for notification if the content changes.
For example, here is the code for the constructor that constructs a JList from a Vector:
That means, if you change the contents of the vector after the list is constructed, the list might show a confusing mix of old and new values until it is completely repainted.
The keyword final in the preceding constructor does not prevent you from changing the vector elsewhere—it only means that the constructor itself won’t modify the value of the listData reference; the keyword is required because the listData object is used in the inner class.
Returns true if the object was contained in the model, false otherwise.
So far, all lists you have seen in this chapter contained strings.
It is actually just as easy to show a list of iconssimply pass an array or vector filled with Icon objects.
More interestingly, you can easily represent your list values with any drawing whatsoever.
Although the JList class can display strings and icons automatically, you need to install a list cell renderer into the JList object for all custom drawing.
A list cell renderer is any class that implements the following interface: Click here to view code imageClick here to view code image.
The component is placed at the appropriate location whenever a cell needs to be rendered.
One way to implement a cell renderer is to create a class that extends JComponent, like this: Click here to view code imageClick here to view code image.
In the paintComponent method, we display each name in its own font.
We also need to make sure to match the usual colors of the look-and-feel of the JList class.
A list box with rendered cells To install the cell renderer, simply call the setCellRenderer method:
Now all list cells are drawn with the custom renderer.
Actually, a simpler method for writing custom renderers works in many cases.
If the rendered image just contains text, an icon, and possibly a change of color, you can get by with configuring a JLabel.
For example, to show the font name in its own font, we can use the following renderer: Click here to view code imageClick here to view code image.
Note that here we don’t write any paintComponent or getPreferredSize methods; the JLabel class already implements these methods to our satisfaction.
All we do is configure the label appropriately by setting its text, font, and color.
This code is a convenient shortcut for those cases where an existing component—in this case, JLabel—already provides all functionality needed to render a cell value.
We could have used a JLabel in our sample program, but we gave you the more general code so you can modify it when you need to do arbitrary drawings in list cells.
If the user scrolls through many list entries, a new component would be constructed every time.
Reconfiguring an existing component is safe and much more efficient.
Click here to view code imageClick here to view code image.
If the list cells do not have fixed size, that component must also implement getPreferredSize.
Tables are common in user interfaces, and the Swing team has put a lot of effort into the table control.
A simple table As you can see from the code in Listing 6.5, the data of the table is stored as a two-dimensional array of Object values:
The entries in the second, third, and fourth columns are automatically converted into objects of type Double, Integer, and Boolean.
The table simply invokes the toString method on each object to display it.
Supply the column names in a separate array of strings:
Note that a JTable, unlike a JList, is not a generic type.
Elements in a list are expected to be of a uniform type—but, in general, there is no single element type for the entire table.
Resize the table vertically until the scroll bar shows up.
Note that the column headers don’t scroll out of view! Next, click on one of the column headers and drag it to the left or right.
See how the entire column becomes detached (see Figure 6.6)
Moving a column To resize columns, simply place the cursor between two columns until the cursor shape changes to an arrow.
Then, drag the column boundary to the desired place (see Figure 6.7)
Resizing columns Users can select rows by clicking anywhere in a row.
The selected rows are highlighted; you will see later how to get selection events.
Users can also edit the table entries by clicking on a cell and typing into it.
However, in this code example, the edits do not change the underlying data.
In your programs, you should either make cells uneditable or handle cell editing events and update your model.
A print dialog box appears, and the table is sent to the printer.
If you resize the TableTest frame so that its height is taller than the table height, you will see a gray area below the table.
Unlike JList and JTree components, the table does not fill the scroll pane’s viewport.
This can be a problem if you want to support drag and drop.
JTable(Object[][] entries, Object[] columnNames) constructs a table with a default table model.
When set, a default row sorter is automatically set whenever the model changes.
In the preceding example, the table data were stored in a two-dimensional array.
However, you should generally not use that strategy in your own code.
If you find yourself dumping data into an array to display it as a table, you should instead consider implementing your own table model.
Table models are particularly simple to implement because you can take advantage of the AbstractTableModel class that implements most of the required methods.
For example, if you want to display the contents of a RowSet that contains the result of a database query, simply provide this method: Click here to view code imageClick here to view code image.
We construct a table that shows some computed values—namely, the growth of an investment under different interest rate scenarios (see Figure 6.8)
Growth of an investment The getValueAt method computes the appropriate value and formats it: Click here to view code imageClick here to view code image.
The getRowCount and getColumnCount methods simply return the number of rows and columns.
Click here to view code imageClick here to view code image.
If you don’t supply column names, the getColumnName method of the AbstractTableModel names the columns A, B, C, and so on.
In this example, we simply label each column with the interest rate.
You can find the complete source code in Listing 6.6
Object getValueAt(int row, int column) gets the value at the given row and column.
In this subsection, you will see how to manipulate the rows and columns in a table.
As you read through this material, keep in mind that a Swing table is quite asymmetric—the operations that you can carry out on rows and columns are different.
The table component was optimized to display rows of information with the same structure, such as the result of a database query, not an arbitrary two-dimensional grid of objects.
In the next example, we again display our planet data, but this time we want to give the table more information about the column types.
The JTable class uses this information to pick an appropriate renderer for the class.
You can see the checkboxes and images in Figure 6.9
A table with planet data To render other types, you can install a custom renderer—see Section 6.2.4, “Cell Rendering and Editing,” on p.
The JTable class stores information about table columns in objects of type TableColumn.
The JTable class stores information about table columns in objects of type TableColumn.
Figure 6.10 shows the relationships among the most important table classes.
If you don’t want to insert or remove columns dynamically, you won’t use the column model much.
The most common use for the column model is simply to get a TableColumn object: Click here to view code imageClick here to view code image.
The TableColumn class gives you control over the resizing behavior of columns.
You can set the preferred, minimum, and maximum width with the methods.
This information is used by the table component to lay out the columns.
When a column is resized, the default is to leave the total size of the table unchanged.
Of course, the width increase or decrease of the resized column must then be distributed over other columns.
The default behavior is to change the size of all columns to the right of the resized column.
That’s a good default because it allows a user to adjust all columns to a desired width, moving from left to right.
You can set another behavior from Table 6.2 by using the method.
If your cells are taller than the default, you may want to set the row height:
The actual row height equals the row height set with these methods, reduced by the row margin.
The default row margin is 1 pixel, but you can change it with the call.
Depending on the selection mode, the user can select rows, columns, or individual cells in the table.
When row selection is enabled, you can control whether the user is allowed to select a single row, a contiguous set of rows, or any set of rows.
You need to retrieve the selection model and use its setSelectionMode method:
Enabling both row and column selection is equivalent to enabling cell selection.
The user then selects ranges of cells (see Figure 6.11)
Selecting a range of cells Run the program in Listing 6.7 to watch cell selection in action.
Enable row, column, or cell selection in the Selection menu and watch how the selection behavior changes.
You can find out which rows and columns are selected by calling the getSelectedRows and getSelectedColumns methods.
Both return an int[] array of the indexes of the selected items.
Note that the index values are those of the table view, not the underlying table model.
Try selecting rows and columns, then drag columns to different places and sort the rows by clicking on column headers.
Use the Print Selection menu item to see which rows and columns are reported as selected.
However, to have finer-grained control over the sorting behavior, install a TableRowSorter<M> object into a JTable and customize it.
The type parameter M denotes the table model; it needs to be a subtype of the TableModel interface.
Click here to view code imageClick here to view code image.
In our example, we will sort the colors in the Color column so that we.
When you click on the Color column, you will see that the blue planets go to the bottom of the table.
This is achieved with the following call: Click here to view code imageClick here to view code image.
If you do not specify a comparator for a column, the sort order is determined as follows: 1.1
It sorts strings in a way that is appropriate for the current locale.
See Chapter 5 for more information about locales and collators.
If the column class implements Comparable, use its compareTo method.
If you want to use this approach, define a converter as follows:
Otherwise, call the toString method on the cell values and sort them with the default collator.
In addition to sorting rows, the TableRowSorter can also selectively hide rows—a process called filtering.
For example, to include all rows that contain at least one moon, call.
An object of a subclass of Number (such as an Integer or Double)
Only objects that have the same class as the given Number object are considered.
If no index values are supplied, all columns are searched.
You can also combine filters with the andFilter, orFilter, and notFilter methods.
To filter for planets not ending in an “s” with at least one moon, you can use this filter combination: Click here to view code imageClick here to view code image.
Annoyingly, the andFilter and orFilter methods don’t use variable arguments but a single parameter of type Iterable.
To implement your own filter, provide a subclass of RowFilter and implement an include method to indicate which rows should be displayed.
This is easy to do, but the glorious generality of the RowFilter class makes it a bit scary.
When dealing with tables, the model is always a subtype of TableModel and the identifier type is Integer.
At some point in the future, other components might also support row filtering.
The RowFilter.Entry class supplies methods to obtain the model, the row identifier, and the value at a given index.
Therefore, you can filter both by row identifier and by the contents of the row.
For example, this filter displays every other row: Click here to view code imageClick here to view code image.
In our sample program, we allow the user to hide arbitrary rows.
The row filter includes all rows whose indexes are not in that set.
The filtering mechanism wasn’t designed for filters with criteria changing over time.
As you saw in the preceding section, you can filter table rows by either their contents or their row identifier.
The removeColumn method of the JTable class removes a column from the table view.
The column data are not actually removed from the model—they are just hidden from view.
If you want it to appear elsewhere, call the moveColumn method.
You can also add a new column that corresponds to a column index in the table model, by adding a new TableColumn object:
You can have multiple table columns that view the same column of the model.
The program in Listing 6.7 demonstrates selection and filtering of rows and columns.
Class getColumnClass(int columnIndex) gets the class for the values in this column.
TableColumnModel getColumnModel() gets the “column model” that describes the arrangement of the table columns.
You need that model to choose between row, column, and cell selection.
If true, rows are selected when the user clicks on cells.
If true, columns are selected when the user clicks on cells.
This value is different from index when rows are sorted or filtered, or when columns are moved or removed.
TableColumn getColumn(int index) gets the table column object that describes the column with the given view index.
TableColumn(int modelColumnIndex) constructs a table column for viewing the model column with the given index.
If any column model indexes are given, only those columns are searched; otherwise, all columns are searched.
For the number filter, the class of the cell value must match the class of number.
If any column model indexes are given, only those columns are searched; otherwise, all columns are searched.
Note that the string returned by the getStringValue method of RowFilter.Entry is matched.
Object getValue(int index) returns the value stored at the given index of this row.
String getStringValue() returns the value stored at the given index of this row, converted to a string.
The TableRowSorter produces entries whose getStringValue calls the sorter’s string converter.
As you saw in Section 6.2.3.2, “Accessing Table Columns,” on p.
There are default renderers for the types Boolean and Icon that render a checkbox or icon.
For all other types, you need to install a custom renderer.
Table cell renderers are similar to the list cell renderers that you saw earlier.
That method is called when the table needs to draw a cell.
You return a component whose paint method is then invoked to fill the cell area.
The table in Figure 6.12 contains cells of type Color.
The renderer simply returns a panel with a background color that is the color object stored in the cell.
A table with cell renderers Click here to view code imageClick here to view code image.
As you can see, the renderer installs a border when the cell has focus.
Generally, you will also want to set the background color of the cell to indicate whether it is currently selected.
We skip this step because it would interfere with the displayed color.
The ListRenderingTest example in Listing 6.4 shows how to indicate the selection status in a renderer.
It takes care of rendering the focus and selection status for you.
You need to tell the table to use this renderer with all objects of type Color.
The setDefaultRenderer method of the JTable class lets you establish this association.
That renderer is now used for all objects of the given type in this table.
If you want to select a renderer based on some other criterion, you need to subclass the JTable class and override the getCellRenderer method.
However, the table header isn’t smart enough to choose an appropriate renderer for the header value.
For example, to show an image icon in a column header, call.
To enable cell editing, the table model must indicate which cells are editable by defining the isCellEditable method.
Most commonly, you will want to make certain columns editable.
In the example program, we allow editing in four columns.
Click here to view code imageClick here to view code image.
The AbstractTableModel defines the isCellEditable method to always return false.
If you click a cell in the Moons column, a combo box appears (see Figure 6.13)
You will shortly see how to install such a combo box as a cell editor.
A cell editor Finally, click a cell in the first column.
What you just saw in action are the three variations of the DefaultCellEditor class.
A DefaultCellEditor can be constructed with a JTextField, a JCheckBox, or a JComboBox.
The JTable class automatically installs a checkbox editor for Boolean cells and a text field editor for all editable cells that don’t supply their own renderer.
The text fields let the user edit the strings that result from applying toString to the return value of the getValueAt method of the table model.
When the edit is complete, the edited value is retrieved by calling the getCellEditorValue method of your editor.
That method should return a value of the correct type (that is, the type returned by the getColumnType method of the model)
To get a combo box editor, set a cell editor manually—the JTable component has no idea what values might be appropriate for a particular type.
Unlike the color cell renderer, this editor does not depend on the object type—we don’t necessarily want to use it for all objects of type Integer.
Instead, we need to install it into a particular column:
A color chooser pops up and lets you pick a new color for the planet.
Editing the cell color with a color chooser The color cell editor is not a standard table cell editor but a custom implementation.
To create a custom cell editor, implement the TableCellEditor interface.
That interface is a bit tedious, and as of Java SE 1.3, an AbstractCellEditor class is provided to take care of the event handling details.
When the cell is being edited, it is presumed to have focus.
The editor component temporarily replaces the renderer when the editing is in progress.
In our example, we return a blank panel that is not colored.
This is an indication to the user that the cell is currently being edited.
Next, you want to have your editor pop up when the user clicks on the cell.
The JTable class calls your editor with an event (such as a mouse click) to find out if that event is acceptable to initiate the editing process.
The AbstractCellEditor class defines the method to accept all events.
However, if you override this method to return false, the table would not go through the trouble of inserting the editor component.
Once the editor component is installed, the shouldSelectCell method is called, presumably with the same event.
You should initiate editing in this method—for example, by popping up an external edit dialog box.
If the user cancels the edit, the table calls the cancelCellEditing method.
If the user has clicked on another table cell, the table calls the stopCellEditing method.
When your stopCellEditing method is called, the table would like to use the partially edited value.
You should return true if the current value is valid.
But if you edit other data, you can ensure that only valid data are retrieved from the editor.
Also, you should call the superclass methods that take care of event firing—otherwise, the editing won’t be properly canceled.
Finally, you need a method that yields the value that the user supplied in the editing process:
To summarize, your custom editor should do the following: 1.1
This can either be a dummy component (if you pop up a dialog box) or a component for in-place editing such as a combo box or text field.
Define the shouldSelectCell, stopCellEditing, and cancelCellEditing methods to handle the start, completion, and cancellation of the editing process.
The stopCellEditing and cancelCellEditing methods should call the superclass methods to ensure that listeners are notified.
Define the getCellEditorValue method to return the value that is the result of the editing process.
Finally, indicate when the user is finished editing by calling the stopCellEditing and cancelCellEditing methods.
When constructing the color dialog box, we install the accept and cancel callbacks that fire these events.
Click here to view code imageClick here to view code image.
You now know how to make a cell editable and how to install an editor.
There is one remaining issue—how to update the model with the value that the user edited.
When editing is complete, the JTable class calls the following method of the table model:
You need to override the method to store the new value.
The value parameter is the object that was returned by the cell editor.
If you implemented the cell editor, you know the type of the object you return from the getCellEditorValue method.
In the case of the DefaultCellEditor, there are three possibilities for that value.
It is a Boolean if the cell editor is a checkbox, a string if it is a text field, and, if the value comes from a combo box, it is the object that the user selected.
If the value object does not have the appropriate type, you need to convert it.
That happens most commonly when a number is edited in a text field.
In our example, we populated the combo box with Integer objects so that no conversion is necessary.
Normally, you want to return true, but you can return false if you don’t want the editing process to change the cell selection.
Returns true if the edited value is in a proper state for retrieval.
Every computer user who has worked with a hierarchical file system has seen tree displays.
Of course, directories and files form only one of the many examples of tree-like organizations.
Many tree structures arise in everyday life, such as the hierarchy of countries, states, and cities shown in Figure 6.15
Fortunately, the Swing library has a JTree class for this purpose.
The JTree class (together with its helper classes) takes care of laying out the tree and processing user requests for expanding and collapsing nodes.
In this section, you will learn how to put the JTree class to use.
As with many other Swing components, you need to provide a model of the data, and the component displays it for you.
To construct a JTree, supply the tree model in the constructor:
There are also constructors that construct trees out of a collection of elements: Click here to view code imageClick here to view code image.
They merely build a forest of trees, each with a single node.
The third constructor seems particularly useless because the nodes appear in the seemingly random order determined by the hash codes of the keys.
How do you obtain a tree model? You can construct your own model by creating a class that implements the TreeModel interface.
You will see later in this chapter how to do that.
For now, we will stick with the DefaultTreeModel that the Swing library supplies.
To construct a default tree model, you must supply a root node.
Click here to view code imageClick here to view code image.
Populate the default tree model with objects of any class that implements the interface.
This class implements the MutableTreeNode interface, a subinterface of TreeNode (see Figure 6.17)
Tree classes A default mutable tree node holds an object—the user object.
Unless you specify a renderer, the tree displays the string that is the result of the toString method.
In our first example, we use strings as user objects.
In practice, you would usually populate a tree with more expressive user objects.
For example, when displaying a directory tree, it makes sense to use File objects for the nodes.
You can specify the user object in the constructor, or you can set it later with the setUserObject method.
Click here to view code imageClick here to view code image.
Next, you need to establish the parent/child relationships between the nodes.
Start with the root node and use the add method to add the children: Click here to view code imageClick here to view code image.
A simple tree Link up all nodes in this fashion.
Click here to view code imageClick here to view code image.
Or, as a shortcut, you can simply pass the root node to the JTree constructor.
When you run the program, the tree first looks as in Figure 6.19
Click on the circle icons (the handles) to open up the subtrees.
The line sticking out from the handle icon points to the right when the subtree is collapsed and down when the subtree is expanded (see Figure 6.20)
We don’t know what the designers of the Metal look-and-feel had in mind, but we think of the icon as a door handle.
You push down on the handle to open the subtree.
Of course, the display of the tree depends on the selected look-and-feel.
In the Windows look-and-feel, the handles have the more familiar look—a “-” or “+” in a box (see Figure 6.21)
A tree with no connecting lines Conversely, to make sure that the lines are shown, use.
The tree is displayed with horizontal lines separating only the children of the root.
A tree with the horizontal line style By default, there is no handle for collapsing the root of the tree.
If you like, you can add one with the call.
Now you can collapse the entire tree into the root node.
A tree with a root handle Conversely, you can hide the root altogether.
You will thus display a forest—a set of trees, each with its own root.
You still must join all trees in the forest to a common root; then, hide the root with the instruction.
There appear to be two roots, labeled “USA” and “Germany.” The actual root that joins the two is made invisible.
A forest Let’s turn from the root to the leaves of the tree.
Note that the leaves have an icon different from the other nodes (see Figure 6.26)
Leaf and folder icons When the tree is displayed, each node is drawn with an icon.
There are actually three kinds of icons: a leaf icon, an opened nonleaf icon, and a closed nonleaf icon.
For simplicity, we refer to the last two as folder icons.
The node renderer needs to know which icon to use for each node.
By default, the decision process works like this: If the isLeaf method of a node returns true, then the leaf icon is used; otherwise, a folder icon is used.
Thus, nodes with children get folder icons, and nodes without children get leaf icons.
Suppose we added a node “Montana” to our sample tree, but we’re at a loss as to what cities to add.
We would not want the state node to get a leaf icon because conceptually only the cities are leaves.
The JTree class has no idea which nodes should be leaves.
If a childless node isn’t automatically a conceptual leaf, you can ask the tree model to use a different criterion for leafiness—namely, to query the “allows children” node property.
Then, tell the tree model to ask the value of the “allows children” property to determine whether a node should be.
With this decision criterion, nodes that allow children get folder icons, and nodes that don’t allow children get leaf icons.
Alternatively, if you construct the tree from the root node, supply the setting for the “asks allows children” property in the constructor.
JTree(TreeNode root, boolean asksAllowChildren) constructs a tree with a default tree model that displays the root and its children.
Otherwise, they are displayed as leaves when their isLeaf method returns true.
This is an “escape hatch” mechanism that some Swing components use for storing properties specific to a look-and-feel.
In the next example program, you will see how to edit a tree.
If you click the Add Sibling or Add Child button, the program adds a new node (with title New) to the tree.
If you click the Delete button, the program deletes the currently selected node.
Editing a tree To implement this behavior, you need to find out which tree node is currently selected.
The JTree class has a surprising way of identifying nodes in a tree.
It does not deal with tree nodes but with paths of objects, called tree paths.
A tree path starts at the root and consists of a sequence of child nodes (see Figure 6.28)
A tree path You might wonder why the JTree class needs the whole path.
Couldn’t it just get a TreeNode and keep calling the getParent method? In fact, the JTree class knows nothing about the TreeNode interface.
That interface is never used by the TreeModel interface; it is only used by the DefaultTreeModel implementation.
You can have other tree models in which the nodes do not implement the TreeNode interface at all.
If you use a tree model that manages other types of objects, those objects might not have getParent and getChild methods.
They would of course need to have some other connection to each other.
It is the job of the tree model to link nodes together.
The JTree class itself has no clue about the nature of their linkage.
For that reason, the JTree class always needs to work with complete paths.
For example, to find out the currently selected node in a tree, use the getSelectionPath method of the JTree class.
You will get a TreePath object back, from which you can retrieve the actual node.
Click here to view code imageClick here to view code image.
Actually, since this particular query is so common, there is a convenience method that gives the selected node immediately: Click here to view code imageClick here to view code image.
This method is not called getSelectedNode because the tree does not know that it contains nodes—its tree model deals only with paths of objects.
Tree paths are one of the two ways in which the JTree class describes nodes.
Quite a few JTree methods take or return an integer index—the row position.
A row position is simply the row number (starting with 0) of the node in the tree display.
Only visible nodes have row numbers, and the row number of a node changes if other nodes before it are expanded, collapsed, or modified.
All JTree methods that use rows have equivalents that use tree paths instead.
If you change the structure of the nodes, you change the model but the associated view is not notified.
You could send out a notification yourself, but if you use the insertNodeInto method of the DefaultTreeModel class, the model class takes care of that.
For example, the following call appends a new node as the last child of the selected node and notifies the tree view:
The automatic notification is a major advantage of using the DefaultTreeModel.
If you supply your own tree model, you have to implement automatic notification by hand.
The DefaultTreeModel class has a reload method that reloads the entire model.
However, don’t call reload simply to update the tree after making a few changes.
When the tree is regenerated, all nodes beyond the root’s children are collapsed again.
It will be quite disconcerting to your users if they have to keep expanding the tree after every change.
When the view is notified of a change in the node structure, it updates the display but does not automatically expand a node to show newly added children.
In particular, if a user in our sample program adds a new child node to a node for which children are currently collapsed, the new node is silently added to the collapsed subtree.
This gives the user no feedback that the command was actually carried out.
In such a case, you should make a special effort to expand all parent nodes so that the newly added node becomes visible.
Use the makeVisible method of the JTree class for this purpose.
The makeVisible method expects a tree path leading to the node that should become visible.
Thus, you need to construct a tree path from the root to the newly inserted node.
To get a tree path, first call the getPathToRoot method of the DefaultTreeModel class.
It returns a TreeNode[] array of all nodes from a node to the root node.
For example, here is how you make the new node visible:
It is curious that the DefaultTreeModel class feigns almost complete ignorance of the TreePath class, even though its job is to communicate with a JTree.
The JTree class uses tree paths a lot, and it never uses arrays of node objects.
But now suppose your tree is contained inside a scroll pane.
After the tree node expansion, the new node might still not be visible because it falls outside the viewport.
This call expands all nodes along the path and tells the ambient scroll pane to scroll the node at the end of the path into view (see Figure 6.29)
The scroll pane scrolls to display a new node.Figure 6.29
Double-clicking invokes the default cell editor, which is implemented by the DefaultCellEditor class (see Figure 6.30)
It is possible to install other cell editors, using the same process that you have seen in our discussion of table cell editors.
The default cell editor Listing 6.13 shows the complete source code of the tree editing program.
Run the program, add a few nodes, and edit them by double-clicking them.
Observe how collapsed nodes expand to show added children and how the scroll pane keeps added nodes in the viewport.
TreePath getSelectionPath() gets the path to the currently selected node, or the path to the first selected node if multiple nodes are selected.
TreeNode getChildAt(int index) looks up the child node at the given index.
Enumeration children() returns an enumeration object that iterates through all children of this node.
This is a drastic operation that you should use only if the nodes have changed completely because of some outside influence.
Sometimes you need to find a node in a tree by starting at the root and visiting all children until you have found a match.
Figure 6.31 shows the traversals for a sample tree—the node labels indicate the order in which the nodes are traversed.
The root is visited first, followed by all of its children, then the grandchildren, and so on.
To visualize depth-first enumeration, imagine a rat trapped in a tree-shaped maze.
It rushes along the first path until it comes to a leaf.
Then, it backtracks and turns around to the next path, and so on.
Computer scientists also call this postorder traversal because the search process visits the children before visiting the parents.
For completeness, there is also a preOrderTraversal, a depth-first search that enumerates parents before the children.
Here is the typical usage pattern: Click here to view code imageClick here to view code image.
That’s no big deal—it just keeps calling getParent until the ancestor is found and then presents the path in reverse order.
In our next example program, we put node enumeration to work.
Type the name of a class into the text field on the bottom of the frame.
The class and all of its superclasses are added to the tree (see Figure 6.32)
An inheritance tree In this example, we take advantage of the fact that the user objects of the tree nodes can be objects of any type.
Since our nodes describe classes, we store Class objects in the nodes.
We don’t want to add the same class object twice, so we need to check whether a class already exists in the tree.
The following method finds the node with a given user object if it exists in the tree.
Click here to view code imageClick here to view code image.
In your applications, you will often need to change the way a tree component draws the nodes.
The most common change is, of course, to choose different icons for nodes and leaves.
Other changes might involve changing the font of the node labels or drawing images at the nodes.
All these changes are possible by installing a new tree cell renderer into the tree.
The label contains the node icon and the node label.
The cell renderer does not draw the “handles” for expanding and collapsing subtrees.
The handles are part of the look-and-feel, and it is recommended that you do not change them.
These settings are used for all nodes in the tree.
You can install a renderer that implements the TreeCellRenderer interface to draw a custom image for each node.
We don’t recommend that you change the font or background color for an entire tree—that is really the job of the look-andfeel.
However, it can be useful to change the font of some nodes in a tree to highlight them.
If you look carefully at Figure 6.32, you will notice that the abstract classes are set in italics.
To change the appearance of individual nodes, install a tree cell renderer.
Tree cell renderers are very similar to the list cell renderers we discussed earlier in this chapter.
The TreeCellRenderer interface has a single method: Click here to view code imageClick here to view code image.
Click here to view code imageClick here to view code image.
If you change the font for a particular node, you must set it back to its default value when the method is called again.
Otherwise, all subsequent nodes will be drawn in the changed font! Look at the code in Listing 6.14 to see how to restore the font to the default.
We do not show an example of a tree cell renderer that draws arbitrary graphics.
If you need this capability, you can adapt the list cell renderer in Listing 6.4; the technique is entirely analogous.
We don’t want to set a particular font because we don’t want to change whatever font the look-and-feel normally uses for labels.
For that reason, we use the font from the label and derive an italic font from it.
Recall that only a single shared JLabel object is returned by all calls.
Also, note how we change the node icons in the ClassTreeFrame constructor.
In breadth-first traversal, children that are closer to the root are visited before those that are farther away.
In depth-first traversal, all children of a node are completely enumerated before its siblings are visited.
The preorder traversal is identical to the postorder traversal except that parents are enumerated before their children.
Most commonly, a tree component is paired with some other component.
When the user selects tree nodes, some information shows up in another window.
When the user selects a class, the instance and static variables of that class are displayed in the text area to the right.
A class browser To obtain this behavior, you need to install a tree selection listener.
That method is called whenever the user selects or deselects tree nodes.
Add the listener to the tree in the normal way:
You can specify whether the user is allowed to select a single node, a contiguous range of nodes, or an arbitrary, potentially discontiguous, set of nodes.
The JTree class uses a TreeSelectionModel to manage node selection.
For example, in our class browser, we want to allow selection of only a single class:
Apart from setting the selection mode, you need not worry about the tree selection model.
How the user selects multiple items depends on the look-and-feel.
In the Metal look-and-feel, hold down the Ctrl key while clicking an item to add it to the selection, or to remove it if it was currently selected.
Hold down the Shift key while clicking an item to select a range of items, extending from the previously selected item to the new item.
If you restricted the user to single-item selection, you can use the convenience method getSelectionPath which returns the first selected path or null if no path was selected.
The TreeSelectionEvent class has a getPaths method that returns an array of TreePath objects, but that array describes selection changes, not the current selection.
Listing 6.14 shows the frame class for the class tree program.
The program displays inheritance hierarchies and customizes the display to show abstract classes in italics.
The program displays inheritance hierarchies and customizes the display to show abstract classes in italics.
You can type the name of any class into the text field at the bottom of the frame.
Press the Enter key or click the Add button to add the class and its superclasses to the tree.
This program is a bit tricky because it uses reflection to construct the class tree.
We use the class tree in this example because inheritance yields a nice supply of trees without laborious coding.
When you display trees in your applications, you will have your own source of hierarchical data.
The method uses the breadth-first search algorithm to find whether the current class is already in the tree by calling the findUserObject method that we implemented in the preceding section.
If the class is not already in the tree, we add the superclasses to the tree, then make the new class node a child and make that node visible.
When you select a tree node, the text area to the right is filled with the fields of the selected class.
In the frame constructor, we restrict the user to single-item selection and add a tree selection listener.
When the valueChanged method is called, we ignore its event parameter and simply ask the tree for the current selection path.
As always, we need to get the last node of the path and look up its user object.
TreePath[] getPaths() gets the first path or all paths that have changed in this selection event.
In the final example, we implement a program that inspects the contents of an object, just like a debugger does (see Figure 6.34)
An object inspection tree Before going further, compile and run the example program.
If the field is an object, expand it to see its instance fields.
If you poke around a few of the instance fields, you should be able to find some familiar classes.
What’s remarkable about the program is that the tree does not use the DefaultTreeModel.
If you already have data that are hierarchically organized, you might not want to build a duplicate tree and worry about keeping both trees synchronized.
That is the situation in our case—the inspected objects are already linked to each other through the object references, so there is no need to replicate the linking structure.
The first group of methods enables the JTree to find the tree nodes by first getting the root, then the children.
The JTree class calls these methods only when the user actually expands a node.
This example shows why the TreeModel interface, like the JTree class itself, does not need an explicit notion of nodes.
The TreeModel is responsible for telling the JTree how they are connected.
The next method of the TreeModel interface is the reverse of getChild:
Actually, this method can be implemented in terms of the first three—see the code in Listing 6.16
The tree model tells the JTree which nodes should be displayed as leaves:
If your code changes the tree model, the tree needs to be notified so that it can redraw itself.
The tree adds itself as a TreeModelListener to the model.
Thus, the model must support the usual listener management methods:
You can see the implementations for these methods in Listing 6.17
When the model modifies the tree contents, it calls one of the four methods of the TreeModelListener interface:
The details of assembling a tree model event that describes an insertion or removal event are quite technical.
You only need to worry about firing these events if your tree can actually have nodes added and removed.
In Listing 6.16, we show you how to fire one event by replacing the root with a new object.
The last three methods of Listing 6.17 show how to use the class.
If you don’t allow editing, this method is never called.
If you don’t need to support editing, constructing a tree model is easily done.
Supply routine implementations of the other five methods, as in Listing 6.16
Now let’s turn to the implementation of the example program.
That variable has a type Employee.class, a name "joe", and a value—the value of the object reference joe.
In Listing 6.18, we define a class Variable that describes a variable in a program:
If the type of the variable is a class, the variable has fields.
Using reflection, we enumerate all fields and collect them in an ArrayList.
Since the getFields method of the Class class does not return the fields of the superclass, we need to call getFields on all superclasses as well.
The getFields method of our Variable class returns the array of fields.
Finally, the toString method of the Variable class formats the node label.
If the variable is not a class, the label also contains the value.
If the type is an array, we do not display the elements of the array.
This would not be difficult to do; we leave it as the proverbial “exercise for the reader.”
Click here to view code imageClick here to view code image.
The getChild method returns a new Variable object that describes the field with the given index.
The getType and getName methods of the Field class yield the field type and name.
However, we made all fields accessible in the Variable constructor, so this won’t happen in practice.
Here is the complete code of the getChild method: Click here to view code imageClick here to view code image.
These three methods reveal the structure of the object tree to the JTree component.
The remaining methods are routine—see the source code in Listing 6.17
There is one remarkable fact about this tree model: It actually describes an infinite tree.
You can verify this by following one of the WeakReference objects.
You get an identical subtree, and you can open its WeakReference object again, ad infinitum.
Of course, you cannot store an infinite set of nodes; the tree model simply generates the nodes on demand as the user expands the parents.
Listing 6.16 shows the frame class of the sample program.
Object getChild(Object parent, int index) gets the child node of the parent node at the given index.
Figure 6.35 shows all text components that are included in the Swing library.
In the following sections, we will introduce the remaining text components.
We will also discuss the JSpinner component that contains a formatted text field together with tiny “up” and “down” buttons to change its contents.
The hierarchy of text components and documents All text components render and edit the data stored in a model object of a class implementing the Document interface.
The JTextField and JTextArea components use a PlainDocument that simply stores a sequence of lines of plain text without any formatting.
The StyledDocument interface describes the additional requirements of styles, fonts, and colors.
The subclass JTextPane of JEditorPane also holds styled text as well as embedded Swing components.
We do not cover the very complex JTextPane in this book but instead refer you to the detailed description in Core Swing by Kim Topley.
For a typical use of the JTextPane class, have a look at the StylePad demo that is included in the JDK.
Most of the intricacies of the Document interface are of interest only if you implement your own text editor.
There is, however, one common use of the interface: tracking changes.
Sometimes, you may want to update a part of your user interface whenever a user edits text, without waiting for the user to click a button.
We show three text fields for the red, blue, and green component of a color.
Whenever the content of the text fields changes, the color should be updated.
Tracking changes in a text field First of all, note that it is not a good idea to monitor keystrokes.
Some keystrokes (such as the arrow keys) don’t change the text.
More importantly, the text can be updated by mouse gestures (such as “middle mouse button pasting” in X11)
Instead, you should ask the document (and not the text component) to notify you whenever the data have changed by installing a document listener:
The first two methods are called when characters have been inserted or removed.
The third method is not called at all for text fields.
For more complex document types, it would be called when some other change, such as a change in formatting, has occurred.
Unfortunately, there is no single callback to tell you that the text has changed—usually you don’t much care how it has changed.
Here is what we do in our sample program: Click here to view code imageClick here to view code image.
The setColor method uses the getText method to obtain the current user input strings from the text fields and sets the color.
Users can type malformed input, such as "twenty", into the text field, or leave a field blank.
In the next section, you will see how you can prevent the user from entering invalid input in the first place.
Instead of listening to document events, you can add an action event listener to a text field.
The action listener is notified whenever the user presses the Enter key.
We don’t recommend this approach, because users don’t always remember to press Enter when they are done entering data.
If you use an action listener, you should also install a focus listener so that you can track when the user leaves the text field.
String getText(int offset, int length) returns the text contained within the given portion of the document.
Document getDocument() gets the document that is the source of the event.
In the previous example program, we wanted the program user to type numbers, not arbitrary strings.
The hyphen, if present at all, must be the first symbol of the input string.
We can install a key listener to the text field and consume all key events that aren’t digits or a hyphen.
Unfortunately, this simple approach, although commonly recommended as a method for input validation, does not work well in practice.
First, not every combination of the valid input characters is a valid number.
But more importantly, there are other ways of changing the text that don’t involve typing character keys.
Depending on the look-andfeel, certain key combinations can be used to cut, copy, and paste text.
For example, in the Metal look-and-feel, the Ctrl+V key combination pastes the content of the paste buffer into the text field.
That is, we also need to monitor that the user doesn’t paste in an invalid character.
Clearly, filtering keystrokes to prevent invalid content begins to look like a real chore.
This is certainly not something that an application programmer should have to worry about.
Perhaps surprisingly, before Java SE 1.4, there were no components for entering numeric values.
Starting with the first edition of Core Java, we supplied an implementation for an IntTextField—a text field for entering a properly formatted integer.
In every new edition, we changed the implementation to extract whatever limited advantage we could from the various half-baked validation schemes added in each version of Java.
Chapter 5 explains in detail how you can select other locales.
As with any text field, you can set the number of columns:
You can set a default value with the setValue method.
That method takes an Object parameter, so you’ll need to wrap the default int value in an Integer object:
Typically, users will supply inputs in multiple text fields and then click a button to read all values.
When the button is clicked, you can get the user-supplied value with the getValue method.
That method returns an Object result, and you need to cast it into the appropriate type.
However, if the user made no changes, the original Integer object is returned.
Therefore, you should cast the return value to the common superclass Number:
The formatted text field is not very interesting until you consider what happens when a user provides illegal input.
Consider what happens when a user supplies input to a text field.
The user types input and eventually decides to leave the field, perhaps by clicking on another component with the mouse.
The I-beam cursor is no longer visible in the text field, and keystrokes are directed toward a different component.
When the formatted text field loses focus, the formatter looks at the text string that the user produced.
If the formatter knows how to convert the text string to an object, the text is valid.
You can use the isEditValid method to check whether the current content of the text field is valid.
The default behavior on loss of focus is called “commit or revert.” If the text string is valid, it is committed.
That object becomes the current value of the field (that is, the return value of the getValue method that you saw in the preceding section)
The value is then converted back to a string, which becomes the text string visible in the field.
Conversely, if the text string is invalid, the current value is not changed and the text field reverts to the string that represents the old value.
For example, if the user enters a bad value, such as x1, the old value is restored when the text field loses focus.
The integer formatter regards a text string as valid if it starts with an integer.
If the text string is invalid, then both the text string and the field value stay unchanged—they are now out of sync.
Even if the text string is valid, neither the text field nor the current value are changed.
You would need to call commitEdit, setValue, or setText to bring them back in sync.
Finally, there is a “revert” behavior that doesn’t ever seem to be useful: Whenever focus is lost, the user input is disregarded, and the text string reverts to the old value.
Suppose a dialog box contains a text field for an integer value.
A user enters a string " 1729", with a leading space, and clicks the OK button.
The leading space makes the number invalid, and the field value reverts to the old value.
The action listener of the OK button retrieves the field value and closes the dialog box.
The user never knows that the new value has been rejected.
In this situation, it is appropriate to select the “commit” behavior and have the OK button listener check that all field edits are valid before closing the dialog box.
The basic functionality of formatted text fields is straightforward and sufficient for most uses.
Perhaps you want to prevent the user from entering nondigits altogether.
For example, whenever the controller processes a command that causes text to be inserted into the document, it calls the “insert string” command.
The string to be inserted can be either a single character or the content of the paste buffer.
A document filter can intercept this command and modify the string or cancel the insertion altogether.
Here is the code for the insertString method of a filter that analyzes the string to be inserted and inserts only the characters that are digits or a – sign.
Click here to view code imageClick here to view code image.
You should also override the replace method of the DocumentFilter class—it is called when text is selected and then replaced.
Here is how you install a formatter to yield the desired filter: Click here to view code imageClick here to view code image.
The Java SE documentation states that the DocumentFilter class was invented to avoid subclassing.
Until Java SE 1.3, filtering in a text field was achieved by extending the PlainDocument class and overriding the insertString and replace methods.
It would have been even more splendid if the filter had also been made pluggable in the formatter class.
Alas, it was not, and we must subclass the formatter.
Try out the FormatTest example program at the end of this section.
You can insert only digits or the minus (-) character.
Note that you can still enter invalid strings such as "1-2-3"
In general, it is impossible to avoid all invalid strings through filtering.
For example, the string "-" is invalid, but a filter can’t reject it because it is a prefix of a legal string "-1"
Even though filters can’t give perfect protection, it makes sense to use them to reject inputs that are obviously invalid.
Another use for filtering is to turn all characters of a string to upper case.
In the insertString and replace methods of the filter, convert the string to be inserted to upper case and then invoke the superclass method.
There is another potentially useful mechanism to alert users to invalid inputs.
If the verifier reports the content of the component to be invalid, the component immediately regains focus.
The user is thus forced to fix the content before supplying other inputs.
A verifier must extend the abstract InputVerifier class and define a verify method.
It is particularly easy to define a verifier that checks formatted text fields.
The fourth text field in the example program has this verifier attached.
Try entering an invalid number (such as x1729) and press the Tab key or click with the mouse on another text field.
However, if you click the OK button, the action listener calls getValue, which reports the last good value.
If you click on a button, the button notifies its action listeners before an invalid component regains focus.
The action listeners can then get an invalid result from the component that failed verification.
There is a reason for this behavior: Users might want to click a Cancel button without first having to fix an invalid input.
For example, you can obtain a text field for the input of currency values by calling.
You can instead choose a “short” format such as 8/5/07
The DefaultFormatter can format objects of any class that has a constructor with a string parameter and a matching toString method.
For example, the URL class has a URL(String) constructor that can be used to construct a URL from a string, such as.
Therefore, you can use the DefaultFormatter to format URL objects.
The formatter calls toString on the field value to initialize the field text.
When the field loses focus, the formatter constructs a new object of the same class as the current value, using the constructor with a String parameter.
If that constructor throws an exception, the edit is not valid.
You can try that out in the example program by entering a URL that does not start with a prefix such as "http:"
That is different from the other formatters and not very useful.
Finally, the MaskFormatter is useful for fixed-size patterns that contain some constant and some variable characters.
For example, Social Security numbers (such as 078-05-1120) can be formatted with a.
Table 6.3 shows the symbols that you can use in a mask formatter.
You can restrict the characters that can be typed into the field by calling one of the methods of the MaskFormatter.
However, there is no way of specifying that the second character cannot be a letter.
Note that the string formatted by the mask formatter has exactly the same length as the pattern.
If the user erases characters during editing, they are replaced with the placeholder character.
By default, a mask formatter is in overtype mode, which is quite intuitive—try it out in the example program.
Also, note that the caret position jumps over the fixed characters in the mask.
The mask formatter is very effective for rigid patterns such as Social Security numbers or American telephone numbers.
However, note that no variation at all is permitted in the mask pattern.
For example, you cannot use a mask formatter for international telephone numbers that have a variable number of digits.
If none of the standard formatters is appropriate, it is fairly easy to define your own formatter.
You can’t use a MaskFormatter because each byte might be represented by one, two, or three digits.
To define your own formatter, extend the DefaultFormatter class and override the methods.
The first method turns the field value into the string that is displayed in the text field.
The second method parses the text that the user typed and turns it back into an object.
If either method detects an error, it should throw a ParseException.
The valueToString method forms a string that separates the bytes with periods.
Click here to view code imageClick here to view code image.
Conversely, the stringToValue method parses the string and produces a byte[] object if the string is valid.
Click here to view code imageClick here to view code image.
Try out the IP address field in the sample program.
If you enter an invalid address, the field reverts to the last valid address.
Click the OK button to retrieve the current values from the fields.
The “Swing Connection” online newsletter has a short article describing a formatter that matches any regular expression.
Object getValue() returns the current valid value of the field.
Note that this might not correspond to the string being edited.
The attempt fails if the formatter cannot convert the object to a string.
The attempt might fail if the formatter cannot convert the string.
Throws a ParseException if value is not appropriate for this formatter.
Throws a ParseException if s is not in the appropriate format.
A return value of null indicates that no filtering is needed.
If mode is true, new characters overwrite existing characters when editing text.
You can disable replacement by not calling super.replace or by calling bypass methods to modify the document without filtering.
Only the characters in the given string are accepted for the variable parts of the mask.
None of the characters in the given string are accepted as input.
Its tail end is used if the user has not supplied all variable characters in the mask.
If it is null or shorter than the mask, the placeholder character fills remaining inputs.
If this flag is true, the field value contains the literal (nonvariable) parts of the mask.
A JSpinner is a component that contains a text field and two small buttons on the side.
When the buttons are clicked, the text field value is incremented or decremented (see Figure 6.38)
Several variations of the JSpinnerJSpinner component component The values in the spinner can be numbers, dates, values from a list, or, in the most general case, any sequence of values for which predecessors and successors can be determined.
The JSpinner class defines standard data models for the first three cases.
You can define your own data model to describe arbitrary sequences.
You can get the current value by calling the getValue method.
Cast it to an Integer and retrieve the wrapped value.
You can change the increment to a value other than 1, and you can supply the lower and upper bounds.
There are two SpinnerNumberModel constructors, one with only int parameters and one with double parameters.
If any of the parameters is a floating-point number, the second constructor is used.
You can have a spinner iterate through any collection of values.
You can construct a SpinnerListModel from an array or a class implementing the List interface (such as an ArrayList)
In our sample program, we display a spinner control with all available font names.
Click here to view code imageClick here to view code image.
However, we found that the direction of the iteration was mildly confusing because it is opposite to that of a combo box.
In a combo box, higher values are below lower values, so you would expect the downward arrow to navigate toward higher values.
But the spinner increments the array index so that the upward arrow yields higher values.
There is no provision for reversing the traversal order in the SpinnerListModel, but an impromptu anonymous subclass yields the desired result:
Try both versions and see which you find more intuitive.
Another good use for a spinner is for a date that the user can increment or decrement.
You can get such a spinner, initialized with today’s date, with the call.
However, if you look carefully at Figure 6.38, you will see that the spinner text shows both date and time, such as.
The time doesn’t make any sense for a date picker.
It turns out to be somewhat difficult to make the spinner show just the date.
Here is the magic incantation: Click here to view code imageClick here to view code image.
Using the same approach, you can also make a time picker.
Click here to view code imageClick here to view code image.
You can display arbitrary sequences in a spinner by defining your own spinner model.
In our sample program, we have a spinner that iterates through all permutations of the string “meat”
You can get to “mate”, “meta”, “team”, and the rest of the total of 24 permutations by clicking the spinner buttons.
The getValue method returns the value stored by the model.
The setValue method must call the fireStateChanged method after setting the new value.
The getNextValue and getPreviousValue methods return the values that should come after or before the current value, or null if the end of the traversal has been reached.
The getNextValue and getPreviousValue methods should not change the current value.
When a user clicks on the upward arrow of the spinner, the getNextValue method is called.
If the return value is not null, it is set by a call to setValue.
In the sample program, we use a standard algorithm to determine the next and previous permutations (see Listing 6.24)
Listing 6.23 shows how to generate the various spinner types.
String toPattern() 1.21.2 gets the editing pattern for this date formatter.
See the Java SE documentation for more details about the pattern.
When overriding this method, you should call fireStateChanged after setting the new value.
Object getPreviousValue() computes (but does not set) the next or previous value in the sequence that this model defines.
Unlike the text components discussed up to this point, the JEditorPane can display and edit styled text, in particular HTML and RTF.
It is a poorly documented format that doesn’t work well even between Microsoft’s own applications.
Frankly, the JEditorPane is not as functional as one would like it to be.
The HTML renderer can display simple files, but it chokes at many complex pages that you typically find on the Web.
A plausible application for the JEditorPane is to display program help in HTML format.
By having control over the help files you provide, you can stay away from features that the JEditorPane does not display well.
The program in Listing 6.25 contains an editor pane that shows the contents of an HTML page.
The selected HTML page is displayed in the editor pane (see Figure 6.39)
The editor pane displaying an HTML page The hyperlinks are active: If you click a link, the application loads it.
Of course, it does not have any of the comfort features, such as page caching or bookmark lists, that you would expect from a commercial browser.
The editor pane does not even display applets! If you click the Editable checkbox, the editor pane becomes editable.
You can type in text and use the Backspace key to delete text.
The component also understands the Ctrl+X, Ctrl+C, and Ctrl+V shortcuts for cut, copy, and paste.
However, you would have to do quite a bit of programming to add support for fonts and formatting.
Also, with some web pages you can see JavaScript commands, comments, and other tags when edit mode is turned on (see Figure 6.40)
The example program lets you investigate the editing feature, but we recommend that you omit it in your programs.
The features of the editor pane that you saw in the example program are easy to use.
The parameter is either a string or a URL object.
Therefore, you can call the setText method as well—it simply displays plain text.
The API documentation is unclear about whether setPage loads the new document in a separate thread (which is generally what you want—the JEditorPane is no speed demon)
However, you can force loading in a separate thread with the following incantation:
The HyperlinkListener interface has a single method, hyperlinkUpdate, that is called when the user moves over or clicks on a link.
You need to call the getEventType method to find out what kind of event occurred.
The first value indicates that the user clicked on the hyperlink.
In that case, you typically want to open the new link.
You can use the second and third values to give some visual feedback, such as a tooltip, when the mouse hovers over the link.
It is a complete mystery why there aren’t three separate methods to handle activation, entry, and exit in the HyperlinkListener interface.
The getURL method of the HyperlinkEvent class returns the URL of the hyperlink.
For example, here is how you can install a hyperlink listener that follows the links that a user activates: Click here to view code imageClick here to view code image.
The event handler simply gets the URL and updates the editor pane.
In that case, we display an error message as plain text.
The program in Listing 6.25 shows all the features that you need to put together an HTML help system.
Under the hood, the JEditorPane is even more complex than the tree and table components.
However, if you don’t need to write a text editor or a renderer of a custom text format, that complexity is hidden from you.
In the following sections, we discuss three classes for indicating the progress of a slow activity.
A ProgressMonitor is a dialog box that contains a progress bar.
A progress bar is a simple component—just a rectangle that is partially filled with color to indicate the progress of an operation.
You can see a progress bar in the bottom right of Figure 6.41
A progress bar You can construct a progress bar much as you construct a slider—by supplying the minimum and maximum value and an optional orientation: Click here to view code imageClick here to view code image.
You can also set the minimum and maximum with the setMinimum and setMaximum methods.
Unlike a slider, the progress bar cannot be adjusted by the user.
If you want to show a different string, you can supply it with the setString method:
The program in Listing 6.26 shows a progress bar that monitors a simulated time-consuming activity.
The SimulatedActivity class increments a value current ten times per second.
We use the SwingWorker class to implement the activity and update the progress bar in the process method.
The SwingWorker invokes the method from the event dispatch thread, so that it is safe to update the progress bar.
See Volume I, Chapter 14 for more information about thread safety in Swing.
Java SE 1.4 added support for an indeterminate progress bar that shows an animation indicating some kind of progress, without specifying the percentage of completion.
That is the kind of progress bar that you see in your browser—it indicates that the browser is waiting for the server and has no idea how long the wait might be.
To display the “indeterminate wait” animation, call the setIndeterminate method.
A progress bar is a simple component that can be placed inside a window.
In contrast, a ProgressMonitor is a complete dialog box that contains a progress bar (see Figure 6.42)
If you click it, the monitor dialog box is closed.
In addition, your program can query whether the user has canceled the dialog box and terminate the monitored action.
Note that the class name does not start with a “J”
A progress monitor dialog box Construct a progress monitor by supplying the following:
The parent component over which the dialog box should pop up.
An object (which should be a string, icon, or component) that is displayed in the dialog box.
However, the progress monitor cannot measure progress or cancel an activity by itself.
You still need to periodically set the progress value by calling the setProgress method.
This is the equivalent of the setValue method of the JProgressBar class.
When the monitored activity has concluded, call the close method to dismiss the dialog box.
You can reuse the same dialog box by calling start again.
The biggest problem with using a progress monitor dialog box is handling the cancellation requests.
You cannot attach an event handler to the Cancel button.
Instead, you need to periodically call the isCanceled method to see if the user has clicked the Cancel button.
If your worker thread can block indefinitely (for example, when reading input from a network connection), it cannot monitor the Cancel button.
In our sample program, we will show you how to use a timer for that purpose.
We will also make the timer responsible for updating the progress measurement.
If you run the program in Listing 6.27, you can observe an interesting feature of the progress monitor dialog box.
Instead, it waits for a short interval to see if the activity has already been completed or is likely to complete in less time than it would take for the dialog box to appear.
The setMillisToPopup is your estimation of the time the dialog box needs to pop up.
The Swing designers set this value to a default of 2 seconds.
Clearly they were mindful of the fact that Swing dialogs don’t always come up as snappily as we all would like.
Supply the parent component, a caption, and, of course, the stream to monitor.
The read method of the progress monitor stream simply passes along the bytes and updates the progress dialog box.
When the file is read, the progress monitor automatically pops up (see Figure 6.43)
The progress monitor stream uses the available method of the InputStream class to determine the total number of bytes in the stream.
However, the available method only reports the number of bytes in the stream that are available without blocking.
Progress monitors work well for files and HTTP URLs because their length is known in advance, but they don’t work with all streams.
The program in Listing 6.28 counts the lines in a file.
If you read in a large file (such as "The Count of Monte Cristo" in the gutenberg directory of the companion code), the progress dialog box pops up.
If the user clicks the Cancel button, the input stream closes.
The code that processes the input already knows how to deal with the end of input, so no change to the programming logic is required to handle cancellation.
Note that the program doesn’t use a very efficient way of filling up the text area.
It would be faster to first read the file into a StringBuilder and then set the text of the text area to the string builder contents.
However, in this example program, we actually like this slow approach—it gives you more time to admire the progress dialog box.
To avoid flicker, we do not display the text area while it is filling up.
JProgressBar(int direction, int min, int max) constructs a slider with the given direction, minimum, and maximum.
If the string is null, a default string “n%” is displayed.
If this property is true, a string is painted on top of the progress bar.
If this property is true, the progress bar becomes a block that moves backward and forward, indicating a wait of unknown duration.
We conclude the discussion of advanced Swing features with a presentation of components that help organize other components.
These include the split pane, a mechanism for splitting an area into multiple parts with boundaries that can be adjusted; the tabbed pane which uses tab dividers to allow a user to flip through multiple panels; and the desktop pane that can be used to implement applications displaying multiple internal frames.
We will close with a discussion of layers—decorators that can be superimposed over other components.
A split pane splits a component into two parts, with an adjustable boundary in between.
The components in the outer split pane are arranged vertically, with a text area on the bottom and another split pane on the top.
That split pane’s components are arranged horizontally, with a list on the left and a label containing an image on the right.
If you like, you can add “one-touch expand” icons to the splitter bar.
You can see those icons in the top pane in Figure 6.44
If you click one of them, the splitter moves all the way in the direction to which the triangle is pointing, expanding one of the panes completely.
The “continuous layout” feature continuously repaints the contents of both components as the user adjusts the splitter.
In the example program, we left the bottom splitter at the default (no continuous layout)
When you drag it, you only move a black outline.
The straightforward program in Listing 6.29 populates a list box with planets.
When the user makes a selection, the planet image is displayed to the right and a description is placed in the text area on the bottom.
Run the program, adjust the splitters, and try out the one-touch expansion and continuous layout features.
JSplitPane(int direction, boolean continuousLayout, Component first, Component second) constructs a new split pane.
When this property is set, the splitter has two icons to completely expand one or the other component.
When this property is set, then the components are continuously updated when the splitter is moved.
Tabbed panes are a familiar user interface device to break up a complex dialog box into subsets of related options.
You can also use tabs to let a user flip through a set of documents or images (see Figure 6.45)
A tabbed pane To create a tabbed pane, first construct a JTabbedPane object, then add tabs to it.
The last parameter of the addTab method has type Component.
To add multiple components into the same tab, first pack them up in a container, such as a JPanel.
The icon is optional; for example, the addTab method does not require an icon:
When you add a new tab to the tab collection, it is not automatically displayed.
For example, here is how you show a tab that you just added to the end:
If you have a lot of tabs, they can take up quite a bit of space.
A tabbed pane with scrolling tabs Set the tab layout to wrapped or scrolling mode by calling.
Now the M is underlined, and users can select the tab by pressing Alt+M.
In our sample program, we add a “close box” to the Pluto tab (because, after all, astronomers do not consider Pluto a planet)
This is achieved by setting the tab component to a panel containing two components: a label with the icon and tab text, and a checkbox with an action listener that removes the tab.
The example program shows a useful technique with tabbed panes.
Sometimes, you may want to update a component just before it is displayed.
In our example program, we load the planet image only when the user actually clicks a tab.
To be notified whenever the user clicks on a tab, install a ChangeListener with the tabbed pane.
Note that you must install the listener with the tabbed pane itself, not with any of the components.
When the user selects a tab, the stateChanged method of the change listener is called.
You can retrieve the tabbed pane as the source of the event.
Call the getSelectedIndex method to find out which pane is about to be displayed.
In Listing 6.30, we first set all tab components to null.
When a new tab is selected, we test whether its component is still null.
Just for fun, we also change the icon from a yellow ball to a red ball to indicate which panes have been visited.
The character is specified as a VK_X constant from the KeyEvent class.
If this component is null, the tab icon and title are rendered.
Otherwise, only the given component is rendered in the tab.
Many applications present information in multiple windows that are all contained inside a large frame.
If you minimize the application frame, all of its windows are hidden at the same time.
In the Windows environment, this user interface is sometimes called the multiple document interface (MDI)
A multiple document interface application For a time, this user interface style was popular, but it has become less prevalent in recent years.
Nowadays, many applications simply display a separate top-level frame for each document.
Which is better? MDI reduces window clutter, but having separate top-level windows means that you can use the buttons and hotkeys of the host windowing system to flip through your windows.
In the world of Java, where you can’t rely on a rich host windowing system, it makes a lot of sense to have your application manage its frames.
Figure 6.48 shows a Java application with three internal frames.
Two of them have decorations on the borders to maximize and iconify them.
A Java application with three internal frames In the Metal look-and-feel, the internal frames have distinctive “grabber” areas that you can use to move the frames around.
You can resize the windows by dragging the resize corners.
You can specify whether you want the icons for resizing or closing the frame.
In the current version of the Metal look-and-feel, the frame icon is not displayed in iconified frames.
In earlier versions of Swing, internal frames were automatically visible and this call was not necessary.
You will probably want to move the position of the next internal frame down so that it won’t overlay the existing frame.
Use that distance to determine the next internal frame’s position.
The Java JDesktopPane and JInternalFrame classes have no built-in support for these operations.
In Listing 6.31, we show you how you can implement these operations yourself.
Tiled internal frames To cascade all windows, reshape windows to the same size and stagger their positions.
The getAllFrames method of the JDesktopPane class returns an array of all internal frames.
However, you need to pay attention to the frame state.
An internal frame can be in one of three states:
Use the isIcon method to find out which internal frames are currently icons and should be skipped.
However, if a frame is in the maximum state, you first need to set it to be resizable by calling setMaximum(false)
The following loop cascades all internal frames on the desktop: Click here to view code imageClick here to view code image.
Tiling frames is trickier, particularly if the number of frames is not a perfect square.
First, count the number of frames that are not icons.
Compute the number of rows in the first column as.
Then the number of columns is int cols = frameCount / rows;
Here is the loop for tiling all frames on the desktop: Click here to view code imageClick here to view code image.
The example program shows another common frame operation: moving the selection from the current frame to the next frame that isn’t an icon.
Traverse all frames and call isSelected until you find the currently selected frame.
Then, look for the next frame in the sequence that isn’t an icon, and try to select it by calling.
If you come back to the original frame, then no other frame was selectable, and you give up.
Here is the complete loop: Click here to view code imageClick here to view code image.
Now that you have seen all these veto exceptions, you might wonder how your frames can issue a veto.
The JInternalFrame class uses a general JavaBeans mechanism for monitoring the setting of properties.
For now, we just want to show you how your frames can veto requests for property changes.
Frames don’t usually want to use a veto to protest iconization or loss of focus, but it is very common for frames to check whether it is OK to close them.
You can close a frame with the setClosed method of the JInternalFrame class.
Since the method is vetoable, it calls all registered vetoable change listeners before proceeding to make the change.
In our example program, we put up a dialog box to ask the user whether it is OK to close the window (see Figure 6.51)
As you see in Chapter 8, you obtain the property name by removing the "set" prefix from the method name and changing the next letter to lower case.
Use the getNewValue method to get the proposed new value.
Click here to view code imageClick here to view code image.
Return normally if you don’t want to veto the change.
If you use internal frames, you should not use the JDialog class for dialog boxes.
They are heavyweight because they create a new frame in the windowing system.
The windowing system does not know how to position them relative to the internal frame that spawned them.
They work exactly like the showXxxDialog methods, except they position a lightweight window over an internal frame.
As for more complex dialog boxes, construct them with a JInternalFrame.
Unfortunately, you then have no built-in support for modal dialog boxes.
In our sample program, we use an internal dialog box to ask the user whether it is OK to close a frame.
Click here to view code imageClick here to view code image.
If you simply want to be notified when a frame is closed, you should not use the veto mechanism.
One criticism that developers have leveled against internal frames is that performance has not been great.
By far the slowest operation is to drag a frame with complex content across the desktop.
The desktop manager keeps asking the frame to repaint itself as it is being dragged, which is quite slow.
Actually, if you use Windows or X Windows with a poorly written video driver, you’ll experience the same problem.
Window dragging appears to be fast on most systems because the video hardware supports the dragging operation by mapping the image inside the frame to a different screen location during the dragging process.
To improve performance without greatly degrading the user experience, you can turn “outline dragging” on.
When the user drags the frame, only the outline of the frame is continuously updated.
The inside is repainted only when the frame is dropped to its final resting place.
This setting is the equivalent of “continuous layout” in the JSplitPane class.
In the sample program, you can use the Window -> Drag Outline checkbox menu selection to toggle outline dragging on or off.
The internal frames on the desktop are managed by a DesktopManager class.
You don’t need to know about this class for normal programming.
It is possible to implement a different desktop behavior by installing a new desktop manager, but we don’t cover that.
Listing 6.31 populates a desktop with internal frames that show HTML pages.
The File -> Open menu option pops up a file dialog box for reading a local HTML file into a new internal frame.
If you click on any link, the linked document is displayed in another internal frame.
JInternalFrame[] getAllFrames() gets all internal frames in this desktop pane.
When the property is true, an icon appears in the frame title to resize, close, maximize, or iconify the internal frame.
When this property is true, the internal frame is iconified, maximized, or closed.
When this property is true, the current internal frame becomes the selected frame on the desktop.
JDesktopPane getDesktopPane() gets the desktop pane of this internal frame.
String getPropertyName() returns the name of the property that is about to be changed.
Object getNewValue() returns the proposed new value for the property.
Java SE 1.7 introduces a feature that lets you place a layer over another component.
You can paint on the layer and listen to events of the underlying component.
You can use layers to add visual clues to your user interface.
For example, you can decorate the current input, invalid inputs, or disabled components.
The JLayer class associates a component with a LayerUI object that is in charge of painting and event handling.
The LayerUI class has a type parameter that must match the associated component.
For example, here we add a layer to a JPanel:
In the paint method, you can paint anything you like.
Be sure to call super.paint to have the component painted.
Here, we draw a transparent color over the entire component: Click here to view code imageClick here to view code image.
In order to listen to events from the associated component or any of its children, the LayerUI class must set the layer’s event mask.
This should be done in the installUI method, like this: Click here to view code imageClick here to view code image.
Now you will receive events in the methods named processXxxEvent.
For example, in our sample application, we repaint the layer after every keystroke: Click here to view code imageClick here to view code image.
Our sample program in Listing 6.32 has three input fields for the RGB values of a color.
Whenever the user changes the values, the color is shown transparently over the panel.
We also trap focus events and show the text of the focused component in a bold font.
JLayer(V view, LayerUI<V> ui) constructs a layer over the given view, delegating painting and event handling to the ui object.
You have now seen how to use the complex components that the Swing framework offers.
You can use the methods of the Graphics class to create simple drawings.
Those methods are sufficient for simple applets and applications, but they fall short when you create complex shapes or when you require complete control over the appearance of the graphics.
The Java 2D API is a more sophisticated class library that you can use to produce high-quality drawings.
In this chapter, we will give you an overview of that API.
We’ll then turn to the topic of printing and show how you can implement printing capabilities in your programs.
We will cover two techniques for transferring data between programs: the system clipboard and the drag-and-drop mechanism.
You can use these techniques to transfer data between two Java applications or between a Java application and a native program.
Finally, we cover techniques for making Java applications feel more like native applications, such as providing a splash screen and an icon in the system tray.
The original JDK 1.0 had a very simple mechanism for drawing shapes.
You selected color and paint mode, and called methods of the Graphics class such as drawRect or fillOval.
You have control over the stroke—the pen that traces shape boundaries.
You can fill shapes with solid colors, varying hues, and repeating patterns.
You can use transformations to move, scale, rotate, or stretch shapes.
You can clip shapes to restrict them to arbitrary areas.
You can select composition rules to describe how to combine the pixels of a new shape with existing pixels.
You can give rendering hints to make trade-offs between speed and drawing quality.
The Java 2D API supplies many shape objects and methods to combine shapes.
Of course, in many practical circumstances, you don’t need all these steps.
There are reasonable defaults for the settings of the 2D graphics context; change the settings only if you want to deviate from the defaults.
In the following sections, you will see how to describe shapes, strokes, paints, transformations, and composition rules.
The various set methods simply set the state of the 2D graphics context.
Similarly, when you construct Shape objects, no drawing takes place.
A shape is only rendered when you call draw or fill.
At that time, the new shape is computed in a rendering pipeline (see Figure 7.1)
The rendering pipeline In the rendering pipeline, the following steps take place to render a shape:
If there is no intersection between the shape and the clipping area, the process stops.
The pixels of the filled shape are composed with the existing pixels.
In Figure 7.1, the circle is part of the existing pixels, and the cup shape is superimposed over it.
In the next section, you will see how to define shapes.
Then, we will turn to the 2D graphics context settings.
Here are some of the methods in the Graphics class to draw shapes:
These methods have been in the Graphics class ever since JDK 1.0
The Java 2D API uses a completely different, object-oriented approach.
Finally, the Point2D class describes a point with an x and a y coordinate.
Points are used to define shapes, but they aren’t themselves shapes.
To draw a shape, first create an object of a class that implements the Shape interface and then call the draw method of the Graphics2D class.
The Java 2D API supplies two additional classes, quadratic and cubic curves, that we will discuss in this section.
There is no Polygon2D class; instead, the GeneralPath class describes paths made up from lines, quadratic and cubic curves.
You can use a GeneralPath to describe a polygon; we’ll show you how later in this section.
Admittedly, ellipses and arcs are not rectangular, but they have a bounding rectangle (see Figure 7.2)
The bounding rectangle of an ellipse and an arcFigure 7.2
The bounding rectangle of an ellipse and an arc Each of the classes with a name ending in “2D” has two subclasses for specifying coordinates as float or double quantities.
Internally, all graphics classes use float coordinates because float numbers use less storage space but have sufficient precision for geometric computations.
However, the Java programming language makes it a bit more tedious to manipulate float numbers.
For that reason, most methods of the graphics classes use double parameters and return values.
Only when constructing a 2D object must you choose between the constructors with float and double coordinates.
For example, Click here to view code imageClick here to view code image.
After object construction, essentially no benefit accrues from remembering the subclass, and you can just store the constructed object in a superclass variable as in the code example above.
That is just a minor syntactical convenience to avoid inflation of outer class names.
Legacy classes from the pre-2D library are marked with a gray fill.
In this section, you will learn how to work with the remaining 2D shapes.
Constructing an elliptical arc Figure 7.6 illustrates the arc types.
You can get a skewed angle with the following formula:
Compute the skewed start and end angles in this way.Then, compute the difference between the two skewed angles.
If the start angle or the difference is negative, add 360 to the start angle.
Then, supply the start angle and the difference to the arc constructor.
In this chapter, we do not get into the mathematics of these curves.
We suggest you get a feel for how the curves look by running the program in Listing 7.1
Moving the control points changes the shape of the curves.
A cubic curve To construct quadratic and cubic curves, give the coordinates of the end points and the control points.
For example, Click here to view code imageClick here to view code image.
You can then extend the path by calling one of the methods lineTo, quadTo, or curveTo.
These methods extend the path by a line, a quadratic curve, or a cubic curve.
For the two curve methods, supply the control points, then the end point.
For example, Click here to view code imageClick here to view code image.
It draws a line back to the starting point of the path.
To make a polygon, simply call moveTo to go to the first corner point, followed by repeated calls to lineTo to visit the other corner points.
The program in Listing 7.1 shows this in more detail.
You can call moveTo at any time to start a new path segment.
Finally, you can use the append method to add arbitrary Shape objects to a general path.
The outline of the shape is added to the end to the path.
The second parameter of the append method is true if the new shape should be connected to the last point on the path, false otherwise.
The program in Listing 7.1 lets you create sample paths.
You can pick a shape maker from the combo box.
Arcs (showing lines for the bounding rectangle and the start and end angles, in addition to the arc itself)
The program is a bit complex because it handles multiple shapes and supports dragging of the control points.
An abstract superclass ShapeMaker encapsulates the commonality of the shape maker classes.
Each shape has a fixed number of control points that the user can move around.
The toString method returns the class name so that the ShapeMaker objects can simply be dumped into a JComboBox.
To enable dragging of the control points, the ShapePanel class handles both mouse and mouse motion events.
If the mouse is pressed on top of a rectangle, subsequent mouse drags move the rectangle.
The majority of the shape maker classes are simple—their makeShape methods just construct and return the requested shapes.
However, the ArcMaker class needs to compute the distorted start and end angles.
Furthermore, to demonstrate that the computation is indeed correct, the returned shape is a GeneralPath containing the arc itself, the bounding rectangle, and the lines from the center of the arc to the angle control points (see Figure 7.9)
See Figure 7.4 for an explanation of the arcWidth and arcHeight parameters.
If connect is true, the current point of the general path is connected to the starting point of the added shape by a straight line.
In the preceding section, you saw how you can specify complex shapes by constructing general paths composed of lines and curves.
By using a sufficient number of lines and curves, you can draw essentially any shape.
For example, the shapes of characters in the fonts that you see on the screen and on your printouts are all made up of lines and cubic curves.
Occasionally, it is easier to describe a shape by composing it from areas, such as rectangles, polygons, or ellipses.
The Java 2D API supports four constructive area geometry operations that combine two areas into a new area:
Constructive area geometry operations To construct a complex area, start with a default area object.
You can stroke the boundary of the area with the draw method or paint the interior with the fill method of the Graphics2D class.
The draw operation of the Graphics2D class draws the boundary of a shape by using the currently selected stroke.
By default, the stroke is a solid line that is 1 pixel wide.
You can select a different stroke by calling the setStroke method and supplying an object of a class that implements the Stroke interface.
The Java 2D API defines only one such class, called BasicStroke.
In this section, we’ll look at the capabilities of the BasicStroke class.
For example, here is how to draw lines that are 10 pixels wide:
When a stroke is more than a pixel thick, the end of the stroke can have different styles.
A butt cap simply ends the stroke at its end point.
A round cap adds a half-circle to the end of the stroke.
A square cap adds a half-square to the end of the stroke.
End cap styles When two thick strokes meet, there are three choices for the join style (see Figure 7.12)
A bevel join joins the strokes with a straight line that is perpendicular to the bisector of the angle between the two strokes.
A round join extends each stroke to have a round cap.
A miter join extends both strokes by adding a “spike.”
The miter join is not suitable for lines that meet at small angles.
If two lines join with an angle that is less than the miter limit, a bevel join is used instead, which prevents extremely long spikes.
You can specify these choices in the BasicStroke constructor, for example: Click here to view code imageClick here to view code image.
Finally, you can create dashed lines by setting a dash pattern.
In the program in Listing 7.2, you can select a dash pattern that spells out SOS in Morse code.
The dash pattern is a float[] array of numbers that contains the lengths of the “on” and “off” intervals (see Figure 7.13)
A dash pattern You can specify the dash pattern and a dash phase when constructing the BasicStroke.
The dash phase indicates where in the dash pattern each line should start.
Click here to view code imageClick here to view code image.
End cap styles are applied to the ends of each dash in a dash pattern.
You can move the ends of the line segments to test the miter limit: Select the miter join, then move the line segment to form a very acute angle.
You will see the miter join turn into a bevel join.
The mouse listener remembers your click on the end point of a line segment, and the mouse motion listener monitors the dragging of the end point.
A set of radio buttons signal the user choices for the end cap style, join style, and solid or dashed line.
The paintComponent method of the StrokePanel class constructs a GeneralPath consisting of the two line segments that join the three points that the user can move with the mouse.
It then constructs a BasicStroke, according to the selections the user made, and finally draws the path.
BasicStroke(float width, int cap, int join, float miterlimit, float[] dash, float dashPhase) constructs a stroke object with the given attributes.
When you fill a shape, its inside is covered with paint.
Use the setPaint method to set the paint style to an object with a class that implements the Paint interface.
The GradientPaint class varies colors by interpolating between two given color values (see Figure 7.15)
The TexturePaint class fills an area with repetitions of an image (see Figure 7.16)
Texture paint You can construct a GradientPaint object by specifying two points and the colors that you want at these two points.
Colors are interpolated along the line joining the two points.
Colors are constant along lines perpendicular to that joining line.
Points beyond an end point of the line are given the color at the end point.
To construct a TexturePaint object, specify a BufferedImage and an anchor rectangle.
We will introduce the BufferedImage class later in this chapter when we discuss images in detail.
The simplest way of obtaining a buffered image is to read an image file:
The anchor rectangle is extended indefinitely in x and y directions to tile the entire coordinate plane.
The image is scaled to fit into the anchor and then replicated into each tile.
Colors are constant along lines perpendicular to the line joining the start and the end point.
By default, the gradient paint is not cyclic—that is, points beyond the start and end points are colored with the same color as the start and end point.
If the gradient paint is cyclic, then colors continue to be interpolated, first returning to the starting point color and then repeating indefinitely in both directions.
The anchor rectangle defines the tiling of the space to be painted; it is repeated indefinitely in x and y directions, and the texture image is scaled to fill each tile.
Suppose you need to draw an object, such as an automobile.
You know, from the manufacturer’s specifications, the height, wheelbase, and total length.
You could, of course, figure out all pixel positions, assuming some number of pixels per meter.
However, there is an easier way: You can ask the graphics context to carry out the conversion for you.
Click here to view code imageClick here to view code image.
The scale method of the Graphics2D class sets the coordinate transformation of the graphics context to a scaling transformation.
That transformation changes user coordinates (user-specified units) to device coordinates (pixels)
User and device coordinates Coordinate transformations are very useful in practice.
The graphics context takes care of the dirty work of transforming them to pixels.
Scaling: blowing up, or shrinking, all distances from a fixed point.
Shear: leaving one line fixed and “sliding” the lines parallel to it by an amount that is proportional to the distance from the fixed line.
Figure 7.18 shows how these four fundamental transformations act on a unit square.
The fundamental transformations The scale, rotate, translate, and shear methods of the Graphics2D class set the coordinate transformation of the graphics context to one of these fundamental transformations.
For example, you might want to rotate shapes and double their size; supply both a rotation and a scaling transformation:
In this case, it does not matter in which order you supply the transformations.
For example, if you want to rotate and shear, then it makes a difference which of the transformations you supply first.
The graphics context will apply the transformations in the order opposite to that in which you supplied them—that is, the last transformation you supply is applied first.
The last transformation (which is applied first) moves the point (x, y) to the origin.
The second transformation rotates with an angle a around the origin.
The final transformation moves the origin back to (x, y)
The overall effect is a rotation with center point (x, y)—see Figure 7.19
Since rotating about a point other than the origin is such a common operation, there is a shortcut:
Composing transformations If you know some matrix theory, you are probably aware that all rotations, translations, scalings, shears, and their compositions can be expressed by transformation matrices of the form:
In the Java 2D API, the AffineTransform class describes such a transformation.
If you know the components of a particular transformation matrix, you can construct it directly as.
Finally, the instance methods setToRotation, setToScale, setToTranslation, and setToShear set a transformation object to a new type.
However, in practice, you shouldn’t call the setTransform operation, as it replaces any existing transformation that the graphics context may have.
For example, a graphics context for printing in landscape mode already contains a 90-degree rotation transformation.
It composes the existing transformation with the new AffineTransform object.
If you just want to apply a transformation temporarily, first get the old transformation, compose it with your new transformation, and finally restore the old transformation when you are done.
Click here to view code imageClick here to view code image.
See the getXxxInstance methods for an explanation of the basic transformations and their parameters.
By setting a clipping shape in the graphics context, you constrain all drawing operations to the interior of that clipping shape.
Click here to view code imageClick here to view code image.
However, in practice, you don’t want to call the setClip operation because it replaces any existing clipping shape that the graphics context might have.
For example, as you will see later in this chapter, a graphics context for printing comes with a clip rectangle that ensures that you don’t draw on the margins.
The clip method intersects the existing clipping shape with the new one that you supply.
If you just want to apply a clipping area temporarily, you should first get the old clip, add your new clip, and finally restore the old clip when you are done: Click here to view code imageClick here to view code image.
In Figure 7.20, we show off the clipping capability with a rather dramatic drawing of a line pattern clipped by a complex shape—namely, the outline of a set of letters.
Using letter shapes to clip a line pattern To obtain the character outlines, you need a font render context.
This text layout object describes the layout of a sequence of characters, as rendered by a particular font render context.
The layout depends on the font render context—the same characters will look different on a screen or on a printer.
More important for our application, the getOutline method returns a Shape object that describes the shape of the outline of the characters in the text layout.
In that case, supply an affine transform to the getOutline operation to specify where you would like the outline to appear.
Click here to view code imageClick here to view code image.
Finally, set the clipping shape and draw a set of lines.
Click here to view code imageClick here to view code image.
TextLayout(String s, Font f, FontRenderContext context) constructs a text layout object from a given string and font, using the font render context to obtain font properties for a particular device.
In the standard RGB color model, every color is described by its red, green, and blue components.
However, it is also convenient to describe areas of an image that are transparent or partially transparent.
When you superimpose an image onto an existing drawing, the transparent pixels do not obscure the pixels under them at all, whereas partially transparent pixels are mixed with the pixels under them.
Figure 7.21 shows the effect of overlaying a partially transparent rectangle on an image.
You can still see the details of the image shine through from under the rectangle.
Overlaying a partially transparent rectangle on an image In the Java 2D API, transparency is described by an alpha channel.
Now let us look at what happens if you superimpose two shapes.
You need to blend or compose the colors and alpha values of the source and destination pixels.
Porter and Duff, two researchers in the field of computer graphics, have formulated 12 possible composition rules for this blending process.
Before going any further, we’d like to point out that only two of these rules have practical significance.
If you find the rules arcane or confusing, just use the SRC_OVER rule.
It is the default rule for a Graphics2D object, and it gives the most intuitive results.
Suppose you have a source pixel with alpha value aS.
In the image, there is already a destination pixel with alpha value aD.
The diagram in Figure 7.22 shows how to design a composition rule.
Porter–Duff composition rules As you can see, most of the rules aren’t very useful.
It doesn’t take the source color into account at all, but it uses the alpha of the source to affect the destination.
The SRC rule is potentially useful—it forces the source color to be used, turning off blending with the destination.
Use the setComposite method of the Graphics2D class to install an object of a class that implements the Composite interface.
The factory method getInstance of the AlphaComposite class yields an AlphaComposite object.
You supply the rule and the alpha value to be used for source pixels.
For example, consider the following code: Click here to view code imageClick here to view code image.
The rectangle is then painted with blue color and an alpha value of 0.5
Since the composition rule is SRC_OVER, it is transparently overlaid on the existing image.
The program in Listing 7.3 lets you explore these composition rules.
Pick a rule from the combo box and use the slider to set the alpha value of the AlphaComposite object.
Furthermore, the program displays a verbal description of each rule.
Note that the descriptions are computed from the composition rule diagrams.
For example, a "DS" in the second row stands for “blends with destination.” The program has one important twist.
There is no guarantee that the graphics context that corresponds to the screen has an alpha channel.
When pixels are deposited to a destination without an alpha channel, the pixel colors are multiplied with the alpha value and the alpha value is discarded.
Now, several of the Porter–Duff rules use the alpha values of the destination, which means a destination alpha channel is important.
For that reason, we use a buffered image with the ARGB color model to compose the shapes.
After the images have been composed, we draw the resulting image to the screen.
Click here to view code imageClick here to view code image.
The Rule class in Listing 7.5 provides a brief explanation for each.
As you run the program, move the alpha slider from left to right to see the effect on the composed shapes.
In the preceding sections you have seen that the rendering process is quite complex.
Although the Java 2D API is surprisingly fast in most cases, sometimes you would like to have control over trade-offs between speed and quality.
The setRenderingHint method of the Graphics2D class lets you set a single hint.
The hints’ keys and values are declared in the RenderingHints class.
The values that end in _DEFAULT denote the defaults that are chosen by a particular implementation as a good trade-off between performance and quality.
This technique removes the “jaggies” from slanted lines and curves.
As you can see in Figure 7.25, a slanted line must be drawn as a “staircase” of pixels.
But if, instead of drawing each pixel completely on or off, you color in the pixels that are partially covered with the color value proportional to the area of the pixel that the line covers, then the result looks much smoother.
Of course, antialiasing takes a bit longer because it has to compute all those color values.
Antialiasing For example, here is how you can request the use of antialiasing:
Click here to view code imageClick here to view code image.
You can also put a bunch of key/value hint pairs into a map and set them all at once by calling the setRenderingHints method.
Any collection class implementing the map interface will do, but you might as well use the RenderingHints class itself.
It implements the Map interface and supplies a default map implementation if you pass null to the constructor.
For example, Click here to view code imageClick here to view code image.
The program shows several rendering hints that we found beneficial.
On some platforms, fractional text metrics move the letters a bit closer together.
If m is null, a default map implementation is provided.
Prior to version 1.4, Java SE had very limited capabilities for reading and writing image files.
It was possible to read GIF and JPEG images, but there was no official support for writing images at all.
The javax.imageio package contains “out of the box” support for reading and writing several common file formats, as well as a framework that enables third parties to add readers and writers for other formats.
As of Java SE 6, the GIF, JPEG, PNG, BMP (Windows bitmap), and WBMP (wireless bitmap) file formats are supported.
In earlier versions, writing of GIF files was not supported because of patent issues.
To load an image, use the static read method of the ImageIO class:
The ImageIO class picks an appropriate reader, based on the file type.
It may consult the file extension and the “magic number” at the beginning of the file for that purpose.
If no suitable reader can be found or the reader can’t decode the file contents, the read method returns null.
Writing an image to a file is just as simple:
Here the format string is a string identifying the image format, such as "JPEG" or "PNG"
The ImageIO class picks an appropriate writer and saves the file.
For more advanced image reading and writing operations that go beyond the static read and write methods of the ImageIO class, you first need to get the appropriate ImageReader and ImageWriter objects.
The ImageIO class enumerates readers and writers that match one of the following:
The MIME standard defines common data formats such as "image/jpeg" and "application/pdf"
For example, you can obtain a reader that reads JPEG files as follows: Click here to view code imageClick here to view code image.
It is possible that the ImageIO class can locate multiple readers that can all read a particular image type.
In that case, you have to pick one of them, but it isn’t clear how you can decide which one is the best.
To find out more information about a reader, obtain its service provider interface:
Perhaps that information can help you decide among the choices, or you might just present a list of readers to your program users and let them choose.
For now, we assume that the first enumerated reader is adequate.
In the sample program in Listing 7.7, we want to find all file suffixes of all available readers so that we can use them in a file filter.
We’d like to present the user with a menu of all supported image types.
That’s not something one would want to present in a menu.
What is needed is a list of “preferred” format names.
We look up the first writer associated with each format name.
Then we ask it what its format names are, in the hope that it will list the most popular one first.
Indeed, for the JPEG writer, this works fine—it lists "JPEG" before the other options.
The PNG writer, on the other hand, lists "png" in lower case before "PNG"
We hope this behavior will be addressed at some time in the future.
In the meantime, we force all-lowercase names to upper case.
Once we pick a preferred name, we remove all alternate names from the original set.
The read method of the ImageIO class reads a single image.
To read multiple images, turn the input source (for example, an input stream or file) into an ImageInputStream.
Click here to view code imageClick here to view code image.
The second parameter indicates that the input is in “seek forward only” mode.
Otherwise, random access is used, either by buffering stream input as it is read or by using random file access.
For example, to find out the number of images in a GIF file, you need to read the entire file.
If you then want to fetch an image, the input must be read again.
This consideration is only important if you read from a stream, if the input contains multiple images, and if the image format doesn’t have the information that you request (such as the image count) in the header.
If you read from a file, simply use Click here to view code imageClick here to view code image.
Here, the parameter indicates that you allow a search of the input to determine the number of images.
Then the getNumImages method returns -1 if it can’t determine the number of images without a search.
Some files contain thumbnails—smaller versions of an image for preview purposes.
You can get the number of thumbnails of an image with the call.
Sometimes you may want to get the image size before actually getting the image—in particular, if the image is huge or comes from a slow network connection.
To write a file with multiple images, you first need an ImageWriter.
The ImageIO class can enumerate the writers capable of writing a particular image format: Click here to view code imageClick here to view code image.
Next, turn an output stream or file into an ImageOutputStream and attach it to the writer.
For example, Click here to view code imageClick here to view code image.
You can optionally supply a list of thumbnails and image metadata (such as compression algorithms and color information)
In this example, we just use null for both; see the API documentation for additional information.
The third parameter can contain an ImageWriteParam object to set image writing details such as tiling and compression; use null for default values.
The program in Listing 7.7 lets you load and save files in the formats for which the Java library supplies readers and writers.
The program displays multiple images (see Figure 7.27), but not thumbnails.
Click here to view code imageClick here to view code image.
The object can be a file, a stream, a RandomAccessFile, or another object for which a service provider exists.
Returns null if no registered service provider can handle the object.
BufferedImage read(int index) reads the image with the given image index (starting at 0)
If allowSearch is false and the number of images cannot be determined without reading forward, then -1 is returned.
BufferedImage readThumbnail(int index, int thumbnailIndex) gets the thumbnail with index thumbnailIndex of the image with the given index.
String getVersion() gets the vendor name and version of this service provider.
String[] getMIMETypes() gets the format names, file suffixes, and MIME types supported by the readers or writers that this service provider creates.
Suppose you have an image and you would like to improve its appearance.
You then need to access the individual pixels of the image and replace them with other pixels.
Or perhaps you want to compute the pixels of an image from scratch—for example, to.
The BufferedImage class gives you control over the pixels in an image, and the classes that implement the BufferedImageOp interface let you transform images.
Most of the images that you manipulate are simply read in from an image file—they were either produced by a device such as a digital camera or scanner, or constructed by a drawing program.
In this section, we’ll show you a different technique for constructing an image—namely, building it up a pixel at a time.
To create an image, construct a BufferedImage object in the usual way.
Now, call the getRaster method to obtain an object of type WritableRaster.
You will use this object to access and modify the pixels of the image.
The complexity here is that you can’t simply set the pixel to a Color value.
You must know how the buffered image specifies color values.
You have to supply them in an array of four integers:
In the lingo of the Java 2D API, these values are called the sample values of the pixel.
There are also setPixel methods that take array parameters of types float[] and double[]
You can supply batches of pixels with the setPixels method.
Specify the starting pixel position and the width and height of the rectangle that you want to set.
Then, supply an array that contains the sample values for all pixels.
For example, if your buffered image has a type of TYPE_INT_ARGB, supply the red, green, blue, and alpha value of the first pixel, then the red, green, blue, and alpha value for the second pixel, and so on.
Click here to view code imageClick here to view code image.
Supply an array of four integers to hold the sample values.
Click here to view code imageClick here to view code image.
If you use an image type other than TYPE_INT_ARGB and you know how that type represents pixel values, you can still use the getPixel/setPixel methods.
However, you have to know the encoding of the sample values in the particular image type.
If you need to manipulate an image with an arbitrary, unknown image type, then you have to work a bit harder.
Every image type has a color model that can translate between sample value arrays and the standard RGB color model.
The RGB color model isn’t as standard as you might think.
The exact look of a color value depends on the characteristics of the imaging device.
Digital cameras, scanners, monitors, and LCD displays all have their own idiosyncrasies.
As a result, the same RGB value can look quite different on different devices.
The specification is a standard method for representing any color that the human eye can perceive as a triplet of coordinates called X, Y, Z.
The Java 2D API uses that mapping when converting between RGB and other color spaces.
To find the color value of a pixel, call the getDataElements method of the Raster class.
The object that is returned by the getDataElements method is actually an array of sample values.
You don’t need to know this to process the object, but it explains why the method is called getDataElements.
The color model can translate the object to standard ARGB values.
The getRGB method returns an int value that has the alpha, red, green, and blue values packed in four blocks of eight bits each.
You can construct a Color value out of that integer with the Color(int argb, boolean hasAlpha) constructor:
To set a pixel to a particular color, reverse these steps.
The getRGB method of the Color class yields an int value with the alpha, red, green, and blue values.
Supply that value to the getDataElements method of the ColorModel class.
Pass the object to the setDataElements method of the WritableRaster class.
Click here to view code imageClick here to view code image.
To illustrate how to use these methods to build an image from individual pixels, we bow to tradition and draw a Mandelbrot set, as shown in Figure 7.28
A Mandelbrot set The idea of the Mandelbrot set is that each point of the plane is associated with a sequence of numbers.
Here is how you can construct the simplest Mandelbrot set.
For each point (a, b), look at sequences that start with (x, y) =
It turns out that if x or y ever gets larger than 2, then the sequence escapes to infinity.
Only the pixels that correspond to points (a, b) leading to a bounded sequence are colored.
The formulas for the number sequences come ultimately from the mathematics of complex numbers; we’ll just take them for granted.
For more on the mathematics of fractals, see, for example, http://classes.yale.edu/fractals.
In this program, we demonstrate how to use the ColorModel class for translating Color values into pixel data.
Just for fun, change the color type of the buffered image to TYPE_BYTE_GRAY.
You don’t need to change any other code—the color model of the image automatically takes care of the conversion from colors to sample values.
BufferedImage(int width, int height, int imageType) constructs a buffered image object.
ColorModel getColorModel() returns the color model of this buffered image.
WritableRaster getRaster() gets the raster for accessing and modifying pixels of this buffered image.
If data is not null, it is assumed to be an array that is appropriate for holding sample data, and it is filled.
Its element type and length depend on the color model.
If sampleValues is not null, it is assumed to be sufficiently long for holding the sample values, and it is filled.
These methods are only useful if you know the meaning of the sample values for a color model.
Its element type and length depend on the color model.
These methods are only useful if you know the encoding of the sample values for a color model.
Its element type and length depend on the color model.
Color(int argb, boolean hasAlpha) 1.21.2 creates a color with the specified combined ARGB value if hasAlpha is true, or the specified RGB value if hasAlpha is false.
In the preceding section, you saw how to build up an image from scratch.
However, often you want to access image data for a different reason: You already have an image and you want to improve it in some way.
But fortunately, the Java 2D API already supplies a number of filters that carry out common image processing operations for you.
After you construct the operation, you simply call the filter method to transform an image into another.
Click here to view code imageClick here to view code image.
The AffineTransformOp carries out an affine transformation on the pixels.
For example, here is how you can rotate an image about its center: Click here to view code imageClick here to view code image.
The AffineTransformOp constructor requires an affine transform and an interpolation strategy.
Interpolation is necessary to determine pixels in the target image if the source pixels are transformed somewhere between target pixels.
For example, if you rotate source pixels, then they will generally not fall exactly onto target pixels.
A rotated image The RescaleOp carries out a rescaling operation.
You can also supply separate scaling values for each color component—see the API notes.
The LookupOp operation lets you specify an arbitrary mapping of sample values.
Supply a table that specifies how each value should be mapped.
In the example program, we compute the negative of all colors, changing the color c to 255 – c.
The LookupOp constructor requires an object of type LookupTable and a map of optional hints.
The LookupTable class is abstract, with two concrete subclasses: ByteLookupTable and ShortLookupTable.
Since RGB color values are bytes, a ByteLookupTable should suffice.
Here is how we construct the LookupOp for the example program: Click here to view code imageClick here to view code image.
The lookup is applied to each color component separately, but not to the alpha component.
You can also supply different lookup tables for each color component—see the API notes.
You cannot apply a LookupOp to an image with an indexed color model.
In those images, each sample value is an offset into a color palette.
The most powerful of the transformations is the ConvolveOp, which carries out a mathematical convolution.
We do not want to get too deeply into the mathematical details, but the basic idea is simple.
Blurring an image The blurring is achieved by replacing each pixel with the average value from the pixel and its eight neighbors.
Intuitively, it makes sense why this operation would blur out the picture.
Mathematically, the averaging can be expressed as a convolution operation with the following kernel:
The kernel of a convolution is a matrix that tells what weights should be applied to the neighboring values.
A different kernel carries out edge detection, locating areas of color changes:
Edge detection is an important technique for analyzing photographic images (see Figure 7.31)
Edge detection and inversion To construct a convolution operation, you first set up an array of the values for the kernel and construct a Kernel object.
Then, construct a ConvolveOp object from the kernel and use it for filtering.
The program in Listing 7.9 allows a user to load in a GIF or JPEG image and carry out the image manipulations that we discussed.
Thanks to the power of the image operations provided by Java 2D API, the program is very simple.
If dest is null, a new destination image is created.
The offset is subtracted from the input before the lookup.
The values in the first constructor are applied to all color components but not the alpha component.
When using the second constructor, you supply either the values for each color component, in which case the alpha component is unaffected, or the values for both alpha and color components.
The offset is subtracted from the input before the lookup.
The values in the first constructor are applied to all color components but not the alpha component.
When using the second constructor, you supply either the values for each color component, in which case the alpha component is unaffected, or the values for both alpha and color components.
ConvolveOp(Kernel kernel, int edgeCondition, RenderingHints hints) constructs a convolution operator.
Edge values need to be treated specially because they don’t have sufficient neighboring values to compute the convolution.
Kernel(int width, int height, float[] matrixElements) constructs a kernel for the given matrix.
The original JDK had no support for printing at all.
It was not possible to print from applets, and you had to get a thirdparty library if you wanted to print from an application.
The 1.1 printing model was designed to allow browser vendors to print the surface of an applet as it appears on a web page (which, however, the browser vendors have not embraced)
Java SE 1.4 added important enhancements, such as discovery of printer features and streaming print jobs for server-side print management.
In this section, we will show you how you can easily print a drawing on a single sheet of paper, how you can manage a multipage printout, and how you can benefit from the elegance of the Java 2D imaging model and easily generate a print preview dialog box.
In this section, we will tackle what is probably the most common printing situation: printing a 2D graphic.
Of course, the graphic can contain text in various fonts or even consist entirely of text.
To generate a printout, you have to take care of these two tasks:
The Printable interface has a single method: int print(Graphics g, PageFormat format, int page)
That method is called whenever the print engine needs to have a page formatted for printing.
Your code draws the text and the images to be printed onto the graphics context.
The page format tells you the paper size and the print margins.
First, call the static getPrinterJob method to get a print job object.
Then set the Printable object that you want to print.
Before starting the print job, you should call the printDialog method to display a print dialog box (see Figure 7.32)
That dialog box gives the user a chance to select the printer to be used (in case multiple printers are available), the page range that should be printed, and various printer settings.
Add attribute settings and pass the attributes object to the printDialog method.
The printDialog method returns true if the user clicked OK and false if the user canceled the dialog box.
If the user accepted, call the print method of the PrinterJob class to start the printing process.
Prior to JDK 1.4, the printing system used the native print and page setup dialog boxes of the host platform.
To show a native print dialog box, call the printDialog method with no parameters.
There is no way to collect user settings in an attribute set.
During printing, the print method of the PrinterJob class makes repeated calls to the print method of the Printable object associated with the job.
Since the job does not know how many pages you want to print, it simply keeps calling the print method.
Therefore, the print job doesn’t have an accurate page count until after the printout is complete.
During the printing process, the print job repeatedly calls the print method of the Printable object.
The print job is allowed to make multiple calls for the same page.
You should therefore not count pages inside the print method but always rely on the page number parameter.
There is a good reason why the print job might call the print method repeatedly for the same page.
Some printers, in particular dot-matrix and inkjet printers, use banding.
They print one band at a time, advance the paper, and then print the next band.
The print job might use banding even for laser printers that print a full page at a time—it gives the print job a way of managing the size of the spool file.
If the print job needs the Printable object to print a band, it sets the clip area of the graphics context to the requested band and calls the print method.
Its drawing operations are clipped against the band rectangle, and only those drawing elements that show up in the band are rendered.
Your print method need not be aware of that process, with one caveat: It should not interfere with the clip area.
The Graphics object that your print method gets is also clipped against the page margins.
If you replace the clip area, you can draw outside the margins.
Especially in a printer graphics context, the clipping area must be respected.
Call clip, not setClip, to further restrict the clipping area.
If you must remove a clip area, make sure to call getClip at the beginning of your print method and restore that clip area.
The graphics context that you receive in the print method is clipped to exclude the margins, but the origin of the coordinate system is nevertheless the top left corner of the paper.
It makes sense to translate the coordinate system to start at the top left corner of the imageable area.
If you want your users to choose the settings for the page margins or to switch between portrait and landscape orientation without setting other printing attributes, you can call the pageDialog method of the PrinterJob class:
One of the tabs of the print dialog box contains the page setup dialog (see Figure 7.34)
You might still want to give users an option to set the page format before printing, especially if your program presents a “what you see is what you get” display of the pages to be printed.
The pageDialog method returns a PageFormat object with the user settings.
Both the paintComponent and the print methods call the same method to carry out the actual drawing.
Click here to view code imageClick here to view code image.
This example displays and prints the image shown in Figure 7.20 on p.
Click the Print button to start printing, or click the Page setup button to open the page setup dialog box.
To show a native page setup dialog box, pass a default PageFormat object to the pageDialog method.
The method clones that object, modifies it according to the user selections in the dialog box, and returns the cloned object.
PageFormat defaultPage() returns the default page format for this printer.
The first method displays a cross-platform dialog box, the second a native dialog box.
The first method modifies the attributes object to reflect the user settings.
Both methods return true if the user accepts the dialog box.
The first method displays a cross-platform dialog box, the second a native dialog box.
Both methods return a PageFormat object with the format that the user requested in the dialog box.
The first method modifies the attributes object to reflect the user settings.
Page orientation is transparent to programmers because the page format and graphics context settings automatically reflect the page orientation.
In practice, you usually shouldn’t pass a raw Printable object to a print job.
Instead, you should obtain an object of a class that implements the Pageable interface.
A book is made up of sections, each of which is a Printable object.
To make a book, add Printable objects and their page counts.
Click here to view code imageClick here to view code image.
Now the print job knows exactly how many pages to print, so the print dialog box displays an accurate page range and the user can select the entire range or subranges.
When the print job calls the print methods of the Printable sections, it passes the current page number of the book, and not of each section, as the current page number.
That is a huge pain—each section must know the page counts of the preceding sections to make sense of the page number parameter.
From your perspective as a programmer, the biggest challenge of using the Book class is that you must know how many pages each section will have when you print it.
Your Printable class needs a layout algorithm that computes the layout of the material on the printed pages.
Before printing starts, invoke that algorithm to compute the page breaks and the page count.
You can retain the layout information so you have it handy during the printing process.
You must guard against the possibility that the user has changed the page format.
If that happens, you must recompute the layout, even if the information that you want to print has not changed.
This program prints a message in very large characters on a number of pages (see Figure 7.35)
You can then trim the margins and tape the pages together to form a banner.
A banner The layoutPages method of the Banner class computes the layout.
We first lay out the message string in a 72-point font.
We then compute the height of the resulting string and compare it with the imageable height of the page.
When printing the string, we magnify it by that scale factor.
To lay out your information precisely, you usually need access to the printer graphics context.
Unfortunately, there is no way to obtain that graphics context before printing actually starts.
In our example program, we make do with the screen graphics context and hope that the font metrics of the screen and printer match.
The getPageCount method of the Banner class first calls the layout method.
Then it scales up the width of the string and divides it by the imageable width of each page.
The quotient, rounded up to the next integer, is the page count.
It sounds like it might be difficult to print the banner because characters can be broken across multiple pages.
However, thanks to the power of the Java 2D API, this turns out not to be a problem at all.
When a particular page is requested, we simply use the translate method of the Graphics2D class to shift the top left corner of the string to the left.
Then, we set a clip rectangle that equals the current page (see Figure 7.36)
Finally, we scale the graphics context with the scale factor that the layout method computed.
Printing a page of a banner This example shows the power of transformations.
The drawing code is kept simple, and the transformation does all the work of placing the drawing at the appropriate place.
Finally, the clip cuts away the part of the image that falls outside the page.
In the next section, you will see another compelling use of transformations—to display a print preview.
Most professional programs have a print preview mechanism that lets you look at your pages on the screen so that you won’t waste paper on a printout that you don’t like.
The printing classes of the Java platform do not supply a standard “print preview” dialog box, but it is easy to design your own (see Figure 7.37)
The PrintPreviewDialog class in Listing 7.14 is completely generic—you can reuse it to preview any kind of printout.
As you use the Next and Previous buttons to flip through the pages, the paintComponent method calls the print method of the Printable object for the requested page.
Normally, the print method draws the page context on a printer graphics context.
However, we supply the screen graphics context, suitably scaled so that the entire printed page fits inside a small screen rectangle.
The print method never knows that it doesn’t actually produce printed pages.
It simply draws onto the graphics context, producing a microscopic print preview on the screen.
This is a compelling demonstration of the power of the Java 2D imaging model.
Listing 7.12 contains the code for the banner printing program.
Type “Hello, World!” into the text field and look at the print preview, then print the banner.
If the page count is not specified, the first page is added.
Printable getPrintable(int page) gets the printable for the specified page.
So far, you have seen how to print 2D graphics.
However, the printing API introduced in Java SE 1.4 affords far greater flexibility.
The API defines a number of data types and lets you find print services that are able to print them.
Objects of a class that implements Printable, Pageable, or RenderableImage.
The data themselves can be stored in a source of bytes or characters such as an input stream, a URL, or an array.
A document flavor describes the combination of a data source and a data type.
The DocFlavor class defines a number of inner classes for the various data sources.
Each of the inner classes defines constants to specify the flavors.
Suppose you want to print a GIF image located in a file.
First, find out whether there is a print service that is capable of handling the task.
Click here to view code imageClick here to view code image.
If the lookup yields an array with more than one element, you select from the listed print services.
You can call the getName method of the PrintService class to get the printer names, and then let the user choose.
For printing, you need an object that implements the Doc interface.
The Java library supplies a class SimpleDoc for that purpose.
The SimpleDoc constructor requires the data source object, the document flavor, and an optional attribute set.
For example, Click here to view code imageClick here to view code image.
As before, the null parameter can be replaced by an attribute set.
Note that this printing process is quite different from that of the preceding section.
For example, you can implement a server-side printing mechanism in which users submit print jobs through a web form.
The program in Listing 7.16 demonstrates how to use a print service to print an image file.
DocPrintJob createPrintJob() creates a print job for printing an object of a class that implements the Doc interface, such as a SimpleDoc.
SimpleDoc(Object data, DocFlavor flavor, DocAttributeSet attributes) constructs a SimpleDoc object that can be printed with a DocPrintJob.
A stream print service generates the same print data but instead sends them to a stream, perhaps for delayed printing or because the print data format can be interpreted by other programs.
In particular, if the print data format is PostScript, it may be useful to save the print data to a file because many programs can process PostScript files.
The Java platform includes a stream print service that can produce PostScript output from images and 2D graphics.
You can use that service on all systems, even if there are no local printers.
Enumerating stream print services is a bit more tedious than locating regular print services.
You need both the DocFlavor of the object to be printed and the MIME type of the stream output.
Click here to view code imageClick here to view code image.
We call the getPrintService method with an output stream parameter to get a StreamPrintService object.
To produce a printout, simply follow the steps of the preceding section.
The print service API contains a complex set of interfaces and classes to specify various kinds of attributes.
Print request attributes request particular features for all doc objects in a print job, such as two-sided printing or the paper size.
Doc attributes are request attributes that apply only to a single doc object.
The other two attributes contain information about the printer and job status.
Print service attributes give information about the print service, such as the printer make and model or whether the printer is currently accepting jobs.
Print job attributes give information about the status of a particular print job, such as whether the job is already completed.
Individual attribute classes implement one or more of these interfaces.
For example, objects of the Copies class describe the number of copies of a printout.
Clearly, a print request can contain a request for multiple copies.
Conversely, an attribute of the print job might be how many of these copies were actually printed.
That number might be lower, perhaps because of printer limitations or because the printer ran out of paper.
Figure 7.38 shows a class diagram of the attribute hierarchy.
The attribute hierarchy In addition to the interfaces and classes for individual attributes, the print service API defines interfaces and classes for attribute sets.
Figure 7.39 shows a class diagram of the attribute set hierarchy.
The attribute set hierarchy For example, you can construct a print request attribute set like this:
After constructing the set, you are freed from worrying about the Hash prefix.
Why have all these interfaces? They make it possible to check for correct attribute usage.
For example, a DocAttributeSet accepts only objects that implement the DocAttribute interface.
Any attempt to add another attribute results in a runtime error.
An attribute set is a specialized kind of map where the keys are of type Class and the values belong to a class that implements the Attribute interface.
The Copies class defines the method to return the object Copies.class, but it isn’t a requirement that the category be the same as the class of the attribute.
When an attribute is added to an attribute set, the category is extracted automatically.
If you subsequently add another attribute with the same category, it overwrites the first one.
To retrieve an attribute, you need to use the category as the key, for example: Click here to view code imageClick here to view code image.
Finally, attributes are organized by the values they can have.
The Copies class extends the IntegerSyntax class that takes care of all integer-valued attributes.
The getValue method returns the integer value of the attribute, for example:
Finally, many attributes can take a finite number of values.
For example, the PrintQuality attribute has three settings: draft, normal, and high.
Attribute classes with a finite number of values extend the EnumSyntax class, which provides a number of convenience methods to set up these enumerations in a typesafe manner.
You need not worry about the mechanism when using such an attribute.
The second column lists the superclass of the attribute class (for example, IntegerSyntax for the Copies attribute) or the set of enumeration values for the attributes with a finite set of values.
As you can see, there are lots of attributes, many of which are quite specialized.
An earlier version of the printing API introduced the JobAttributes and PageAttributes classes, whose purpose was similar to the printing attributes covered in this section.
If the set has another attribute with the same category, that attribute is replaced by the given attribute.
Returns true if the set changed as a result of this operation.
Attribute get(Class category) retrieves the attribute with the given category key, or null if no such attribute exists.
Returns true if the set changed as a result of this operation.
Attribute[] toArray() returns an array with all attributes in this set.
You now know how to print 2D graphics and other document types, how to enumerate printers and stream print services, and how to set and retrieve attributes.
Next, we turn to two important user interface issues: the clipboard and the drag-and-drop mechanism.
One of the most useful and convenient user interface mechanisms of GUI environments (such as Windows and the X Window System) is cut and paste.
You select some data in one program and cut or copy them to the clipboard.
Then, you switch to another program and paste the clipboard contents into that application.
Using the clipboard, you can transfer text, images, or other data from one document to another or, of course, from one place in a document to another in the same document.
Cut and paste is so natural that most computer users never think about it.
Even though the clipboard is conceptually simple, implementing clipboard services is actually harder than you might think.
Suppose you copy text from a word processor to the clipboard.
If you paste that text into another word processor, you expect the fonts and formatting to stay intact.
That is, the text in the clipboard needs to retain the formatting information.
However, if you paste the text into a plain text field, you expect that just the characters are pasted in, without additional.
To support this flexibility, the data provider must be able offer the clipboard data in multiple formats, so the data consumer can pick one of them.
The system clipboard implementations of Microsoft Windows and the Macintosh are similar, but, of course, there are slight differences.
However, the X Window System clipboard mechanism is much more limited—cutting and pasting of anything but plain text is only sporadically supported.
You should consider these limitations when trying out the programs in this section.
Often, programs need to support cut and paste of data types that the system clipboard cannot handle.
The data transfer API supports the transfer of arbitrary local object references in the same virtual machine.
Between different virtual machines, you can transfer serialized objects and references to remote objects.
Table 7.5 summarizes the data transfer capabilities of the clipboard mechanism.
Here is an overview of the most important classes and interfaces of that package:
Objects that can be transferred via a clipboard must implement the Transferable interface.
Transferable objects are the only items that can be put on or taken off a clipboard.
The system clipboard is a concrete example of a Clipboard.
The DataFlavor class describes data flavors that can be placed on the clipboard.
The StringSelection class is a concrete class that implements the Transferable interface.
A class must implement the ClipboardOwner interface if it wants to be notified when the clipboard contents have been overwritten by someone else.
If a program transfers simple data (such as a string), it simply sets the clipboard contents and moves on.
However, if a program places onto the clipboard complex data that can be formatted in multiple flavors, then it might not actually want to prepare all the flavors, because there is a good chance that most of them will be never needed.
However, it then needs to hang on to the clipboard data so it can create the flavors later when they are requested.
The clipboard owner is notified (by a call to its lostOwnership method) when the contents of the clipboard change.
That tells it that the information is no longer needed.
In our sample programs, we don’t worry about clipboard ownership.
The best way to get comfortable with the data transfer classes is to start with the simplest situation: transferring text to and from the system clipboard.
For strings to be transferred to the clipboard, they must be wrapped into StringSelection objects.
Click here to view code imageClick here to view code image.
The actual transfer is done by a call to setContents, which takes a StringSelection object and a ClipBoardOwner as parameters.
If you are not interested in designating a clipboard owner, set the second parameter to null.
Here is the reverse operation—reading a string from the clipboard: Click here to view code imageClick here to view code image.
Listing 7.17 is a program that demonstrates cutting and pasting between a Java application and the system clipboard.
If you select some text in the text area and click Copy, the selection is copied to the system clipboard.
You can then paste it into any text editor (see Figure 7.40)
Conversely, when you copy text from the text editor, you can paste it into our sample program.
In addition, every data flavor has a human-readable name (such as "GIF Image")
There is no standard data flavor for transferring GIF image data.
If no class parameter is given, then the representation class is InputStream.
Three MIME types are defined for transferring local, serialized, and remote Java objects:
The x- prefix indicates that this is an experimental name, not one that is sanctioned by IANA, the organization that assigns standard MIME type names.
The listener is notified when the collection of data flavors on the clipboard changes.
String getMimeType() returns the MIME type string for this data flavor.
This is either the class parameter of the MIME type or InputStream.
Objects that you want to transfer via the clipboard must implement the Transferable interface.
The StringSelection class is currently the only public class in the Java standard library that implements the Transferable interface.
In this section, you will see how to transfer images into the clipboard.
Since Java does not supply a class for image transfer, you must implement it yourself.
Click here to view code imageClick here to view code image.
Curiously, however, it does not supply the wrapper class that is necessary to place images onto the clipboard.
The program in Listing 7.18 demonstrates the transfer of images between a Java application and the system clipboard.
When the program starts, it generates an image containing a red circle.
Click the Copy button to copy the image to the clipboard and then paste it into another application (see Figure 7.41)
From another application, copy an image into the system clipboard.
Then click the Paste button and see the image being pasted into the example program (see Figure 7.42)
Copying from a Java program to a native programFigure 7.41
Copying from a native program to a Java programFigure 7.42
Copying from a native program to a Java program The program is a straightforward modification of the text transfer program.
Suppose you want to copy and paste objects from one Java application to another.
You can accomplish this task by placing serialized Java objects onto the system clipboard.
The Copy button copies the current color to the system clipboard as a serialized Color object.
The Paste button checks whether the system clipboard contains a serialized Color object.
If so, it fetches the color and sets it as the current choice of the color chooser.
You can transfer the serialized object between two Java applications (see Figure 7.43)
Click Copy in the first program, then click Paste in the second program.
The Color object is transferred from one virtual machine to the other.
Data are copied between two instances of a Java application.
To enable data transfer, the Java platform places the binary data of the serialized object on the system clipboard.
Another Java program—not necessarily of the same type as the one that generated the clipboard data—can retrieve the clipboard data and deserialize the object.
Of course, a non-Java application will not know what to do with the clipboard data.
The text is simply the result of the toString method, applied to the transferred object.
To see the second flavor, run the program, click on a color, and then select the Paste command in your text editor.
Essentially no additional programming is required to transfer a serializable object.
As before, you have to build your own transfer wrapper—see the example code for details.
Occasionally, you might need to copy and paste a data type that isn’t one of the data types supported by the system clipboard and that isn’t serializable.
To transfer an arbitrary Java object reference within the same JVM, use the MIME type.
The process is entirely analogous to the SerialTransferable wrapper of the preceding example.
An object reference is only meaningful within a single virtual machine.
For that reason, you cannot copy the shape object to the system clipboard.
You need to synchronize the local and the system clipboard, so that users don’t confuse the two.
Currently, the Java platform doesn’t do that synchronization for you.
Clipboard(String name) constructs a local clipboard with the given name.
When you use cut and paste to transmit information between two programs, the clipboard acts as an intermediary.
The drag and drop metaphor cuts out the middleman and lets two programs communicate directly.
The Java platform offers basic support for drag and drop.
You can carry out drag and drop operations between Java applications and native applications.
This section shows you how to write a Java application that is a drop target, and an application that is a drag source.
Before going deeper into the Java platform support for drag and drop, let us quickly look at the drag-and-drop user interface.
We use the Windows Explorer and WordPad programs as examples—on another platform, you can experiment with locally available programs with drag-and-drop capabilities.
You initiate a drag operation with a gesture inside a drag source—by first selecting one or more elements and then dragging the selection away from its initial location.
When you release the mouse button over a drop target that accepts the drop operation, the drop target queries the drag source for information about the dropped elements and carries out an appropriate operation.
For example, if you drop a file icon from a file manager on top of a directory icon, the file is moved into that directory.
However, if you drag it to a text editor, the text editor opens the file.
If you hold down the Ctrl key while dragging, the type of the drop action changes from a move action to a copy action, and a copy of the file is placed into the directory.
If you hold down both Shift and Ctrl keys, then a link to the file is placed into the directory.
Other platforms might use other keyboard combinations for these operations.
Thus, there are three types of drop actions with different gestures:
The intention of the link action is to establish a reference to the dropped element.
Such links typically require support from the host operating system (such as symbolic links for files, or object links for document components) and don’t usually make a lot of sense in cross-platform programs.
In this section, we focus on using drag and drop for copying and moving.
There is usually some visual feedback for the drag operation.
As the cursor moves over possible drop targets, the cursor shape indicates whether the drop is possible or not.
If a drop is possible, the cursor shape also indicates the type of the drop action.
For example, you can select text in WordPad or gedit and drag it.
Try dropping text fragments into willing drop targets and see how they react.
This experiment shows a disadvantage of drag and drop as a user interface mechanism.
It can be difficult for users to anticipate what they can drag, where they can drop it, and what happens when they do.
Because the default “move” action can remove the original, many users are understandably cautious about experimenting with drag and drop.
You can drag selected text from a number of components, and you can drop text into text components.
For backward compatibility, you must call the setDragEnabled method to activate dragging.
The java.awt.dnd package provides a lower-level drag-and-drop API that forms the basis for the Swing drag and drop.
You can select multiple items in the list, table, or tree (see Listing 7.21) and drag them.
You first select with the mouse, then let go of the mouse button, then click it again, and then you drag.
When you drop the items in the text area, you can see how the dragged information is formatted.
Table cells are separated by tabs, and each selected row is on a separate line (see Figure 7.44)
You can only copy, not move, items from the list, table, tree, file chooser, or color chooser.
Removing items from a list, table, or tree is not possible with all data models.
You will see in the next section how to implement this capability when the data model is editable.
You cannot drag into the list, table, tree, or file chooser.
If you run two copies of the program, you can drag a color from one color chooser to the other.
You cannot drag text out of the text area because we didn’t call setDragEnabled on it.
The Swing package provides a potentially useful mechanism to quickly turn a component into a drag source and drop target.
You can install a transfer handler for a given property.
You can now drag a color into the text field, and its background color changes.
When a drop occurs, then the transfer handler checks whether one of the data flavors has representation class Color.
By installing this transfer handler into the text field, you disable the standard transfer handler.
You can no longer cut, copy, paste, drag, or drop text in the text field.
However, you can now drag color out of this text field.
You still need to select some text to initiate the drag gesture.
When you drag the text, you will find that you can drop it into the color chooser and change its color value to the text field’s background color.
However, you cannot drop the text into the text area.
Click here to view code imageClick here to view code image.
In the previous section, you saw how to take advantage of the basic drag-and-drop support in Swing.
In this section, we’ll show you how to configure any component as a drag source.
In the next section, we’ll discuss drop targets and present a sample component that is both a source and a target for images.
To customize the drag-and-drop behavior of a Swing component, subclass the TransferHandler class.
First, override the getSourceActions method to indicate which actions (copy, move, link) your component supports.
Next, override the createTransferable method that produces a Transferable object, following the same process that you use for copying to the clipboard.
In our sample program, we drag images out of a JList that is filled with image icons (see Figure 7.45)
The selected image is simply placed into an ImageTransferable wrapper.
The ImageListImageList drag-and-drop application drag-and-drop application Click here to view code imageClick here to view code image.
In our example, we are fortunate that a JList is already wired for initiating a drag gesture.
If you add drag support to a component that does not recognize a drag gesture, you need to initiate the transfer yourself.
For example, here is how you can initiate dragging on a JLabel: Click here to view code imageClick here to view code image.
Here, we simply start the transfer when the user clicks on the label.
A more sophisticated implementation would watch for a mouse motion that drags the mouse by a small amount.
When the user completes the drop action, the exportDone method of the source transfer handler is invoked.
In that method, you need to remove the transferred object if the user carried out a move action.
Here is the implementation for the image list: Click here to view code imageClick here to view code image.
To summarize, to turn a component into a drag source, you have to add a transfer handler that specifies the following:
How the original data is removed after a move action.
In addition, if your drag source is a component other than those listed in Table 7.7 on p.
In this section, we’ll show you how to implement a drop target.
We’ll add drop support so that users can drop images into the list.
To make a component into a drop target, set a TransferHandler and implement the canImport and importData methods.
This is most commonly used for dropping files into an application.
Valid drop locations include the frame decorations and the menu bar, but not components contained in the frame (which have their own transfer handlers)
The canImport method is called continuously as the user moves the mouse over the drop target component.
This information affects the cursor icon that gives visual feedback whether the drop is allowed.
Through this parameter, you can obtain the drop action chosen by the user, the drop location, and the data to be transferred.
Before Java SE 6, a different canImport method was called that only supplies a list of data flavors.
In the canImport method, you can also override the user drop action.
For example, if a user chose the move action but it would be inappropriate to remove the original, you can force the transfer handler to use a copy action instead.
The image list component is willing to accept drops of file lists and images.
However, if a file list is dragged into the component, a user-selected MOVE action is changed into a COPY action, so that the image files do not get deleted.
A more sophisticated implementation could check that the files actually contain images.
The Swing components JList, JTable, JTree, and JTextComponent give visual feedback about insertion positions as the mouse is moved over the drop target.
By default, the selection (for JList, JTable, and JTree) or the caret (for JTextComponent) is used to indicate the drop location.
That approach is neither user-friendly nor flexible, and it is the default solely for backward compatibility.
You should call the setDropMode method to choose a more appropriate visual feedback.
You can control whether the dropped data should overwrite existing items or be inserted between them.
Table 7.8 shows the drop modes supported by the Swing components.
Visual indicators for dropping onto an item and between two itemsFigure 7.46
Visual indicators for dropping onto an item and between two items.
Once the user completes the drop gesture, the importData method is invoked.
You need to obtain the data from the drag source.
Invoke the getTransferable method on the TransferSupport parameter to obtain a reference to a Transferable object.
This is the same interface that is used for copy and paste.
One data type that is commonly used for drag and drop is the DataFlavor.
A file list describes a set of files that is dropped onto the target.
Here is the code for retrieving the files: Click here to view code imageClick here to view code image.
When dropping into one of the components listed in Table 7.8, you need to know precisely where to drop the data.
Invoke the getDropLocation method on the TransferSupport parameter to find where the drop occurred.
The JList, JTable, JTree, and JTextComponent classes define subclasses that specify location in the particular data model.
For example, a location in a list is simply an integer index, but a location in a tree is a tree path.
Here is how we obtain the drop location in our image list: Click here to view code imageClick here to view code image.
The importData method is also called when data is pasted into the component with the Ctrl+V keystroke.
Therefore, if the isDrop method returns false, we simply append the pasted data to the end of the list.
When inserting into a list, table, or tree, you also need to check whether the data is supposed to be inserted between items or whether it should replace the item at the drop location.
For the other components, see the API notes for their drop location classes at the end of this section.
To summarize, to turn a component into a drop target, add a transfer handler that specifies the following:
In addition, if you add drop support to a JList, JTable, JTree, or JTextComponent, you should set the drop mode.
Note that the ImageList class is both a drag source and a drop target.
You can also drag image files from a file chooser of another program into the lists.
DataFlavor[] getDataFlavors() gets the data flavors of the data to be transferred.
Initially, this is the user drop action, but it can be overridden by the transfer handler.
Point getDropPoint() gets the mouse location of the drop in the target component.
We finish this chapter with several features for making Java applications feel more like native applications.
The splash screen feature allows your application to display a splash screen as the virtual machine starts up.
Finally, you now have access to the system tray and can clutter it up with icons, just like so many native applications do.
A common complaint about Java applications is their long startup time.
The Java virtual machine takes some time to load all required classes, particularly for a Swing application that needs to pull in large amounts of Swing and AWT library code.
Users dislike applications that take a long time to bring up an initial screen, and they might even try launching the application multiple times if they suspect the first launch was unsuccessful.
The remedy is a splash screen—a small window that appears quickly, telling the user that the application has been launched successfully.
Of course, you can put up a window as soon as your main method starts.
However, the main method is only launched after the class loader has loaded all dependent classes, which might take a while.
Instead, you can ask the virtual machine to show an image immediately on launch.
The image is displayed immediately and automatically disappears when the first AWT window is made visible.
Animation (in GIF) and transparency (GIF and PNG) are supported.
If your application is ready to go as soon as it reaches main, you can skip the remainder of this section.
However, many applications use a plug-in architecture in which a small core loads a set of plugins at startup.
In that case, you can indicate the loading progress on the splash screen.
You can draw directly on the splash screen, or you can replace it with a borderless frame with identical contents and then draw inside the frame.
To draw directly on the splash screen, get a reference to the splash screen and get its graphics context and dimensions: Click here to view code imageClick here to view code image.
When you are done, call update to ensure that the drawing is refreshed.
Our sample program draws a simple progress bar, as seen in the left image in Figure 7.47
Click here to view code imageClick here to view code image.
The initial splash screen and a borderless follow-up windowFigure 7.47
The splash screen is a singleton object.You cannot construct your own.
If no splash screen was set on the command line or in the manifest, the getSplashScreen method returns null.
It is tedious to compute all pixel positions, and your progress indicator won’t match the native progress bar.
To avoid these problems, you can replace the initial splash screen with a follow-up window of the same size and content as soon as the main method starts.
The right image in Figure 7.47 shows a borderless frame with a panel that paints the splash screen and contains a JProgressBar.
Now we have full access to the Swing API and can easily add message strings without having to fuss with pixel positions.
Note that we do not need to remove the initial splash screen.
It is automatically removed as soon as the follow-up window is made visible.
Unfortunately, there is a noticeable flash when the splash screen is replaced by the follow-up window.
Graphics2D createGraphics() gets a graphics context for drawing on the splash screen.
The splash screen is automatically closed when the first AWT window is made visible.
You can also open, edit, and print files, using the applications that are registered for the file type.
If it returns true, the current platform supports the launching of desktop applications.
Then call the static getDesktop method to obtain a Desktop instance.
For example, in the Gnome desktop on Linux, it is possible to open files, but you cannot print them.
To find out what is supported on your platform, call the isSupported method, passing a value in the Desktop.Action enumeration.
To open, edit, or print a file, first check that the action is supported, and then call the open, edit, or print method.
You can simply call the URI constructor with a string containing an http or https URL.
To launch the default e-mail program, you need to construct a URI of a particular format, namely.
Unfortunately, the URI class does not know anything about mailto URIs, so you have to assemble and encode your own.
The second version can be used to fill in parts of the e-mail message.
Many desktop environments have an area for icons of programs that run in the background and occasionally notify users of events.
In Windows, this area is called the system tray, and the icons are called tray icons.
A typical example of such a program is a monitor that checks for software updates.
If new updates are available, the monitor program can change the appearance of the icon or display a message near the icon.
Frankly, the system tray is somewhat overused, and computer users are not usually filled with joy when they discover yet another tray icon.
Our sample system tray application—a program that dispenses virtual fortune cookies—is no exception to that rule.
As in the Desktop class discussed in the preceding section, you first call the static isSupported method to check that the local Java platform supports the system tray.
If so, you get a SystemTray singleton by calling the static getSystemTray method.
The most important method of the SystemTray class is the add method that lets you add a TrayIcon instance.
The tooltip that is visible when the mouse hovers over the icon.
The pop-up menu that is displayed when the user clicks on the icon with the right mouse button.
The pop-up menu is an instance of the PopupMenu class of the AWT library, representing a native pop-up menu, not a Swing menu.
Fill it out with AWT MenuItem instances, each having an action listener just like the Swing counterpart.
Finally, a tray icon can display notifications to the user (see Figure 7.49)
Call the displayMessage method of the TrayIcon class and specify the caption, message, and message type.
A notification from a tray icon Listing 7.25 shows the application that places a fortune cookie icon into the system tray.
The program reads a fortune cookie file (from the venerable UNIX fortune program) in which each fortune is terminated by a line containing a % character.
Mercifully, there is a pop-up menu with a command to exit the application.
If only all tray icons were so considerate! Listing 7.25
Dimension getTrayIconSize() gets the dimensions for an icon in the system tray.
TrayIcon(Image image, String tooltip, PopupMenu popupMenu) constructs a tray icon with the given image, tooltip, and pop-up menu.
If set, the image is scaled to fit the tooltip icon area; if not (the default), it is cropped (if too large) or centered (if too small)
Typical cases are clicking on a notification or double-clicking on the tray icon.
You have now reached the end of this long chapter covering advanced AWT features.
In the next chapter, we will discuss the JavaBeans specification and its use for GUI builders.
The official definition of a bean, as given in the JavaBeans specification, is: “A bean is a reusable software component based on Sun’s JavaBeans specification that can be manipulated visually in a builder tool.” Once you implement a bean, others can use it in a builder environment (such as NetBeans)
Instead of having to write tedious code, they can simply drop your bean into a GUI form and customize it with dialog boxes.
This chapter explains how you can implement beans so that other developers can use them easily.
We’d like to address a common confusion before going any further: The JavaBeans that we discuss in this chapter have little in common with Enterprise JavaBeans (EJB)
Enterprise JavaBeans are server-side components with support for transactions, persistence, replication, and security.
At a very basic level, they too are components that can be manipulated in builder tools.
However, the Enterprise JavaBeans technology is quite a bit more complex than the “Standard Edition” JavaBeans technology.
That does not mean that standard JavaBeans components are limited to client-side programming.
Web technologies such as JavaServer Faces (JSF) and JavaServer Pages (JSP) rely heavily on the JavaBeans component model.
Why Beans? Programmers with experience in Visual Basic will immediately recognize why beans are so important.
Programmers coming from environments where the tradition is to “roll your own” for everything often find it hard to believe that Visual Basic is one of the most successful examples of reusable object technology.
For those who have never worked with Visual Basic, here, in a nutshell, is how you build a Visual Basic application:
Build the interface by dropping components (called controls in Visual Basic) onto a form window.
Through property inspectors, set the components’ properties such as height, color, or behavior.
The property inspectors also list the events to which components can react.
For other events, you write short snippets of event-handling code.
For example, in Volume I, Chapter 2, we wrote a program that displays an image in a frame.
Here’s what you would do in Visual Basic to create a program with pretty much the same functionality:
Add two controls to a window: an Image control for displaying graphics and a Common Dialog control for selecting a file.
Set the Filter properties of the Common Dialog control so that only the files that the Image control can handle will show up, as shown in Figure 8.1
The Properties window in Visual Basic for an image applicationFigure 8.1
The Properties window in Visual Basic for an image application 3.3
Write four lines of Visual Basic code that will be activated when the project first starts running.
All the code you need for this sequence looks like this:
The code pops up the file dialog box—but only the files with the right extension are shown because of how we set the filter property.
After the user selects an image file, the code tells the Image control to display it.
The layout activity, combined with these statements, gives essentially the same functionality as a page of Java code.
Clearly it is a lot easier to learn how to drop components and set properties than to write a page of code.
We do not want to imply that Visual Basic is a good solution for every problem.
It is clearly optimized for a particular kind of problems—the UI-intensive Windows programs.
The JavaBeans technology was invented to make Java technology competitive in this arena.
It enables vendors to create Visual Basic-style development environments that make it possible to build user interfaces with a minimum of programming.
Writing a bean is not technically difficult—there are only a few new classes and interfaces for you to master.
In particular, the simplest kind of a bean is nothing more than a Java class that follows some fairly strict naming conventions for its methods.
Some authors claim that a bean must have a no-argument constructor.
However, some builder tools do require a no-argument constructor for each bean.
Listing 8.1 at the end of this section shows the code for an ImageViewer bean that could give a Java builder environment the same functionality as the Visual Basic image control from the previous section.
When you look at this code, notice that the ImageViewerBean class really doesn’t look any different from any other class.
For example, all accessor methods begin with get, and all mutator methods begin with set.
As you will soon see, builder tools use this standard naming convention to discover properties.
For example, fileName is a property of this bean because it has get and set methods.
Note that a property is not the same as an instance field.
In this particular example, the fileName property is computed from the file instance field.
Properties are conceptually at a higher level than instance fields—they are features of the interface, whereas instance fields belong to the implementation of the class.
One point that you need to keep in mind when you read through the examples in this chapter is that real-world beans are much more elaborate and tedious to code than our brief examples—for two reasons:
You need to expose lots of properties so that your users can access most of your bean’s functionality with a visual design tool without programming.
Fortunately, you need to master only a small number of concepts to write beans with a rich set of behaviors.
The example beans in this chapter, although not trivial, are kept simple enough to illustrate the necessary concepts.
Before we get into the mechanics of writing beans, we want you to see how you might use or test them.
ImageViewerBean is a perfectly usable bean, but outside a builder environment it can’t show off its special features.
Each builder environment uses its own set of strategies to ease the programmer’s life.
We cover one such environment: the NetBeans integrated development environment available from http://netbeans.org.
In this example, we use two beans, ImageViewerBean and FilePickerBean.
We will analyze the code for FilePickerBean later in this chapter.
To make any bean usable in a builder tool, package into a JAR file all class files that are used by the bean code.
Unlike the JAR files for an applet, a JAR file for a bean needs a manifest file that specifies which class files in the archive are beans and should be included in the builder’s toolbox.
Note the blank line between the manifest version and bean name.
Some builder environments have problems loading beans from the default package, so you should always place beans into a package.
If your bean contains multiple class files, mention in the manifest which class files are beans that you want to have displayed in the toolbox.
For example, you could place ImageViewerBean and FilePickerBean into the same JAR file and use the manifest.
Make sure that there are no spaces after the ends of each line, that there are blank lines after the version and between bean entries, and that the last line ends in a newline.
You can also add other items, such as icon images, to the JAR file.
Make sure to include all files that your bean needs in the JAR file.
Builder environments have a mechanism for adding new beans, typically by loading JAR files.
Compile the ImageViewerBean and FilePickerBean classes and package them into JAR files.
Now a dialog box pops up that lists all the beans found in the JAR file.
However, the icon is just a default icon—you will see later how to add icons to a bean.
Now you are ready to compose these beans into an application.
The promise of component-based development is to compose your application from prefabricated components, with a minimum of programming.
In this section, you will see how to compose an application from the ImageViewerBean and FilePickerBean components.
On the following screen, set a name for your application (such as ImageViewer), and click the Finish button.
Now you see a project viewer on the left and the source code editor in the middle.
Enter a name for the frame class (such as ImageViewerFrame) and click the Finish button.
You now get a form editor with a blank frame.
To add a bean to the form, select the bean in the palette located to the right of the form editor.
Adding a bean Figure 8.5 shows the result of adding an ImageViewerBean onto the frame.
If you look into the source window, you will find that the source code now contains the Java instructions to add the bean objects to the frame (see Figure 8.6)
The source code is bracketed by dire warnings that you should not edit it.
Any edits would be lost when the builder environment updates the code as you modify the form.
A builder environment is not required to update source code as you build an application.
A builder environment can generate source code when you are done editing, serialize the beans you customized, or perhaps produce an entirely different description of your building activity.
For example, the experimental Bean Builder at http://java.net/projects/bean-builder lets you design GUI applications without writing any source code at all.
The JavaBeans mechanism doesn’t attempt to force an implementation strategy on a builder tool.
Instead, it aims to supply information about beans that the builder tools can take advantage of in one way or another.
Now go back to the design view and click ImageViewerBean in the form.
On the right-hand side is a property inspector that lists the bean’s property names and their current values.
This is a vital part of component-based development tools because setting properties at design time is how you set the initial state of a component.
For example, you can modify the text property of the label used for the image bean simply by typing a new name into the property inspector.
To change the text property, just edit a string in a text field.
The form is immediately updated to reflect your change (see Figure 8.7)
When you change the setting of a property, the NetBeans environment updates the source code to reflect your action.
For example, if you set the text field to Hello, the instruction.
As already mentioned, other builder tools might have different strategies for recording property settings.
Properties don’t have to be strings; they can be values of any Java type.
To make it possible for users to set values for properties of any type, builder tools use specialized property editors.
Property editors either come with the builder or are supplied by the bean developer.
You will see how to write your own property editors later in this chapter.
To see a simple property editor at work, look at the foreground property.
Notice that you’ll immediately see the change to the property value—the label text changes its color.
More interestingly, choose a file name for an image file in the property inspector.
If you look closely at the property inspector in NetBeans, you will find a large number of mysterious properties such as focusCycleRoot and paintingForPrint.
You will see later in this chapter how you can suppress their visibility in the property inspector.
To complete our application, place a FilePickerBean object into the frame.
Now we want the image to be loaded when the fileName property of FilePickerBean is changed.
This happens through a PropertyChange event; we’ll discuss these kinds of events later in this chapter.
To react to the event, select FilePickerBean and select the Events tab from its property inspector.
A dialog box appears that shows that no handlers are currently associated with this event.
You are prompted for a method name (see Figure 8.8)
Adding an event to a bean Now look at the code editor.
Event handling code has been added, and there is a new method:
The image is displayed in the image viewer (see Figure 8.9)
The image viewer application This process demonstrates that you can create a Java application from beans by setting properties and providing a small amount of code for event handlers.
In this section, we’ll cover the basic rules for designing your own beans.
First, we want to stress there is no cosmic beans class that you extend to build your beans.
Visual beans directly or indirectly extend the Component class, but non-visual beans don’t have to extend any particular superclass.
Remember, a bean is simply any class that can be manipulated in a builder tool.
The builder tool does not look at the superclass to determine the bean nature of a class, but analyzes the names of its methods.
To enable this analysis, the method names for beans must follow certain patterns.
Extending it would, therefore, be rather pointless, even though you will see it done occasionally, supposedly for greater “clarity.” Obviously, since a bean can’t extend both Beans and Component, this approach won’t work for visual beans.
In fact, the Beans class contains methods that are designed to be called by builder tools—for example, to check whether the tool is operating at design time or run time.
Other languages for visual design environments, such as Visual Basic and C#, have special keywords such as “Property” and “Event” to express these concepts directly.
The designers of the Java specification decided not to add keywords to the language to support visual programming.
Therefore, they needed an alternative so that a builder tool could analyze a bean to learn its properties or events.
If the bean writer uses standard naming patterns for properties and events, the builder tool can use the reflection mechanism to understand what properties and events the bean is supposed to expose.
Alternatively, the bean writer can supply a bean information class that tells the builder tool about the properties and events of the bean.
We start by using the naming patterns because they are easier to use.
You’ll see later in this chapter how to supply a bean information class.
Although the documentation calls these standard naming patterns “design patterns,” these are really only naming conventions that have nothing to do with the design patterns used in object-oriented programming.
For example, in our ImageViewerBean, there is only one read/write property (for the file name to be viewed), with the following methods:
If you have a get method but not an associated set method, you define a read-only property.
Conversely, a set method without an associated get method defines a write-only property.
The get and set methods you create can do more than simply get and set a private data field.
Like any Java method, they can carry out arbitrary actions.
For example, the setFileName method of the ImageViewerBean class not only sets the value of the fileName data field but also opens the file and loads the image.
In Visual Basic and C#, properties also come from get and set methods.
However, in both these languages, you need to explicitly define properties so that builder tools wouldn’t need to second-guess the programmer’s intentions by analyzing method names.
In these languages, properties have another advantage: Using a property name on the left side of an assignment automatically calls the set method.
Using a property name in an expression automatically calls the get method.
This syntax was considered for Java, but the language designers felt that it was a poor idea to hide a method call behind syntax that looks like field access.
Properties that have boolean values should use the is/set naming pattern, as in the following examples:
For example, an animation might have a property running, with two methods public boolean isRunning() public void setRunning(boolean b)
It is legal to use a get prefix for a boolean property accessor (such as getRunning), but the is prefix is preferred.
The designers of the JavaBeans specification decided that the name of the property in our example would be fileName, with a lowercase f, even though the get and set methods contain an uppercase F (getFileName, setFileName)
The bean analyzer performs a process called decapitalization to derive the property name.
That is, the first character after get or set is converted to lowercase.
The rationale is that this process results in method and property names that are more natural to programmers.
However, if the first two letters are upper case (as in getURL), then the first letter of the property is not changed to lower case.
After all, a property name of uRL would look ridiculous.
What do you do if your class has a pair of get and set methods that don’t correspond to a property you want users to manipulate in a property inspector? In your own classes, you can of course avoid that situation by renaming your methods.
However, if you extend another class, you inherit the method names from the superclass.
This happens, for example, when your bean extends JPanel or JLabel—a large number of uninteresting properties show up in the property inspector.
You will see later in this chapter how you can override the automatic property discovery process by supplying bean information.
In the bean information, you can specify exactly which properties your bean should expose.
A bean builder environment will infer that your bean generates events when you supply methods to add and remove event listeners.
All event class names must end in Event, and the classes must extend the EventObject class.
The listener interface must be called EventNameListener, and the methods to manage the listeners must be called Click here to view code imageClick here to view code image.
If you look at the code for ImageViewerBean, you’ll see that it has no events to expose.
However, many Swing components generate events, and they follow this pattern.
For example, the AbstractButton class generates ActionEvent objects, and it has the following methods to manage ActionListener objects: Click here to view code imageClick here to view code image.
If your event class doesn’t extend EventObject, chances are that your code will compile just fine because none of the methods of the EventObject class are actually needed.
However, your bean will mysteriously fail—the introspection mechanism will not recognize the events.
A sophisticated bean will expose lots of different properties and events.
Properties can be as simple as the fileName property that you saw in ImageViewerBean and FilePickerBean or as sophisticated as a color value or even an array of data points—we’ll encounter both of these cases later in this chapter.
The JavaBeans specification allows four types of properties, illustrated here by various examples.
A simple property is one that takes a single value such as a string or a number.
The fileName property of the ImageViewer is an example of a simple property.
Simple properties are easy to program: Just use the set/get naming convention as described earlier.
For example, if you look at the code in Listing 8.1, you can see that all it took to implement a simple string property was the following:
For example, the FilePickerBean uses an indexed property for the file extensions.
It provides these four methods: Click here to view code imageClick here to view code image.
Bound properties tell interested listeners that their value has changed.
For example, the fileName property in FilePickerBean is a bound property.
When the file name changes, then ImageViewerBean is automatically notified and loads the new file.
To implement a bound property, you must implement two mechanisms:
Whenever the value of the property changes, the bean must send a PropertyChange event to all registered listeners.
To enable interested listeners to register themselves, the bean has to implement the following two methods: Click here to view code imageClick here to view code image.
To use this convenience class, add an instance field of this class:
Delegate the task of adding and removing property change listeners to that object: Click here to view code imageClick here to view code image.
That method has three parameters: the name of the property, the old value, and the new value.
Here is the boilerplate code for a typical setter of a bound property: Click here to view code imageClick here to view code image.
To notify the listeners of a property change, simply call the firePropertyChange method of the JComponent superclass.
If the property type is not a class type, then the property value objects are instances of the usual wrapper classes.
A constrained property is constrained by the fact that any listener can “veto” proposed changes, forcing it to revert to the old setting.
The Java library contains only a few examples of constrained properties.
One of them is the closed property of the JInternalFrame class.
Adding and removing listeners should be delegated to this object.
For example: Click here to view code imageClick here to view code image.
To update a constrained property value, a bean uses the following three-phase approach: 1.1
Notify all vetoable change listeners of the intent to change the property value.
Notify all property change listeners to confirm that a change has occurred.
For example: Click here to view code imageClick here to view code image.
It is important that you don’t change the property value until all the registered vetoable change listeners have agreed to the proposed change.
Conversely, a vetoable change listener should never assume that a change that it agrees to is actually.
The only reliable way to get notified when a change is actually happening is through a property change listener.
Note that you cannot install a vetoable change listener for a specific property into a JComponent.
We end our discussion of JavaBeans properties by showing the full code for FilePickerBean (see Listing 8.2)
The FilePickerBean has a filename property and an indexed extensions property.
Instead, we relied on the ability of the JPanel class to manage property change listeners.
If you use the standard naming patterns for the methods of your bean class, a builder tool can use reflection to determine features such as properties and events.
This process makes it simple to get started with bean programming, but naming patterns are rather limiting.
As your beans become complex, there might be features of your bean that naming patterns will not reveal.
Moreover, as we already mentioned, many beans have get/set method pairs that should not correspond to bean properties.
If you need a more flexible mechanism for describing information about your bean, define an object that implements the BeanInfo interface.
When you provide such an object, a builder tool will consult it about the features that your bean supports.
The name of the bean info class must be formed by adding BeanInfo to the name of the bean.
The bean info class must be part of the same package as the bean itself.
You won’t normally write a class that implements all methods of the BeanInfo interface.
Instead, extend the SimpleBeanInfo convenience class that has default implementations for all the methods in the BeanInfo interface.
The most common reason for supplying a BeanInfo class is to gain control of the bean properties.
Construct a PropertyDescriptor for each property by supplying the name of the property and the class of the bean that contains it.
For example, suppose ImageViewerBean wants to hide all properties it inherits from the JLabel superclass and expose only the fileName property.
The following BeanInfo class does just that: Click here to view code imageClick here to view code image.
Other methods also return EventSetDescriptor and MethodDescriptor arrays, but they are less commonly used.
If one of these methods returns null (as is the case for the SimpleBeanInfo methods), then the standard naming patterns apply.
However, if you override a method to return a non-null array, then you must include all properties, events, or methods in your array.
Sometimes, you might want to write generic code that discovers properties or events of an arbitrary bean.
The Introspector constructs a BeanInfo class that completely describes the bean, taking into account the information in BeanInfo companion classes.
Another useful method in the BeanInfo interface is the getIcon method that lets you give your bean a custom icon.
The BeanInfo interface has four constants that cover the standard sizes:
In the following class, we use the loadImage convenience method in the SimpleBeanInfo class to load the icon images: Click here to view code imageClick here to view code image.
A return of null indicates that the naming conventions should be used to find the properties.
Image getIcon(int iconType) returns an image object that can represent the bean in toolboxes, tool bars, and the like.
There are four constants, as described earlier, for the standard types of icons.
Image loadImage(String resourceName) returns an image object file associated with the resource.
The resource name is a path name, taken relative to the directory containing the bean info class.
However, currently there is no explicit support for supplying feature names in multiple locales.
The first constructor assumes that you follow the standard convention for the names of the get and set methods.
Class<?> getPropertyType() returns a Class object for the property type.
Method getWriteMethod() returns the method to get or set the property.
The first constructor assumes that you follow the standard convention for the names of the get and set methods.
If you add an integer or string property to a bean, that property is automatically displayed in the bean’s property inspector.
But what happens if you add a property whose values cannot easily be edited in a text field—for example, a Date.
For example, a property editor for a date object might be a calendar that lets the user scroll through the months and pick a date.
A property editor for a Color object would let the user select the red, green, and blue components of the color.
Also, of course, there are property editors for basic types such as String (a text field) and boolean (a checkbox)
The process for supplying a new property editor is slightly involved.
First, you create a bean info class to accompany your bean.
Create one object for each property that should be displayed in a property editor, even those for which you just want the default editor.
Construct a PropertyDescriptor by supplying the name of the property and the class of the bean that contains it.
Next, build an array of descriptors for properties of your bean.
For example, the chart bean that we discuss in this section has five properties:
The code in Listing 8.3 shows the ChartBeanBeanInfo class that specifies the property editors for these properties.
The title and graphColor properties are used with the default editors—that is, the string and color editors that come with the builder tool.
Its position can be set to left, center, or right.
If the inverse property is true, then the background is colored and the bars of the chart are white.
Before we get into the mechanics of writing property editors, we should point out that an editor is under the control of the builder, not the bean.
When the builder displays the property inspector, it carries out the following steps for each bean property:
It asks the bean to tell it the current value of the property.
It then asks the property editor to display the value.
A property editor must supply a no-argument constructor, and it must implement the PropertyEditor interface.
For every property editor you write, choose one of three ways to display and edit the property value:
For example, our chart bean has a property that lets you choose where the title should be displayed: left, center, or right.
Of course we don’t want them to appear as uppercase strings LEFT, CENTER, RIGHT—unless we are trying to enter the User Interface Hall of Horrors.
Instead, we’ll define a property editor whose getAsText method picks a string that looks pleasing to the developer: Click here to view code imageClick here to view code image.
Ideally, these strings should appear in the current locale, not necessarily in English—but we leave that as an exercise to the reader.
Conversely, we need to supply a method that converts a text string back to the property value: Click here to view code imageClick here to view code image.
If we simply supply these two methods, the property inspector will provide a text field.
It is initialized by a call to getAsText, and the setAsText method is called when we are done editing.
Of course, in our situation, this is not a good choice for the titlePosition property—unless, of course, we are also competing for entry into the User Interface Hall of Shame.
It is better to display all valid settings in a combo box (see Figure 8.11)
Simply write a getTags method that returns an array of strings:
The default getTags method returns null, indicating that a text field is appropriate for editing the property value.
When supplying the getTags method, you still need to supply the getAsText and setAsText methods.
The getTags method simply specifies the strings that should be offered to the user.
With this method, you can give to the builder tool the Java code that sets a property to its current value.
The builder tool uses this string for automatic code generation.
Try it out in NetBeans: If you edit the titlePosition property, NetBeans inserts code such as.
We replace the $ with a period, and add the result of invoking toString on the enumeration value.
When the user clicks on that area, a custom editor dialog box pops up (see Figure 8.12)
The dialog box contains a component to edit the property values, supplied by the property editor, and various buttons, supplied by the builder environment.
In our example, the customizer is rather spare, containing a single button.
The book’s companion code contains a more elaborate editor for editing chart values.
A custom editor dialog box To build a GUI-based property editor, you first tell the property inspector that you will paint the value and not use a string.
Override the getAsText method in the PropertyEditor interface to return null and the isPaintable method to return true.
It receives a Graphics context and the coordinates of the rectangle inside which you can paint.
Note that this rectangle is typically small, so you can’t have a very elaborate representation.
Click here to view code imageClick here to view code image.
The user must click on it to pop up a custom editor.
Next, the getCustomEditor method of the PropertyEditor interface constructs and returns an object of the custom editor class.
Listing 8.5 shows the code for the InverseEditor that displays the current property value in the property inspector.
Listing 8.6 shows the code for the custom editor panel for changing the value.
String getAsText() override this method to return a string representation of the current value of the property.
The default returns null to indicate that the property cannot be represented as a string.
String[] getTags() override this method to return an array of all possible string representations of the property values so they can be displayed in a choice box.
The default returns null to indicate that there is not a finite set of string values.
Component getCustomEditor() override this method to return the component that contains a customized GUI for editing the property value.
A property editor is responsible for allowing the user to set one property at a time.
Especially if certain properties of a bean relate to each other, it might be more user-friendly to provide a way to edit multiple properties at the same time.
To enable this feature, supply a customizer instead of (or in addition to) multiple property editors.
Moreover, some beans might have features that are not exposed as properties and therefore cannot be edited through the property inspector.
In the example program for this section, we develop a customizer for the chart bean.
The customizer lets you set several properties of the chart bean in one dialog box, as shown in Figure 8.13
The customizer for the ChartBeanChartBean To add a customizer to your bean, you must supply a BeanInfo class and override the getBeanDescriptor method, as shown in the following example.
Click here to view code imageClick here to view code image.
Note that you need not follow any naming pattern for the customizer class.
Nevertheless, it is the usual practice to name the customizer as BeanNameCustomizer.
You will see in the next section how to implement a customizer.
Any customizer class you write must have a no-argument constructor, extend the Component class, and implement the Customizer interface.
The setObject method taking a parameter that specifies the bean being customized.
In NetBeans, you must right-click on the bean and select the Customize menu option to pop up the customizer.
At that point, the builder calls the setObject method of the customizer.
Notice that your customizer is created before it is actually linked to an instance of your bean.
Therefore, you cannot assume any information about the state of a bean in the constructor.
Customizers typically present the user with many options, so it may be handy to use the tabbed pane user interface.
We use this approach and have the customizer extend the JTabbedPane class.
Of course, this kind of user interface can be tedious to code—our example devotes over 100 lines just to setting it up in the constructor.
However, this task requires only the usual Swing programming skills, and we don’t dwell on the details here.
You will often need to edit property values in a customizer.
Instead of implementing a new interface for setting the property value of a particular class, you can simply locate an existing property editor and add it to your user interface! For example, in our ChartBean customizer, we need to set the graph color; we know that NetBeans has a perfectly good property editor for colors, so we locate it as follows: Click here to view code imageClick here to view code image.
Once we have all components laid out, we initialize their values in the setObject method.
The setObject method is called when the customizer is displayed.
To proceed, we store that bean reference—we’ll need it later to notify the bean of property changes.
Here is a part of the setObject method of the chart bean customizer that does this initialization: Click here to view code imageClick here to view code image.
Finally, we hook up event handlers to track the user’s activities.
Whenever the user changes the value of a component, the component fires an event that our customizer must handle.
Let us follow that process with a couple of user interface elements in the chart bean customizer.
When the user types a new title, we want to update the title property.
We attach a DocumentListener to the text field into which the user types the title.
Click here to view code imageClick here to view code image.
The three listener methods call the setTitle method of the customizer.
That method calls the bean to update the property value and then fires a property change event.
This update is necessary only for properties that are not bound.
Click here to view code imageClick here to view code image.
When the color value changes in the color property editor, we want to update the graph color of the bean.
We track the color changes by attaching a listener to the property editor.
Perhaps confusingly, that editor also sends out property change events.
Click here to view code imageClick here to view code image.
Listing 8.7 provides the full code of the chart bean customizer.
JavaBeans persistence uses JavaBeans properties to save beans to a stream and to read them back at a later time or in a different virtual machine.
In this regard, JavaBeans persistence is similar to object serialization.
However, there is an important difference: JavaBeans persistence is suitable for long-term storage.
When an object is serialized, its instance fields are written to a stream.
If the implementation of a class changes, its instance fields can change.
You cannot simply read files that contain serialized objects of older versions.
It is possible to detect version differences and translate between old and new data representations.
However, the process is extremely tedious and should only be applied in desperate situations.
The design tool saves the result of mouse clicks—a collection of frames, panels, buttons, and other Swing components—in a file, using the long-term persistence format.
This approach cuts out the tedious source code for laying out and wiring up Swing components.
Suppose you want to save a JFrame object to a file so that you can retrieve it later.
If you look into the source code of the JFrame class and its superclasses, you will see dozens of instance fields.
If the frame were to be serialized, all of the field values would need to be written.
The no-argument constructor initializes all instance fields, and a couple of properties are set.
If you archive the frame object, the JavaBeans persistence mechanism saves exactly these statements in XML format:
When the object is read back, the statements are executed: A JFrame object is constructed, and its title and visible properties are set to the given values.
It does not matter if the internal representation of the JFrame has changed in the meantime.
All that matters is that you can restore the object by setting properties.
Note that only those properties that are different from the default are archived.
The XMLEncoder makes a default JFrame and compares its property with the frame that is being archived.
Property setter statements are generated only for properties that are different from the default.
As a result, the archives are generally smaller than the result of serialization.
When serializing Swing components, the difference is particularly dramatic because Swing objects have a lot of state, most of which is never changed from the default.
Of course, there are minor technical hurdles with this approach.
To save an object to a stream, use an XMLEncoder: Click here to view code imageClick here to view code image.
When you run the program, first click the Save button and save the frame to a file.
Then move the original frame to a different position and click Load to see another frame pop up at the original location.
Have a look inside the XML file that the program produces.
Here, we had to construct the action listeners with the EventHandler class.
The XMLEncoder cannot archive arbitrary inner classes, but it knows how to handle EventHandler objects.
JavaBeans persistence is not limited to the storage of Swing components.
You can use the mechanism to store any collection of objects, provided you follow a few simple rules.
In the following sections, you will learn how you can use JavaBeans persistence as a long-term storage format for your own data.
Using JavaBeans persistence is trivial if one can obtain the state of every object by setting properties.
But in real programs, there are always a few classes that don’t work that way.
It doesn’t have a no-argument constructor, and it doesn’t have methods setName, setSalary, setHireDay.
Such a delegate is responsible for generating an XML encoding of an object.
The persistence delegate for the Employee class overrides the instantiate method to produce an expression that constructs an object.
Click here to view code imageClick here to view code image.
This means: “To re-create oldInstance, call the new method (i.e., the constructor) on the Employee.class object, and supply the given parameters.” The parameter name oldInstance is a bit misleading—this is simply the instance that is being saved.
Once the delegate is installed, you can save Employee objects.
For example, the statements Click here to view code imageClick here to view code image.
The decoder simply executes the statements and expressions that it finds in its XML input.
If all constructor parameters can be obtained by accessing properties of oldInstance, then you need not write the instantiate method yourself.
If you are the author of the class, you can do even better.
Suppose, for example, that the Employee class had a constructor with three parameters (name, salary, and hire day)
Then we could annotate the constructor as follows: Click here to view code imageClick here to view code image.
This tells the encoder to call the getName, getSalary, and getHireDay property getters and write the resulting values into the object expression.
Sometimes, you need to save objects obtained from factory methods, not constructors.
Consider, for example, how you get an InetAddress object: Click here to view code imageClick here to view code image.
Click here to view code imageClick here to view code image.
A sample output is Click here to view code imageClick here to view code image.
You must install this delegate with the concrete subclass, such as Inet4Address, not with the abstract InetAddress class!
The state of some classes is built up by calls to methods that are not property setters.
You can generate a sequence of statements that are recorded in the archive.
To re-create a BitSet object, you have to set all the bits that were present in the original.
The following initialize method generates the necessary statements: Click here to view code imageClick here to view code image.
Occasionally, a class has a property with a getter and setter that the XMLDecoder discovers, but you don’t want to include the property value in the archive.
To suppress archiving of a property, mark it as transient in the property descriptor.
For example, the following statement marks the removeMode property of the DamageReporter class (which you will see in detail in the next section) as transient.
The program in Listing 8.9 shows the various persistence delegates at work.
Keep in mind that this program shows a worst-case scenario—in actual applications, many classes can be archived without the use of delegates.
We’ll end the description of JavaBeans persistence with a complete example (see Figure 8.15)
This application writes a damage report for a rental car.
The rental car agent enters the rental record, selects the car type, uses the mouse to click on damaged areas on the car, and saves the report.
Nothing needs to be done for the rentalRecord and carType properties.
The persistence delegate generates statements that call the click method.
The removeMode property (which specifies whether mouse clicks add or remove damage marks) is transient because it should not be saved in damage reports.
Here is a sample damage report: Click here to view code imageClick here to view code image.
The sample application does not use JavaBeans persistence to save the GUI of the application.
That might be of interest to creators of development tools, but here we are focusing on how to use the persistence mechanism to store application data.
This method should only be called from a persistence delegate.
Expression(Object value, Object target, String methodName, Object[] parameters) constructs an expression that calls the given method on target with the given parameters.
The result of the expression is assumed to be value.
To call a constructor, target should be a Class object and methodName should be "new"
Statement(Object target, String methodName, Object[] parameters) constructs a statement that calls the given method on target, with the given parameters.
You have now worked your way through three long chapters on GUI programming with Swing, AWT, and JavaBeans.
In the next chapter, we’ll move on to an entirely different topic: security.
Security has always been a core feature of the Java platform.
As the world in which we live and compute gets more dangerous, a thorough understanding of Java security will be of increasing importance for many developers.
When Java technology first appeared on the scene, the excitement was not about a well-crafted programming language but about the possibility of safely executing applets delivered over the Internet (see Volume I, Chapter 10 for more on applets)
Obviously, delivering executable applets is only practical when the recipients are sure that the code can’t wreak havoc on their machines.
For this reason, security was and is a major concern of both the designers and the users of Java technology.
This means that unlike other languages and systems, where security was implemented as an afterthought or a reaction to breakins, security mechanisms are an integral part of Java technology.
Language design features (bounds checking on arrays, no unchecked type conversions, no pointer arithmetic, and so on)
An access control mechanism that controls what the code can do (such as file access, network access, and so on)
Code signing, whereby code authors can use standard cryptographic algorithms to authenticate Java code.
Then, the users of the code can determine exactly who created the code and whether the code has been altered after it was signed.
The virtual machine has a mechanism for loading class files—for example, by reading the files from disk or by requesting them from the Web; it uses this mechanism to load the contents of the MyProgram class file.
If the MyProgram class has fields or superclasses of another class type, their class files are loaded as well.
The process of loading all the classes that a given class depends on is called resolving the class.
The virtual machine then executes the main method in MyProgram (which is static, so no instance of a class needs to be created)
If the main method or a method that main calls requires additional classes, these are loaded next.
The class loading mechanism doesn’t just use a single class loader, however.
The system class loader (sometimes also called the application class loader)
The bootstrap class loader loads the system classes (typically, from the JAR file rt.jar)
It is an integral part of the virtual machine and is usually implemented in C.
There is no ClassLoader object corresponding to the bootstrap class loader.
The extension class loader loads “standard extensions” from the jre/lib/ext directory.
You can drop JAR files into that directory, and the extension class loader will find the classes in them, even without any class path.
Some people recommend this mechanism to avoid the “class path hell,” but see the next cautionary note.
It locates classes in the directories and JAR/ZIP files on the class path, as set by the CLASSPATH environment variable or the -classpath command-line option.
In Oracle Java implementation, the extension and system class loaders are implemented in Java.
You can run into grief if you drop a JAR file into the jre/lib/ext directory and one of its classes needs to load a class that is not a system or extension class.
The extension class loader does not use the class path.
Keep that in mind before you use the extension directory as a way to manage your class file hassles.
In addition to all the places already mentioned, classes can be loaded from the jre/lib/endorsed directory.
This mechanism can only be used to replace certain standard Java libraries (such as those for XML and CORBA support) with newer versions.
Every class loader except for the bootstrap one has a parent class loader.
A class loader is supposed to give its parent a chance to load any given class and only load it if the parent has failed.
The bootstrap class loader finds and loads the class in rt.jar, so neither of the other class loaders searches any further.
Some programs have a plugin architecture in which certain parts of the code are packaged as optional plugins.
If the plugins are packaged as JAR files, you can simply load the plugin classes with an instance of URLClassLoader.
Click here to view code imageClick here to view code image.
Because no parent was specified in the URLClassLoader constructor, the parent of the pluginLoader is the system class loader.
The class loader hierarchy Most of the time, you don’t have to worry about the class loader hierarchy.
Generally, classes are loaded because they are required by other classes, and that process is transparent to you.
Occasionally, you need to intervene and specify a class loader.
Your application code contains a helper method that calls Class.forName( classNameString)
Your application code contains a helper method that calls Class.forName( classNameString)
The classNameString specifies a class that is contained in the plugin JAR.
The author of the plugin has reasons to expect that the class should be loaded.
However, the helper method’s class was loaded by the system class loader, and that is the class loader used by Class.forName.
To overcome this problem, the helper method needs to use the correct class loader.
Alternatively, it can require that the correct class loader is set as the context class loader of the current thread.
Each thread has a reference to a class loader, called the context class loader.
The main thread’s context class loader is the system class loader.
When a new thread is created, its context class loader is set to the creating thread’s context class loader.
Thus, if you don’t do anything, all threads will have their context class loaders set to the system class loader.
The helper method can then retrieve the context class loader: Click here to view code imageClick here to view code image.
The question remains when the context class loader is set to the plugin class loader.
Generally, it is a good idea to set the context class loader when invoking a method of a plugin class that was loaded with a different class loader.
Alternatively, the caller of the helper method can set the context class loader.
If you write a method that loads a class by name, it is a good idea to offer the caller the choice between passing an explicit class loader and using the context class loader.
Don’t simply use the class loader of the method’s class.
Every Java programmer knows that package names are used to eliminate name conflicts.
There are two classes called Date in the standard library, but of course their real names are java.util.Date and java.sql.Date.
The simple name is only a programmer convenience and requires the inclusion of appropriate import statements.
In a running program, all class names contain their package names.
It might surprise you, however, that you can have two classes in the same virtual machine that have the same class and package name.
A class is determined by its full name and the class loader.
This technique is useful for loading code from multiple sources.
For example, a browser uses separate instances of the applet class loader for each web page.
This allows the virtual machine to separate classes from different web pages, no matter what they are named.
Suppose a web page contains two applets, provided by different advertisers, and each applet has a class called Banner.
Since each applet is loaded by a separate class loader, these classes are entirely distinct and do not conflict with each other.
Two class loaders load different classes with the same name.Figure 9.2
Two class loaders load different classes with the same name.
This technique has other uses as well, such as “hot deployment” of servlets and Enterprise JavaBeans.
You can write your own class loader for specialized purposes.
That lets you carry out custom checks before you pass the bytecodes to the virtual machine.
For example, you can write a class loader that can refuse to load a class that has not been marked as “paid for.” To write your own class loader, simply extend the ClassLoader class and override the method.
The loadClass method of the ClassLoader superclass takes care of the delegation to the parent and calls findClass only if the class hasn’t already been loaded and if the parent class loader was unable to load the class.
Load the bytecodes for the class from the local file system or some other source.
Call the defineClass method of the ClassLoader superclass to present the bytecodes to the virtual machine.
In the program of Listing 9.1, we implement a class loader that loads encrypted class files.
The program asks the user for the name of the first class to load (that is, the class containing main) and the decryption key.
It then uses a special class loader to load the specified class and calls the main method.
The class loader decrypts the specified class and all nonsystem classes that are referenced by it.
Finally, the program calls the main method of the loaded class (see Figure 9.3)
The Caesar.java program of Listing 9.2 carries out the encryption.
To not confuse the regular class loader, we use a different extension, .caesar, for the encrypted class files.
To decrypt, the class loader simply subtracts the key from every byte.
In the companion code for this book, you will find four class files, encrypted with a key value of 3—the traditional choice.
To run the encrypted program, you’ll need the custom class loader defined in our ClassLoaderTest program.
Encrypting class files has a number of practical uses (provided, of course, that you use something stronger than the Caesar cipher)
They can neither be executed by a standard virtual machine nor readily disassembled.
This means that you can use a custom class loader to authenticate the user of the class or to ensure that a program has been paid for before it will be allowed to run.
Of course, encryption is only one application of a custom class loader.
You can use other types of class loaders to solve other problems—for example, storing class files in a database.
ClassLoader getClassLoader() gets the class loader that loaded this class.
ClassLoader getParent() 1.21.2 returns the parent class loader, or null if the parent class loader is the bootstrap class loader.
Class defineClass(String name, byte[] byteCodeData, int offset, int length) adds a new class to the virtual machine whose bytecodes are provided in the given data range.
If a URL ends in a /, it is assumed to be a directory, otherwise it is assumed to be a JAR file.
If no context class loader is set explicitly when a thread is started, the parent’s context class loader is used.
When a class loader presents the bytecodes of a newly loaded Java platform class to the virtual machine, these bytecodes are first inspected by a verifier.
The verifier checks that the instructions cannot perform actions that are obviously damaging.
Here are some of the checks that the verifier carries out:
Rules for accessing private data and methods are not violated.
If any of these checks fails, the class is considered corrupted and will not be loaded.
Accidental errors, such as uninitialized variables, can easily wreak havoc if they are not caught.
More importantly, in the wide open world of the Internet, you must be protected against malicious programmers who create evil effects on purpose.
For example, by modifying values on the runtime stack or by writing to the private data fields of system objects, a program can break through the security system of a browser.
You might wonder, however, why a special verifier checks all these features.
After all, the compiler would never allow you to generate a class file in which an uninitialized variable is used or in which a private data field is accessed from another class.
Indeed, a class file generated by a compiler for the Java programming language always passes verification.
However, the bytecode format used in the class files is well documented, and it is an easy matter for someone with experience in assembly programming and a hex editor to manually produce a class file containing valid but unsafe instructions for the Java virtual machine.
Once again, keep in mind that the verifier is always guarding against maliciously altered class files, not just checking the class files produced by a compiler.
Here’s an example of how to construct such an altered class file.
This is a simple program that calls a method and displays the method result.
The program can be run both as a console program and as an applet.
In this case, n is not initialized, and it could have any random value.
Of course, the compiler detects that problem and refuses to compile the program.
To create a bad class file, we have to work a little harder.
First, run the javap program to find out how the compiler translates the fun method.
You can use any hex editor to carry out the modification.
You get an error message: Click here to view code imageClick here to view code image.
Now run the program with the -noverify (or -Xverify:none) option.
This is actually 2 plus the value that happened to be stored in the variable n, which never was initialized.
To see how browsers handle verification, we wrote this program to run either as an application or an applet.
Load the applet into a browser, using a file URL such as.
You then see an error message displayed indicating that verification has failed (Figure 9.5)
Loading a corrupted class file raises a method verification error.Figure 9.5
Loading a corrupted class file raises a method verification error.
Once a class has been loaded into the virtual machine and checked by the verifier, the second security mechanism of the Java platform springs into action: the security manager.
The security manager is a class that controls whether a specific operation is permitted.
The default behavior when running Java applications is that no security manager is installed, so all these operations are permitted.
The applet viewer, on the other hand, enforces a security policy that is quite restrictive.
For example, applets are not allowed to exit the virtual machine.
If they try calling the exit method, a security exception is thrown.
The exit method of the Runtime class calls the checkExit method of the security manager.
Here is the entire code of the exit method: Click here to view code imageClick here to view code image.
The security manager now checks if the exit request came from the browser or an individual applet.
If the security manager agrees with the exit request, the checkExit method simply returns and normal processing continues.
However, if the security manager doesn’t want to grant the request, the checkExit method throws a SecurityException.
It then calls the private native exitInternal method that actually terminates the virtual machine.
There is no other way of terminating the virtual machine, and since the exitInternal method is private, it cannot be called from any other class.
Thus, any code that attempts to exit the virtual machine must go through the exit method and thus through the checkExit security check without triggering a security exception.
Clearly, the integrity of the security policy depends on careful coding.
Clearly, the integrity of the security policy depends on careful coding.
The providers of system services in the standard library must always consult the security manager before attempting any sensitive operation.
The security manager of the Java platform allows both programmers and system administrators fine-grained control over individual security permissions.
We’ll then show how you can control permissions with policy files.
Finally, we’ll explain how you can define your own permission types.
It is possible to implement and install your own security manager, but you should not attempt this unless you are an expert in computer security.
It is much safer to configure the standard security manager.
Just like a child that can only play in a sandbox, remote code was only allowed to paint on the screen and interact with the user.
The applet security manager denied all access to local resources.
However, both versions of the JDK provided an all-or-nothing approach.
Programs either had full access or they had to play in the sandbox.
Starting with Java SE 1.2, the Java platform has a much more flexible mechanism.
A security policy maps code sources to permission sets (see Figure 9.6)
A security policy A code source is specified by a code base and a set of certificates.
For example, the code base of remote applet code is the HTTP URL from which the applet is loaded.
The code base of code in a JAR file is the file’s URL.
A certificate, if present, is an assurance by some party that the code has not been tampered with.
A permission is any property that is checked by a security manager.
The Java platform supports a number of permission classes, each encapsulating the details of a particular permission.
For example, the following instance of the FilePermission class states that it is okay to read and write any file in the /tmp directory.
More importantly, the default implementation of the Policy class reads permissions from a permission file.
Inside a permission file, the same read permission is expressed as.
Many more permission classes have been added in subsequent Java releases.
A part of the hierarchy of permission classes In the preceding section, you saw that the SecurityManager class has security check methods such as checkExit.
These methods exist only for the convenience of the programmer and for backward compatibility.
For example, here is the source code for the checkExit method: Click here to view code imageClick here to view code image.
Each class has a protection domain—an object that encapsulates both the code source and the collection of permissions of the class.
When the SecurityManager needs to check a permission, it looks at the classes of all methods currently on the call stack.
It then gets the protection domains of all classes and asks each protection domain if its permission collection allows the operation currently being checked.
Why do all methods on the call stack need to allow a particular operation? Let us work through an example.
Suppose the init method of an applet wants to open a file.
The FileInputStream and SecurityManager classes are system classes for which CodeSource is null and the permissions consist of an instance of the AllPermission class, which allows all operations.
As you can see, the checkPermission method must take into account the restricted permissions of the applet class.
By checking the entire call stack, the security mechanism ensures that one class can never ask another class to carry out a sensitive operation on its behalf.
This brief discussion of permission checking explains the basic concepts.
With security, the devil lies in the details, and we encourage you to read the book by Li Gong for more information.
The method throws a SecurityException if the permission is not granted.
CodeSource getCodeSource() gets the code source of this protection domain.
Certificate[] getCertificates() gets the certificate chain for class file signatures associated with this code source.
The policy manager reads policy files that contain instructions for mapping code sources to permissions.
Here is a typical policy file: Click here to view code imageClick here to view code image.
The file .java.policy (notice the period at the beginning of the file name) in the user’s home directory.
You can change the locations of these files in the java.security configuration file in the jre/lib/security.
A system administrator can modify the java.security file and specify policy URLs that reside on another server and cannot be edited by users.
There can be any number of policy URLs (with consecutive numbers) in the policy file.
If you want to store policies outside the file system, you can implement a subclass of the Policy class that gathers the permissions.
During testing, we don’t like to constantly modify the standard policy files.
Therefore, we prefer to explicitly name the policy file required for each application.
You can set a system property inside your applications’ main method:
You can use the -J option of the appletviewer to pass any command-line argument to the virtual machine.
In these examples, the MyApp.policy file is added to the other policies in effect.
An easy mistake during testing is to accidentally leave a .java.policy file that grants a lot of permissions, perhaps even AllPermission, in the home directory.
If you find that your application doesn’t seem to pay attention to the restrictions in your policy file, check for a left-behind .java.policy file in your home directory.
If you use a UNIX system, this is a particularly easy mistake to make because files with names that start with a period are not displayed by default.
As you saw previously, Java applications by default do not install a security manager.
Therefore, you won’t see the effect of policy files until you install one.
In the remainder of this section, we’ll show you in detail how to describe permissions in the policy file.
We’ll describe the entire policy file format, except for code certificates which we cover later in this chapter.
The code source contains a code base (which can be omitted if the entry applies to code from all sources) and the names of trusted principals and certificate signers (which can be omitted if signatures are not required for this entry)
Otherwise, it is taken to be the name of a JAR file.
For example, Click here to view code imageClick here to view code image.
The code base is a URL and should always contain forward slashes as file separators, even for file URLs in Windows.
Everyone knows that http URLs start with two slashes (http://)
But there seems enough confusion about file URLs that the policy file reader accepts two forms of file URLs, namely, file://localFile and file:localFile.
Furthermore, a slash before a Windows drive letter is optional.
The permissions have the following structure: permission className targetName, actionList;
It is a list of actions, such as read or connect, separated by commas.
Some permission classes don’t need target names and action lists.
Table 9.2 lists the commonly used permission classes and their actions.
As you can see from Table 9.2, most permissions simply permit a particular operation.
You can think of the operation as the target with an implied action "permit"
However, the targets for the file, socket, and property permissions are more complex, and we need to investigate them in detail.
For example, the following permission entry gives access to all files in the directory /myapp and any of its subdirectories.
You must use the \\ escape sequence to denote a backslash in a Windows file name.
Socket permission targets consist of a host and a port range.
Finally, property permission targets can have one of two forms:
For example, the following permission entry allows a program to read all properties that start with java.vm:
The JDK comes with a rudimentary tool, called policytool, that you can use to edit policy files (see Figure 9.8)
Of course, this tool is not suitable for end users who would be completely mystified by most of the settings.
We view it as a proof of concept for an administration tool that might be used by system administrators who prefer point-andclick over syntax.
Still, what’s missing is a sensible set of categories (such as low, medium, or high security) that is meaningful to nonexperts.As a general observation, we believe that the Java platform certainly contains all the pieces for a fine-grained security model but it could benefit from some polish in delivering these pieces to end users and system administrators.
In this section, you’ll see how you can supply your own permission class that users can refer to in their policy files.
To implement your permission class, extend the Permission class and supply the following methods:
A constructor with two String parameters, for the target and the action list.
Permissions have an ordering, in which more general permissions imply more specific ones.
This permission allows reading and writing of any file in the /tmp directory and any of its subdirectories.
This permission implies other, more specific permissions: Click here to view code imageClick here to view code image.
Consider the following example of the use of the implies method.
When the FileInputStream constructor wants to open a file for reading, it checks whether it has permission to do so.
For that check, a specific file permission object is passed to the checkPermission method:
The security manager now asks all applicable permissions whether they imply this permission.
If any one of them implies it, the check passes.
If you define your own permission classes, you need to define a suitable notion of implication for your permission objects.
Suppose, for example, that you define a TVPermission for a set-top box powered by Java technology.
You need to implement the implies method so that this permission implies a more specific one, such as.
In the next sample program, we implement a new permission for monitoring the insertion of text into a text area.
The program ensures that you cannot add “bad words” such as sex, drugs, and C++ into a text area.
We use a custom permission class so that the list of bad words can be supplied in a policy file.
The following subclass of JTextArea asks the security manager whether it is okay to add new text: Click here to view code imageClick here to view code image.
Word check permissions have two possible actions: insert (the permission to insert a specific text) and avoid (the permission to add any text that avoids certain bad words)
You should run this program with the following policy file: Click here to view code imageClick here to view code image.
This policy file grants the permission to insert any text that avoids the bad words sex, drugs, and C++
You can find the implementation of this class in Listing 9.4
Note that to retrieve the permission target, you need to use the confusingly named getName method of the Permission class.
Since permissions are described by a pair of strings in policy files, permission classes need to be prepared to parse these strings.
In particular, we use the following method to transform the comma-separated list of bad words of an avoid permission into a genuine Set: Click here to view code imageClick here to view code image.
This code allows us to use the equals and containsAll methods to compare sets.
As you saw in Chapter 2, the equals method of a set class finds two sets to be equal if they contain the same elements in any order.
For example, the sets resulting from "sex,drugs,C++" and "C++,drugs,sex" are equal.
Make sure that your permission class is a public class.
The policy file loader cannot load classes with package visibility outside the boot class path, and it silently ignores any classes that it cannot find.
Type any text into the text field and click the Insert button.
If the security check passes, the text is appended to the text area.
If not, an error message is displayed (see Figure 9.9)
If you carefully look at Figure 9.9, you will see that the message window has a warning triangle, which is supposed to warn viewers that this window may have been popped up without permission.
If you like, you can edit the policy file to grant that permission.
You have now seen how to configure Java platform security.
For additional control, you can define custom permissions that can be configured in the same way as the standard permissions.
Permission(String name) constructs a permission with the given target name.
That is the case if the other permission describes a more specific condition that is a consequence of the condition described by this permission.
The “authentication” part is concerned with ascertaining the identity of a program user.
It supports, among others, UNIX logins, NT logins, Kerberos authentication, and certificate-based authentication.
Once a user has been authenticated, you can attach a set of permissions.
For example, here we grant Harry a particular set of permissions that other users do not have: Click here to view code imageClick here to view code image.
Its getName method returns the UNIX login name, and we check whether that name equals "harry"
Use a LoginContext to allow the security manager to check such a grant statement.
Here is the basic outline of the login code: Click here to view code imageClick here to view code image.
Now the subject denotes the individual who has been authenticated.
The string parameter "Login1" in the LoginContext constructor refers to an entry with the same name in the JAAS configuration file.
Here is a sample configuration file: Click here to view code imageClick here to view code image.
A login policy consists of a sequence of login modules, each of which is labeled required, sufficient, requisite, or optional.
The meaning of these keywords is given by the following algorithm: A login authenticates a subject, which can have multiple principals.
A principal describes some property of the subject, such as the user name, group ID, or role.
As you saw in the grant statement, principals govern permissions.
A grant clause can test for a principal, with the syntax.
When a user has logged in, you then run, in a separate access control context, the code that requires checking of principals.
Use the static doAs or doAsPrivileged method to start a new PrivilegedAction whose run method executes the code.
Both of those methods execute an action by calling the run method of an object that implements the PrivilegedAction interface, using the permissions of the subject’s principals: Click here to view code imageClick here to view code image.
The difference between the doAs and doAsPrivileged methods is subtle.
The doAs method starts out with the current access control context, whereas the doAsPrivileged method starts out with a new context.
The latter method allows you to separate the permissions for the login code and the “business logic.” In our example application, the login code has permissions Click here to view code imageClick here to view code image.
The AuthTest program authenticates a user and runs a simple action that retrieves a system property.
To make this example work, package the code for the login and the action into two separate JAR files:
If you look at the policy file in Listing 9.8, you will see that the UNIX user with the name harry has the permission to read all files.
Then run the command Click here to view code imageClick here to view code image.
When running the program, use a semicolon to separate the JAR files:
The AuthTest program should now display the value of the user.home property.
However, if you log in with a different name, a security exception should be thrown because you no longer have the required permission.
It is very easy to get the setup wrong by making seemingly innocuous changes.
The name corresponds to the login descriptor in the JAAS configuration file.
Invokes the login method on the managers in the JAAS configuration file.
Invokes the logout method on the managers in the JAAS configuration file.
The doAsPrivileged methods execute the action in the given access control context.
Object run() You must define this method to execute the code that you want to have executed on behalf of a subject.
Object run() You must define this method to execute the code that you want to have executed on behalf of a subject.
In this section, we’ll look at a JAAS example that shows you:
Supplying your own login module is useful if you store login information in a database.
Even if you are happy with the default module, studying a custom module will help you understand the JAAS configuration file options.
Role-based authentication is essential if you manage a large number of users.
It would be impractical to put the names of all legitimate users into a policy file.
Instead, the login module should map users to roles such as “admin” or “HR,” and the permissions should be based on these roles.
One job of the login module is to populate the principal set of the subject that is being authenticated.
If a login module supports roles, it adds Principal objects that describe roles.
The Java library does not provide a class for this purpose, so we wrote our own (see Listing 9.10)
The class simply stores a description/value pair, such as role=admin.
Its getName method returns that pair, so we can add role-based permissions into a policy file:
Of course, in a realistic login module, you would store this information in a database or directory.
You can find the code for the SimpleLoginModule in Listing 9.11
If so, we add two SimplePrincipal objects to the subject’s principal set: Click here to view code imageClick here to view code image.
A sharedState map that can be used for communication between login modules.
An options map that contains the name/value pairs that are set in the login configuration.
The login module retrieves the pwfile settings from the options map.
The login module does not gather the user name and password; that is the job of a separate handler.
This separation allows you to use the same login module without worrying whether the login information comes from a GUI dialog box, a console prompt, or a configuration file.
The handler is specified when you construct the LoginContext, for example: Click here to view code imageClick here to view code image.
However, in our application, we have our own GUI for collecting the user name and password (see Figure 9.10)
We produce a simple handler that merely stores and returns that information (see Listing 9.12)
A custom login module The handler has a single method, handle, that processes an array of Callback objects.
A number of predefined classes, such as NameCallback and PasswordCallback, implement the Callback interface.
You could also add your own class, such as RetinaScanCallback.
The handler code is a bit unsightly because it needs to analyze the types of the callback objects: Click here to view code imageClick here to view code image.
The login module prepares an array of the callbacks that it needs for authentication: Click here to view code imageClick here to view code image.
The program in Listing 9.13 displays a form for entering the login information and the name of a system property.
If the user is authenticated, the property value is retrieved in a PrivilegedAction.
As you can see from the policy file in Listing 9.14, only users with the admin role have permission to read properties.
As in the preceding section, you must separate the login and action code.
Create two JAR files: Click here to view code imageClick here to view code image.
It is possible to support a more complex two-phase protocol, whereby a login is committed if all modules in the login configuration were successful.
For more information, see the login module developer’s guide at http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/JAASLMDevGuide.html.
String getPrompt() gets the prompt to use when querying this name.
String getDefaultName() gets the default name to use when querying this name.
String getPrompt() gets the prompt to use when querying this password.
During login processing, uses the given handler to gather login information.
Use the sharedState map for communicating with other login modules.
The options map contains the name/value pairs specified in the login configuration for this module instance.
As we said earlier, applets were what started the Java craze.
In practice, people discovered that although they could write animated applets (like the famous “nervous text” applet), applets could not do a whole lot of useful stuff in the JDK 1.0 security model.
For example, since applets under JDK 1.0 were so closely supervised, they couldn’t do much good on a corporate intranet, even though relatively little risk attaches to executing an applet from your company’s secure intranet.
It quickly became clear to Sun that for applets to become truly useful, it was important for users to be able to assign different levels of security, depending on where the applet originated.
If an applet comes from a trusted supplier and has not been tampered with, the user of that applet can decide whether to give the applet more privileges.
To give more trust to an applet, we need to know two things:
In the past 50 years, mathematicians and computer scientists have developed sophisticated algorithms for ensuring the integrity of data and for electronic signatures.
The java.security package contains implementations of many of these algorithms.
Fortunately, you don’t need to understand the underlying mathematics to use the algorithms in the java.security package.
In the next sections, we’ll show you how message digests can detect changes in data files and how digital signatures can prove the identity of the signer.
A message digest is a digital fingerprint of a block of data.
As with real fingerprints, one hopes that no two messages have the same SHA-1 fingerprint.
But 2160 is so large that the probability of duplication occurring is negligible.
Now, think of nine other people—for example, your nine least favorite managers or professors.
The chance that you and all of them will die from lightning strikes is higher than that of a forged message having the same SHA-1 fingerprint as the original.
Of course, more than ten people, none of whom you are likely to know, will die from lightning strikes.
However, we are talking about the far slimmer chance that your particular choice of people will be wiped out.
If one bit or several bits of the data are changed, the message digest also changes.
A forger who is in possession of a given message cannot construct a fake message that has the same message digest as the original.
The second property is again a matter of probabilities, of course.
Consider the following message by the billionaire father: “Upon my death, my property shall be divided equally among my children; however, my son George shall receive nothing.”
The distrustful father has deposited the message with one attorney and the fingerprint with another.
He wants to change the message so that Bill gets nothing.
Of course, that changes the fingerprint to a completely different bit pattern:
Can George find some other wording that matches the fingerprint? If he had been the proud owner of a billion computers from the time the Earth was formed, each computing a million messages a second, he would not yet have found a message he could substitute.
A number of algorithms have been designed to compute such message digests.
Both algorithms scramble the bits of a message in ingenious ways.
Note that subtle regularities have been discovered in both algorithms.
The MessageDigest class is a factory for creating objects that encapsulate the fingerprinting algorithms.
It has a static method, called getInstance, that returns an object of a class that extends the MessageDigest class.
After you have obtained a MessageDigest object, feed it all the bytes in the message by repeatedly calling the update method.
For example, the following code passes all bytes in a file to the alg object just created to do the fingerprinting:
This method pads the input as required by the fingerprinting algorithm, does the computation, and returns the digest as an array of bytes.
In the last section, you saw how to compute a message digest—a fingerprint for the original message.
If the message is altered, the fingerprint of the altered message will not match the fingerprint of the original.
If the message and its fingerprint are delivered separately, the recipient can check whether the message has been tampered with.
However, if both the message and the fingerprint were intercepted, it is an easy matter to modify the message and then recompute the fingerprint.
After all, the message digest algorithms are publicly known, and they don’t require secret keys.
In that case, the recipient of the forged message and the recomputed fingerprint would never know that the message has been altered.
To help you understand how digital signatures work, we’ll explain a few concepts from the field called public key cryptography.
Public key cryptography is based on the notion of a public key and private key.
The idea is that you tell everyone in the world your public key.
However, only you hold the private key, and it is important that you safeguard it and don’t release it to anyone else.
The keys are matched by mathematical relationships, though the exact nature of these relationships is not important to us.
For example, here is a matching pair of public and private Digital Signature Algorithm (DSA) keys.
Public key: Click here to view code imageClick here to view code image.
Private key: Click here to view code imageClick here to view code image.
It is believed to be practically impossible to compute one key from the other.
That is, even though everyone knows your public key, they can’t compute your private key in your lifetime, no matter how many computing resources they have available.
It might seem difficult to believe that you can’t compute the private key from the public key, but nobody has ever found an algorithm to do this for the encryption algorithms in common use today.
If the keys are sufficiently long, brute forcesimply trying all possible keys—would require more computers than can be built from all the atoms in the solar system, crunching away for thousands of years.
Of course it is possible that someone could come up with algorithms for computing keys that are much more clever than brute force.
For example, the RSA algorithm (the encryption algorithm invented by Rivest, Shamir, and Adleman) depends on the difficulty of factoring large numbers.
For the last 20 years, many of the best mathematicians have tried to come up with good factoring algorithms, but so far with no success.
For that reason, most cryptographers believe that keys with a “modulus” of 2,000 bits or more are currently completely safe from any attack.
Public key signature exchange with DSA Figure 9.11 illustrates how the process works in practice.
Suppose Alice wants to send Bob a message, and Bob wants to know this message came from Alice and not an impostor.
Alice writes the message and signs the message digest with her private key.
Bob then applies the public key to verify the signature.
If the verification passes, Bob can be assured of two facts:
The message was signed by Alice, the holder of the private key that matches the public key that Bob used for verification.
You can see why the security of private keys is so important.
If someone steals Alice’s private key, or if a government can require her to turn it over, then she is in trouble.
The thief or a government agent can now impersonate her by sending messages, such as money transfer instructions, that others will believe came from Alice.
The JDK comes with the keytool program, which is a command-line tool to generate and manage a set of certificates.
We expect that ultimately the functionality of this tool will be embedded in other, more user-friendly programs.
But right now, we’ll use keytool to show how Alice can sign a document and send it to Bob, and how Bob can verify that the document really was signed by Alice and not an imposter.
The keytool program manages keystores, databases of certificates and private/public key pairs.
Here is how Alice creates a keystore, alice.certs, and generates a key pair with alias alice:
When creating or opening a keystore, you are prompted for a keystore password.
If you were to use the keytool-generated keystore for any serious purpose, you would need to choose a good password and safeguard this file.
When generating a key, you are prompted for the following information: Click here to view code imageClick here to view code image.
The keytool uses names in the X.500 format, whose components are Common Name (CN), Organizational Unit (OU), Organization (O), Location (L), State (ST), and Country (C), to identify key owners and certificate issuers.
Finally, specify a key password, or press Enter to use the keystore password as the key password.
Suppose Alice wants to give her public key to Bob.
When Bob receives the certificate, he can print it: keytool -printcert -file alice.cer.
The printout looks like this: Click here to view code imageClick here to view code image.
If Bob wants to check that he got the right certificate, he can call Alice and verify the certificate fingerprint over the phone.
Some certificate issuers publish certificate fingerprints on their web sites.
For example, to check the VeriSign certificate in the keystore jre/lib/security/ cacerts directory, use the -list option:
One of the certificates in this keystore is Click here to view code imageClick here to view code image.
Once Bob trusts the certificate, he can import it into his keystore.
Never import into a keystore a certificate that you don’t fully trust.
Once a certificate is added to the keystore, any program that uses the keystore assumes that the certificate can be used to verify signatures.
Alice simply adds the document to be signed into a JAR file.
She then uses the jarsigner tool to add the signature to the file.
She needs to specify the keystore, the JAR file, and the alias of the key to use.
When Bob receives the file, he uses the -verify option of the jarsigner program.
The jarsigner program finds the X.500 name of the key owner in the digital signature and looks for a matching certificate in the keystore.
If the JAR file is not corrupted and the signature matches, the jarsigner program prints.
Suppose you get a message from your friend Alice, signed with her private key, using the method we just showed you.
You might already have her public key, or you can easily get it by asking her for a copy or by getting it from her web page.
Then, you can verify that the message was in fact authored by Alice and has not been tampered with.
Now, suppose you get a message from a stranger who claims to represent a famous software company, urging you to run a program attached to the message.
The stranger even sends you a copy of his public key so you can verify that he authored the message.
This proves that the message was signed with the matching private key and has not been corrupted.
Be careful: You still have no idea who wrote the message.
Anyone could have generated a pair of public and private keys, signed the message with the private key, and sent the signed message and the public key to you.
The problem of determining the identity of the sender is called the authentication problem.
The usual way to solve the authentication problem is simple.
Suppose the stranger and you have a common acquaintance you both trust.
Suppose the stranger meets your acquaintance in person and hands over a disk with the public key.
Your acquaintance later meets you, assures you that he met the stranger and that the stranger indeed works for the famous software company, and then gives you the disk (see Figure 9.12)
That way, your acquaintance vouches for the authenticity of the stranger.
Authentication through a trusted intermediary In fact, your acquaintance does not actually need to meet you.
Instead, he can use his private key to sign the stranger’s public key file (see Figure 9.13)
Generate a key pair and export the public key: Click here to view code imageClick here to view code image.
For Alice to send messages to Cindy and to everyone else at ACME Software, she needs to bring her certificate to the Information Resources Department and have it signed.
In the book’s companion code, we supply a CertificateSigner class to fill the gap.
An authorized staff member at ACME Software would verify Alice’s identity and generate a signed certificate as follows: Click here to view code imageClick here to view code image.
The certificate signer program must have access to the ACME Software keystore, and the staff member must know the keystore password.
Alternatively, ACME Software can simply store the file in a company directory.
Remember, this file contains Alice’s public key and an assertion by ACME Software that this key really belongs to Alice.
The keystore verifies that the key was signed by a trusted root key that is already present in the keystore.
Once Cindy has added the root certificate and the certificates of the people who regularly send her documents, she never has to worry about the keystore again.
In the preceding section, we simulated a CA with a keystore and the CertificateSigner tool.
However, most CAs run more sophisticated software to manage certificates, and they use slightly different formats for certificates.
This section shows the added steps required to interact with those software packages.
We will use the OpenSSL software package as an example.
The software is pre-installed on many Linux systems and Mac OS X, and a Cygwin port is also available.
This script creates a subdirectory called demoCA in the current directory.
The directory contains a root key pair and storage for certificates and certificate revocation lists.
You will want to import the public key into the Java keystores of all employees, but it is in the Privacy Enhanced Mail (PEM) format, not the DER format that the keystore accepts easily.
It seems quite incredible that the keytool cannot carry out this editing operation itself.
To sign Alice’s public key, you start by generating a certificate request that contains the certificate in the PEM format:
You can use the same steps to have a certificate signed by a public certificate authority such as VeriSign.
One of the most important uses of authentication technology is signing executable programs.
If you download a program, you are naturally concerned about the damage it can do.
For example, the program could have been infected by a virus.
If you know where the code comes from and that it has not been tampered with since it left its origin, your comfort level will be a lot higher than without this knowledge.
In fact, if the program was also written in Java, you can use this information to make a rational decision about what privileges you will allow that program to have.
You might want it to run just in a sandbox as a.
For example, if you download a word processing program, you might want to grant it access to your printer and to files in a certain subdirectory.
However, you might not want to give it the right to make network connections so it wouldn’t try to send your files to a third party without your knowledge.
In this section, we’ll show you how to sign applets and Web Start applications for use with the Java Plug-in software.
In the first scenario, a system administrator installs policy files and certificates on local machines.
Whenever the Java Plug-in tool loads signed code, it consults the policy file for the permissions and the keystore for signatures.
Installing the policies and certificates is straightforward and can be done once per desktop.
End users can then run signed corporate code outside the sandbox.
Whenever a new program is created or an existing one is updated, it must be signed and deployed on the web server.
However, no desktops need to be touched as the programs evolve.
We think this is a reasonable scenario that can be an attractive alternative to deploying corporate applications on every desktop.
In the second scenario, software vendors obtain certificates that are signed by CAs such as VeriSign.
When an end user visits a web site that contains a signed applet, a pop-up dialog box identifies the software vendor and gives the end user two choices: to run the applet with full privileges or to confine it to the sandbox.
We’ll discuss this less desirable scenario in detail in Section 9.6.2, “Software Developer Certificates,” on p.
For the remainder of this section, we will describe how you can build policy files that grant specific permissions to code from known sources.
Building and deploying these policy files is not for casual end users.
However, system administrators can carry out these tasks in preparation for distributing intranet programs.
Suppose ACME Software wants its employees to run certain programs that require local file access, and it wants to deploy these programs through a browser as applets or Web Start applications.
Since these programs cannot run inside the sandbox, ACME Software needs to install policy files on the employee machines.
As you saw earlier in this chapter, ACME could identify the programs by their code base.
But that means ACME would need to update the policy files each time the programs are moved to a different web server.
Instead, ACME decides to sign the JAR files that contain the program code.
Of course, the keystore containing the private root key must be kept in a safe place.
Therefore, we create a second keystore client.certs for the public certificates and add the public acmeroot certificate into it.
Click here to view code imageClick here to view code image.
To make a signed JAR file, programmers add their class files to a JAR file in the usual way.
The signed applet is now ready to be deployed on a web server.
A policy file must be distributed to each client machine.
To reference a keystore, a policy file starts with the line.
Relative URLs are relative to the location of the policy file.
The type is JKS if the keystore was generated by keytool.
Any signed code that can be verified with the public key associated with the alias is now granted the permissions inside the grant clause.
You can try out the code signing process with the applet in Listing 9.17
The default security policy only lets the applet read files from its code base and any subdirectories.
Use appletviewer to run the applet and verify that you can view files from the code base directory, but not from other directories.
We provide a policy file applet.policy with the contents: Click here to view code imageClick here to view code image.
The usePolicy permission overrides the default “all or nothing” permission for signed applets.
Here, we say that any applets signed by acmeroot are allowed to read files in the /etc directory.
Now the applet can read files from the /etc directory, thus demonstrating that the signing mechanism works.
As a final test, you can run your applet inside the browser (see Figure 9.14)
You need to copy the permission file and the keystore inside the Java deployment directory.
If you run UNIX or Linux, that directory is the .java/deployment subdirectory of your home directory.
In the following, we’ll refer to that directory as deploydir.
Double-check that you are not wiping out an existing java.policy file.
If there is one, add the applet.policy contents to it.
For more details on configuring client Java security, read the sections “Deployment Configuration File and Properties” and “Java Control Panel” in the Java deployment guide at http://docs.oracle.com/javase/7/docs/technotes/guides/deployment/deployment-guide/overview.html.
When you are done, remember to clean up your deploydir/security directory.
If you load the applet again after cleaning up, you should no longer be able to read files from the local file system.
Up to now, we discussed scenarios in which programs are delivered in an intranet and for which a system administrator configures a security policy that controls the privileges of the programs.
However, that strategy only works with programs from known sources.
Suppose that while surfing the Internet, you encounter a web site that offers to run an applet or Web Start application from an unfamiliar vendor, provided you grant it the permission to do so (see Figure 9.15)
Such a program is signed with a software developer certificate issued by a CA.
The pop-up dialog box identifies the software developer and the certificate issuer.
If you click that button, the applet is not canceled—instead, it runs in the sandbox.
What facts do you have at your disposal that might influence your decision? Here is what you know:
The program really was signed with that certificate, and it hasn’t been modified in transit.
The certificate really was signed by Thawte—it was verified by the public key in the local cacerts file.
Does that tell you whether the code is safe to run? Can you trust a vendor if all you know is the vendor’s name and the fact that Thawte sold them a software developer certificate? One would like to think that Thawte went to some degree of trouble to assure itself that ChemAxon Kft.
However, no certificate issuer carries out a comprehensive audit of the honesty and competence of software vendors.
They merely verify the identity, typically by inspecting a scanned copy of a business license or passport.
In the situation of an unknown vendor, an end user is ill-equipped to make an intelligent decision whether to let this program run outside the sandbox, with all permissions of a local application.
If the vendor is a well-known company, the user can at least take the past track record of the company into account.
We don’t like situations in which a program demands “give me all rights, or I won’t run at all.” Naive users are too often cowed into granting access that can put them in danger.
Would it help if each program explained what rights it needs and requested specific permission for those rights? Unfortunately, as you have seen, that can get pretty technical.
It doesn’t seem reasonable for an end user to have to ponder whether a program should really have the right to inspect the AWT event queue.
It would be better if applets and Web Start applications on the public Internet tried harder to stay within their respective sandboxes, and if those sandboxes were improved.
The Web Start API that we discussed in Volume I, Chapter 10 is a step in the right direction.
So far, we have discussed one important cryptographic technique implemented in the Java security API—namely, authentication through digital signatures.
When information is authenticated, the information itself is plainly visible.
The digital signature merely verifies that the information has not been changed.
In contrast, when information is encrypted, it is not visible.
Authentication is sufficient for code signing—there is no need for hiding the code.
However, encryption is necessary when applets or applications transfer confidential information, such as credit card numbers and other personal data.
In the past, patents and export controls prevented many companies from offering strong encryption.
Fortunately, export controls are now much less stringent, and the patents for important algorithms have expired.
Nowadays, Java SE has excellent encryption support as a part of the standard library.
The Java cryptographic extensions contain a class Cipher that is the superclass of all encryption algorithms.
The JDK comes with ciphers by the provider named "SunJCE"
It is the default provider used if you don’t specify another provider name.
You might want another provider if you need specialized algorithms that Oracle does not support.
The Data Encryption Standard (DES) is a venerable block cipher with a key length of 56 bits.
Nowadays, the DES algorithm is considered obsolete because it can be cracked with brute force (see, for example, http://w2.eff.org/Privacy/Crypto/Crypto_misc/DESCracker)
A far better alternative is its successor, the Advanced Encryption Standard (AES)
Once you have a cipher object, initialize it by setting the mode and the key:
The wrap and unwrap modes encrypt one key with another—see the next section for an example.
Now you can repeatedly call the update method to encrypt blocks of data: Click here to view code imageClick here to view code image.
When you are done, you must call the doFinal method once.
If a final block of input data is available (with fewer than blockSize bytes), call.
The call to doFinal is necessary to carry out padding of the final block.
Suppose the last block of the input data has fewer than eight bytes.
Of course, we can fill the remaining bytes with 0, to obtain one final block of eight bytes, and encrypt it.
But when the blocks are decrypted, the result will have several trailing 0 bytes appended to it, and therefore will be slightly different from the original input file.
That could be a problem; to avoid it, we need a padding scheme.
A commonly used padding scheme is the one described in the Public Key Cryptography Standard (PKCS) #5 by RSA Security, Inc.
In this scheme, the last block is not padded with a pad value of zero, but with a pad value that equals the number of pad bytes.
In other words, if L is the last (incomplete) block, it is padded as follows: Click here to view code imageClick here to view code image.
For decryption, the very last byte of the plaintext is a count of the padding characters to discard.
Each cipher has a different format for keys, and you need to make sure that the key generation is random.
If the block length of the cipher is variable, also specify the desired block length.
For example, here is how you generate an AES key: Click here to view code imageClick here to view code image.
Alternatively, you can produce a key from a fixed set of raw data (perhaps derived from a password or the timing of keystrokes)
Then construct a SecretKeySpec (which implements the SecretKey interface) like this: Click here to view code imageClick here to view code image.
When generating keys, make sure you use truly random numbers.
For example, the regular random number generator in the Random class, seeded by the current date and time, is not random enough.
Suppose the computer clock is accurate to 1/10 of a second.
If an attacker knows the day a key was issued (as can often be deduced from a message date or certificate expiration date), it is an easy matter to generate all possible seeds for that day.
The SecureRandom class generates random numbers that are far more secure than those produced by the Random class.
You still need to provide a seed to start the number sequence at a random spot.
The best method for doing this is to obtain random input from a hardware device such as a white-noise generator.
Another reasonable source for random input is to ask the user to type away aimlessly on the keyboard, with each keystroke contributing only one or two bits to the random seed.
Once you gather such random bits in an array of bytes, pass it to the setSeed method:
If you don’t seed the random number generator, it will compute its own 20-byte seed by launching threads, putting them to sleep, and measuring the exact time when they are awakened.
In the past, algorithms that relied on timing some components of the computer, such as hard disk access time, were shown not to be completely random.
The sample program at the end of this section puts the AES cipher to work (see Listing 9.18)
The crypt utility method in Listing 9.19 will be reused in other examples.
To use the program, you first need to generate a secret key.
Decrypt with the command java aes.AESTest -decrypt encryptedFile decryptedFile secret.key.
The -genkey option produces a new secret key and serializes it in the given file.
That operation takes a long time because the initialization of the secure random generator is time-consuming.
The -encrypt and -decrypt options both call into the same crypt method that calls the update and doFinal methods of the cipher.
Note how the update method is called as long as the input blocks have the full length, and the doFinal method is either called with a partial input block (which is then padded) or with no additional data (to generate one pad block)
This method takes into account any buffered bytes in the cipher object.
The third method returns the number of bytes placed into out.
The fourth method returns the number of bytes placed into out.
The JCE library provides a convenient set of stream classes that automatically encrypt or decrypt stream data.
For example, here is how you can encrypt data to a file: Click here to view code imageClick here to view code image.
Similarly, you can use a CipherInputStream to read and decrypt data from a file: Click here to view code imageClick here to view code image.
The cipher stream classes transparently handle the calls to update and doFinal, which is clearly a convenience.
The AES cipher that you have seen in the preceding section is a symmetric cipher.
The same key is used for both encryption and decryption.
If Alice sends Bob an encrypted method, Bob needs the same key that Alice used.
If Alice changes the key, she needs to send Bob both the message and, through a secure channel, the new key.
But perhaps she has no secure channel to Bob—which is why she encrypts her messages to him in the first place.
In a public key cipher, Bob has a key pair consisting of a public key and a matching private key.
Bob can publish the public key anywhere, but he must closely guard the private key.
Alice simply uses the public key to encrypt her messages to Bob.
All known public key algorithms are much slower than symmetric key algorithms such as DES or AES.
It would not be practical to use a public key algorithm to encrypt large amounts of information.
However, that problem can easily be overcome by combining a public key cipher with a fast symmetric cipher, like this:
Alice sends Bob both the encrypted symmetric key and the encrypted plaintext.
Bob uses his private key to decrypt the symmetric key.
Bob uses the decrypted symmetric key to decrypt the message.
Nobody but Bob can decrypt the symmetric key because only Bob has the private key for decryption.
Thus, the expensive public key encryption is only applied to a small amount of key data.
The most commonly used public key algorithm is the RSA algorithm invented by Rivest, Shamir, and Adleman.
Until October 2000, the algorithm was protected by a patent assigned to RSA Security, Inc.
To use the RSA algorithm, you need a public/private key pair.
Use a KeyPairGenerator like this: Click here to view code imageClick here to view code image.
The -encrypt option generates an AES key and wraps it with the public key.
To try the program, first generate the RSA keys: java rsa.RSATest -genkey public.key private.key.
Then encrypt a file: java rsa.RSATest -encrypt plaintextFile encryptedFile public.key.
Finally, decrypt it and verify that the decrypted file matches the plaintext: java rsa.RSATest -decrypt encryptedFile decryptedFile private.key.
You have now seen how the Java security model allows controlled execution of code, which is a unique and increasingly important aspect of the Java platform.
You have also seen the services for authentication and encryption that the Java library provides.
We did not cover a number of advanced and specialized issues, among them:
The GSS-API for “generic security services” that provides support for the Kerberos protocol (and, in principle, other protocols for secure message exchange)
If you need to implement SASL in your application, look at http://docs.oracle.com/javase/7/docs/technotes/guides/security/sasl/sasl-refguide.html.
Using SSL over HTTP is transparent to application programmers; simply use URLs that start with https.
If you want to add SSL to your application, see the Java Secure Socket Extension (JSSE) reference at http://java.sun.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html.
Now that we have completed our overview of Java security, we turn, in the next chapter, to scripting, compiling, and annotation processing.
The scripting API lets you invoke code in a scripting language such as JavaScript or Groovy.
You can use the compiler API when you want to compile Java code inside your application.
Annotation processors operate on Java source or class files that contain annotations.
As you will see, there are many applications for annotation processing, ranging from simple diagnostics to “bytecode engineering”—the insertion of bytecodes into class files or even running programs.
On the other hand, most scripting languages lack features that are beneficial for programming complex applications, such as strong typing, encapsulation, and modularity.
It is therefore tempting to combine the advantages of scripting and traditional languages.
The scripting API lets you do just that for the Java platform.
It enables you to invoke scripts written in JavaScript, Groovy, Ruby, and even exotic languages such as Scheme and Haskell, from a Java program.
Most scripting languages that run on the Java virtual machine have this capability.
In the following sections, we’ll show you how to select an engine for a particular language, how to execute scripts, and how to take advantage of advanced features that some scripting engines offer.
A scripting engine is a library that can execute scripts in a particular language.
When the virtual machine starts, it discovers the available scripting engines.
You can ask each engine factory for the supported engine names, MIME types, and file extensions.
Java SE 7 includes a version of Rhino, a JavaScript interpreter developed by the Mozilla foundation.
You can add more languages by providing the necessary JAR files on the class path.
The scripting language itself is implemented by a single JAR file or a set of JARs.
The engine that adapts the language to the scripting API usually requires an additional JAR.
The site http://java.net/projects/scripting provides engines for a wide range of scripting languages.
List<String> getMimeTypes() gets the names, script file extensions, and MIME types under which this factory is known.
Once you have an engine, you can call a script simply by invoking.
If one script defines variables, functions, or classes, most scripting engines retain the definitions for later use.
Effects from one thread might be visible from another thread.
You will often want to add variable bindings to the engine.
A binding consists of a name and an associated Java object.
The script code reads the definition of k from the bindings in the “engine scope.” This is particularly important because most scripting languages can access Java objects, often with a syntax that is simpler than the Java syntax.
In addition to the engine scope, there is also a global scope.
Instead of adding bindings to the engine or global scope, you can collect them in an object of type Bindings and pass it to the eval method:
This is useful if a set of bindings should not persist for future calls to the eval method.
You might want to have scopes other than the engine and global scopes.
For example, a web container might need request and session scopes.
You will need to write a class that implements the ScriptContext interface, managing a collection of scopes.
Each scope is identified by an integer number, and scopes with lower numbers should be searched first.
Object eval(Reader reader, Bindings bindings) evaluates the script given by the string or reader, subject to the given bindings.
Bindings createBindings() creates an empty Bindings object suitable for this engine.
You can redirect the standard input and output of a script by calling the setReader and setWriter methods of the script context.
For example, Click here to view code imageClick here to view code image.
Any output written with the JavaScript print or println functions is sent to writer.
You can pass any Writer to the setWriter method, but the Rhino engine throws an exception if it is not a PrintWriter.
The setReader and setWriter methods only affect the scripting engine’s standard input and output sources.
The Rhino engine does not have the notion of a standard input source.
ScriptContext getContext() gets the default script context for this engine.
With many script engines, you can invoke a function in the scripting language without having to evaluate the actual script code.
This is useful if you allow users to implement a service in a scripting language of their choice.
The script engines that offer this functionality implement the Invocable interface.
To call a function, call the invokeFunction method with the function name, followed by the function parameters:
Here, the implicitParam object is a proxy to an object in the scripting language.
It must be the result of a prior call to the scripting engine.
However, all method parameters must be bound to names, whereas invokeMethod can be called with arbitrary values.
You can go a step further and ask the scripting engine to implement a Java interface.
Then you can call scripting functions and methods with the Java method call syntax.
The details depend on the scripting engine, but typically you need to supply a function for each method of the interface.
In an object-oriented scripting language, you can access a script class through a matching Java interface.
For example, consider this JavaScript code, which defines a SimpleGreeter class.
Click here to view code imageClick here to view code image.
You can use this class to construct greeters with different salutations (such as “Hello”, “Goodbye”, and so on)
After evaluating the JavaScript class definition, call Click here to view code imageClick here to view code image.
In summary, the Invocable interface is useful if you want to call scripting code from Java without worrying about the scripting language syntax.
Some scripting engines can compile scripting code into an intermediate form for efficient execution.
The following example shows how to compile and evaluate code contained in a script file: Click here to view code imageClick here to view code image.
The following code executes the compiled script if compilation was successful, or the original script if the engine didn’t support compilation.
Of course, it only makes sense to compile a script if you need to execute it repeatedly.
CompiledScript compile(Reader reader) compiles the script given by a string or reader.
To illustrate the scripting API, we will write a sample program that allows users to specify event handlers in a scripting language of their choice.
Have a look at the program in Listing 10.1 that adds scripting to an arbitrary frame class.
By default it reads the ButtonFrame class in Listing 10.2, which is similar to the event handling demo in Volume I, with two differences:
For example, if you choose to use JavaScript, supply the event handlers in a file js.properties, like this: Click here to view code imageClick here to view code image.
The companion code also has files for Groovy and SISC Scheme.
The program starts by loading an engine for the language specified on the command line.
We then process a script init.language if it is present.
This seems like a good idea in general; moreover, the Scheme interpreter needs some cumbersome initializations that we did not want to include in every event handler script.
Next, we recursively traverse all child components and add the bindings (name, object) into the engine scope.
For each property, we synthesize an event handler proxy that causes the script code to be executed.
The essential part, however, is that each event handler calls.
We then attach an ActionListener with an actionPerformed method that executes the script.
The engine contains a binding that binds the name "panel" to the JPanel object.
When the event occurs, the setBackground method of the panel is executed, and the color changes.
You can run this program with the JavaScript event handlers, simply by executing.
To try out Scheme, download SISC Scheme from http://sisc-scheme.org and run.
Then our program would become an interpreter for GUIs that have visual presentation defined by XML and behavior defined by a scripting language.
Note the similarity to a dynamic HTML page or a dynamic server-side scripting environment.
In the preceding sections, you saw how to interact with code in a scripting language.
Now we turn to a different scenario: Java programs that compile Java code.
There are quite a few tools that need to invoke the Java compiler, such as:
Templating tools that process snippets of Java code, such as JavaServer Pages (JSP)
As of Java SE 6, a public API for compilation is a part of the Java platform, and it is no longer necessary to use tools.jar.
Here is a sample call: Click here to view code imageClick here to view code image.
The compiler sends output and error messages to the provided streams.
You can set these parameters to null, in which case System.out and System.err are used.
The first parameter of the run method is an input stream.
As the compiler takes no console input, you can always leave it as null.
The run method is inherited from a generic Tool interface, which allows for tools that read input.
The remaining parameters of the run method are simply the arguments that you would pass to javac if you invoked it on the command line.
You can have even more control over the compilation process with a CompilationTask object.
Control the source of program code—for example, by providing code in a string builder instead of a file.
Control the placement of class files—for example, by storing them in a database.
Listen to error and warning messages as they occur during compilation.
The location of source and class files is controlled by a JavaFileManager.
It is responsible for determining JavaFileObject instances for source and class files.
A JavaFileObject can correspond to a disk file, or it can provide another mechanism for reading and writing its contents.
The listener receives a Diagnostic object whenever the compiler reports a warning or error message.
It simply collects all diagnostics so that you can iterate through them after the compilation is complete.
A Diagnostic object contains information about the problem location (including file name, line number, and column number) as well as a human-readable description.
To obtain a CompilationTask object, call the getTask method of the JavaCompiler class.
A Writer for any compiler output that is not reported as a Diagnostic, or null to use System.err.
A JavaFileManager, or null to use the compiler’s standard file manager.
Class names for annotation processing, or null if none are specified (we’ll discuss annotation processing later in this chapter)
JavaFileObject instances for source files You need to provide the last three arguments as Iterable objects.
For example, a sequence of options might be specified as.
For example, Click here to view code imageClick here to view code image.
However, if you want the compiler to read source code from somewhere other than a disk file, you need to supply your own JavaFileObject subclass.
Listing 10.3 shows the code for a source file object with data contained in a StringBuilder.
We’ll use this class in our example program in which we dynamically produce the code for a Java class and then compile it.
You can pass it to an Executor for execution in another thread, or you can simply invoke the call method.
Click here to view code imageClick here to view code image.
If you simply want the compiler to produce class files on disk, you need not customize the JavaFileManager.
However, our sample application will generate class files in byte arrays and later read them from memory, using a special class loader.
Listing 10.4 defines a class that implements the JavaFileObject interface.
It turns out a bit tricky to tell the compiler’s file manager to use these file objects.
We achieve this with the following outline: Click here to view code imageClick here to view code image.
In summary, call the run method of the JavaCompiler task if you simply want to invoke the compiler in the usual way, reading and writing disk files.
You can capture the output and error messages, but you need to parse them yourself.
If you want more control over file handling or error reporting, use the CompilationTask interface instead.
Its API is quite complex, but you can control every aspect of the compilation process.
You can supply null for default error reporting, locale, and character set.
Diagnostic.Kind getKind() gets the type of this diagnostic—one of ERROR, WARNING, MANDATORY_WARNING, NOTE, or OTHER.
String getMessage(Locale locale) gets the message describing the issue raised in this diagnostic.
OutputStream openOutputStream() override this method for a file object that represents a class file and produces a stream to which the bytecodes can be written.
In the JSP technology for dynamic web pages, you can mix HTML with snippets of Java code, such as.
In our sample application, we use a simpler example and generate dynamic Swing code instead.
The idea is that you use a GUI builder to lay out the components in a frame and specify the behavior of the components in an external file.
Note that the constructor of the frame class calls an abstract method addEventHandlers.
We leave it as the proverbial exercise to the reader to extend the code generation to other event types.
We place the subclass into a package with the name x, which we hope is not used anywhere else in the program.
The generated code has the form Click here to view code imageClick here to view code image.
These objects capture the class files generated when the x.Frame class is compiled.
The method adds each file object to a list before returning it so that we can locate the bytecodes later.
Note that compiling the x.Frame class produces a class file for the main class and one class file per listener class.
After compilation, we build a map that associates class names with bytecode arrays.
A simple class loader (shown in Listing 10.8) loads the classes stored in this map.
We ask the class loader to load the class that we just compiled, and then we construct and display the application’s frame class.
Click here to view code imageClick here to view code image.
When you click the buttons, the background color changes in the usual way.
Now the Yellow button is disabled after you click it.
You will not find any source or class files for the classes in the x package.
This example demonstrates how you can use dynamic compilation with in-memory source and class files.
Annotations are tags that you insert into your source code so that some tool can process them.
The tools can operate on the source level, or they can process class files into which the compiler has placed annotations.
Annotations do not change the way in which your programs are compiled.
The Java compiler generates the same virtual machine instructions with or without the annotations.
To benefit from annotations, you need to select a processing tool.
You need to use annotations that your processing tool understands, then apply the processing tool to your code.
There is a wide range of uses for annotations, and that generality can be confusing at first.
Automatic generation of auxiliary files, such as deployment descriptors or bean information classes.
Automatic generation of code for testing, logging, transaction semantics, and so on.
We’ll start our discussion of annotations with the basic concepts and put them to use in a concrete example: We will mark methods as event listeners for AWT components, and show you an annotation processor that analyzes the annotations and hooks.
We’ll then discuss the syntax rules in detail and finish the chapter with two advanced examples for annotation processing.
One of them processes source-level annotations, the other uses the Apache Bytecode Engineering Library to process class files, injecting additional bytecodes into annotated methods.
In Java, an annotation is used like a modifier and is placed before the annotated item without a semicolon.
A modifier is a keyword such as public or static.
The name of each annotation is preceded by an @ symbol, similar to Javadoc comments.
Another tool might remove all test methods from a class file so that they are not shipped with the program after it has been tested.
These elements can be processed by the tools that read the annotations.
Other forms of elements are possible; we’ll discuss them later in this chapter.
Besides methods, you can annotate classes, fields, and local variables—an annotation can be anywhere you could put a modifier such as public or static.
The methods of the interface correspond to the elements of the annotation.
For example, the JUnit Test annotation is defined by the following interface:
Tools that process annotations receive objects that implement the annotation interface.
A tool would call the timeout method to retrieve the timeout element of a particular Test annotation.
They annotate the Test annotation, marking it as an annotation that can be applied to methods only and is retained when the class file is loaded into the virtual machine.
You have now seen the basic concepts of program metadata and annotations.
In the next section, we’ll walk through a concrete example of annotation processing.
One of the more boring tasks in user interface programming is the wiring of listeners to event sources.
Many listeners are of the form Click here to view code imageClick here to view code image.
In this section, we’ll design an annotation to avoid this drudgery.
The annotation, defined in Listing 10.9, is used as follows:
The programmer no longer has to make calls to addActionListener.
The compiler places them in the class file, and the virtual machine loads them.
We now need a mechanism to analyze them and install action listeners.
The static processAnnotations method enumerates all methods of the object it received.
For each method, it gets the ActionListenerFor annotation object and processes it.
Click here to view code imageClick here to view code image.
Here, we use the getAnnotation method defined in the AnnotatedElement interface.
The name of the source field is stored in the annotation object.
We retrieve it by calling the source method, and then look up the matching field.
The source element must be the name of a field.
For each annotated method, we construct a proxy object, implementing the ActionListener interface, with an actionPerformed method that calls the annotated method.
The key observation is that the functionality of the annotations was established by the processAnnotations method.
Figure 10.1 shows how annotations are handled in this example.
Processing annotations at runtime In this example, the annotations were processed at runtime.
It is also possible to process them at the source level; a source code generator would then produce the code for adding the listeners.
Alternatively, the annotations can be processed at the bytecode level; a bytecode editor could inject the calls to addActionListener into the frame constructor.
This sounds complex, but libraries are available to make this task relatively straightforward.
You can see an example in Section 10.7, “Bytecode Engineering,” on p.
Our example was not intended as a serious tool for user interface programmers.
A utility method for adding a listener could be just as convenient for the programmer as the annotation.
You could make the class truly useful by supplying a method that adds the event handler instead of just constructing it.
However, this example shows the mechanics of annotating a program and of analyzing the annotations.
Having seen a concrete example, you are now more prepared (we hope) for the following sections that describe the annotation syntax in complete detail.
Annotation[] getAnnotations() gets all annotations present for this item, including inherited annotations.
If no annotations are present, an array of length 0 is returned.
If no annotations are present, an array of length 0 is returned.
In this section, we cover everything you need to know about the annotation syntax.
The default value of the declaration is used if an element value is not specified.
The value of the assignedTo element is the string "[none]"
Defaults are not stored with the annotation; instead, they are dynamically computed.
If no elements are specified, either because the annotation doesn’t have any or because all of them use the default value, you don’t need to use parentheses.
If an element has the special name value and no other element is specified, you can omit the element name and the = symbol.
For example, had we defined the ActionListenerFor annotation interface of the preceding section as.
That interface is a regular interface, not an annotation interface.
See the API notes at the end of this section for the methods provided by this interface.
Instead, the virtual machine generates proxy classes and objects when needed.
For example, when requesting an ActionListenerFor annotation, the virtual machine carries out an operation similar to the following: Click here to view code imageClick here to view code image.
The element declarations in the annotation interface are actually method declarations.
The methods of an annotation interface can have no parameters and no throws clauses, and they cannot be generic.
The type of an annotation element is one of the following:
A primitive type (int, short, long, byte, char, double, float, or boolean)
An array of the preceding types (an array of arrays is not a legal element type)
Here are examples of valid element declarations: Click here to view code imageClick here to view code image.
Since annotations are evaluated by the compiler, all element values must be compile-time constants.
For example, Click here to view code imageClick here to view code image.
You will need to find other defaults, such as "" or Void.class.
Since an annotation element can be another annotation, you can build arbitrarily complex annotations.
It is an error to introduce circular dependencies in annotations.
For example, BugReport has an element of the annotation type Reference, therefore Reference cannot have an element of type BugReport.
However, annotations for local variables can only be processed at the source level.
Therefore, all local variable annotations are discarded when a class is compiled.
Similarly, annotations for packages are not retained beyond the source level.
An item can have multiple annotations, provided they belong to different types.
You cannot use the same annotation type more than once when annotating a particular item.
For example, Click here to view code imageClick here to view code image.
Note that calling getClass on an annotation object would return the actual class, not the interface.
Four of them are meta-annotations that describe the behavior of annotation interfaces.
The others are regular annotations that you can use to annotate items in your source code.
We’ll discuss them in detail in the following two sections.
The @Deprecated annotation can be attached to any items for which use is no longer encouraged.
The compiler will warn when you use a deprecated item.
This annotation has the same role as the @deprecated Javadoc tag.
The compiler checks that a method with this annotation really overrides a method from the superclass.
For example, if you declare Click here to view code imageClick here to view code image.
After all, the equals method does not over-ride the equals method of the Object class because that method has a parameter of type Object, not MyClass.
The @Generated annotation is intended for use by code generator tools.
For example, a code editor can hide the generated code, or a code generator can remove older versions of generated code.
Each annotation must contain a unique identifier for the code generator.
A date string (in ISO 8601 format) and a comment string are optional.
Methods tagged with these annotations should be invoked immediately after an object has been constructed or immediately before it is being removed.
For example, consider a web application that accesses a database.
Of course, the database access information should not be hardwired into the web application.
Instead, the web container has some user interface for setting connection parameters and a JNDI name for a data source.
In the web application, you can reference the data source like this:
When an object containing this field is constructed, the container “injects” a reference to the data source.
The @Target meta-annotation is applied to an annotation, restricting the items to which the annotation applies.
For example, Click here to view code imageClick here to view code image.
You can specify any number of element types, enclosed in braces.
An annotation without an @Target restriction can be applied to any item.
The compiler checks that you apply an annotation only to a permitted item.
For example, if you apply @BugReport to a field, a compile-time error results.
The @Retention meta-annotation specifies how long an annotation is retained.
You can specify at most one of the values in Table 10.4
In the following two sections, you will see examples of processing annotations at the source and class file levels.
The @Documented meta-annotation gives a hint to documentation tools such as Javadoc.
Documented annotations should be treated just like other modifiers such as protected or static for documentation purposes.
The use of other annotations is not included in the documentation.
For example, suppose we declare @ActionListenerFor as a documented annotation:
Now the documentation of each annotated method contains the annotation, as shown in Figure 10.2
Documented annotations If an annotation is transient (such as @BugReport), you should probably not document its use.
Therefore, the Javadoc documentation for annotations shows whether they are documented.
When a class has an inherited annotation, then all of its subclasses automatically have the same annotation.
This makes it easy to create annotations that work as marker interfaces, such as Serializable.
In fact, an annotation @Serializable would be more appropriate than the Serializable marker interface with no methods.
A class is serializable because there is runtime support for reading and writing its fields, not because of any principles of object-oriented design.
An annotation describes this fact better than does interface inheritance.
Of course, the Serializable interface was created in JDK 1.1, long before annotations existed.
Suppose you define an inherited annotation @Persistent to indicate that objects of a class can be saved in a database.
Then the subclasses of persistent classes are automatically annotated as persistent.
Click here to view code imageClick here to view code image.
When the persistence mechanism searches for objects to store in the database, it will detect both Employee and Manager objects.
One use for annotation is the automatic generation of “side files” that contain additional information about programs.
In the past, the Enterprise Edition of Java was notorious for making programmers fuss with lots of boilerplate code.
Modern versions of Java EE use annotations to greatly simplify the programming model.
In this section, we demonstrate this technique with a simpler example.
We write a program that automatically produces bean info classes.
You tag bean properties with an annotation and then run a tool that parses the source file, analyzes the annotations, and writes out the source file of the bean info class.
Recall from Chapter 8 that a bean info class describes a bean more precisely than the automatic introspection process can.
The bean info class lists all of the properties of the bean.
The ChartBeanBeanInfo class in Chapter 8 is a typical example.
To eliminate the drudgery of writing bean info classes, we supply an @Property annotation.
You can tag either the property getter or setter, like this:
Note that the annotation has a retention policy of SOURCE.
It is not included in class files and not available during reflection.
It would have made sense to declare the editor element to have type Class.
However, the annotation processor cannot retrieve annotations of type Class because the meaning of a class can depend on external factors (such as the class path or class loaders)
Therefore, we use a string to specify the editor class name.
To automatically generate the bean info class of a class with name BeanClass, we carry out the following tasks: 1.1
For each annotated method, recover the property name by stripping off the get or set prefix and “decapitalizing” the remainder.
For each property, write a statement for constructing a PropertyDescriptor.
Write the code for returning an array of all property descriptors.
All this is easy enough to do, provided we can locate all methods that have been tagged with the @Property annotation.
As of Java SE 6, you can add annotation processors to the Java compiler.
In Java SE 5, a stand-alone tool, called apt, was used for the same purpose.
It then selects the annotation processors that should be applied.
If an annotation processor creates a new source file, then the process is repeated.
Once a processing round yields no further source files, all source files are compiled.
Processing source-level annotations We do not discuss the annotation processing API in detail, but the program in Listing 10.13 will give you a flavor of its capabilities.
An annotation processor implements the Processor interface, generally by extending the AbstractProcessor class.
The designers of the API themselves love annotations, so they use an annotation for this purpose: Click here to view code imageClick here to view code image.
The process method has two parameters: the set of annotations that is being processed in this round, and a RoundEnv reference that contains information about the current processing round.
In the process method, we iterate through all annotated methods.
For each method, we get the property name by stripping off the get, set, or is prefix and changing the next letter to lower case.
Here is the outline of the code: Click here to view code imageClick here to view code image.
The process method should return true if it claims all the annotations presented to it; that is, if those annotations should not be passed on to other processors.
Note that we create the output writer as follows: Click here to view code imageClick here to view code image.
The AbstractProcessor class has a protected field processingEnv for accessing various processing services.
The Filer interface is responsible for creating new files and tracking them so that they can be processed in subsequent processing rounds.
When an annotation processor detects an error, it uses the Messager to communicate with the user.
For example, we issue an error message if a method has been annotated with @Property but its name doesn’t start with get, set, or is: Click here to view code imageClick here to view code image.
In the companion code for this book, we supply an annotated file, ChartBean.java.
To see the annotation processing in action, add the command-line option XprintRounds to the javac command.
You will get this output: Click here to view code imageClick here to view code image.
This example demonstrates how tools can harvest source file annotations to produce other files.
Annotation processors may choose to generate XML descriptors, property files, shell scripts, HTML documentation, and so on.
Some people have suggested using annotations to remove an even bigger drudgery.
Wouldn’t it be nice if trivial getters and setters were generated automatically? For example, the annotation.
However, those methods need to be added to the same class.
This requires editing a source file, not just generating another file, and is beyond the capabilities of annotation processors.
It would be possible to build another tool for this purpose, but such a tool would go beyond the mission of annotations.
An annotation is intended as a description about a code item, not a directive for adding or changing code.
You have seen how annotations can be processed at runtime or at the source code level.
There is a third possibility: processing at the bytecode level.
Unless annotations are removed at the source level, they are present in the class files.
The format is rather complex, and it would be challenging to process class files without special libraries.
One such library is the Bytecode Engineering Library (BCEL), available at http://jakarta.apache.org/bcel.
In this section, we use BCEL to add logging messages to annotated methods.
For each method, check whether it has a LogEntry annotation.
If it does, add the bytecodes for the following instructions at the beginning of the method:
Inserting these bytecodes sounds tricky, but BCEL makes it fairly straightforward.
We don’t describe the process of analyzing and inserting bytecodes in detail.
The important point is that the program in Listing 10.14 edits a class file and inserts a logging call at the beginning of the methods annotated with the LogEntry annotation.
If you are interested in the details of bytecode engineering, read through the BCEL manual at http://jakarta.apache.org/bcel/manual.html.
You’ll need version 6.0 or later of the BCEL library to compile and run the EntryLogger program.
As this chapter was written, that version was still a work in progress.
If it isn’t finished when you read this, check out the trunk from the Subversion repository.
For example, here is how you add the logging instructions to Item.java in Listing 10.15: Click here to view code imageClick here to view code image.
You can see the inserted instructions at the beginning of the hashCode, equals, and compareTo methods.
Click here to view code imageClick here to view code image.
The SetTest program in Listing 10.16 inserts Item objects into a hash set.
When you run it with the modified class file, you will see the logging messages.
Click here to view code imageClick here to view code image.
Note the call to equals when we insert the same item twice.
Annotations are used to add directives to a program, and a bytecode editing tool picks up the directives and modifies the virtual machine instructions.
Click here to view code imageClick here to view code image.
In the preceding section, you saw a tool that edits class files.
However, it can be cumbersome to add yet another tool into the build process.
An attractive alternative is to defer the bytecode engineering until load time, when the class loader loads the class.
Before Java SE 5.0, you had to write a custom class loader to achieve this task.
Now, the instrumentation API has a hook for installing a bytecode transformer.
The transformer must be installed before the main method of the program is called.
You can meet this requirement by defining an agent, a library that is loaded to monitor a program in some way.
The agent code can carry out initializations in a premain method.
Implement a class with a method public static void premain(String arg, Instrumentation instr)
The agent can get a single command-line argument, which is passed in the arg parameter.
The instr parameter can be used to install various hooks.
Package the agent code and the manifest into a JAR file, for example: Click here to view code imageClick here to view code image.
For example, to run the SetTest program with the entry logging agent, call Click here to view code imageClick here to view code image.
The Item argument is the name of the class that the agent should modify.
The transformer first checks whether the class name matches the agent argument.
If so, it uses the EntryLogger class from the preceding section to modify the bytecodes.
However, the modified bytecodes are not saved to a file.
Instead, the transformer returns them for loading into the virtual machine (see Figure 10.4)
In other words, this technique carries out “just in time” modification of the bytecodes.
You have seen three technologies for processing code: scripting, compiling Java programs, and processing annotations.
On the other hand, building annotation tools is undeniably complex and not something that most developers will need to tackle.
This chapter gave you the background for understanding the inner workings of the annotation tools you will encounter, and perhaps piqued your interest in developing your own tools.
In the next chapter, you will learn about the RMI mechanism, a distributed object model for Java programs.
Periodically, the programming community starts thinking that the solution to all its problems is “objects everywhere.” The idea is to have a happy family of collaborating objects that can be located anywhere.
When an object on one computer needs to invoke a method on an object on another computer, it sends a network message that contains the details of the request.
The remote object computes a response, perhaps by accessing a database or by communicating with additional objects.
Once the remote object has the answer to the client request, it sends the answer back over the network.
Conceptually, this process sounds simple, but you need to understand what goes on under the hood to use distributed objects effectively.
In this chapter, we’ll focus on the Remote Method Invocation (RMI) protocol for communicating between two Java virtual machines which might run on different computers.
At one time, RMI was thought to be a viable technology for application programmers, but at this point, RMI is mostly of interest as a case study of a simple distributed object system.
A client computer makes a request and sends the request data across a network to a server.
The server processes the request and sends back a response for the client to analyze.
Transmitting objects between client and server We would like to say at the outset that these requests and responses are not what you would see in a web application.
It can be any application that executes business rules of any complexity.
The client application might or might not interact with a human user, and if it does, it can have a command-line or Swing user interface.
The protocol for the request and response data allows the transfer of arbitrary objects, whereas traditional web applications are limited by using HTTP for the request and HTML for the response.
What we want is a mechanism by which the client programmer makes a regular method call, without worrying about sending data across the network or parsing the response.
The solution is to install a proxy object on the client.
The proxy is an object located in the client virtual machine that appears to the client program as if it were the remote object.
The client calls the proxy, making a regular method call.
The client proxy contacts the server, using a network protocol.
Similarly, the programmer who implements the service doesn’t want to fuss with client communication.
The solution is to install a second proxy object on the server.
The server proxy communicates with the client proxy, and it makes regular method calls to the object implementing the service (see Figure 11.2)
Remote method call with proxies How do the proxies communicate with each other? That depends on the implementation technology.
The Common Object Request Broker Architecture (CORBA) supports method calls between objects of any programming language.
The web services architecture is a collection of protocols, sometimes collectively described as WS-*
The Java RMI technology supports method calls between distributed Java objects.
Client and server programs can be written in C, C++, C#, Java, or any other language.
You supply an interface description to specify the signatures of the methods and the types of the data that your objects can handle.
These descriptions are formatted in a special language, called Interface Definition Language (IDL) for CORBA and Web Services Description Language (WSDL) for web services.
For many years, quite a few people believed that CORBA was the object model of the future.
Web services had a similar amount of buzz when they first appeared, with the promise that they are simpler and, of course, founded on the goodness of the World Wide Web and XML.
However, with the passing of time and the work of many committees, the protocol stack has become less simple, as it acquired more of the features that CORBA had all along.
The XML protocol has the advantage of being (barely) human-readable, which helps with debugging.
On the other hand, XML processing is a significant performance bottleneck.
If the communicating programs are implemented in Java code, the full generality and complexity of CORBA or WS-* is not required.
Sun developed a simple mechanism, called RMI, specifically for communication between Java applications.
It is well worth learning about RMI, even if you are not going to use it in your own programs.
Using a straightforward architecture, you will learn about the mechanisms essential for programming distributed applications.
The key to distributed computing is the remote method call.
Some code on one machine (called the client) wants to invoke a method on an object on another machine (the remote object)
To make this possible, the method parameters must somehow be shipped to the other machine, the server must be informed so it can locate the remote object and execute the method, and the return value must be shipped back.
Before looking at this process in detail, we want to point out that the client/ server terminology applies only to a single method call.
The computer that calls the remote method is the client for that call, and the computer hosting the object that processes the call is the server for that call.
It is entirely possible for the roles to be reversed somewhere down the road.
The server of a previous call can itself become the client when it invokes a remote method on an object residing on another computer.
When client code wants to invoke a method on a remote object, it actually calls an ordinary method on a proxy object called a stub.
For example, Click here to view code imageClick here to view code image.
The stub resides on the client machine, not on the server.
It knows how to contact the server over the network.
On the server side, a receiver object performs the following actions: 1.1
It captures the return value or the exception of the call.
It sends a package consisting of the marshalled return data back to the stub on the client.
The client stub unmarshals the return value or exception from the server.
The value becomes the return value of the stub call; if the remote method threw an exception, the stub rethrows it in the virtual machine of the caller.
Figure 11.3 shows the information flow of a remote method invocation.
Parameter marshalling This process is obviously complex, but the good news is that it is completely automatic and, to a large extent, transparent for the programmer.
The details of implementing remote objects and getting client stubs depend on the technology for distributed objects.
In the following sections, we’ll have a close look at RMI.
To introduce the RMI programming model, we’ll start with a simple example.
The client program asks the warehouse about the price of a product.
In the following sections, you will see how to implement and launch the server and client programs.
The capabilities of remote objects are expressed in interfaces that are shared between the client and server.
For example, the interface in Listing 11.1 describes the service provided by a remote warehouse object.
As you will see, deployment of remote applications is complex, and we want to avoid the added complexity of package directories.
Interfaces for remote objects must always extend the Remote interface defined in the java.rmi package.
All the methods in those interfaces must also declare that they will throw a RemoteException.
Remote method calls are inherently less reliable than local calls—it is always possible that a remote call will fail.
For example, the server might be temporarily unavailable, or there might be a network problem.
Your client code must be prepared to deal with these possibilities.
For these reasons, you must handle the RemoteException with every remote method call and specify the appropriate action to take when the call does not succeed.
Next, on the server side, you must provide the class that actually carries out the work advertised in the remote interfacesee Listing 11.2
The WarehouseImpl constructor is declared to throw a RemoteException because the superclass constructor can throw that exception.
This happens when there is a problem connecting to the network service that tracks remote objects.
In that situation, you need to manually instantiate the remote objects and pass them to the static exportObject method.
The second parameter is 0 to indicate that any suitable port can be used to listen to client connections.
The term “unicast” refers to the fact that the remote object is located by making a call to a single IP address and port.
More sophisticated distributed object systems (such as JINI) allow for “multicast” lookup of remote objects that might be on a number of different servers.
To access a remote object that exists on the server, the client needs a local stub object.
How can the client request such a stub? The most common method is to call a remote method of another remote object and get a stub object as a return value.
There is, however, a chicken-and-egg problem here: The first remote object has to be located some other way.
For that purpose, the JDK provides a bootstrap registry service.
A server program registers at least one remote object with a bootstrap registry.
The server tells the registry at the given location to associate or “bind” the name with the object.
Here is the code for registering a WarehouseImpl object with the RMI registry on the same server: Click here to view code imageClick here to view code image.
The program in Listing 11.3 simply constructs and registers a WarehouseImpl object.
For security reasons, an application can bind, unbind, or rebind registry object references only if it runs on the same host as the registry.
NameClassPair is a helper class that contains both the name of the bound object and the name of its class.
For example, the following code displays the names of all registered objects:
A client gets a stub to access a remote object by specifying the server and the remote object name in the following way: Click here to view code imageClick here to view code image.
It is notoriously difficult to keep names unique in a global registry, so you should not use this technique as the general method for locating objects on the server.
Instead, there should be relatively few named remote objects registered with the bootstrap service.
These should be the objects that can locate other objects for you.
The code in Listing 11.4 shows the client that obtains a stub to the remote warehouse object and invokes the remote getPrice method.
The client obtains a Warehouse stub and invokes the getPrice method on it.
Behind the scenes, the stub contacts the server and causes the getPrice method to be invoked on the WarehouseImpl object.
InitialContext() constructs a naming context that can be used for accessing the RMI registry.
Throws a NamingException if the name is not currently bound.
It is legal to unbind a name that doesn’t exist.
String getClassName() gets the name of the class to which the named object belongs.
Throws a NotBoundException if the name is not currently bound.
Throws the NotBound exception if the name is not currently bound.
The array contains a snapshot of the names present in the registry.
Deploying an application that uses RMI can be tricky because so many things can go wrong—and the error messages you get when something goes wrong are so poor.
We have found that it really pays off to test the deployment under realistic conditions, separating the classes for client and server.
Make two separate directories to hold the classes for starting the server and client.
When deploying RMI applications, one commonly needs to dynamically deliver classes to running programs.
Keep in mind that one instance of the registry will serve many different RMI applications.
The RMI registry needs to have access to the class files of the service interfaces that are being registered.
When the registry starts, however, one cannot predict all future registration requests.
Therefore, the RMI registry dynamically loads the class files of any remote interfaces it has not previously encountered.
Dynamically delivered class files are distributed through standard web servers.
In our case, the server program needs to make the Warehouse.class file available to the RMI registry, so we put that file into a third directory that we call download.
We use a web server to serve the contents of that directory.
When the application is deployed, the server, RMI registry, web server, and client can be located on four different computers —see Figure 11.5
However, for testing purposes, we will use a single computer.
For security reasons, the rmiregistry service that is part of the JDK only allows binding calls from the same host.
That is, the server and rmiregistry process need to be located on the same computer.
However, the RMI architecture allows for a more general RMI registry implementation that supports multiple servers.
To test our sample application, use the NanoHTTPD web server available from http://elonen.iki.fi/code/nanohttpd.
This tiny web server is implemented in a single Java source file.
Open a new console window, change to the download direc-tory, and copy NanoHTTPD.java to that directory.
Compile the source file and start the web server with the command.
Use any other available port if port 8080 is already used on your machine.
Next, open another console window, change to a directory that contains no class files, and start the RMI registry:
Before starting the RMI registry, make sure the CLASSPATH environment variable is not set to anything, and doublecheck that the current directory contains no class files.
Otherwise, the RMI registry might find spurious class files which will confuse it when it should download additional classes from a different source.
In a nutshell, each stub object has a codebase entry that specifies from where it was loaded.
If the RMI registry finds a class locally, it will set the wrong codebase.
Open a third console window, change to the server directory, and issue the command java -Djava.rmi.server.codebase=http://localhost:8080/ WarehouseServer.
The server program communicates this URL to the RMI registry.
You will see a message that demonstrates that the Warehouse.class file has been served to the RMI registry.
It is very important to ensure that the codebase URL ends with a slash (/)
This seems strange—after all, the program just creates a WarehouseImpl object and registers it.
Actually, the main method does exit immediately after registration, as you would expect.
Thus, the program stays around to allow clients to connect to it.
Finally, open a fourth console window, change to the client directory, and run.
You will see a short message, indicating that the remote method was successfully invoked (see Figure 11.6)
If you just want to test out basic program logic, you can put your client and server class files into the same directory.Then you can start the RMI registry, server, and client in that directory.
However, as RMI class loading is the source of much grief and confusion, we felt it best to show you right away the correct setup for dynamic class loading.
Try it—you’ll get a good impression of the RMI traffic.
If you want to see additional logging messages, you have to configure RMI loggers using the standard Java logging API.
See Volume I, Chapter 11 for more information on logging.
You can fine-tune the settings by adjusting the individual levels for each logger instead of the global level.
For example, to track the class-loading activity, you can set.
Here is an example of a logging message that shows a class loading problem.
The RMI registry cannot find the Warehouse class because the web server has been shut down: Click here to view code imageClick here to view code image.
Objects of classes that implement the Remote interface are transferred as remote references.
Objects of classes that implement the Serializable interface but not the Remote interface are copied using serialization.
All of this is automatic and requires no programmer intervention.
Keep in mind that serialization can be slow for large objects, and that the remote method cannot mutate serialized parameters.
You can, of course, avoid these issues by passing around remote references.
That, too, comes at a cost: Invoking methods on remote references is far more expensive than calling local methods.
Being aware of these costs will allow you to make informed choices when designing remote services.
Remote objects are garbage-collected automatically, just as local objects are.
When the local garbage collector finds that there are no further local uses of a remote reference, it notifies the distributed collector that the server is no longer referenced by this client.
When a server is no longer used by any clients, it is marked as garbage.
Our next example program will illustrate the transfer of remote and serializable objects.
We change the Warehouse interface as shown in Listing 11.5
Given a list of keywords, the warehouse returns the Product that is the best match.
Our sample client passes a value obtained by a call to Arrays.asList.
Fortunately, that method is guaranteed to return a serializable list as well.
The return type Product encapsulates the description, price, and location of the product (see Listing 11.6)
The server constructs a Product object, and the client gets a copy (see Figure 11.7)
Copying local parameter and result objects However, there is a subtlety.
The Product class has an instance field of type Warehouse—a remote interface.
The warehouse object is not serialized, which is just as well as it might have a huge amount of state.
Instead, the client receives a stub to a remote Warehouse object.
That stub might be different from the centralWarehouse stub on which the getProduct method was called.
In our implementation, we will have two kinds of products, toasters and books, that are located in different warehouses.
A list of keyword strings is sent to the server, and the warehouse returns an instance of a class Product.
Of course, the client program will need the class file Product.class to compile.
However, whenever our server program cannot find a match for the keywords, it returns the one product that is sure to delight everyone: the Core Java book.
That object is an instance of the Book class, a subclass of Product.
When the client was compiled, it might have never seen the Book class.
Yet when it runs, it needs to be able to execute Book methods that override Product methods.
This demonstrates that the client needs to have the capability of loading additional classes at runtime.
The client uses the same mechanism as the RMI registry.
Classes are served by a web server, the RMI server class communicates the URL to the client, and the client makes an HTTP request to download the class files.
Whenever a program loads new code from another network location, there is a security issue.
For that reason, you need to use a security manager in RMI applications that dynamically load classes.
See Chapter 9 for more information on class loaders and security managers.
Programs that use RMI should install a security manager to control the activities of the dynamically loaded classes.
If all classes are available locally, you do not actually need a security manager.
If you know all class files of your program at deployment time, you can deploy them all locally.
However, it often happens that the client or server program evolves and new classes are added over time.
Any time you load code from another source, you need a security manager.
By default, the SecurityManager restricts all code in the program from establishing network connections.
However, the program needs to make network connections to three remote locations:
To run the sample application, be sure you have killed the RMI registry, web server, and the server program from the preceding sample.
Compile the source files for the interface, implementation, client, and server classes.
In the first console window, change to a directory that has no class files.
In the second console window, change to the download directory and start NanoHTTPD.
In the third console window, change to the server directory and start the server.
In the fourth console window, change to the client directory and run the client.
Note that the getDescription method is overridden to show the ISBN.
When the client program runs, it shows the ISBN for the Core Java book, which proves that the Book class was loaded dynamically.
If an item cannot be found in the warehouse, the backup warehouse is searched.
Only the central warehouse is entered into the RMI registry.
Note that a remote reference to the backup warehouse can be passed to the client even though it is not included in the RMI registry.
This happens whenever no keyword matches and a Core Java book (whose location field references the backup warehouse) is sent to the client.
Click here to view code imageClick here to view code image.
Now suppose a WarehouseImpl class implements this interface as well as the Warehouse interface.
When a remote reference to such a service center is transferred to another virtual machine, the recipient obtains a stub that has access to the remote methods in both the ServiceCenter and the Warehouse interface.
You can use the instanceof operator to find out whether a particular remote object implements an interface.
Suppose you receive a remote object through a variable of type Warehouse.
The remote object might or might not be a service center.
To find out, use the test if (location instanceof ServiceCenter)
In the case of a hash set or hash map, the hashCode method must be defined as well.
However, there is a problem when trying to compare remote objects.
To find out if two remote objects have the same contents, the call to equals would need to contact the servers containing the objects and compare their contents.
But the equals method in the class Object is not declared to throw a RemoteException, whereas all methods in a remote interface must throw that exception.
Since a subclass method cannot throw more exceptions than the superclass method it replaces, you cannot define an equals method in a remote interface.
Instead, the equals and hashCode methods on stub objects simply look at the location of the remote objects.
The equals method deems two stubs equal if they refer to the same remote object.
Two stubs that refer to different remote objects are never equal, even if those objects have identical contents.
Similarly, the hash code is computed only from the object identifier.
For the same technical reasons, remote references do not have a clone method.
If clone were to make a remote call to tell the server to clone the implementation object, then the clone method would need to throw a RemoteException.
To summarize, you can use remote references in sets and hash tables, but you must remember that equality testing and hashing do not take into account the contents of the remote objects.
In the preceding sample programs, we used a server program to instantiate and register objects so that clients could make remote calls on them.
However, in some cases, it might be wasteful to instantiate lots of remote objects and have them wait for connections, whether or not client objects use them.
The activation mechanism lets you delay the object construction so that a remote object is only constructed when at least one client invokes a remote method on it.
To take advantage of activation, the client code is completely unchanged.
The client simply requests a remote reference and makes calls through it.
However, the server program is replaced by an activation program that constructs activation descriptors of the objects that are to be constructed at a later time, and binds receivers for remote method calls with the naming service.
When a call is made for the first time, the information in the activation descriptor is used to construct the object.
Of course, it also implements one or more remote interfaces.
Since the object construction is delayed until a later time, it must happen in a standardized form.
Therefore, you must provide a constructor that takes two parameters:
An activation ID (which you simply pass to the superclass constructor)
A single object containing all construction information, wrapped in a MarshalledObject.
If you need multiple construction parameters, you must package them into a single object.
You can always use an Object[] array or an ArrayList for this purpose.
When you build the activation descriptor, you will construct a MarshalledObject from the construction information like.
In the constructor of the implementation object, use the get method of the MarshalledObject class to obtain the deserialized construction information.
To demonstrate activation, we modify the WarehouseImpl class so that the construction information is a map of descriptions and prices.
That information is wrapped into a MarshalledObject and unwrapped in the constructor: Click here to view code imageClick here to view code image.
By passing 0 as the second parameter of the superclass constructor, we indicate that the RMI library should assign a suitable port number to the listener port.
This constructor prints a message so that you can see that the warehouse object is activated on demand.
Your remote objects don’t actually have to extend the Activatable class.
An activation group describes common parameters for launching the virtual machine that contains the remote objects.
Construct an activation group descriptor as follows: Click here to view code imageClick here to view code image.
We don’t need any for this example, so we pass a null reference.
For each object that should be constructed on demand, you need the following:
The activation group ID for the virtual machine in which the object should be constructed.
The URL string from which to load the class files.
This should be the base URL, not including package paths.
For example, Click here to view code imageClick here to view code image.
It returns an object of some class that implements the remote interfaces of the implementation class.
You can bind that object with the naming service: Click here to view code imageClick here to view code image.
Unlike the server programs of the preceding examples, the activation program exits after registering and binding the activation receivers.
The remote objects are constructed only when the first remote method call occurs.
Start the RMI registry in the rmi directory (which contains no class files)
The rmid program listens to activation requests and activates objects in a separate virtual machine.
To launch a virtual machine, the rmid program needs certain permissions.
These are specified in a policy file (see Listing 11.12)
Use the -J option to pass an option to the virtual machine running the activation daemon.
The program exits after the activation receivers have been registered with the naming service.
You might wonder why you need to specify the code-base as it is also provided in the constructor of the activation descriptor.
However, that information is only processed by the RMI activation daemon.
The RMI registry still needs the codebase to load the remote interface classes.
When you run the client for the first time, you will also see the constructor messages in the shell window of the activation daemon.
Use 0 for the port to have a port assigned automatically.
Returns the activation receiver that should be made available to remote callers.
Use 0 for the port to have a port assigned automatically.
Returns the activation receiver that should be made available to remote callers.
Object get() deserializes the stored object data and returns the object.
The env parameter contains the path to the virtual machine executable and command-line options, or it is null if no special settings are required.
You have now seen the RMI mechanism, a distributed object model for Java programs.
In the final chapter, we will turn to a different aspect of Java programming: interacting, on the same machine, with “native” code in a different programming language.
While a “100% Pure Java” solution is nice in principle, there are situations in which you will want to write (or use) code written in another language.
Particularly in the early days of Java, many people assumed that it would be a good idea to use C or C++ to speed up critical parts of a Java application.
A presentation at the 1996 JavaOne conference showed this clearly.
The implementors of the cryptography library at Sun Microsystems reported that a pure Java platform implementation of their cryptographic functions was more than adequate.
It was true that the code was not as fast as a C implementation would have been, but it turned out not to matter.
The Java platform implementation was far faster than the network I/O.
If a part of your application is written in another language, you must supply a separate native library for every platform you want to support.
Code written in C or C++ offers no protection against overwriting memory through invalid pointer usage.
It is easy to write native methods that corrupt your program or infect the operating system.
Thus, we suggest using native code only when you need to.
In particular, there are three reasons why native code might be the right choice:
Your application requires access to system features or devices that are not accessible through the Java platform.
You have substantial amounts of tested and debugged code in another language, and you know how to port it to all desired target platforms.
You have found, through benchmarking, that the Java code is much slower than the equivalent code in another language.
The Java platform has an API for interoperating with native C code called the Java Native Interface (JNI)
You can also use C++ instead of C to write native methods.
There are a few advantages—type checking is slightly stricter, and accessing the JNI functions is a bit more convenient.
However, JNI does not support any mapping between Java and C++ classes.
Suppose you have a C function that does something you like and, for one reason or another, you don’t want to bother reimplementing it in Java.
For the sake of illustration, we’ll start with a simple C function that prints a greeting.
The Java programming language uses the keyword native for a native method, and you will obviously need to place a method in a class.
The native keyword alerts the compiler that the method will be defined externally.
Of course, native methods will contain no code in the Java programming language, and the method header is followed immediately by a terminating semicolon.
Therefore, native method declarations look similar to abstract method declarations.
As in the previous chapter, we do not use packages here to keep examples simple.
In this particular example, the native method is also declared as static.
We’ll start with a static method because we do not yet want to deal with parameter passing.
To implement the native code, write a corresponding C function.
You must name that function exactly the way the Java virtual machine expects.
Replace every period with an underscore, and append the prefix Java_
If you overload native methods—that is, if you provide multiple native methods with the same name—you must append a double underscore followed by the encoded argument types.
We’ll describe the encoding of the argument types later in this chapter.
Actually, nobody does this by hand; instead, run the javah utility which automatically generates the function names.
To use javah, first compile the source file in Listing 12.1:
Next, call the javah utility, which produces a C header file from the class file.
The javah executable can be found in the jdk/bin directory.
Invoke it with the name of the class, just as you would start a Java program:
This command creates a header file, HelloNative.h, shown in Listing 12.2
The macros JNIEXPORT and JNICALL are defined in the header file jni.h.
They denote compiler-dependent specifiers for exported functions that come from a dynamically loaded library.
Now, simply copy the function prototype from the header file into the source file and give the implementation code for the function, as shown in Listing 12.3
In this simple function, ignore the env and cl arguments.
However, you must then declare the functions that implement the native methods as extern "C"
This stops the C++ compiler from “mangling” the method name.
Compile the native C code into a dynamically loaded library.
For example, with the Gnu C compiler on Linux, use these commands:
That batch file sets up the path and the environment variables needed by the compiler.
You can also use the freely available Cygwin programming environment from www.cygwin.com.
It contains the Gnu C compiler and libraries for UNIX-style programming on Windows.
With Cygwin, use the command Click here to view code imageClick here to view code image.
Alternatively, compile with -D __int64="long long", as shown in the sample compiler invocation.
To ensure that the virtual machine will load the library before the first use of the class, use a static initialization block, as in Listing 12.4
Figure 12.1 gives a summary of the native code processing.
Processing native code After you compile and run this program, the message “Hello, Native World!” is displayed in a terminal window.
If you run Linux, you must add the current directory to the library path.
However, keep in mind that this message is generated by the C printf command and not by any Java programming language code.
We have taken the first steps toward bridging the gap between the two languages! In summary, follow these steps to link a native method to a Java program:
Run javah to get a header file with a C declaration for the method.
The exact method for locating the library is operating system dependent.
Some shared libraries for native code must execute certain initializations.
You can place any initialization code into a JNI_OnLoad method.
Similarly, when the virtual machine (VM) shuts down, it will call the JNI_OnUnload method if you provide it.
When passing numbers between C and Java, you should understand which types correspond to each other.
For example, although C does have data types called int and long, their implementation is platform-dependent.
In the Java platform, of course, an int is always a 32-bit integer.
For that reason, JNI defines types jint, jlong, and so on.
Table 12.1 shows the correspondence between Java types and C types.
In the header file jni.h, these types are declared with typedef statements as the equivalent types on the target platform.
Until Java SE 5.0, Java had no direct analog of the C printf function.
In the following examples, we will suppose you are stuck with an ancient JDK release and decide to implement the same functionality by calling the C printf function in a native method.
Notice that when the method is implemented in C, all int and double parameters are changed to jint and jdouble, as shown in Listing 12.6
The function simply assembles a format string "%w.pf" in the variable fmt, then calls printf.
Next, we want to consider how to transfer strings to and from native methods.
Strings are quite different in the two languages: In Java they are sequences of UTF-16 code points whereas C strings are null-terminated sequences of bytes.
This is clumsy, but it is a historical accident—the JVM specification was written when Unicode was still limited to 16 bits.
If your C code already uses Unicode, you’ll want to use the second set of conversion functions.
On the other hand, if all your strings are restricted to ASCII characters, you can use the “modified UTF-8” conversion functions.
A native method with a String parameter actually receives a value of an opaque type called jstring.
A native method with a return value of type String must return a value of type jstring.
For example, the NewStringUTF function makes a new jstring object out of a char array that contains ASCII characters or, more generally, “modified UTF-8”-encoded byte sequences.
Here is a call to the NewStringUTF function: Click here to view code imageClick here to view code image.
Unless explicitly mentioned otherwise, all code in this chapter is C code.
All calls to JNI functions use the env pointer that is the first argument of every native method.
The env pointer is a pointer to a table of function pointers (see Figure 12.2)
Therefore, you must prefix every JNI call with (*env)-> to actually dereference the function pointer.
Furthermore, env is the first parameter of every JNI function.
The C++ version of the JNIEnv class has inline member functions that take care of the function pointer lookup for you.
Note that you omit the JNIEnv pointer from the parameter list of the call.
To read the contents of an existing jstring object, use the GetStringUTFChars function.
Note that a specific virtual machine is free to choose this character encoding for its internal string representation, so you might get a character pointer into the actual Java string.
Since Java strings are meant to be immutable, it is very important that you treat the const seriously and do not try to write into this character array.
The virtual machine must know when you are finished using the string so that it can garbage-collect it.
The garbage collector runs in a separate thread, and it can interrupt the execution of native methods.
Alternatively, you can supply your own buffer to hold the string characters by calling the GetStringRegion or GetStringUTFRegion methods.
Finally, the GetStringUTFLength function returns the number of characters needed for the “modified UTF-8” encoding of the string.
Let us put these functions to work and write a class that calls the C function sprintf.
We would like to call the function as shown in Listing 12.8
Listing 12.9 shows the class with the native sprint method.
Therefore, the C function that formats a floating-point number has the prototype.
In this function, we chose to keep error handling simple.
If the format code to print a floating-point number is not of the form %w.pc, where c is one of the characters e, E, f, g, or G, then we simply do not format the number.
We’ll show you later how to make a native method throw an exception.
All the native methods you saw so far were static methods with number and string parameters.
Again, this is not something you would normally want to do, but it does illustrate how to access fields from a native method when you need to do so.
To see how to access instance fields from a native method, we will reimplement the raiseSalary method.
Unlike the previous examples of native methods, this is not a static method.
It is no longer of type jclass but of type jobject.
In fact, it is an equivalent of the this reference.
Static methods obtain a reference to the class, whereas nonstatic methods obtain a reference to the implicit this argument object.
Now we access the salary field of the implicit argument.
In the “raw” Java-to-C binding of Java 1.0, this was easy—a programmer could directly access object data fields.
However, direct access requires all virtual machines to expose their internal data layout.
For that reason, the JNI requires programmers to get and set the values of data fields by calling special JNI functions.
In our case, we need to use the GetDoubleField and SetDoubleField functions because the type of salary is double.
The general syntax is: Click here to view code imageClick here to view code image.
Here, fieldID is a value of a special type, jfieldID, that identifies a field in a structure, and Xxx represents a Java data type (Object, Boolean, Byte, and so on)
To obtain the fieldID, you must first get a value representing the class, which you can do in one of two ways.
The FindClass function lets you specify the class name as a string (curiously, with / characters instead of periods as package name separators)
You’ll learn the complete rules for encoding signatures in the next section.
You might be thinking that accessing a data field seems quite convoluted.
The designers of the JNI did not want to expose the data fields directly, so they had to supply functions for getting and setting field values.
To minimize the cost of these functions, computing the field ID from the field name—which is the most expensive step—is factored out into a separate step.
That is, if you repeatedly get and set the value of a particular field, you can incur the cost of computing the field identifier only once.
The following code reimplements the raiseSalary method as a native method: Click here to view code imageClick here to view code image.
Class references are only valid until the native method returns.Thus, you cannot cache the return values of GetObjectClass in your code.
Do not store away a class reference for reuse in a later method call.You must call GetObjectClass every time the native method executes.
If this is intolerable, you can lock the reference with a call to NewGlobalRef:
Now you can use the class reference and field IDs in subsequent calls.
When you are done using the class, make sure to call.
Listing 12.13 contains the C code for the native raiseSalary method.
As you have no object, you must use FindClass instead of GetObjectClass to obtain the class reference.
You have to supply the class, not the instance object, when accessing the field.
For example, here is how you can get a reference to System.out: Click here to view code imageClick here to view code image.
To access instance fields and call methods defined in the Java programming language, you need to learn the rules for “mangling” the names of data types and method signatures.
A method signature describes the parameters and return type of the method.
For the complete signature of a method, list the parameter types inside a pair of parentheses and then list the return type.
For example, a method receiving two integers and returning an integer is encoded as.
That is, the method receives a string and returns void.
Note that the semicolon at the end of the L expression is the terminator of the type expression, not a separator between parameters.
Note that there is no separator between the D and Ljava/util/Date;
Also note that in this encoding scheme, you must use / instead of.
The V at the end denotes a return type of void.
Even though you don’t specify a return type for constructors in Java, you need to add a V to the virtual machine signature.
You can use the javap command with option -s to generate the method signatures from class files.
You will get the following output, displaying the signatures of all fields and methods.
Click here to view code imageClick here to view code image.
There is no rationale whatsoever for forcing programmers to use this mangling scheme for signatures.
Then again, using the mangled signatures lets you partake in the mystique of programming close to the virtual machine.
Of course, Java programming language functions can call C functions—that is what native methods are for.
Can we go the other way? Why would we want to do this anyway? It often happens that a native method needs to request a service from an object that was passed to it.
We’ll first show you how to do it for instance methods, then for static methods.
As an example of calling a Java method from native code, let’s enhance the Printf.
That is, it should be able to print a string on an arbitrary PrintWriter object.
Here is the definition of the method in Java: Click here to view code imageClick here to view code image.
We’ll first assemble the string to be printed into a String object str, as in the sprint method that we already implemented.
Then, from the C function that implements the native method, we’ll call the print method of the PrintWriter class.
You can call any Java method from C by using the function call.
Just as you need a fieldID to access a field of an object, you need a method ID to call a method.
To obtain a method ID, call the JNI function GetMethodID and supply the class, the name of the method, and the method signature.
In our example, we want to obtain the ID of the print method of the PrintWriter class.
As you saw in Volume I, Chapter 12, the PrintWriter class has several overloaded methods called print.
For that reason, you must also supply a string describing the parameters and the return value of the specific function that you want to use.
Here is the complete code to make the method call, by.
Listing 12.16 contains the C code for the native fprint method.
The numerical method IDs and field IDs are conceptually similar to Method and Field objects in the reflection API.
Calling static methods from native methods is similar to calling instance methods.
Supply a class object, not an implicit parameter object, when invoking the method.
The return value of this call is a string that gives the current class path.
As we have no object of the class System readily available, we use FindClass rather than GetObjectClass.
Next, we need the ID of the static getProperty method.
Hence, we obtain the method ID as follows: Click here to view code imageClick here to view code image.
Click here to view code imageClick here to view code image.
The return value of this method is of type jobject.
In C, the types jstring and jclass, as well as the array types to be introduced later, are all type-equivalent to jobject.
The cast of the preceding example is therefore not strictly necessary in C.
But in C++, these types are defined as pointers to “dummy classes” that have the correct inheritance hierarchy.
For example, assigning a jstring to a jobject is legal without a cast in C++, but an assignment from a jobject to a jstring requires a cast.
A native method can create a new Java object by invoking its constructor.
Several variants of the JNI functions can be used to call a Java method from native code.
These are not as important as the functions that we already discussed, but they are occasionally useful.
The function calls the version of the method in the specified class, bypassing the normal dynamic dispatch mechanism.
All call functions have versions with suffixes “A” and “V” that receive the explicit parameters in an array or a va_list (as defined in the C header stdarg.h)
The third function receives the method parameters in a va_list, as defined in the C header stdarg.h.
The first function has a variable number of arguments—simply append the method parameters after the method ID.
The second function receives the method arguments in an array of jvalue.
The third function receives the method parameters in a va_list, as defined in the C header stdarg.h.
The first function has a variable number of arguments—simply append the method parameters after the method ID.
The second function receives the method arguments in an array of jvalue.
The third function receives the method parameters in a va_list, as defined in the C header stdarg.h.
The method ID is obtained from GetMethodID with a method name of "<init>" and a return type of void.
The first function has a variable number of arguments—simply append the method parameters after the method ID.
The second function receives the method arguments in an array of jvalue.
The third function receives the method parameters in a va_list, as defined in the C header stdarg.h.
All array types of the Java programming language have corresponding C types, as shown in Table 12.2
In C, all these array types are actually type synonyms of jobject.
In C++, however, they are arranged in the inheritance hierarchy shown in Figure 12.3
How you access elements in an array depends on whether the array stores objects or a primitive type (bool, char, or a numeric type)
Click here to view code imageClick here to view code image.
Although simple, this approach is also clearly inefficient; you want to be able to access array elements directly, especially when doing vector and matrix computations.
Here, the type Xxx must be a primitive type—that is, not Object.
You can then read and write the array elements directly.
The variable is filled with JNI_TRUE if the array is a copy.
If you aren’t interested in that information, just pass a NULL pointer.
Here is a code sample that multiplies all elements in an array of double values by a constant.
We obtain a C pointer a into the Java array and then access individual elements as a[i]
Click here to view code imageClick here to view code image.
Whether the virtual machine actually copies the array depends on how it allocates arrays and does its garbage collection.
Some “copying” garbage collectors routinely move objects around and update object references.
That strategy is not compatible with “pinning” an array to a particular location, because the collector cannot update the pointer values in native code.
In the Sun JVM implementation, boolean arrays are represented as packed arrays of 32-bit words.
To access just a few elements of a large array, use the GetXxxArrayRegion and SetXxxArrayRegion methods that copy a range of elements from the Java array into a C array and back.
You can create new Java arrays in native methods with the NewXxxArray function.
To create a new array of objects, specify the length, the type of the array elements, and an initial element for all entries (typically, NULL)
Here is an example: Click here to view code imageClick here to view code image.
Java SE 1.4 added three methods to the JNI API: Click here to view code imageClick here to view code image.
Direct buffers are used in the java.nio package to support more efficient input/ output operations and to minimize the copying of data between native and Java arrays.
Native methods are a significant security risk to Java programs.
The C runtime system has no protection against array bounds errors, indirection through bad pointers, and so on.
It is particularly important that programmers of native methods handle all error conditions to preserve the integrity of the Java platform.
In particular, when your native method diagnoses a problem that it cannot handle, it should report this problem to the Java virtual machine.
Instead, you must call the Throw or ThrowNew function to create a new exception object.
When the native method exits, the Java virtual machine throws that exception.
To use the Throw function, call NewObject to create an object of a subtype of Throwable.
For example, here we allocate an EOFException object and throw it: Click here to view code imageClick here to view code image.
It is usually more convenient to call ThrowNew, which constructs an exception object, given a class and a “modified UTF8” byte sequence.
Both Throw and ThrowNew merely post the exception; they do not interrupt the control flow of the native method.
Only when the method returns does the Java virtual machine throw the exception.
Therefore, every call to Throw and ThrowNew should always be immediately followed by a return statement.
If you implement native methods in C++, you cannot throw a Java exception object in your C++ code.
In a C++ binding, it would be possible to implement a translation between exceptions in the C++ and Java programming languages; however, this is not currently done.
Use Throw or ThrowNew to throw a Java exception in a native C++ method, and make sure that your native methods throw no C++ exceptions.
Normally, native code need not be concerned with catching Java exceptions.
However, when a native method calls a Java method, that method might throw an exception.
Moreover, a number of the JNI functions throw exceptions as well.
In situations like these, a native method should call the ExceptionOccurred method to determine whether an exception has been thrown.
If you just want to check whether an exception has been thrown, without obtaining a reference to the exception object, use.
Normally, a native method should simply return when an exception has occurred so that the virtual machine can propagate it to the Java code.
However, a native method may analyze the exception object to determine if it can handle the exception.
If it can, then the function must be called to turn off the exception.
In our next example, we implement the fprint native method with all the paranoia appropriate for a native method.
An OutOfMemoryError if the call to malloc fails Finally, to demonstrate how to check for an exception when calling a Java method from a native method, we send the string to the stream, a character at a time, and call ExceptionOccurred after each call.
When the native method returns, the virtual machine again raises the exception.
The test program in Listing 12.19 demonstrates how the native method throws an exception when the formatting string is not valid.
Up to now, we have considered programs in the Java programming language that made a few C calls, presumably because C was faster or allowed access to functionality inaccessible from the Java platform.
You have a C or C++ program and would like to make calls to Java code.
The invocation API enables you to embed the Java virtual machine into a C or C++ program.
Here is the minimal code that you need to initialize a virtual machine: Click here to view code imageClick here to view code image.
The call to JNI_CreateJavaVM creates the virtual machine and fills in a pointer jvm to the virtual machine and a pointer env to the execution environment.
You can supply any number of options to the virtual machine.
Simply increase the size of the options array and the value of vm_args.nOptions.
When you run into trouble and your program crashes, refuses to initialize the JVM, or can’t load your classes, turn on the JNI debugging mode.
You will see a flurry of messages that indicate the progress in initializing the JVM.
If you don’t see your classes loaded, check both your path and class path settings.
Once you have set up the virtual machine, you can call Java methods as described in the preceding sections.
You’ll need the jvm pointer only to call other functions in the invocation API.
The most important one is the function to terminate the virtual machine:
Our sample program overcomes this problem by loading the library manually.
Make sure to compile the Welcome.java file before starting the invocation test program.
To compile this program under Linux, use Click here to view code imageClick here to view code image.
You will need to make sure that the INCLUDE and LIB environment variables include the paths to the Windows API header and library files.
With Cygwin, compile with Click here to view code imageClick here to view code image.
Before you run the program under Linux/UNIX, make sure that the LD_LIBRARY_PATH contains the directories for the shared libraries.
For example, if you use the bash shell on Linux, issue the following command:
In this section, we describe a full, working example that covers everything we discussed in this chapter: using native methods with strings, arrays, objects, constructor calls, and error handling.
We’ll show you how to put a Java platform wrapper around a subset of the ordinary C-based API used to work with the Windows registry.
Of course, the Windows registry being a Windows-specific feature, such a program is inherently nonportable.
For that reason, the standard Java library has no support for the registry, and it makes sense to use native methods to gain access to it.
The Windows registry is a data depository that holds configuration information for the Windows operating system and application programs.
It provides a single point for administration and backup of system and application preferences.
On the downside, the registry is also a single point of failure—if you mess up the registry, your computer could malfunction or even fail to boot! We don’t suggest that you use the registry to store configuration parameters for your Java programs.
The Java preferences API is a better solution (see Volume I, Chapter 10 for more information)
We’ll simply use the registry to demonstrate how to wrap a nontrivial native API into a Java class.
The principal tool for inspecting the registry is the registry editor.
Because of the potential for error by naive but enthusiastic users, there is no icon for launching the registry editor.
Instead, start a DOS shell (or open the Start -> Run dialog box) and type regedit.
The left side shows the keys, which are arranged in a tree structure.
Note that each key starts with one of the HKEY nodes like.
The right side shows the name/value pairs associated with a particular key.
The values can also be integers or arrays of bytes.
We create a simple interface to access the registry from Java code, and then implement this interface with native code.
Our interface allows only a few registry operations; to keep the code size down, we omitted some important operations such as adding, deleting, and enumerating keys.
It should be easy to add the remaining registry API functions.
Even with the limited subset that we supply, you can.
Here is the Java class that encapsulates a registry key: Click here to view code imageClick here to view code image.
The names method returns an enumeration that holds all the names stored with the key.
The getValue method returns an object that is either a string, an Integer object, or a byte array.
The value parameter of the setValue method must also be of one of these three types.
Fortunately, you have seen essentially all the tools that are required, such as the conversion between Java strings and arrays and those of C.
You also saw how to raise a Java exception in case something goes wrong.
Two issues make these native methods more complex than the preceding examples.
The getValue and setValue methods deal with the type Object, which can be one of String, Integer, or byte[]
The enumeration object stores the state between successive calls to hasMoreElements and nextElement.
The method (shown in Listing 12.22) goes through the following steps:
To read their values, the registry API requires that keys be open.
Queries the type and size of the value associated with the name.
Calls NewStringUTF to create a new string with the value data if the type is REG_SZ (a string)
Closes the key and returns the object (String, Integer, or byte[]) that had been created.
As you can see, this example illustrates quite nicely how to generate Java objects of different types.
In this native method, coping with the generic return type is not difficult.
The jstring, jobject, or jarray reference is simply returned as a jobject.
However, the setValue method receives a reference to an Object and must determine the Object’s exact type to save the Object as a string, integer, or byte array.
Here is an overview of the steps in the setValue method:
Call GetStringUTFChars to get a pointer to the characters if the type is String.
Call the intValue method to get the integer stored in the wrapper object if the type is Integer.
Release the pointer to the data if the type is String or byte[]
Finally, let us turn to the native methods that enumerate keys.
When the enumeration process starts, we must open the key.
For the duration of the enumeration, we must retain the key handle—that is, the key handle must be stored with the enumeration object.
The key handle is of type DWORD (a 32-bit quantity), so it can be stored in a Java integer.
We store it in the hkey field of the enumeration class.
When the enumeration starts, the field is initialized with SetIntField.
In this example, we store three other data items with the enumeration object.
When the enumeration first starts, we can query the registry for the count of name/value pairs and the length of the longest name, which we need so we can allocate C character arrays to hold the names.
These values are stored in the count and maxsize fields of the enumeration object.
Let’s walk through the native methods that support the enumeration.
The nextElement method needs to work a little harder: 1.1
As the registry API is specific to Windows, this program will not work on other operating systems.
Listing 12.23 shows a program to test our new registry functions.
We add three name/value pairs, a string, an integer, and a byte array to the key.
We then enumerate all names of that key and retrieve their values.
Although adding these name/value pairs to that key probably does no harm, you might want to use the registry editor to remove them after running this program.
Click here to view code imageClick here to view code image.
If cl represents the class Object or an interface, returns NULL.
You have now reached the end of the second volume of Core Java, completing a long journey in which you encountered many advanced APIs.
We concluded with very technical chapters on security, remote methods, annotation processing, and native methods.
We hope that you enjoyed your tour through the vast.
