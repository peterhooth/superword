I sure wish I had this book ten years ago.
James Gosling, fellow and vice president, Sun Microsystems, Inc., and inventor of the Java programming language.
I like books that under-promise in their titles and over-deliver in their contents.
This book has 57 items of programming advice that are well chosen.
Each item reveals a clear, deep grasp of the language.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.
In particular, and without limitation, these intellectual property rights may include one or more U.S.
The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions.
No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.
The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales, which may include electronic versions and/or custom covers and content particular to your business, training goals, marketing focus, and branding interests.
Item 2: Consider a builder when faced with many constructor.
Item 17: Design and document for inheritance or else prohibit it.
Item 44: Write doc comments for all exposed API elements.
Item 50: Avoid strings where other types are more appropriate.
If you have ever studied a second language yourself and then tried to use it outside the classroom, you know that there are three things you must master: how the language is structured (grammar), how to name things you want to talk about (vocabulary), and the customary and effective ways to say everyday things (usage)
Too often only the first two are covered in the classroom, and you find native speakers constantly suppressing their laughter as you try to make yourself understood.
You need to understand the core language: is it algorithmic, functional, object-oriented? You need to know the vocabulary: what data structures, operations, and facilities are provided by the standard libraries? And you need to be familiar with the customary and effective ways to structure your code.
Books about programming languages often cover only the first two, or discuss usage only spottily.
Maybe that’s because the first two are in some ways easier to write about.
Grammar and vocabulary are properties of the language alone, but usage is characteristic of a community that uses it.
The libraries address graphic display support, networking, distributed computing, and security.
But how is the language best put to use in practice?
Programs, unlike spoken sentences and unlike most books and magazines, are likely to be changed over time.
It’s typically not enough to produce code that operates effectively and is readily understood by other persons; one must also organize the code so that it is easy to modify.
There may be ten ways to write code for some task T.
Of those ten ways, seven will be awkward, inefficient, or puzzling.
Of the other three, which is most likely to be similar to the code needed for the task T' in next year’s software release?
This book addresses your third need: customary and effective usage.
Joshua Bloch has spent years extending, implementing, and using the Java programming language at Sun Microsystems; he has also read a lot of other people’s code, including mine.
Here he offers good advice, systematically organized, on how to structure your code so that it works well, so that other people can understand it, so that future modifications and improvements are less likely to cause headachesperhaps, even, so that your programs will be pleasant, elegant, and graceful.
A lot has happened to the Java platform since I wrote the first edition of this book in 2001, and it’s high time for a second edition.
With Gilad Bracha, I had the good fortune to lead the teams that designed the new language features.
I also had the good fortune to serve on the team that designed and developed the concurrency library, which was led by Doug Lea.
The other big change in the platform is the widespread adoption of modern Integrated Development Environments (IDEs), such as Eclipse, IntelliJ IDEA, and NetBeans, and of static analysis tools, such as FindBugs.
While I have not been involved in these efforts, I’ve benefited from them immensely and learned how they affect the Java development experience.
In 2004, I moved from Sun to Google, but I’ve continued my involvement in the development of the Java platform over the past four years, contributing to the concurrency and collections APIs through the good offices of Google and the Java Community Process.
I’ve also had the pleasure of using the Java platform to develop libraries for use within Google.
Now I know what it feels like to be a user.
As was the case in 2001 when I wrote the first edition, my primary goal is to share my experience with you so that you can imitate my successes while avoiding my failures.
The new material continues to make liberal use of real-world examples from the Java platform libraries.
The first edition succeeded beyond my wildest expectations, and I’ve done my best to stay true to its spirit while covering all of the new material that was required to bring the book up to date.
It was inevitable that the book would grow, and grow it did, from fifty-seven items to seventy-eight.
Not only did I add twenty-three items, but I thoroughly revised all the original material and retired a.
In the Appendix, you can see how the material in this edition relates to the material in the first edition.
In the Preface to the First Edition, I wrote that the Java programming language and its libraries were immensely conducive to quality and productivity, and a joy to work with.
The platform is much bigger now than it was in 2001 and more complex, but once you learn the patterns and idioms for using the new features, they make your programs better and your life easier.
I hope this edition captures my continued enthusiasm for the platform and helps make your use of the platform and its new features more effective and enjoyable.
In 1996 I pulled up stakes and headed west to work for JavaSoft, as it was then known, because it was clear that that was where the action was.
In the intervening five years I’ve served as Java platform libraries architect.
I’ve designed, implemented, and maintained many of the libraries and served as a consultant for many others.
Presiding over these libraries as the Java platform matured was a once-in-alifetime opportunity.
It is no exaggeration to say that I had the privilege to work with some of the great software engineers of our generation.
In the process, I learned a lot about the Java programming language—what works, what doesn’t, and how to use the language and its libraries to best effect.
This book is my attempt to share my experience with you so that you can imitate my successes while avoiding my failures.
I borrowed the format from Scott Meyers’s Effective C++ [Meyers98], which consists of fifty items, each conveying one specific rule for improving your programs and designs.
I found the format to be singularly effective, and I hope you do too.
In many cases, I took the liberty of illustrating the items with real-world examples from the Java platform libraries.
When describing something that could have been done better, I tried to pick on code that I wrote myself, but occasionally I pick on something written by a colleague.
I sincerely apologize if, despite my best efforts, I’ve offended anyone.
While this book is not targeted solely at developers of reusable components, it is inevitably colored by my experience writing such components over the past two decades.
I naturally think in terms of exported APIs (Application Programming Interfaces), and I encourage you to do likewise.
Even if you aren’t developing reusable components, thinking in these terms tends to improve the quality of the software you write.
Furthermore, it’s not uncommon to write a reusable component without knowing it: You write something useful, share it with your buddy across the hall, and before long you have half a dozen users.
At this point, you no longer have the flexibility to change the API at will and are thankful for all the effort that you put into designing the API when you first wrote the software.
My focus on API design may seem a bit unnatural to devotees of the new lightweight software development methodologies, such as Extreme Programming [Beck99]
These methodologies emphasize writing the simplest program that could possibly work.
If you’re using one of these methodologies, you’ll find that a focus on API design serves you well in the refactoring process.
The fundamental goals of refactoring are the improvement of system structure and the avoidance of code duplication.
These goals are impossible to achieve in the absence of welldesigned APIs for the components of the system.
I have found the Java programming language and its libraries to be immensely conducive to quality and productivity, and a joy to work with.
I hope this book captures my enthusiasm and helps make your use of the language more effective and enjoyable.
I thank the readers of the first edition of this book for giving it such a kind and enthusiastic reception, for taking its ideas to heart, and for letting me know what a positive influence it had on them and their work.
I thank the many professors who used the book in their courses, and the many engineering teams that adopted it.
I thank the whole team at Addison-Wesley for the their kindness, professionalism, patience, and grace under pressure.
Through it all, my editor Greg Doench remained unflappable: a fine editor and a perfect gentleman.
My production manager, Julie Nahil, was everything that a production manager should be: diligent, prompt, organized, and friendly.
I have once again been blessed with the best team of reviewers imaginable, and I give my sincerest thanks to each of them.
Again, these reviewers made numerous suggestions that led to great improvements in this book and saved me from many embarrassments.
I give special thanks to Doug Lea and Tim Peierls, who served as sounding boards for many of the ideas in this book.
Doug and Tim were unfailingly generous with their time and knowledge.
I thank my manager at Google, Prabha Krishna, for her continued support and encouragement.
Finally, I thank my wife, Cindy Bloch, for encouraging me to write, for reading each item in raw form, for helping me with Framemaker, for writing the index, and for putting up with me while I wrote.
I thank Patrick Chan for suggesting that I write this book and for pitching the idea to Lisa Friendly, the series managing editor; Tim Lindholm, the series technical editor; and Mike Hendrickson, executive editor of Addison-Wesley.
I thank Lisa, Tim, and Mike for encouraging me to pursue the project and for their superhuman patience and unyielding faith that I would someday write this book.
I thank James Gosling and his original team for giving me something great to write about, and I thank the many Java platform engineers who followed in James’s footsteps.
In particular, I thank my colleagues in Sun’s Java Platform Tools and Libraries Group for their insights, their encouragement, and their support.
I thank my manager, Andrew Bennett, and my director, Larry Abrahams, for lending their full and enthusiastic support to this project.
I thank Rich Green, the VP of Engineering at Java Software, for providing an environment where engineers are free to think creatively and to publish their work.
They made numerous suggestions that led to great improvements in this book and saved me from many embarrassments.
Numerous colleagues, inside and outside Sun, participated in technical discussions that improved the quality of this book.
A special thanks is due Doug Lea, who served as a sounding board for many of the ideas in this book.
Doug has been unfailingly generous with his time and his knowledge.
Even under an impossibly tight schedule, they were always friendly and accommodating.
I am honored that he chose to participate in this project.
Finally, I thank my wife, Cindy Bloch, for encouraging and occasionally threatening me to write this book, for reading each item in its raw form, for helping me with Framemaker, for writing the index, and for putting up with me while I wrote.
This book consists of seventy-eight items, each of which conveys one rule.
The rules capture practices generally held to be beneficial by the best and most experienced programmers.
The items are loosely grouped into ten chapters, each concerning one broad aspect of software design.
The book is not intended to be read from cover to cover: each item stands on its own, more or less.
The items are heavily cross-referenced so you can easily plot your own course through the book.
Most of the items in this book use these features in some way.
The following table shows you where to go for primary coverage of these features:
A key feature of this book is that it contains code examples illustrating many design patterns and idioms.
Where appropriate, they are cross-referenced to the standard reference work in this area [Gamma95]
Many items contain one or more program examples illustrating some practice to be avoided.
Such examples, sometimes known as antipatterns, are clearly labeled with a comment such as “// Never do this!” In each case, the item explains why the example is bad and suggests an alternative approach.
This book is not for beginners: it assumes that you are already comfortable with the Java programming language.
While the book is designed to be accessible to anyone with a working knowledge of the language, it should provide food for thought even for advanced programmers.
Most of the rules in this book derive from a few fundamental principles.
The user of a module should never be surprised by its behavior.
Modules should be as small as possible but no smaller.
As used in this book, the term module refers to any reusable software component, from an individual method to a complex system consisting of multiple packages.
The dependencies between modules should be kept to a minimum.
Errors should be detected as soon as possible after they are made, ideally at compile time.
While the rules in this book do not apply 100 percent of the time, they do characterize best programming practices in the great majority of cases.
You should not slavishly follow these rules, but violate them only occasionally and with good reason.
Learning the art of programming, like most other disciplines, consists of first learning the rules and then learning when to break them.
For the most part, this book is not about performance.
It is about writing programs that are clear, correct, usable, robust, flexible, and maintainable.
If you can do that, it’s usually a relatively simple matter to get the performance you need (Item 55)
Some items do discuss performance concerns, and a few of these items provide performance numbers.
These numbers, which are introduced with the phrase “On my machine,” should be regarded as approximate at best.
When discussing features of the Java programming language and its libraries, it is sometimes necessary to refer to specific releases.
For brevity, this book uses “engineering version numbers” in preference to official release names.
This table shows the mapping between release names and engineering version numbers.
The examples are reasonably complete, but they favor readability over completeness.
They freely use classes from the packages java.util and java.io.
In order to compile the examples, you may have to add one or more of these import statements:
For the most part, this book uses technical terms as they are defined in The Java Language Specification, Third Edition [JLS]
The language supports four kinds of types: interfaces (including annotations), classes (including enums), arrays, and primitives.
Class instances and arrays are objects; primitive values are not.
A class’s members consist of its fields, methods, member classes, and member interfaces.
A method’s signature consists of its name and the types of its formal parameters; the signature does not include the method’s return type.
This book uses a few terms differently from the The Java Language Specification.
Unlike The Java Language Specification, this book uses inheritance as a synonym for subclassing.
To describe the access level that applies when none is specified, this book uses the descriptive term package-private instead of the technically correct term default access [JLS, 6.6.1]
This book uses a few technical terms that are not defined in The Java Language Specification.
The term exported API, or simply API, refers to the classes, interfaces, constructors, members, and serialized forms by which a programmer accesses a class, interface, or package.
The term API, which is short for application programming interface, is used in preference to the otherwise preferable term interface to avoid confusion with the language construct of that name.
A programmer who writes a program that uses an API is referred to as a user of the API.
A class whose implementation uses an API is a client of the API.
Classes, interfaces, constructors, members, and serialized forms are collectively known as API elements.
An exported API consists of the API elements that are accessible outside of the package that defines the API.
These are the API elements that any client can use and the author of the API commits to support.
Not coincidentally, they are also the elements for which the Javadoc utility generates documentation in its default mode of operation.
Loosely speaking, the exported API of a package consists of the public and protected members and constructors of every public class or interface in the package.
The normal way for a class to allow a client to obtain an instance of itself is to provide a public constructor.
There is another technique that should be a part of every programmer’s toolkit.
A class can provide a public static factory method, which is simply a static method that returns an instance of the class.
Here’s a simple example from Boolean (the boxed primitive class for the primitive type boolean)
This method translates a boolean primitive value into a Boolean object reference:
The static factory method described in this item has no direct equivalent in Design Patterns.
A class can provide its clients with static factory methods instead of, or in addition to, constructors.
Providing a static factory method instead of a public constructor has both advantages and disadvantages.
One advantage of static factory methods is that, unlike constructors, they have names.
If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read.
A class can have only a single constructor with a given signature.
Programmers have been known to get around this restriction by providing two constructors whose parameter lists differ only in the order of their parameter types.
The user of such an API will never be able to remember which constructor is which and will end up calling the wrong one by mistake.
People reading code that uses these constructors will not know what the code does without referring to the class documentation.
Because they have names, static factory methods don’t share the restriction discussed in the previous paragraph.
In cases where a class seems to require multiple constructors with the same signature, replace the constructors with static factory methods and carefully chosen names to highlight their differences.
A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time they’re invoked.
This allows immutable classes (Item 15) to use preconstructed instances, or to cache instances as they’re constructed, and dispense them repeatedly to avoid creating unnecessary duplicate objects.
It can greatly improve performance if equivalent objects are requested often, especially if they are expensive to create.
The ability of static factory methods to return the same object from repeated invocations allows classes to maintain strict control over what instances exist at any time.
Also, it allows an immutable class (Item 15) to make the guarantee that no two equal instances exist: a.equals(b) if and only if a==b.
If a class makes this guarantee, then its clients can use the == operator instead of the equals(Object) method, which may result in improved performance.
A third advantage of static factory methods is that, unlike constructors, they can return an object of any subtype of their return type.
This gives you great flexibility in choosing the class of the returned object.
One application of this flexibility is that an API can return objects without making their classes public.
Hiding implementation classes in this fashion leads to a very compact API.
This technique lends itself to interface-based frameworks (Item 18), where interfaces provide natural return types for static factory methods.
Interfaces can’t have static methods, so by convention, static factory methods for an interface named Type are put in a noninstantiable class (Item 4) named Types.
For example, the Java Collections Framework has thirty-two convenience implementations of its collection interfaces, providing unmodifiable collections, synchronized collections, and the like.
The Collections Framework API is much smaller than it would have been had it exported thirty-two separate public classes, one for each convenience implementation.
It is not just the bulk of the API that is reduced, but the conceptual weight.
The user knows that the returned object has precisely the API specified by its interface, so there is no need to read additional class documentation for the implementation classes.
Furthermore, using such a static factory method requires the client to refer to the returned object by its interface rather than its implementation class, which is generally good practice (Item 52)
Not only can the class of an object returned by a public static factory method be nonpublic, but the class can vary from invocation to invocation depending on the values of the parameters to the static factory.
Any class that is a subtype of the declared return type is permissible.
The class of the returned object can also vary from release to release for enhanced software maintainability and performance.
They return one of two implementations, depending on the size of the underlying enum type: if it has sixty-four or fewer elements, as most enum types do, the static factories return a RegularEnumSet instance, which is backed by a single long; if the enum type has sixty-five or more elements, the factories return a JumboEnumSet instance, backed by a long array.
The existence of these two implementation classes is invisible to clients.
If RegularEnumSet ceased to offer performance advantages for small enum types, it could be eliminated from a future release with no ill effects.
Similarly, a future release could add a third or fourth implementation of EnumSet if it proved beneficial for performance.
Clients neither know nor care about the class of the object they get back from the factory; they care only that it is some subclass of EnumSet.
The class of the object returned by a static factory method need not even exist at the time the class containing the method is written.
Such flexible static factory methods form the basis of service provider frameworks, such as the Java Database Connectivity API (JDBC)
A service provider framework is a system in which multiple service providers implement a service, and the system makes the implementations available to its clients, decoupling them from the implementations.
There are three essential components of a service provider framework: a service interface, which providers implement; a provider registration API, which the system uses to register implementations, giving clients access to them; and a service access API, which clients use to obtain an instance of the service.
The service access API typically allows but does not require the client to specify some criteria for choosing a provider.
In the absence of such a specification, the API returns an instance of a default implementation.
The service access API is the “flexible static factory” that forms the basis of the service provider framework.
An optional fourth component of a service provider framework is a service provider interface, which providers implement to create instances of their service implementation.
In the absence of a service provider interface, implementations are registered by class name and instantiated reflectively (Item 53)
There are numerous variants of the service provider framework pattern.
Here is a simple implementation with a service provider interface and a default provider:
A fourth advantage of static factory methods is that they reduce the verbosity of creating parameterized type instances.
Unfortunately, you must specify the type parameters when you invoke the constructor of a parameterized class even if they’re obvious from context.
This typically requires you to provide the type parameters twice in quick succession:
This redundant specification quickly becomes painful as the length and complexity of the type parameters increase.
With static factories, however, the compiler can figure out the type parameters for you.
Then you could replace the wordy declaration above with this succinct alternative:
Someday the language may perform this sort of type inference on constructor invocations as well as method invocations, but as of release 1.6, it does not.
Unfortunately, the standard collection implementations such as HashMap do not have factory methods as of release 1.6, but you can put these methods in your own utility class.
More importantly, you can provide such static factories in your own parameterized classes.
The main disadvantage of providing only static factory methods is that classes without public or protected constructors cannot be subclassed.
The same is true for nonpublic classes returned by public static factories.
For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework.
Arguably this can be a blessing in disguise, as it encourages programmers to use composition instead of inheritance (Item 16)
A second disadvantage of static factory methods is that they are not readily distinguishable from other static methods.
They do not stand out in API documentation in the way that constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors.
The Javadoc tool may someday draw attention to static factory methods.
In the meantime, you can reduce this disadvantage by drawing attention to static factories in class or interface comments, and by adhering to common naming conventions.
In the case of a singleton, getInstance takes no parameters and returns the sole instance.
Type indicates the type of object returned by the factory method.
Type indicates the type of object returned by the factory method.
In summary, static factory methods and public constructors both have their uses, and it pays to understand their relative merits.
Often static factories are preferable, so avoid the reflex to provide public constructors without first considering static factories.
Item 2: Consider a builder when faced with many constructor parameters.
Static factories and constructors share a limitation: they do not scale well to large numbers of optional parameters.
Consider the case of a class representing the Nutrition Facts label that appears on packaged foods.
These labels have a few required fields—serving size, servings per container, and calories per servingand over twenty optional fields—total fat, saturated fat, trans fat, cholesterol, sodium, and so on.
Most products have nonzero values for only a few of these optional fields.
What sort of constructors or static factories should you write for such a class? Traditionally, programmers have used the telescoping constructor pattern, in which you provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on, culminating in a constructor with all the optional parameters.
When you want to create an instance, you use the constructor with the shortest parameter list containing all the parameters you want to set:
Typically this constructor invocation will require many parameters that you don’t want to set, but you’re forced to pass a value for them anyway.
In this case, we passed a value of 0 for fat.
With “only” six parameters this may not seem so bad, but it quickly gets out of hand as the number of parameters increases.
In short, the telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it.
The reader is left wondering what all those values mean and must carefully count parameters to find out.
Long sequences of identically typed parameters can cause subtle bugs.
If the client accidentally reverses two such parameters, the compiler won’t complain, but the program will misbehave at runtime (Item 40)
A second alternative when you are faced with many constructor parameters is the JavaBeans pattern, in which you call a parameterless constructor to create the object and then call setter methods to set each required parameter and each optional parameter of interest:
This pattern has none of the disadvantages of the telescoping constructor pattern.
It is easy, if a bit wordy, to create instances, and easy to read the resulting code:
Unfortunately, the JavaBeans pattern has serious disadvantages of its own.
Because construction is split across multiple calls, a JavaBean may be in an inconsistent state partway through its construction.
The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters.
Attempting to use an object when it’s in an inconsistent state may cause failures that are far removed from the code containing the bug, hence difficult to debug.
A related disadvantage is that the JavaBeans pattern precludes the possibility of making a class immutable (Item 15), and requires added effort on the part of the programmer to ensure thread safety.
It is possible to reduce these disadvantages by manually “freezing” the object when its construction is complete and not allowing it to be used until frozen, but this variant is unwieldy and rarely used in practice.
Moreover, it can cause errors at runtime, as the compiler cannot ensure that the programmer calls the freeze method on an object before using it.
Luckily, there is a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern.
Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object.
Then the client calls setter-like methods on the builder object to set each optional parameter of interest.
Finally, the client calls a parameterless build method to generate the object, which is immutable.
The builder is a static member class (Item 22) of the class it builds.
Note that NutritionFacts is immutable, and that all parameter default values are in a single location.
The builder’s setter methods return the builder itself so that invocations can be chained.
This client code is easy to write and, more importantly, to read.
The Builder pattern simulates named optional parameters as found in Ada and Python.
Like a constructor, a builder can impose invariants on its parameters.
It is critical that they be checked after copying the parameters from the builder to the object, and that they be checked on the object fields rather than the builder fields (Item 39)
The exception’s detail method should indicate which invariant is violated (Item 63)
Another way to impose invariants involving multiple parameters is to have setter methods take entire groups of parameters on which some invariant must hold.
This has the advantage of detecting the invariant failure as soon as the invalid parameters are passed, instead of waiting for build to be invoked.
A minor advantage of builders over constructors is that builders can have multiple varargs parameters.
Because builders use separate methods to set each parameter, they can have as many varargs parameters as you like, up to one per setter method.
A single builder can be used to build multiple objects.
The parameters of the builder can be tweaked between object creations to vary the objects.
The builder can fill in some fields automatically, such as a serial number that automatically increases each time an object is created.
In other words, a client can pass such a builder to a method to enable the method to create one or more objects for the client.
To enable this usage, you need a type to represent the builder.
Methods that take a Builder instance would typically constrain the builder’s type parameter using a bounded wildcard type (Item 28)
For example, here is a method that builds a tree using a client-provided Builder instance to build each node:
The traditional Abstract Factory implementation in Java has been the Class object, with the newInstance method playing the part of the build method.
The newInstance method always attempts to invoke the class’s parameterless constructor, which may not even exist.
You don’t get a compile-time error if the class has no accessible parameterless constructor.
Also, the newInstance method propagates any exceptions thrown by the parameterless constructor, even though newInstance lacks the corresponding throws clauses.
In order to create an object, you must first create its builder.
Also, the Builder pattern is more verbose than the telescoping constructor pattern, so it should be used only if there are enough parameters, say, four or more.
But keep in mind that you may want to add parameters in the future.
If you start out with constructors or static factories, and add a builder when the class evolves to the point where the number of parameters starts to get out of hand, the obsolete constructors or static factories will stick out like a sore thumb.
Therefore, it’s often better to start with a builder in the first place.
In summary, the Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters, especially if most of those parameters are optional.
Client code is much easier to read and write with builders than with the traditional telescoping constructor pattern, and builders are much safer than JavaBeans.
Item 3: Enforce the singleton property with a private constructor or an enum type.
Singletons typically represent a system component that is intrinsically unique, such as the window manager or file system.
Making a class a singleton can make it difficult to test its clients, as it’s impossible to substitute a mock implementation for a singleton unless it implements an interface that serves as its type.
Before release 1.5, there were two ways to implement singletons.
Both are based on keeping the constructor private and exporting a public static member to provide access to the sole instance.
The private constructor is called only once, to initialize the public static final field Elvis.INSTANCE.
The lack of a public or protected constructor guarantees a “monoelvistic” universe: exactly one Elvis instance will exist once the Elvis class is initialized—no more, no less.
If you need to defend against this attack, modify the constructor to make it throw an exception if it’s asked to create a second instance.
In the second approach to implementing singletons, the public member is a static factory method:
The main advantage of the public field approach is that the declarations make it clear that the class is a singleton: the public static field is final, so it will always contain the same object reference.
There is no longer any performance advantage to the public field approach: modern Java virtual machine (JVM) implementations are almost certain to inline the call to the static factory method.
One advantage of the factory-method approach is that it gives you the flexibility to change your mind about whether the class should be a singleton without changing its API.
The factory method returns the sole instance but could easily be modified to return, say, a unique instance for each thread that invokes it.
Often neither of these advantages is relevant, and the final-field approach is simpler.
To make a singleton class that is implemented using either of the previous approaches serializable (Chapter 11), it is not sufficient merely to add implements Serializable to its declaration.
To maintain the singleton guarantee, you have to declare all instance fields transient and provide a readResolve method (Item 77)
Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings.
To prevent this, add this readResolve method to the Elvis class:
Return the one true Elvis and let the garbage collector // take care of the Elvis impersonator.
As of release 1.5, there is a third approach to implementing singletons.
This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks.
While this approach has yet to be widely adopted, a single-element enum type is the best way to implement a singleton.
Occasionally you’ll want to write a class that is just a grouping of static methods and static fields.
Such classes have acquired a bad reputation because some people abuse them to avoid thinking in terms of objects, but they do have valid uses.
Lastly, they can be used to group methods on a final class, instead of extending the class.
Such utility classes were not designed to be instantiated: an instance would be nonsensical.
In the absence of explicit constructors, however, the compiler provides a public, parameterless default constructor.
To a user, this constructor is indistinguishable from any other.
It is not uncommon to see unintentionally instantiable classes in published APIs.
Attempting to enforce noninstantiability by making a class abstract does not work.
Furthermore, it misleads the user into thinking the class was designed for inheritance (Item 17)
A default constructor is generated only if a class contains no explicit constructors, so a class can be made noninstantiable by including a private constructor:
Because the explicit constructor is private, it is inaccessible outside of the class.
The AssertionError isn’t strictly required, but it provides insurance in case the constructor is accidentally invoked from within the class.
It guarantees that the class will never be instantiated under any circumstances.
This idiom is mildly counterintuitive, as the constructor is provided expressly so that it cannot be invoked.
It is therefore wise to include a comment, as shown above.
As a side effect, this idiom also prevents the class from being subclassed.
All constructors must invoke a superclass constructor, explicitly or implicitly, and a subclass would have no accessible superclass constructor to invoke.
Item 5: Avoid creating unnecessary objects It is often appropriate to reuse a single object instead of creating a new functionally equivalent object each time it is needed.
An object can always be reused if it is immutable (Item 15)
As an extreme example of what not to do, consider this statement:
The statement creates a new String instance each time it is executed, and none of those object creations is necessary.
The argument to the String constructor ("stringette") is itself a String instance, functionally identical to all of the objects created by the constructor.
If this usage occurs in a loop or in a frequently invoked method, millions of String instances can be created needlessly.
This version uses a single String instance, rather than creating a new one each time it is executed.
Furthermore, it is guaranteed that the object will be reused by any other code running in the same virtual machine that happens to contain the same string literal [JLS, 3.10.5]
You can often avoid creating unnecessary objects by using static factory methods (Item 1) in preference to constructors on immutable classes that provide both.
The constructor creates a new object each time it’s called, while the static factory method is never required to do so and won’t in practice.
In addition to reusing immutable objects, you can also reuse mutable objects if you know they won’t be modified.
Here is a slightly more subtle, and much more common, example of what not to do.
It involves mutable Date objects that are never modified once their values have been computed.
The isBabyBoomer method unnecessarily creates a new Calendar, TimeZone, and two Date instances each time it is invoked.
The version that follows avoids this inefficiency with a static initializer:
The improved version of the Person class creates Calendar, TimeZone, and Date instances only once, when it is initialized, instead of creating them every time isBabyBoomer is invoked.
Changing boomStart and boomEnd from local variables to static final fields makes it clear that these dates are treated as constants, making the code more understandable.
In the interest of full disclosure, the savings from this sort of optimization will not always be this dramatic, as Calendar instances are particularly expensive to create.
It would be possible to eliminate the unnecessary initializations by lazily initializing these fields (Item 71) the first time the isBabyBoomer method is invoked, but it is not recommended.
As is often the case with lazy initialization, it would complicate the implementation and would be unlikely to result in a noticeable performance improvement beyond what we’ve already achieved (Item 55)
In the previous examples in this item, it was obvious that the objects in question could be reused because they were not modified after initialization.
An adapter is an object that delegates to a backing object, providing an alternative interface to the backing object.
Because an adapter has no state beyond that of its backing object, there’s no need to create more than one instance of a given adapter to a given object.
For example, the keySet method of the Map interface returns a Set view of the Map object, consisting of all the keys in the map.
Naively, it would seem that every call to keySet would have to create a new Set instance, but every call to keySet on a given Map object may return the same Set instance.
Although the returned Set instance is typically mutable, all of the returned objects are functionally identical: when one of the returned objects changes, so do all the others because they’re all backed by the same Map instance.
While it is harmless to create multiple instances of the keySet view object, it is also unnecessary.
There’s a new way to create unnecessary objects in release 1.5
It is called autoboxing, and it allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed.
Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.
There are subtle semantic distinctions, and not-so-subtle performance differences (Item 49)
Consider the following program, which calculates the sum of all the positive int.
To do this, the program has to use long arithmetic, because an int is not big enough to hold the sum of all the positive int values:
This program gets the right answer, but it is much slower than it should be, due to a one-character typographical error.
The variable sum is declared as a Long instead of a long, which means that the program constructs about 231 unnecessary Long instances (roughly one for each time the long i is added to the Long sum)
The lesson is clear: prefer primitives to boxed primitives, and watch out for unintentional autoboxing.
This item should not be misconstrued to imply that object creation is expensive and should be avoided.
On the contrary, the creation and reclamation of small objects whose constructors do little explicit work is cheap, especially on modern JVM implementations.
Creating additional objects to enhance the clarity, simplicity, or power of a program is generally a good thing.
Conversely, avoiding object creation by maintaining your own object pool is a bad idea unless the objects in the pool are extremely heavyweight.
The classic example of an object that does justify an object pool is a database connection.
The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects.
Also, your database license may limit you to a fixed number of connections.
Generally speaking, however, maintaining your own object pools clutters your code, increases memory footprint, and harms performance.
Modern JVM implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight objects.
The counterpoint to this item is Item 39 on defensive copying.
Item 5 says, “Don’t create a new object when you should reuse an existing one,” while Item 39 says, “Don’t reuse an existing object when you should create a new one.” Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object.
Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely affects style and performance.
Item 6: Eliminate obsolete object references When you switch from a language with manual memory management, such as C or C++, to a garbage-collected language, your job as a programmer is made much easier by the fact that your objects are automatically reclaimed when you’re through with them.
It seems almost like magic when you first experience it.
It can easily lead to the impression that you don’t have to think about memory management, but this isn’t quite true.
There’s nothing obviously wrong with this program (but see Item 26 for a generic version)
You could test it exhaustively, and it would pass every test with flying colors, but there’s a problem lurking.
Loosely speaking, the program has a “memory leak,” which can silently manifest itself as reduced performance due to.
In extreme cases, such memory leaks can cause disk paging and even program failure with an OutOfMemoryError, but such failures are relatively rare.
So where is the memory leak? If a stack grows and then shrinks, the objects that were popped off the stack will not be garbage collected, even if the program using the stack has no more references to them.
This is because the stack maintains obsolete references to these objects.
An obsolete reference is simply a reference that will never be dereferenced again.
In this case, any references outside of the “active portion” of the element array are obsolete.
The active portion consists of the elements whose index is less than size.
Memory leaks in garbage-collected languages (more properly known as unintentional object retentions) are insidious.
If an object reference is unintentionally retained, not only is that object excluded from garbage collection, but so too are any objects referenced by that object, and so on.
Even if only a few object references are unintentionally retained, many, many objects may be prevented from being garbage collected, with potentially large effects on performance.
The fix for this sort of problem is simple: null out references once they become obsolete.
In the case of our Stack class, the reference to an item becomes obsolete as soon as it’s popped off the stack.
The corrected version of the pop method looks like this:
It is always beneficial to detect programming errors as quickly as possible.
When programmers are first stung by this problem, they may overcompensate by nulling out every object reference as soon as the program is finished using it.
This is neither necessary nor desirable, as it clutters up the program unnecessarily.
Nulling out object references should be the exception rather than the norm.
The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope.
This occurs naturally if you define each variable in the narrowest possible scope (Item 45)
So when should you null out a reference? What aspect of the Stack class makes it susceptible to memory leaks? Simply put, it manages its own memory.
The storage pool consists of the elements of the elements array (the object reference cells, not the objects themselves)
The elements in the active portion of the array (as defined earlier) are allocated, and those in the remainder of the array are free.
The garbage collector has no way of knowing this; to the garbage collector, all of the object references in the elements array are equally valid.
Only the programmer knows that the inactive portion of the array is unimportant.
The programmer effectively communicates this fact to the garbage collector by manually nulling out array elements as soon as they become part of the inactive portion.
Generally speaking, whenever a class manages its own memory, the programmer should be alert for memory leaks.
Whenever an element is freed, any object references contained in the element should be nulled out.
Once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant.
If you’re lucky enough to implement a cache for which an entry is relevant exactly so long as there are references to its key outside of the cache, represent the cache as a WeakHashMap; entries will be removed automatically after they become obsolete.
Remember that WeakHashMap is useful only if the desired lifetime of cache entries is determined by external references to the key, not the value.
More commonly, the useful lifetime of a cache entry is less well defined, with entries becoming less valuable over time.
Under these circumstances, the cache should occasionally be cleansed of entries that have fallen into disuse.
The LinkedHashMap class facilitates the latter approach with its removeEldestEntry method.
For more sophisticated caches, you may need to use java.lang.ref directly.
A third common source of memory leaks is listeners and other callbacks.
If you implement an API where clients register callbacks but don’t deregister them explicitly, they will accumulate unless you take some action.
The best way to ensure that callbacks are garbage collected promptly is to store only weak references to them, for instance, by storing them only as keys in a WeakHashMap.
Because memory leaks typically do not manifest themselves as obvious failures, they may remain present in a system for years.
They are typically discovered only as a result of careful code inspection or with the aid of a debugging tool known as a heap profiler.
Therefore, it is very desirable to learn to anticipate problems like this before they occur and prevent them from happening.
Their use can cause erratic behavior, poor performance, and portability problems.
Finalizers have a few valid uses, which we’ll cover later in this item, but as a rule of thumb, you should avoid finalizers.
C++ programmers are cautioned not to think of finalizers as Java’s analog of C++ destructors.
In C++, destructors are the normal way to reclaim the resources associated with an object, a necessary counterpart to constructors.
In Java, the garbage collector reclaims the storage associated with an object when it becomes unreachable, requiring no special effort on the part of the programmer.
C++ destructors are also used to reclaim other nonmemory resources.
In Java, the tryfinally block is generally used for this purpose.
One shortcoming of finalizers is that there is no guarantee they’ll be executed promptly [JLS, 12.6]
It can take arbitrarily long between the time that an object becomes unreachable and the time that its finalizer is executed.
This means that you should never do anything time-critical in a finalizer.
For example, it is a grave error to depend on a finalizer to close files, because open file descriptors are a limited resource.
If many files are left open because the JVM is tardy in executing finalizers, a program may fail because it can no longer open files.
The promptness with which finalizers are executed is primarily a function of the garbage collection algorithm, which varies widely from JVM implementation to JVM implementation.
The behavior of a program that depends on the promptness of finalizer execution may likewise vary.
It is entirely possible that such a program will run perfectly on the JVM on which you test it and then fail miserably on the JVM favored by your most important customer.
Providing a finalizer for a class can, under rare conditions, arbitrarily delay reclamation of its instances.
A colleague debugged a long-running GUI application that was mysteriously dying with an OutOfMemoryError.
Analysis revealed that at the time of its death, the application had thousands of graphics objects on its finalizer queue just waiting to be finalized and reclaimed.
Unfortunately, the finalizer thread was running at a lower priority than another application thread, so objects weren’t getting finalized at the rate they became eligible for finalization.
The language specification makes no guarantees as to which thread will execute finalizers, so there is no portable way to prevent this sort of problem other than to refrain from using finalizers.
Not only does the language specification provide no guarantee that finalizers will get executed promptly; it provides no guarantee that they’ll get executed at.
It is entirely possible, even likely, that a program terminates without executing finalizers on some objects that are no longer reachable.
As a consequence, you should never depend on a finalizer to update critical persistent state.
For example, depending on a finalizer to release a persistent lock on a shared resource such as a database is a good way to bring your entire distributed system to a grinding halt.
They may increase the odds of finalizers getting executed, but they don’t guarantee it.
These methods are fatally flawed and have been deprecated [ThreadStop]
In case you are not yet convinced that finalizers should be avoided, here’s another tidbit worth considering: if an uncaught exception is thrown during finalization, the exception is ignored, and finalization of that object terminates [JLS, 12.6]
If another thread attempts to use such a corrupted object, arbitrary nondeterministic behavior may result.
Normally, an uncaught exception will terminate the thread and print a stack trace, but not if it occurs in a finalizer—it won’t even print a warning.
Oh, and one more thing: there is a severe performance penalty for using finalizers.
On my machine, the time to create and destroy a simple object is about 430 times slower to create and destroy objects with finalizers.
So what should you do instead of writing a finalizer for a class whose objects encapsulate resources that require termination, such as files or threads? Just provide an explicit termination method, and require clients of the class to invoke this method on each instance when it is no longer needed.
These methods are often overlooked, with predictably dire performance consequences.
Explicit termination methods are typically used in combination with the try-finally construct to ensure termination.
Invoking the explicit termination method inside the finally clause ensures that it will get executed even if an exception is thrown while the object is being used:
So what, if anything, are finalizers good for? There are perhaps two legitimate uses.
One is to act as a “safety net” in case the owner of an object forgets to call its explicit termination method.
While there’s no guarantee that the finalizer will be invoked promptly, it may be better to free the resource late than never, in those (hopefully rare) cases when the client fails to call the explicit termination method.
But the finalizer should log a warning if it finds that the resource has not been terminated, as this indicates a bug in the client code, which should be fixed.
If you are considering writing such a safety-net finalizer, think long and hard about whether the extra protection is worth the extra cost.
The four classes cited as examples of the explicit termination method pattern (FileInputStream, FileOutputStream, Timer, and Connection) have finalizers that serve as safety nets in case their termination methods aren’t called.
Such warnings generally can’t be added after an API is published, as it would appear to break existing clients.
A second legitimate use of finalizers concerns objects with native peers.
A native peer is a native object to which a normal object delegates via native methods.
Because a native peer is not a normal object, the garbage collector doesn’t know about it and can’t reclaim it when its Java peer is reclaimed.
A finalizer is an appropriate vehicle for performing this task, assuming the native peer holds no critical resources.
If the native peer holds resources that must be terminated promptly, the class should have an explicit termination method, as described above.
The termination method should do whatever is required to free the critical resource.
The termination method can be a native method, or it can invoke one.
It is important to note that “finalizer chaining” is not performed automatically.
If a class (other than Object) has a finalizer and a subclass overrides it, the subclass finalizer must invoke the superclass finalizer manually.
You should finalize the subclass in a try block and invoke the superclass finalizer in the corresponding finally block.
This ensures that the superclass finalizer gets executed even if the subclass finalization throws an exception and vice versa.
You can ignore Override annotations for now, or see Item 36 to find out what they mean:
If a subclass implementor overrides a superclass finalizer but forgets to invoke it, the superclass finalizer will never be invoked.
It is possible to defend against such a careless or malicious subclass at the cost of creating an additional object for every object to be finalized.
Instead of putting the finalizer on the class requiring finalization, put the finalizer on an anonymous class (Item 22) whose sole purpose is to finalize its enclosing instance.
A single instance of the anonymous class, called a finalizer guardian, is created for each instance of the enclosing class.
The enclosing instance stores the sole reference to its finalizer guardian in a private instance field so the finalizer guardian becomes eligible for finalization at the same time as the enclosing instance.
When the guardian is finalized, it performs the finalization activity desired for the enclosing instance, just as if its finalizer were a method on the enclosing class:
Note that the public class, Foo, has no finalizer (other than the trivial one it inherits from Object), so it doesn’t matter whether a subclass finalizer calls super.finalize or not.
This technique should be considered for every nonfinal public class that has a finalizer.
In summary, don’t use finalizers except as a safety net or to terminate noncritical native resources.
In those rare instances where you do use a finalizer, remember to invoke super.finalize.
If you use a finalizer as a safety net, remember to log the invalid usage from the finalizer.
Lastly, if you need to associate a finalizer with a public, nonfinal class, consider using a finalizer guardian, so finalization can take place even if a subclass finalizer fails to invoke super.finalize.
All of its nonfinal methods (equals, hashCode, toString, clone, and finalize) have explicit general contracts because they are designed to be overridden.
It is the responsibility of any class overriding these methods to obey their general contracts; failure to do so will prevent other classes that depend on the contracts (such as HashMap and HashSet) from functioning properly in conjunction with the class.
This chapter tells you when and how to override the nonfinal Object methods.
Overriding the equals method seems simple, but there are many ways to get it wrong, and consequences can be dire.
The easiest way to avoid problems is not to override the equals method, in which case each instance of the class is equal only to itself.
This is the right thing to do if any of the following conditions apply:
This is true for classes such as Thread that represent active entities rather than values.
The equals implementation provided by Object has exactly the right behavior for these classes.
You don’t care whether the class provides a “logical equality” test.
Under these circumstances, the equals implementation inherited from Object is adequate.
A superclass has already overridden equals, and the superclass behavior is appropriate for this class.
For example, most Set implementations inherit their equals implementation from AbstractSet, List implementations from AbstractList, and Map implementations from AbstractMap.
The class is private or package-private, and you are certain that its equals method will never be invoked.
Arguably, the equals method should be overridden under these circumstances, in case it is accidentally invoked:
So when is it appropriate to override Object.equals? When a class has a notion of logical equality that differs from mere object identity, and a superclass has not already overridden equals to implement the desired behavior.
A value class is simply a class that represents a value, such as Integer or Date.
A programmer who compares references to value objects using the equals method expects to find out whether they are logically equivalent, not whether they refer to the same object.
Not only is overriding the equals method necessary to satisfy programmer expectations; it enables instances to serve as map keys or set elements with predictable, desirable behavior.
One kind of value class that does not require the equals method to be overridden is a class that uses instance control (Item 1) to ensure that at most one object exists with each value.
For these classes, logical equality is the same as object identity, so Object’s equals method functions as a logical equals method.
When you override the equals method, you must adhere to its general contract.
Here is the contract, copied from the specification for Object [JavaSE6]:
Reflexive: For any non-null reference value x, x.equals(x) must return true.
Symmetric: For any non-null reference values x and y, x.equals(y) must return true if and only if y.equals(x) returns true.
Transitive: For any non-null reference values x, y, z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) must return true.
Consistent: For any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.
For any non-null reference value x, x.equals(null) must return false.
Unless you are mathematically inclined, this might look a bit scary, but do not ignore it! If you violate it, you may well find that your program behaves erratically or crashes, and it can be very difficult to pin down the source of the failure.
Many classes, including all collections classes, depend on the objects passed to them obeying the equals contract.
Now that you are aware of the dangers of violating the equals contract, let’s go over the contract in detail.
The good news is that, appearances notwithstanding, the contract really isn’t very complicated.
Once you understand it, it’s not hard to adhere to it.
Reflexivity—The first requirement says merely that an object must be equal to itself.
If you were to violate it and then add an instance of your class to a collection, the collection’s contains method might well say that the collection didn’t contain the instance that you just added.
Symmetry—The second requirement says that any two objects must agree on whether they are equal.
Unlike the first requirement, it’s not hard to imagine violating this one unintentionally.
For example, consider the following class, which implements a case-insensitive string.
The case of the string is preserved by toString but ignored in comparisons:
The well-intentioned equals method in this class naively attempts to interoperate with ordinary strings.
Let’s suppose that we have one case-insensitive string and one ordinary one:
What does list.contains(s) return at this point? Who knows? In Sun’s current implementation, it happens to return false, but that’s just an implementation artifact.
In another implementation, it could just as easily return true or throw a runtime exception.
Once you’ve violated the equals contract, you simply don’t know how other objects will behave when confronted with your object.
To eliminate the problem, merely remove the ill-conceived attempt to interoperate with String from the equals method.
Once you do this, you can refactor the method to give it a single return:
Transitivity—The third requirement of the equals contract says that if one object is equal to a second and the second object is equal to a third, then the first object must be equal to the third.
Again, it’s not hard to imagine violating this requirement unintentionally.
Consider the case of a subclass that adds a new value component to its superclass.
Let’s start with a simple immutable twodimensional integer point class:
Suppose you want to extend this class, adding the notion of color to a point:
How should the equals method look? If you leave it out entirely, the implementation is inherited from Point and color information is ignored in equals comparisons.
While this does not violate the equals contract, it is clearly unacceptable.
Suppose you write an equals method that returns true only if its argument is another color point with the same position and color:
The problem with this method is that you might get different results when comparing a point to a color point and vice versa.
The former comparison ignores color, while the latter comparison always returns false because the type of the argument is incorrect.
To make this concrete, let’s create one point and one color point:
If o is a normal Point, do a color-blind comparison if (!(o instanceof ColorPoint))
This approach does provide symmetry, but at the expense of transitivity:
The first two comparisons are “color-blind,” while the third takes color into account.
So what’s the solution? It turns out that this is a fundamental problem of equivalence relations in object-oriented languages.
There is no way to extend an instantiable class and add a value component while preserving the equals contract, unless you are willing to forgo the benefits of object-oriented abstraction.
You may hear it said that you can extend an instantiable class and add a value component while preserving the equals contract by using a getClass test in place of the instanceof test in the equals method:
Point p = (Point) o; return p.x == x && p.y == y;
This has the effect of equating objects only if they have the same implementation class.
While this may not seem so bad, the consequences are unacceptable.
Let’s suppose we want to write a method to tell whether an integer point is on the unit circle.
While this may not be the fastest way to implement the functionality, it works fine.
But suppose you extend Point in some trivial way that doesn’t add a value component, say, by having its constructor keep track of how many instances have been created:
The Liskov substitution principle says that any important property of a type should also hold for its subtypes, so that any method written for the type should work equally well on its subtypes [Liskov87]
But suppose we pass a CounterPoint instance to the onUnitCircle method.
If the Point class uses a getClassbased equals method, the onUnitCircle method will return false regardless of the CounterPoint instance’s x and y values.
This is so because collections, such as the HashSet used by the onUnitCircle method, use the equals method to test for containment, and no CounterPoint instance is equal to any Point.
If, however, you use a proper instanceof-based equals method on Point, the same onUnitCircle method will work fine when presented with a CounterPoint.
While there is no satisfactory way to extend an instantiable class and add a value component, there is a fine workaround.
There are some classes in the Java platform libraries that do extend an instantiable class and add a value component.
The equals implementation for Timestamp does violate symmetry and can cause erratic behavior if Timestamp and Date objects are used in the same collection or are otherwise intermixed.
The Timestamp class has a disclaimer cautioning programmers against mixing dates and timestamps.
While you won’t get into trouble as long as you keep them separate, there’s nothing to prevent you from mixing them, and the resulting errors can be hard to debug.
This behavior of the Timestamp class was a mistake and should not be emulated.
Note that you can add a value component to a subclass of an abstract class without violating the equals contract.
This is important for the sort of class hierarchies that you get by following the advice in Item 20, “Prefer class hierarchies to tagged classes.” For example, you could have an abstract class Shape with no value components, a subclass Circle that adds a radius field, and a subclass Rectangle that adds length and width fields.
Problems of the sort shown above won’t occur so long as it is impossible to create a superclass instance directly.
Consistency—The fourth requirement of the equals contract says that if two objects are equal, they must remain equal for all time unless one (or both) of them is modified.
In other words, mutable objects can be equal to different objects at different times while immutable objects can’t.
When you write a class, think hard about whether it should be immutable (Item 15)
If you conclude that it should, make sure that your equals method enforces the restriction that equal objects remain equal and unequal objects remain unequal for all time.
Whether or not a class is immutable, do not write an equals method that depends on unreliable resources.
It’s extremely difficult to satisfy the consistency requirement if you violate this prohibition.
For example, java.net.URL’s equals method relies on comparison of the IP addresses of the hosts associated with the URLs.
Translating a host name to an IP address can require network access, and it isn’t guaranteed to yield the same results over time.
This can cause the URL equals method to violate the equals contract and has caused problems in practice.
Unfortunately, this behavior cannot be changed due to compatibility requirements.
With very few exceptions, equals methods should perform deterministic computations on memory-resident objects.
While it is hard to imagine accidentally returning true in response to the invocation o.equals(null), it isn’t hard to imagine accidentally throwing a.
Many classes have equals methods that guard against this with an explicit test for null:
To test its argument for equality, the equals method must first cast its argument to an appropriate type so its accessors may be invoked or its fields accessed.
Before doing the cast, the method must use the instanceof operator to check that its argument is of the correct type:
But the instanceof operator is specified to return false if its first operand is null, regardless of what type appears in the second operand [JLS, 15.20.2]
Therefore the type check will return false if null is passed in, so you don’t need a separate null check.
Putting it all together, here’s a recipe for a high-quality equals method:
Use the == operator to check if the argument is a reference to this object.
This is just a performance optimization, but one that is worth doing if the comparison is potentially expensive.
Use the instanceof operator to check if the argument has the correct type.
Typically, the correct type is the class in which the method occurs.
Use an interface if the class implements an interface that refines the equals contract to permit comparisons across classes that implement the interface.
Because this cast was preceded by an instanceof test, it is guaranteed to succeed.
For each “significant” field in the class, check if that field of the argument matches the corresponding field of this object.
If all these tests succeed, return true; otherwise, return false.
If the type in step 2 is an interface, you must access the argument’s fields via interface methods; if the type is a class, you may be able to access the fields directly, depending on their accessibility.
For primitive fields whose type is not float or double, use the == operator for comparisons; for object reference fields, invoke the equals method recursively; for float fields, use the Float.compare method; and for double fields, use Double.compare.
The special treatment of float and double fields is made necessary by the existence of Float.NaN, -0.0f and the analogous double constants; see the Float.equals documentation for details.
If every element in an array field is significant, you can use one of the Arrays.equals methods added in release 1.5
When you are finished writing your equals method, ask yourself three questions: Is it symmetric? Is it transitive? Is it consistent? And don’t just ask yourself; write unit tests to check that these properties hold! If they don’t, figure out why not, and modify the equals method accordingly.
Of course your equals method also has to satisfy the other two properties (reflexivity and “non-nullity”), but these two usually take care of themselves.
For a concrete example of an equals method constructed according to the.
If you simply test fields for equality, it’s not hard.
If you are overly aggressive in searching for equivalence, it’s easy to get into trouble.
It is generally a bad idea to take any form of aliasing into account.
For example, the File class shouldn’t attempt to equate symbolic links referring to the same file.
Don’t substitute another type for Object in the equals declaration.
It is not uncommon for a programmer to write an equals method that looks like this, and then spend hours puzzling over why it doesn’t work properly:
A common source of bugs is the failure to override the hashCode method.
You must override hashCode in every class that overrides equals.
Failure to do so will result in a violation of the general contract for Object.hashCode, which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable.
Here is the contract, copied from the Object specification [JavaSE6]:
Whenever it is invoked on the same object more than once during an execution of an application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified.
This integer need not remain consistent from one execution of an application to another execution of the same application.
If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.
It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results.
However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.
The key provision that is violated when you fail to override hashCode is the second one: equal objects must have equal hash codes.
Two distinct instances may be logically equal according to a class’s equals method, but to Object’s hashCode method, they’re just two objects with nothing much in common.
Therefore Object’s hashCode method returns two seemingly random numbers instead of two equal numbers as required by the contract.
For example, consider the following simplistic PhoneNumber class, whose equals method is constructed according to the recipe in Item 8:
Suppose you attempt to use this class with a HashMap:
Notice that two PhoneNumber instances are involved: one is used for insertion into the HashMap, and a second, equal, instance is used for (attempted) retrieval.
The PhoneNumber class’s failure to override hashCode causes the two equal instances to have unequal hash codes, in violation of the hashCode contract.
Therefore the get method is likely to look for the phone number in a different hash bucket from the one in which it was stored by the put method.
Even if the two instances happen to hash to the same bucket, the get method will almost certainly return null, as HashMap has an optimization that caches the hash code associated with each entry and doesn’t bother checking for object equality if the hash codes don’t match.
Fixing this problem is as simple as providing a proper hashCode method for the PhoneNumber class.
So what should a hashCode method look like? It’s trivial to write one that is legal but not good.
This one, for example, is always legal but should never be used:
It’s legal because it ensures that equal objects have the same hash code.
It’s atrocious because it ensures that every object has the same hash code.
Therefore, every object hashes to the same bucket, and hash tables degenerate to linked lists.
Programs that should run in linear time instead run in quadratic time.
For large hash tables, this is the difference between working and not working.
A good hash function tends to produce unequal hash codes for unequal objects.
This is exactly what is meant by the third provision of the hashCode contract.
Ideally, a hash function should distribute any reasonable collection of unequal instances uniformly across all possible hash values.
Luckily it’s not too difficult to achieve a fair approximation.
Store some constant nonzero value, say, 17, in an int variable called result.
For each significant field f in your object (each field taken into account by the equals method, that is), do the following: a.
If the field is a byte, char, short, or int, compute (int) f.
If the field is an object reference and this class’s equals method compares the field by recursively invoking equals, recursively invoke hashCode on the field.
If a more complex comparison is required, compute a “canonical representation” for this field and invoke hashCode on the canonical representation.
If the field is an array, treat it as if each element were a separate field.
That is, compute a hash code for each significant element by applying these rules recursively, and combine these values per step 2.b.
If every element in an array field is significant, you can use one of the Arrays.hashCode methods added in release 1.5
Write unit tests to verify your intuition! If equal instances have unequal hash codes, figure out why and fix the problem.
You may exclude redundant fields from the hash code computation.
In other words, you may ignore any field whose value can be computed from fields included in the computation.
You must exclude any fields that are not used in equals comparisons, or you risk violating the second provision of the hashCode contract.
If zero were used as the initial value in step 1, the overall hash value would be unaffected by any such initial fields, which could increase collisions.
The multiplication in step 2.b makes the result depend on the order of the fields, yielding a much better hash function if the class has multiple similar fields.
For example, if the multiplication were omitted from a String hash function, all anagrams would have identical hash codes.
The value 31 was chosen because it is an odd prime.
If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting.
The advantage of using a prime is less clear, but it is traditional.
Because this method returns the result of a simple deterministic computation whose only inputs are the three significant fields in a PhoneNumber instance, it is clear that equal PhoneNumber instances have equal hash codes.
This method is, in fact, a perfectly good hashCode implementation for PhoneNumber, on a par with those in the Java platform libraries.
It is simple, reasonably fast, and does a reasonable job of dispersing unequal phone numbers into different hash buckets.
If a class is immutable and the cost of computing the hash code is significant, you might consider caching the hash code in the object rather than recalculating it each time it is requested.
If you believe that most objects of this type will be used as hash keys, then you should calculate the hash code when the instance is created.
Otherwise, you might choose to lazily initialize it the first time hashCode is invoked (Item 71)
It is not clear that our PhoneNumber class merits this treatment, but just to show you how it’s done:
Lazily initialized, cached hashCode private volatile int hashCode; // (See Item 71)
While the recipe in this item yields reasonably good hash functions, it does not yield state-of-the-art hash functions, nor do the Java platform libraries provide such hash functions as of release 1.6
Writing such hash functions is a research topic, best left to mathematicians and theoretical computer scientists.
Perhaps a later release of the platform will provide state-of-the-art hash functions for its classes and utility methods to allow average programmers to construct such hash functions.
In the meantime, the techniques described in this item should be adequate for most applications.
Do not be tempted to exclude significant parts of an object from the hash code computation to improve performance.
While the resulting hash function may run faster, its poor quality may degrade hash tables’ performance to the point where they become unusably slow.
If this happens, the hash function will map all the instances to a very few hash codes, and hash-based collections will display quadratic performance.
The String hash function implemented in all releases prior to 1.2 examined at most sixteen characters, evenly spaced throughout the string, starting with the first character.
For large collections of hierarchical names, such as URLs, this hash function displayed exactly the pathological behavior noted here.
Many classes in the Java platform libraries, such as String, Integer, and Date, include in their specifications the exact value returned by their hashCode method as a function of the instance value.
This is generally not a good idea, as it severely limits your ability to improve the hash function in future releases.
If you leave the details of a hash function unspecified and a flaw is found or a better hash function discovered, you can change the hash function in a subsequent release, confident that no clients depend on the exact values returned by the hash function.
The toString method is automatically invoked when an object is passed to println, printf, the string concatenation operator, or assert, or printed by a debugger.
The printf method was added to the platform in release 1.5, as were related methods including String.format, which is roughly equivalent to C’s sprintf.
If you’ve provided a good toString method for PhoneNumber, generating a useful diagnostic message is as easy as this:
When practical, the toString method should return all of the interesting information contained in the object, as in the phone number example just shown.
It is impractical if the object is large or if it contains state that is not conducive to string representation.
One important decision you’ll have to make when implementing a toString method is whether to specify the format of the return value in the documentation.
It is recommended that you do this for value classes, such as phone numbers or matrices.
The advantage of specifying the format is that it serves as a standard, unambiguous, human-readable representation of the object.
This representation can be used for input and output and in persistent human-readable data objects, such as XML documents.
If you specify the format, it’s usually a good idea to provide a matching static factory or constructor so programmers can easily translate back and forth between the object and its string representation.
This approach is taken by many value classes in the Java platform libraries, including BigInteger, BigDecimal, and most of the boxed primitive classes.
The disadvantage of specifying the format of the toString return value is that once you’ve specified it, you’re stuck with it for life, assuming your class is widely used.
Programmers will write code to parse the representation, to generate it, and to embed it into persistent data.
If you change the representation in a future release, you’ll break their code and data, and they will yowl.
By failing to specify a format, you preserve the flexibility to add information or improve the format in a subsequent release.
Whether or not you decide to specify the format, you should clearly document your intentions.
If you specify the format, you should do so precisely.
For example, here’s a toString method to go with the PhoneNumber class in Item 9:
If you decide not to specify a format, the documentation comment should read something like this:
After reading this comment, programmers who produce code or persistent data that depends on the details of the format will have no one but themselves to blame when the format is changed.
Whether or not you specify the format, provide programmatic access to all of the information contained in the value returned by toString.
For example, the PhoneNumber class should contain accessors for the area code, prefix, and line number.
If you fail to do this, you force programmers who need this information to parse the string.
Besides reducing performance and making unnecessary work for programmers, this process is error-prone and results in fragile systems that break if you change the format.
By failing to provide accessors, you turn the string format into a de facto API, even if you’ve specified that it’s subject to change.
Its primary flaw is that it lacks a clone method, and Object’s clone method is protected.
You cannot, without resorting to reflection (Item 53), invoke the clone method on an object merely because it implements Cloneable.
Even a reflective invocation may fail, as there is no guarantee that the object has an accessible clone method.
Despite this flaw and others, the facility is in wide use so it pays to understand it.
This item tells you how to implement a well-behaved clone method, discusses when it is appropriate to do so, and presents alternatives.
This is a highly atypical use of interfaces and not one to be emulated.
Normally, implementing an interface says something about what a class can do for its clients.
In the case of Cloneable, it modifies the behavior of a protected method on a superclass.
If implementing the Cloneable interface is to have any effect on a class, the class and all of its superclasses must obey a fairly complex, unenforceable, and thinly documented protocol.
The resulting mechanism is extralinguistic: it creates an object without calling a constructor.
The precise meaning of “copy” may depend on the class of the object.
The general intent is that, for any object x, the expression x.clone() != x.
Copying an object will typically entail creating a new instance of its class, but it may require copying of internal data structures as well.
The provision that “no constructors are called” is too strong.
A well-behaved clone method can call constructors to create objects internal to the clone under construction.
If the class is final, clone can even return an object created by a constructor.
In practice, programmers assume that if they extend a class and invoke super.clone from the subclass, the returned object will be an instance of the subclass.
The only way a superclass can provide this functionality is to return an object obtained by calling super.clone.
If a clone method returns an object created by a constructor, it will have the wrong class.
Therefore, if you override the clone method in a nonfinal class, you should return an object obtained by invoking super.clone.
If all of a class’s superclasses obey this rule, then invoking super.clone will eventually invoke Object’s clone method, creating an instance of the right class.
This mechanism is vaguely similar to automatic constructor chaining, except that it isn’t enforced.
The Cloneable interface does not, as of release 1.6, spell out in detail the responsibilities that a class takes on when it implements this interface.
In practice, a class that implements Cloneable is expected to provide a properly functioning public clone method.
It is not, in general, possible to do so unless all of the class’s superclasses provide a well-behaved clone implementation, whether public or protected.
Suppose you want to implement Cloneable in a class whose superclasses provide well-behaved clone methods.
The object you get from super.clone() may or may not be close to what you’ll eventually return, depending on the nature of the class.
This object will be, from the standpoint of each superclass, a fully functional clone of the original object.
The fields declared in your class (if any) will have values identical to those of the object being cloned.
If every field contains a primitive value or a reference to an immutable object, the returned object may be exactly what you need, in which case no further processing is necessary.
In this case, all you need do in addition to declaring that you implement Cloneable is to provide public access to Object’s protected clone method:
Note that the above clone method returns PhoneNumber, not Object.
In other words, it is now legal for an overriding method’s return type to be a subclass of the overridden method’s return type.
This allows the overriding method to provide more information about the returned object and eliminates the need for casting in the client.
The general principle at play here is never make the client do anything the library can do for the client.
If an object contains fields that refer to mutable objects, using the simple clone implementation shown above can be disastrous.
If its clone method merely returns super.clone(), the resulting Stack instance will have the correct value in.
Modifying the original will destroy the invariants in the clone and vice versa.
This situation could never occur as a result of calling the sole constructor in the Stack class.
In effect, the clone method functions as another constructor; you must ensure that it does no harm to the original object and that it properly establishes invariants on the clone.
In order for the clone method on Stack to work properly, it must copy the internals of the stack.
The easiest way to do this is to call clone recursively on the elements array:
Note that we do not have to cast the result of elements.clone() to Object[]
As of release 1.5, calling clone on an array returns an array whose compile-time type is the same as that of the array being cloned.
Note also that the above solution would not work if the elements field were final, because clone would be prohibited from assigning a new value to the field.
This is a fundamental problem: the clone architecture is incompatible with normal use of final fields referring to mutable objects, except in cases where the mutable objects may be safely shared between an object and its clone.
In order to make a class cloneable, it may be necessary to remove final modifiers from some fields.
For example, suppose you are writing a clone method for a hash table whose internals consist of an array of buckets, each of which references the first entry in a linked list of key-value pairs or is null if the bucket is empty.
Suppose you merely clone the bucket array recursively, as we did for Stack:
Though the clone has its own bucket array, this array references the same linked lists as the original, which can easily cause nondeterministic behavior in both the clone and the original.
To fix this problem, you’ll have to copy the linked list that comprises each bucket individually.
The private class HashTable.Entry has been augmented to support a “deep copy” method.
The clone method on HashTable allocates a new buckets array of the proper size and iterates over the original buckets array, deep-copying each nonempty bucket.
The deep-copy method on Entry invokes itself recursively to copy the entire linked list headed by the entry.
While this technique is cute and works fine if the buckets aren’t too long, it is not a good way to clone a linked list because it consumes one stack frame for each element in the list.
If the list is long, this could easily cause a stack overflow.
To prevent this from happening, you can replace the recursion in deepCopy with iteration:
A final approach to cloning complex objects is to call super.clone, set all of the fields in the resulting object to their virgin state, and then call higher-level methods to regenerate the state of the object.
This approach typically yields a simple, reasonably elegant clone method that generally doesn’t run quite as fast as one that directly manipulates the innards of the object and its clone.
Like a constructor, a clone method should not invoke any nonfinal methods on the clone under construction (Item 17)
If clone invokes an overridden method, this method will execute before the subclass in which it is defined has had a chance to fix its state in the clone, quite possibly leading to corruption in the clone and the original.
Therefore the put(key, value) method discussed in the previous paragraph should be either final or private.
If it is private, it is presumably the “helper method” for a nonfinal public method.
Public clone methods should omit it because methods that don’t throw checked exceptions are easier to use (Item 59)
This gives subclasses the freedom to implement Cloneable or not, just as if they extended Object directly.
If you decide to make a thread-safe class implement Cloneable, remember that its clone method must be properly synchronized just like any other method (Item 66)
Object’s clone method is not synchronized, so even if it is otherwise satisfactory, you may have to write a synchronized clone method that invokes super.clone()
To recap, all classes that implement Cloneable should override clone with a public method whose return type is the class itself.
This method should first call super.clone and then fix any fields that need to be fixed.
Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object being cloned, and replacing the clone’s references to these objects with references to the copies.
While these internal copies can generally be made by calling clone recursively, this is not always the best approach.
If the class contains only primitive fields or references to immutable objects, then it is probably the case that no fields need to be fixed.
For example, a field representing a serial number or other unique ID or a field representing the object’s creation time will need to be fixed, even if it is primitive or immutable.
If you extend a class that implements Cloneable, you have little choice but to implement a well-behaved.
Otherwise, you are better off providing an alternative means of object copying, or simply not providing the capability.
For example, it doesn’t make sense for immutable classes to support object copying, because copies would be virtually indistinguishable from the original.
A fine approach to object copying is to provide a copy constructor or copy factory.
A copy factory is the static factory analog of a copy constructor:
The copy constructor approach and its static factory variant have many advantages over Cloneable/clone: they don’t rely on a risk-prone extralinguistic object creation mechanism; they don’t demand unenforceable adherence to thinly documented conventions; they don’t conflict with the proper use of final fields; they don’t throw unnecessary checked exceptions; and they don’t require casts.
While it is impossible to put a copy constructor or factory in an interface, Cloneable fails to function as an interface because it lacks a public clone method.
Therefore you aren’t giving up interface functionality by using a copy constructor or factory in preference to a clone method.
Furthermore, a copy constructor or factory can take an argument whose type is an interface implemented by the class.
For example, by convention all generalpurpose collection implementations provide a constructor whose argument is of type Collection or Map.
Interface-based copy constructors and factories, more properly known as conversion constructors and conversion factories, allow the client to choose the implementation type of the copy rather than forcing the client to accept the implementation type of the original.
Suppose you have a HashSet s, and you want to copy it as a TreeSet.
The clone method can’t offer this functionality, but it’s easy with a conversion constructor: new TreeSet(s)
Given all of the problems associated with Cloneable, it’s safe to say that other interfaces should not extend it, and that classes designed for inheritance (Item 17) should not implement it.
Because of its many shortcomings, some expert programmers simply choose never to override the clone method and never to invoke it except, perhaps, to copy arrays.
If you design a class for inheritance, be aware that if you choose not to provide a well-behaved protected clone method, it will be impossible for subclasses to implement Cloneable.
Unlike the other methods discussed in this chapter, the compareTo method is not declared in Object.
Rather, it is the sole method in the Comparable interface.
It is similar in character to Object’s equals method, except that it permits order comparisons in addition to simple equality comparisons, and it is generic.
By implementing Comparable, a class indicates that its instances have a natural ordering.
Sorting an array of objects that implement Comparable is as simple as this:
It is similarly easy to search, compute extreme values, and maintain automatically sorted collections of Comparable objects.
For example, the following program, which relies on the fact that String implements Comparable, prints an alphabetized list of its command-line arguments with duplicates eliminated:
By implementing Comparable, you allow your class to interoperate with all of the many generic algorithms and collection implementations that depend on this interface.
You gain a tremendous amount of power for a small amount of effort.
Virtually all of the value classes in the Java platform libraries implement Comparable.
If you are writing a value class with an obvious natural ordering, such as alphabetical order, numerical order, or chronological order, you should strongly consider implementing the interface:
The general contract of the compareTo method is similar to that of equals:
Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.
Throws ClassCastException if the specified object’s type prevents it from being compared to this object.
This implies that x.compareTo(y) must throw an exception if and only if y.compareTo(x) throws an exception.
It is strongly recommended, but not strictly required, that (x.compareTo(y) == 0) == (x.equals(y))
Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact.
The recommended language is “Note: This class has a natural ordering that is inconsistent with equals.”
Don’t be put off by the mathematical nature of this contract.
Like the equals contract (Item 8), this contract isn’t as complicated as it looks.
Across classes, compareTo, unlike equals, doesn’t have to work: it is permitted to throw ClassCastException if two object references being compared refer to objects of different classes.
Usually, that is exactly what compareTo should do, and what it will do if the class is properly parameterized.
While the contract doesn’t preclude interclass comparisons, there are, as of release 1.6, no classes in the Java platform libraries that support them.
Just as a class that violates the hashCode contract can break other classes that depend on hashing, a class that violates the compareTo contract can break other classes that depend on comparison.
Classes that depend on comparison include the sorted collections TreeSet and TreeMap, and the utility classes Collections and Arrays, which contain searching and sorting algorithms.
The first provision says that if you reverse the direction of a comparison between two object references, the expected thing happens: if the first object is less than the second, then the second must be greater than the first; if the first object is equal to the second, then the second must be equal to the first; and if the first object is greater than the second, then the second must be less than the first.
The second provision says that if one object is greater than a second, and the second is greater than a third, then the first must be greater than the third.
The final provision says that all objects that compare as equal must yield the same results when compared to any other object.
One consequence of these three provisions is that the equality test imposed by a compareTo method must obey the same restrictions imposed by the equals contract: reflexivity, symmetry, and transitivity.
Therefore the same caveat applies: there is no way to extend an instantiable class with a new value component while preserving the compareTo contract, unless you are willing to forgo the benefits of object-oriented abstraction (Item 8)
If you want to add a value component to a class that implements Comparable, don’t extend it; write an unrelated class containing an instance of the first class.
This frees you to implement whatever compareTo method you like on the second class, while allowing its client to view an instance of the second class as an instance of the first class when needed.
The final paragraph of the compareTo contract, which is a strong suggestion rather than a true provision, simply states that the equality test imposed by the compareTo method should generally return the same results as the equals method.
If this provision is obeyed, the ordering imposed by the compareTo method is said to be consistent with equals.
If it’s violated, the ordering is said to be inconsistent with equals.
A class whose compareTo method imposes an order that is inconsistent with equals will still work, but sorted collections containing elements of the class may not obey the general contract of the appropriate collection interfaces (Collection, Set, or Map)
This is because the general contracts for these interfaces are defined in terms of the equals method, but sorted collections use the equality test imposed by compareTo in place of equals.
It is not a catastrophe if this happens, but it’s something to be aware of.
For example, consider the BigDecimal class, whose compareTo method is inconsistent with equals.
If, however, you perform the same procedure using a TreeSet instead of a HashSet, the set will contain only one element because the two BigDecimal instances are equal when compared using the compareTo method.
Writing a compareTo method is similar to writing an equals method, but there are a few key differences.
Because the Comparable interface is parameterized, the compareTo method is statically typed, so you don’t need to type check or cast its argument.
If the argument is of the wrong type, the invocation won’t even compile.
The field comparisons in a compareTo method are order comparisons rather than equality comparisons.
Compare object reference fields by invoking the compareTo method recursively.
If a field does not implement Comparable, or you need to use a nonstandard ordering, you can use an explicit Comparator instead.
It is the normal pattern to follow when declaring a class to implement Comparable.
For floating-point fields, use Double.compare or Float.compare in place of the relational operators, which do not obey the general contract for compareTo when applied to floating point values.
If a class has multiple significant fields, the order in which you compare them is critical.
You must start with the most significant field and work your way down.
If a comparison results in anything other than zero (which represents equality), you’re done; just return the result.
If all fields are equal, the objects are equal; return zero.
The technique is demonstrated by this compareTo method for the PhoneNumber class in Item 9:
Area codes are equal, compare prefixes if (prefix < pn.prefix)
Area codes and prefixes are equal, compare line numbers if (lineNumber < pn.lineNumber)
Recall that the contract for compareTo does not specify the magnitude of the return value, only the sign.
You can take advantage of this to simplify the code and probably make it run a bit faster:
Area codes are equal, compare prefixes int prefixDiff = prefix - pn.prefix; if (prefixDiff != 0)
Area codes and prefixes are equal, compare line numbers return lineNumber - pn.lineNumber;
This trick works fine here but should be used with extreme caution.
If i is a large positive int and j is a large negative int, (i - j) will overflow and return a negative value.
The resulting compareTo method will return incorrect results for some arguments and violate the first and second provisions of the compareTo contract.
This is not a purely theoretical problem: it has caused failures in real systems.
These failures can be difficult to debug, as the broken compareTo method works properly for most input values.
The language provides many powerful elements that you can use to design classes and interfaces.
This chapter contains guidelines to help you make the best use of these elements so that your classes and interfaces are usable, robust, and flexible.
The single most important factor that distinguishes a well-designed module from a poorly designed one is the degree to which the module hides its internal data and other implementation details from other modules.
A well-designed module hides all of its implementation details, cleanly separating its API from its implementation.
Modules then communicate only through their APIs and are oblivious to each others’ inner workings.
This concept, known as information hiding or encapsulation, is one of the fundamental tenets of software design [Parnas72]
Information hiding is important for many reasons, most of which stem from the fact that it decouples the modules that comprise a system, allowing them to be developed, tested, optimized, used, understood, and modified in isolation.
This speeds up system development because modules can be developed in parallel.
It eases the burden of maintenance because modules can be understood more quickly and debugged with little fear of harming other modules.
While information hiding does not, in and of itself, cause good performance, it enables effective performance tuning: once a system is complete and profiling has determined which modules are causing performance problems (Item 55), those modules can be optimized without affecting the correctness of other modules.
Information hiding increases software reuse because modules that aren’t tightly coupled often prove useful in other contexts besides the ones for which they were developed.
Finally, information hiding decreases the risk in building large systems, because individual modules may prove successful even if the system does not.
The access control mechanism [JLS, 6.6] specifies the accessibility of classes, interfaces, and members.
The accessibility of an entity is determined by the location of its declaration and by which, if any, of the access modifiers (private, protected, and public) is present on the declaration.
Proper use of these modifiers is essential to information hiding.
The rule of thumb is simple: make each class or member as inaccessible as possible.
In other words, use the lowest possible access level consistent with the proper functioning of the software that you are writing.
For top-level (non-nested) classes and interfaces, there are only two possible access levels: package-private and public.
If you declare a top-level class or interface with the public modifier, it will be public; otherwise, it will be package-private.
If a top-level class or interface can be made package-private, it should be.
By making it package-private, you make it part of the implementation rather than the exported API, and you can modify it, replace it, or eliminate it in a subsequent release without fear of harming existing clients.
If you make it public, you are obligated to support it forever to maintain compatibility.
If a package-private top-level class (or interface) is used by only one class, consider making the top-level class a private nested class of the sole class that uses it (Item 22)
This reduces its accessibility from all the classes in its package to the one class that uses it.
But it is far more important to reduce the accessibility of a gratuitously public class than of a package-private top-level class: the public class is part of the package’s API, while the package-private top-level class is already part of its implementation.
For members (fields, methods, nested classes, and nested interfaces), there are four possible access levels, listed here in order of increasing accessibility:
Technically known as default access, this is the access level you get if no access modifier is specified.
After carefully designing your class’s public API, your reflex should be to make all other members private.
Only if another class in the same package really needs to access a member should you remove the private modifier, making the member package-private.
If you find yourself doing this often, you should reexamine the design of your system to see if another decomposition might yield classes that are better decoupled from one another.
That said, both private and package-private members are part of a class’s implementation and do not normally impact its exported API.
For members of public classes, a huge increase in accessibility occurs when the access level goes from package-private to protected.
A protected member is part of the class’s exported API and must be supported forever.
Also, a protected member of an exported class represents a public commitment to an implementation detail (Item 17)
There is one rule that restricts your ability to reduce the accessibility of methods.
If a method overrides a superclass method, it is not permitted to have a lower access level in the subclass than it does in the superclass [JLS, 8.4.8.3]
This is necessary to ensure that an instance of the subclass is usable anywhere that an instance of the superclass is usable.
If you violate this rule, the compiler will generate an error message when you try to compile the subclass.
A special case of this rule is that if a class implements an interface, all of the class methods that are also present in the interface must be declared public.
This is so because all members of an interface are implicitly public [JLS, 9.1.5]
To facilitate testing, you may be tempted to make a class, interface, or member more accessible.
It is acceptable to make a private member of a public class package-private in order to test it, but it is not acceptable to raise the accessibility any higher than that.
In other words, it is not acceptable to make a class, interface, or member a part of a package’s exported API to facilitate testing.
Luckily, it isn’t necessary either, as tests can be made to run as part of the package being tested, thus gaining access to its package-private elements.
If an instance field is nonfinal, or is a final reference to a mutable object, then by making the field public, you give up the ability to limit the values that can be stored in the field.
This means you also give up the ability to enforce invariants involving the field.
Also, you give up the ability to take any action when the field is modified, so classes with public mutable fields are not thread-safe.
Even if a field is final and refers to an immutable object, by making the field public you give up the flexibility to switch to a new internal data representation in which the field does not exist.
The same advice applies to static fields, with the one exception.
You can expose constants via public static final fields, assuming the constants form an integral part of the abstraction provided by the class.
By convention, such fields have names consisting of capital letters, with words separated by underscores (Item 56)
It is critical that these fields contain either primitive values or references to immutable objects (Item 15)
A final field containing a reference to a mutable object has all the disadvantages of a nonfinal field.
While the reference cannot be modified, the referenced object can be modified—with disastrous results.
Note that a nonzero-length array is always mutable, so it is wrong for a class to have a public static final array field, or an accessor that returns such a field.
If a class has such a field or accessor, clients will be able to modify the contents of the array.
Beware of the fact that many IDEs generate accessors that return references to private array fields, resulting in exactly this problem.
You can make the public array private and add a public immutable list:
Alternatively, you can make the array private and add a public method that returns a copy of a private array:
To choose between these alternatives, think about what the client is likely to do with the result.
Which return type will be more convenient? Which will give better performance?
To summarize, you should always reduce accessibility as much as possible.
After carefully designing a minimal public API, you should prevent any stray classes, interfaces, or members from becoming a part of the API.
With the exception of public static final fields, public classes should have no public fields.
Ensure that objects referenced by public static final fields are immutable.
Item 14: In public classes, use accessor methods, not public fields.
Occasionally, you may be tempted to write degenerate classes that serve no purpose other than to group instance fields:
Because the data fields of such classes are accessed directly, these classes do not offer the benefits of encapsulation (Item 13)
You can’t change the representation without changing the API, you can’t enforce invariants, and you can’t take auxiliary action when a field is accessed.
Hard-line object-oriented programmers feel that such classes are anathema and should always be replaced by classes with private fields and public accessor methods (getters) and, for mutable classes, mutators (setters):
Certainly, the hard-liners are correct when it comes to public classes: if a class is accessible outside its package, provide accessor methods, to preserve the flexibility to change the class’s internal representation.
If a public class exposes its data fields, all hope of changing its representation is lost, as client code can be distributed far and wide.
However, if a class is package-private or is a private nested class, there is nothing inherently wrong with exposing its data fields—assuming they do an.
This approach generates less visual clutter than the accessor-method approach, both in the class definition and in the client code that uses it.
While the client code is tied to the class’s internal representation, this code is confined to the package containing the class.
If a change in representation becomes desirable, you can make the change without touching any code outside the package.
In the case of a private nested class, the scope of the change is further restricted to the enclosing class.
Several classes in the Java platform libraries violate the advice that public classes should not expose fields directly.
Prominent examples include the Point and Dimension classes in the java.awt package.
Rather than examples to be emulated, these classes should be regarded as cautionary tales.
As described in Item 55, the decision to expose the internals of the Dimension class resulted in a serious performance problem that is still with us today.
While it’s never a good idea for a public class to expose fields directly, it is less harmful if the fields are immutable.
You can’t change the representation of such a class without changing its API, and you can’t take auxiliary actions when a field is read, but you can enforce invariants.
For example, this class guarantees that each instance represents a valid time:
It is less harmful, though still questionable, for public classes to expose immutable fields.
It is, however, sometimes desirable for package-private or private nested classes to expose fields, whether mutable or immutable.
An immutable class is simply a class whose instances cannot be modified.
All of the information contained in each instance is provided when it is created and is fixed for the lifetime of the object.
The Java platform libraries contain many immutable classes, including String, the boxed primitive classes, and BigInteger and BigDecimal.
There are many good reasons for this: Immutable classes are easier to design, implement, and use than mutable classes.
They are less prone to error and are more secure.
Don’t provide any methods that modify the object’s state (known as mutators)
This prevents careless or malicious subclasses from compromising the immutable behavior of the class by behaving as if the object’s state has changed.
Preventing subclassing is generally accomplished by making the class final, but there is an alternative that we’ll discuss later.
This clearly expresses your intent in a manner that is enforced by the system.
This prevents clients from obtaining access to mutable objects referred to by fields and modifying these objects directly.
While it is technically permissible for immutable classes to have public final fields containing primitive values or references to immutable objects, it is not recommended because it precludes changing the internal representation in a later release (Item 13)
If your class has any fields that refer to mutable objects, ensure that clients of the class cannot obtain references to these objects.
Never initialize such a field to a client-provided object reference or return the object reference from an accessor.
Many of the example classes in previous items are immutable.
One such class is PhoneNumber in Item 9, which has accessors for each attribute but no corresponding mutators.
This class represents a complex number (a number with both real and imaginary parts)
In addition to the standard Object methods, it provides accessors for the real and imaginary parts and provides the four basic arithmetic operations: addition, subtraction, multiplication, and division.
Notice how the arithmetic operations create and return a new Complex instance rather than modifying this instance.
It is known as the functional approach because methods return the result of applying a function to their operand without modifying it.
Contrast this to the more common procedural or imperative approach in which methods apply a procedure to their operand, causing its state to change.
The functional approach may appear unnatural if you’re not familiar with it, but it enables immutability, which has many advantages.
An immutable object can be in exactly one state, the state in which it was created.
If you make sure that all constructors establish class invariants, then it is guaranteed that these invariants will remain true for all time, with no further effort on your part or on the part of the programmer who uses the class.
Mutable objects, on the other hand, can have arbitrarily complex state spaces.
If the documentation does not provide a precise description of the state transitions performed by mutator methods, it can be difficult or impossible to use a mutable class reliably.
They cannot be corrupted by multiple threads accessing them concurrently.
This is far and away the easiest approach to achieving thread safety.
In fact, no thread can ever observe any effect of another thread on an immutable object.
Immutable classes should take advantage of this by encouraging clients to reuse existing instances wherever.
One easy way to do this is to provide public static final constants for frequently used values.
An immutable class can provide static factories (Item 1) that cache frequently requested instances to avoid creating new instances when existing ones would do.
Using such static factories causes clients to share instances instead of creating new ones, reducing memory footprint and garbage collection costs.
Opting for static factories in place of public constructors when designing a new class gives you the flexibility to add caching later, without modifying clients.
A consequence of the fact that immutable objects can be shared freely is that you never have to make defensive copies (Item 39)
In fact, you never have to make any copies at all because the copies would be forever equivalent to the originals.
Therefore, you need not and should not provide a clone method or copy constructor (Item 11) on an immutable class.
This was not well understood in the early days of the Java platform, so the String class does have a copy constructor, but it should rarely, if ever, be used (Item 5)
Not only can you share immutable objects, but you can share their internals.
For example, the BigInteger class uses a sign-magnitude representation internally.
The sign is represented by an int, and the magnitude is represented by an int array.
The negate method produces a new BigInteger of like magnitude and opposite sign.
It does not need to copy the array; the newly created BigInteger points to the same internal array as the original.
Immutable objects make great building blocks for other objects, whether mutable or immutable.
It’s much easier to maintain the invariants of a complex object if you know that its component objects will not change underneath it.
A special case of this principle is that immutable objects make great map keys and set elements: you don’t have to worry about their values changing once they’re in the map or set, which would destroy the map or set’s invariants.
The only real disadvantage of immutable classes is that they require a separate object for each distinct value.
Creating these objects can be costly, especially if they are large.
For example, suppose that you have a million-bit BigInteger and you want to change its low-order bit:
The flipBit method creates a new BigInteger instance, also a million bits long, that differs from the original in only one bit.
The operation requires time and space proportional to the size of the BigInteger.
Like BigInteger, BitSet represents an arbitrarily long sequence of bits, but unlike BigInteger, BitSet is mutable.
The BitSet class provides a method that allows you to change the state of a single bit of a millionbit instance in constant time.
The performance problem is magnified if you perform a multistep operation that generates a new object at every step, eventually discarding all objects except the final result.
The first is to guess which multistep operations will be commonly required and provide them as primitives.
If a multistep operation is provided as a primitive, the immutable class does not have to create a separate object at each step.
For example, BigInteger has a package-private mutable “companion class” that it uses to speed up multistep operations such as modular exponentiation.
It is much harder to use the mutable companion class than to use BigInteger for all of the reasons outlined earlier, but luckily you don’t have to: the implementors of BigInteger did the hard work for you.
The package-private mutable companion class approach works fine if you can accurately predict which complex multistage operations clients will want to perform on your immutable class.
If not, then your best bet is to provide a public mutable companion class.
The main example of this approach in the Java platform libraries is the String class, whose mutable companion is StringBuilder (and the largely obsolete StringBuffer)
Arguably, BitSet plays the role of mutable companion to BigInteger under certain circumstances.
Now that you know how to make an immutable class and you understand the pros and cons of immutability, let’s discuss a few design alternatives.
Recall that to guarantee immutability, a class must not permit itself to be subclassed.
Typically this is done by making the class final, but there is another, more flexible way to do it.
The alternative to making an immutable class final is to make all of its constructors private or package-private, and to add public static factories in place of the public constructors (Item 1)
To make this concrete, here’s how Complex would look if you took this approach:
While this approach is not commonly used, it is often the best alternative.
It is the most flexible because it allows the use of multiple package-private implementation classes.
To its clients that reside outside its package, the immutable class is effectively final because it is impossible to extend a class that comes from another package and that lacks a public or protected constructor.
Besides allowing the flexibility of multiple implementation classes, this approach makes it possible to tune the performance of the class in subsequent releases by improving the objectcaching capabilities of the static factories.
For example, suppose that you want to provide a means of creating a complex number based on its polar coordinates.
This would be very messy using constructors because the natural constructor would have the same signature that we already used: Complex(double, double)
Just add a second static factory with a name that clearly identifies its function:
It was not widely understood that immutable classes had to be effectively final when BigInteger and BigDecimal were written, so all of their methods may be.
Unfortunately, this could not be corrected after the fact while preserving backward compatibility.
If you write a class whose security depends on the immutability of a BigInteger or BigDecimal argument from an untrusted client, you must check to see that the argument is a “real” BigInteger or BigDecimal, rather than an instance of an untrusted subclass.
If it is the latter, you must defensively copy it under the assumption that it might be mutable (Item 39):
The list of rules for immutable classes at the beginning of this item says that no methods may modify the object and that all its fields must be final.
In fact these rules are a bit stronger than necessary and can be relaxed to improve performance.
In truth, no method may produce an externally visible change in the object’s state.
However, some immutable classes have one or more nonfinal fields in which they cache the results of expensive computations the first time they are needed.
If the same value is requested again, the cached value is returned, saving the cost of recalculation.
This trick works precisely because the object is immutable, which guarantees that the computation would yield the same result if it were repeated.
This technique, an example of lazy initialization (Item 71), is also used by String.
Otherwise an attacker could create a mutable instance of your notquite-immutable class.
To summarize, resist the urge to write a set method for every get method.
Classes should be immutable unless there’s a very good reason to make them mutable.
Immutable classes provide many advantages, and their only disadvantage is the potential for performance problems under certain circumstances.
You should always make small value objects, such as PhoneNumber and Complex, immutable.
There are several classes in the Java platform libraries, such as.
You should seriously consider making larger value objects, such as String and BigInteger, immutable as well.
You should provide a public mutable companion class for your immutable class only once you’ve confirmed that it’s necessary to achieve satisfactory performance (Item 55)
If a class cannot be made immutable, limit its mutability as much as possible.
Reducing the number of states in which an object can exist makes it easier to reason about the object and reduces the likelihood of errors.
Therefore, make every field final unless there is a compelling reason to make it nonfinal.
Constructors should create fully initialized objects with all of their invariants established.
Don’t provide a public initialization method separate from the constructor or static factory unless there is a compelling reason to do so.
Similarly, don’t provide a “reinitialize” method that enables an object to be reused as if it had been constructed with a different initial state.
Such methods generally provide little if any performance benefit at the expense of increased complexity.
It is mutable, but its state space is kept intentionally small.
You create an instance, schedule it for execution, and optionally cancel it.
Once a timer task has run to completion or has been canceled, you may not reschedule it.
A final note should be added concerning the Complex class in this item.
Inheritance is a powerful way to achieve code reuse, but it is not always the best tool for the job.
It is safe to use inheritance within a package, where the subclass and the superclass implementations are under the control of the same programmers.
It is also safe to use inheritance when extending classes specifically designed and documented for extension (Item 17)
Inheriting from ordinary concrete classes across package boundaries, however, is dangerous.
As a reminder, this book uses the word “inheritance” to mean implementation inheritance (when one class extends another)
The problems discussed in this item do not apply to interface inheritance (when a class implements an interface or where one interface extends another)
In other words, a subclass depends on the implementation details of its superclass for its proper function.
The superclass’s implementation may change from release to release, and if it does, the subclass may break, even though its code has not been touched.
As a consequence, a subclass must evolve in tandem with its superclass, unless the superclass’s authors have designed and documented it specifically for the purpose of being extended.
To make this concrete, let’s suppose we have a program that uses a HashSet.
To tune the performance of our program, we need to query the HashSet as to how many elements have been added since it was created (not to be confused with its current size, which goes down when an element is removed)
To provide this functionality, we write a HashSet variant that keeps count of the number of attempted element insertions and exports an accessor for this count.
The HashSet class contains two methods capable of adding elements, add and addAll, so we override both of these methods:
The number of attempted element insertions private int addCount = 0;
Suppose we create an instance and add three elements using the addAll method:
We would expect the getAddCount method to return three at this point, but it returns six.
What went wrong? Internally, HashSet’s addAll method is implemented on top of its add method, although HashSet, quite reasonably, does not document this implementation detail.
Each of these three invocations added one more to addCount, for a total increase of six: each element added with the addAll method is double-counted.
We could “fix” the subclass by eliminating its override of the addAll method.
While the resulting class would work, it would depend for its proper function on the fact that HashSet’s addAll method is implemented on top of its add method.
This “self-use” is an implementation detail, not guaranteed to hold in all implementations of the Java platform and subject to change from release to release.
It would be slightly better to override the addAll method to iterate over the specified collection, calling the add method once for each element.
This would guarantee the correct result whether or not HashSet’s addAll method were implemented atop its add method, because HashSet’s addAll implementation would no longer be invoked.
It amounts to reimplementing superclass methods that may or may not.
Additionally, it isn’t always possible, as some methods cannot be implemented without access to private fields inaccessible to the subclass.
A related cause of fragility in subclasses is that their superclass can acquire new methods in subsequent releases.
Suppose a program depends for its security on the fact that all elements inserted into some collection satisfy some predicate.
This can be guaranteed by subclassing the collection and overriding each method capable of adding an element to ensure that the predicate is satisfied before adding the element.
This works fine until a new method capable of inserting an element is added to the superclass in a subsequent release.
Once this happens, it becomes possible to add an “illegal” element merely by invoking the new method, which is not overridden in the subclass.
Several security holes of this nature had to be fixed when Hashtable and Vector were retrofitted to participate in the Collections Framework.
You might think that it is safe to extend a class if you merely add new methods and refrain from overriding existing methods.
While this sort of extension is much safer, it is not without risk.
If the superclass acquires a new method in a subsequent release and you have the bad luck to have given the subclass a method with the same signature and a different return type, your subclass will no longer compile [JLS, 8.4.8.3]
If you’ve given the subclass a method with the same signature and return type as the new superclass method, then you’re now overriding it, so you’re subject to the two problems described above.
Furthermore, it is doubtful that your method will fulfill the contract of the new superclass method, as that contract had not yet been written when you wrote the subclass method.
Luckily, there is a way to avoid all of the problems described earlier.
Instead of extending an existing class, give your new class a private field that references an instance of the existing class.
This design is called composition because the existing class becomes a component of the new one.
Each instance method in the new class invokes the corresponding method on the contained instance of the existing class and returns the results.
This is known as forwarding, and the methods in the new class are known as forwarding methods.
The resulting class will be rock solid, with no dependencies on the implementation details of the existing class.
Even adding new methods to the existing class will have no impact on the new class.
Note that the implementation is broken into two pieces, the class itself and a reusable forwarding class, which contains all of the forwarding methods and nothing else:
The design of the InstrumentedSet class is enabled by the existence of the Set interface, which captures the functionality of the HashSet class.
The InstrumentedSet class implements the Set interface and has a single constructor whose argument is also of type Set.
In essence, the class transforms one Set into another, adding the instrumentation functionality.
Unlike the inheritance-based approach, which works only for a single concrete class and requires a separate constructor for each supported constructor in the superclass, the wrapper class can be used to instrument any Set implementation and will work in conjunction with any preexisting constructor:
The InstrumentedSet class can even be used to temporarily instrument a set instance that has already been used without instrumentation:
The InstrumentedSet class is known as a wrapper class because each InstrumentedSet instance contains (“wraps”) another Set instance.
Sometimes the combination of composition and forwarding is loosely referred to as delegation.
One caveat is that wrapper classes are not suited for use in callback frameworks, wherein objects pass selfreferences to other objects for subsequent invocations (“callbacks”)
Because a wrapped object doesn’t know of its wrapper, it passes a reference to itself (this) and callbacks elude the wrapper.
Some people worry about the performance impact of forwarding method invocations or the memory footprint impact of wrapper objects.
It’s tedious to write forwarding methods, but you have to write the forwarding class for each interface only once, and forwarding classes may be provided for you by the package containing the interface.
Inheritance is appropriate only in circumstances where the subclass really is a subtype of the superclass.
In other words, a class B should extend a class A only if.
If you are tempted to have a class B extend a class A, ask yourself the question: Is every B really an A? If you cannot truthfully answer yes to this question, B should not extend A.
If the answer is no, it is often the case that B should contain a private instance of A and expose a smaller and simpler API: A is not an essential part of B, merely a detail of its implementation.
There are a number of obvious violations of this principle in the Java platform libraries.
For example, a stack is not a vector, so Stack should not extend Vector.
Similarly, a property list is not a hash table, so Properties should not extend Hashtable.
If you use inheritance where composition is appropriate, you needlessly expose implementation details.
The resulting API ties you to the original implementation, forever limiting the performance of your class.
More seriously, by exposing the internals you let the client access them directly.
At the very least, this can lead to confusing semantics.
Most seriously, the client may be able to corrupt invariants of the subclass by modifying the superclass directly.
In the case of Properties, the designers intended that only strings be allowed as keys and values, but direct access to the underlying Hashtable allows this invariant to be violated.
Once this invariant is violated, it is no longer possible to use other parts of the Properties API (load and store)
By the time this problem was discovered, it was too late to correct it because clients depended on the use of nonstring keys and values.
There is one last set of questions you should ask yourself before deciding to use inheritance in place of composition.
Does the class that you contemplate extending have any flaws in its API? If so, are you comfortable propagating those flaws into your class’s API? Inheritance propagates any flaws in the superclass’s API, while composition lets you design a new API that hides these flaws.
To summarize, inheritance is powerful, but it is problematic because it violates encapsulation.
It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass.
Even then, inheritance may lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance.
To avoid this fragility, use composition and forwarding instead of inheritance, especially if an appropriate interface to implement a wrapper class exists.
Not only are wrapper classes more robust than subclasses, they are also more powerful.
Item 17: Design and document for inheritance or else prohibit it.
Item 16 alerted you to the dangers of subclassing a “foreign” class that was not designed and documented for inheritance.
So what does it mean for a class to be designed and documented for inheritance?
First, the class must document precisely the effects of overriding any method.
In other words, the class must document its self-use of overridable methods.
For each public or protected method or constructor, the documentation must indicate which overridable methods the method or constructor invokes, in what sequence, and how the results of each invocation affect subsequent processing.
By overridable, we mean nonfinal and either public or protected.
More generally, a class must document any circumstances under which it might invoke an overridable method.
For example, invocations might come from background threads or static initializers.
By convention, a method that invokes overridable methods contains a description of these invocations at the end of its documentation comment.
The description begins with the phrase “This implementation.” This phrase should not be taken to indicate that the behavior may change from release to release.
It connotes that the description concerns the inner workings of the method.
Removes a single instance of the specified element from this collection, if it is present (optional operation)
More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if the collection contains one or more such elements.
Returns true if the collection contained the specified element (or equivalently, if the collection changed as a result of the call)
This implementation iterates over the collection looking for the specified element.
If it finds the element, it removes the element from the collection using the iterator’s remove method.
This documentation leaves no doubt that overriding the iterator method will affect the behavior of the remove method.
Furthermore, it describes exactly how the behavior of the Iterator returned by the iterator method will affect the behavior of the remove method.
Contrast this to the situation in Item 16, where the.
But doesn’t this violate the dictum that good API documentation should describe what a given method does and not how it does it? Yes, it does! This is an unfortunate consequence of the fact that inheritance violates encapsulation.
To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.
Design for inheritance involves more than just documenting patterns of selfuse.
To allow programmers to write efficient subclasses without undue pain, a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods or, in rare instances, protected fields.
Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive.
Shifts any succeeding elements to the left (reduces their index)
This call shortens the ArrayList by (toIndex - fromIndex) elements.
This method is called by the clear operation on this list and its sublists.
Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.
This method is of no interest to end users of a List implementation.
It is provided solely to make it easy for subclasses to provide a fast clear method on sublists.
In the absence of the removeRange method, subclasses would have to make do with quadratic performance when the clear method was invoked on sublists or rewrite the entire subList mechanism from scratch—not an easy task!
So how do you decide what protected members to expose when you design a class for inheritance? Unfortunately, there is no magic bullet.
The best you can do is to think hard, take your best guess, and then test it by writing subclasses.
You should expose as few protected members as possible, because each one represents a commitment to an implementation detail.
On the other hand, you must not expose too few, as a missing protected member can render a class practically unusable for inheritance.
The only way to test a class designed for inheritance is to write subclasses.
If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious.
Conversely, if several subclasses are written and none uses a protected member, you should probably make it private.
Experience shows that three subclasses are usually sufficient to test an extendable class.
One or more of these subclasses should be written by someone other than the superclass author.
When you design for inheritance a class that is likely to achieve wide use, realize that you are committing forever to the self-use patterns that you document and to the implementation decisions implicit in its protected methods and fields.
These commitments can make it difficult or impossible to improve the performance or functionality of the class in a subsequent release.
Therefore, you must test your class by writing subclasses before you release it.
Also, note that the special documentation required for inheritance clutters up normal documentation, which is designed for programmers who create instances of your class and invoke methods on them.
As of this writing, there is little in the way of tools or commenting conventions to separate ordinary API documentation from information of interest only to programmers implementing subclasses.
There are a few more restrictions that a class must obey to allow inheritance.
The superclass constructor runs before the subclass constructor, so the overriding method in the subclass will get invoked before the subclass constructor has run.
If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected.
To make this concrete, here’s a class that violates this rule:
Here’s a subclass that overrides the overrideMe, method which is erroneously invoked by Super’s sole constructor:
You might expect this program to print out the date twice, but it prints out null the first time, because the overrideMe method is invoked by the Super constructor before the Sub constructor has a chance to initialize the date field.
The Cloneable and Serializable interfaces present special difficulties when designing for inheritance.
It is generally not a good idea for a class designed for inheritance to implement either of these interfaces, as they place a substantial burden on programmers who extend the class.
There are, however, special actions that you can take to allow subclasses to implement these interfaces without mandating that they do so.
If you do decide to implement Cloneable or Serializable in a class designed for inheritance, you should be aware that because the clone and readObject methods behave a lot like constructors, a similar restriction applies: neither clone nor readObject may invoke an overridable method, directly or indirectly.
In the case of the readObject method, the overriding method will run before the subclass’s state has been deserialized.
In the case of the clone method, the overriding method will run before the subclass’s clone method has a chance to.
In either case, a program failure is likely to follow.
In the case of clone, the failure can damage the original object as well as the clone.
This can happen, for example, if the overriding method assumes it is modifying the clone’s copy of the object’s deep structure, but the copy hasn’t been made yet.
Finally, if you decide to implement Serializable in a class designed for inheritance and the class has a readResolve or writeReplace method, you must make the readResolve or writeReplace method protected rather than private.
If these methods are private, they will be silently ignored by subclasses.
This is one more case where an implementation detail becomes part of a class’s API to permit inheritance.
By now it should be apparent that designing a class for inheritance places substantial limitations on the class.
There are some situations where it is clearly the right thing to do, such as abstract classes, including skeletal implementations of interfaces (Item 18)
There are other situations where it is clearly the wrong thing to do, such as immutable classes (Item 15)
But what about ordinary concrete classes? Traditionally, they are neither final nor designed and documented for subclassing, but this state of affairs is dangerous.
Each time a change is made in such a class, there is a chance that client classes that extend the class will break.
The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed.
The easier of the two is to declare the class final.
The alternative is to make all the constructors private or package-private and to add public static factories in place of the constructors.
This advice may be somewhat controversial, as many programmers have grown accustomed to subclassing ordinary concrete classes to add facilities such as instrumentation, notification, and synchronization or to limit functionality.
If a class implements some interface that captures its essence, such as Set, List, or Map, then you should feel no compunction about prohibiting subclassing.
The wrapper class pattern, described in Item 16, provides a superior alternative to inheritance for augmenting the functionality.
If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance.
If you feel that you must allow inheritance from such a class, one reasonable approach is to ensure that the class never invokes any of its overridable methods and to document this fact.
In other words, eliminate the class’s self-use of overridable methods entirely.
In doing so, you’ll create a class that is reasonably safe to subclass.
Overriding a method will never affect the behavior of any other method.
You can eliminate a class’s self-use of overridable methods mechanically, without changing its behavior.
Move the body of each overridable method to a private “helper method” and have each overridable method invoke its private helper method.
Then replace each self-use of an overridable method with a direct invocation of the overridable method’s private helper method.
The Java programming language provides two mechanisms for defining a type that permits multiple implementations: interfaces and abstract classes.
The most obvious difference between the two mechanisms is that abstract classes are permitted to contain implementations for some methods while interfaces are not.
A more important difference is that to implement the type defined by an abstract class, a class must be a subclass of the abstract class.
Any class that defines all of the required methods and obeys the general contract is permitted to implement an interface, regardless of where the class resides in the class hierarchy.
Because Java permits only single inheritance, this restriction on abstract classes severely constrains their use as type definitions.
Existing classes can be easily retrofitted to implement a new interface.
All you have to do is add the required methods if they don’t yet exist and add an implements clause to the class declaration.
For example, many existing classes were retrofitted to implement the Comparable interface when it was introduced into the platform.
Existing classes cannot, in general, be retrofitted to extend a new abstract class.
If you want to have two classes extend the same abstract class, you have to place the abstract class high up in the type hierarchy where it subclasses an ancestor of both classes.
Unfortunately, this causes great collateral damage to the type hierarchy, forcing all descendants of the common ancestor to extend the new abstract class whether or not it is appropriate for them to do so.
Loosely speaking, a mixin is a type that a class can implement in addition to its “primary type” to declare that it provides some optional behavior.
For example, Comparable is a mixin interface that allows a class to declare that its instances are ordered with respect to other mutually comparable objects.
Such an interface is called a mixin because it allows the optional functionality to be “mixed in” to the type’s primary functionality.
Abstract classes can’t be used to define mixins for the same reason that they can’t be retrofitted onto existing classes: a class cannot have more than one parent, and there is no reasonable place in the class hierarchy to insert a mixin.
Type hierarchies are great for organizing some things, but other things don’t fall neatly into a rigid hierarchy.
For example, suppose we have an interface representing a singer and another representing a songwriter:
Because we used interfaces rather than abstract classes to define these types, it is perfectly permissible for a single class to implement both Singer and Songwriter.
In fact, we can define a third interface that extends both Singer and Songwriter and adds new methods that are appropriate to the combination:
You don’t always need this level of flexibility, but when you do, interfaces are a lifesaver.
The alternative is a bloated class hierarchy containing a separate class for every supported combination of attributes.
If there are n attributes in the type system, there are 2n possible combinations that you might have to support.
Bloated class hierarchies can lead to bloated classes containing many methods that differ only in the type of their arguments, as there are no types in the class hierarchy to capture common behaviors.
If you use abstract classes to define types, you leave the programmer who wants to add functionality with no alternative but to use inheritance.
The resulting classes are less powerful and more fragile than wrapper classes.
While interfaces are not permitted to contain method implementations, using interfaces to define types does not prevent you from providing implementation assistance to programmers.
You can combine the virtues of interfaces and abstract classes by providing an abstract skeletal implementation class to go with each nontrivial interface that you export.
The interface still defines the type, but the skeletal implementation takes all of the work out of implementing it.
By convention, skeletal implementations are called AbstractInterface, where Interface is the name of the interface they implement.
When properly designed, skeletal implementations can make it very easy for programmers to provide their own implementations of your interfaces.
For example, here’s a static factory method containing a complete, fully functional List implementation:
When you consider all that a List implementation does for you, this example is an impressive demonstration of the power of skeletal implementations.
Because of all the translation back and forth between int values and Integer instances (boxing and unboxing), its performance is not terribly good.
Note that a static factory is provided and that the class is an inaccessible anonymous class (Item 22) hidden inside the static factory.
The beauty of skeletal implementations is that they provide the implementation assistance of abstract classes without imposing the severe constraints that abstract classes impose when they serve as type definitions.
For most implementors of an interface, extending the skeletal implementation is the obvious choice, but it is strictly optional.
If a preexisting class cannot be made to extend the skeletal implementation, the class can always implement the interface manually.
Furthermore, the skeletal implementation can still aid the implementor’s task.
It provides most of the benefits of multiple inheritance, while avoiding the pitfalls.
Writing a skeletal implementation is a relatively simple, if somewhat tedious, process.
First you must study the interface and decide which methods are the primitives in terms of which the others can be implemented.
These primitives will be the abstract methods in your skeletal implementation.
Then you must provide concrete implementations of all the other methods in the interface.
For example, here’s a skeletal implementation of the Map.Entry interface:
For brevity’s sake, the documentation comments were omitted from the previous example, but good documentation is absolutely essential for skeletal implementations.
A simple implementation is like a skeletal implementation in that it implements an interface and is designed for inheritance, but it differs in that it isn’t abstract: it is the simplest possible working implementation.
You can use it as it stands or subclass it as circumstances warrant.
Using abstract classes to define types that permit multiple implementations has one great advantage over using interfaces: It is far easier to evolve an abstract class than an interface.
If, in a subsequent release, you want to add a new method to an abstract class, you can always add a concrete method containing a reasonable default implementation.
All existing implementations of the abstract class will then provide the new method.
It is, generally speaking, impossible to add a method to a public interface without breaking all existing classes that implement the interface.
Classes that previously implemented the interface will be missing the new method and won’t compile anymore.
You could limit the damage somewhat by adding the new method to the skeletal implementation at the same time as you add it to the interface, but this really wouldn’t solve the problem.
Any implementation that didn’t inherit from the skeletal implementation would still be broken.
Once an interface is released and widely implemented, it is almost impossible to change.
If an interface contains a minor flaw, it will irritate you and its users forever.
If an interface is severely deficient, it can doom an API.
The best thing to do when releasing a new interface is to have as many programmers as possible implement the interface in as many ways as possible before the interface is frozen.
This will allow you to discover flaws while you can still correct them.
To summarize, an interface is generally the best way to define a type that permits multiple implementations.
An exception to this rule is the case where ease of evolution is deemed more important than flexibility and power.
Under these circumstances, you should use an abstract class to define the type, but only if you understand and can accept the limitations.
If you export a nontrivial interface, you should strongly consider providing a skeletal implementation to go with it.
Finally, you should design all of your public interfaces with the utmost care and test them thoroughly by writing multiple implementations.
When a class implements an interface, the interface serves as a type that can be used to refer to instances of the class.
That a class implements an interface should therefore say something about what a client can do with instances of the class.
It is inappropriate to define an interface for any other purpose.
One kind of interface that fails this test is the so-called constant interface.
Such an interface contains no methods; it consists solely of static final fields, each exporting a constant.
Classes using these constants implement the interface to avoid the need to qualify constant names with a class name.
The constant interface pattern is a poor use of interfaces.
That a class uses some constants internally is an implementation detail.
Implementing a constant interface causes this implementation detail to leak into the class’s exported API.
It is of no consequence to the users of a class that the class implements a constant interface.
Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.
If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.
These interfaces should be regarded as anomalies and should not be emulated.
If you want to export constants, there are several reasonable choices.
If the constants are strongly tied to an existing class or interface, you should add them to the class or interface.
If the constants are best viewed as members of an enumerated type, you should export.
Otherwise, you should export the constants with a noninstantiable utility class (Item 4)
Here is a utility class version of the PhysicalConstants example above:
If you make heavy use of the constants exported by a utility class, you can avoid the need for qualifying the constants with the class name by making use of the static import facility, introduced in release 1.5:
In summary, interfaces should be used only to define types.
Occasionally you may run across a class whose instances come in two or more flavors and contain a tag field indicating the flavor of the instance.
For example, consider this class, which is capable of representing a circle or a rectangle:
Tag field - the shape of this figure final Shape shape;
These fields are used only if shape is RECTANGLE double length; double width;
This field is used only if shape is CIRCLE double radius;
They are cluttered with boilerplate, including enum declarations, tag fields, and switch statements.
Readability is further harmed because multiple implementations are jumbled together in a single class.
Memory footprint is increased because instances are burdened with irrelevant fields belonging to other flavors.
Fields can’t be made final unless constructors initialize irrelevant fields, resulting in more boilerplate.
Constructors must set the tag field and initialize the right data fields with no help from the compiler: if you initialize the wrong fields, the program will fail at runtime.
You can’t add a flavor to a tagged class unless you can modify its source file.
If you do add a flavor, you must remember to add a case to every switch statement, or the class will fail at runtime.
Finally, the data type of an instance gives no clue as to its flavor.
Luckily, object-oriented languages such as Java offer a far better alternative for defining a single data type capable of representing objects of multiple flavors: subtyping.
A tagged class is just a pallid imitation of a class hierarchy.
To transform a tagged class into a class hierarchy, first define an abstract class containing an abstract method for each method in the tagged class whose behavior depends on the tag value.
In the Figure class, there is only one such method, which is area.
This abstract class is the root of the class hierarchy.
If there are any methods whose behavior does not depend on the value of the tag, put them in this class.
Similarly, if there are any data fields used by all the flavors, put them in this class.
There are no such flavor-independent methods or fields in the Figure class.
Next, define a concrete subclass of the root class for each flavor of the original tagged class.
Include in each subclass the data fields particular to its flavor.
In our example, radius is particular to circle, and length and width are particular to rectangle.
Also include in each subclass the appropriate implementation of each abstract method in the root class.
Here is the class hierarchy corresponding to the original Figure class:
This class hierarchy corrects every shortcoming of tagged classes noted previously.
The code is simple and clear, containing none of the boilerplate found in the original.
The implementation of each flavor is allotted its own class, and none of these classes are encumbered by irrelevant data fields.
The compiler ensures that each class’s constructor initializes its data fields, and that each class has an implementation for every abstract method declared in the root class.
This eliminates the possibility of a runtime failure due to a missing switch case.
Multiple programmers can extend the hierarchy independently and interoperably without access to the source for the root class.
There is a separate data type associated with each flavor, allowing programmers to indicate the flavor of a variable and to restrict variables and input parameters to a particular flavor.
Another advantage of class hierarchies is that they can be made to reflect natural hierarchical relationships among types, allowing for increased flexibility and better compile-time type checking.
Suppose the tagged class in the original example also allowed for squares.
The class hierarchy could be made to reflect the fact that a square is a special kind of rectangle (assuming both are immutable):
Note that the fields in the above hierarchy are accessed directly rather than by accessor methods.
This was done for brevity and would be unacceptable if the hierarchy were public (Item 14)
If you’re tempted to write a class with an explicit tag field, think about whether the tag could be eliminated and the class replaced by a hierarchy.
When you encounter an existing class with a tag field, consider refactoring it into a hierarchy.
Item 21: Use function objects to represent strategies Some languages support function pointers, delegates, lambda expressions, or similar facilities that allow programs to store and transmit the ability to invoke a particular function.
Such facilities are typically used to allow the caller of a function to specialize its behavior by passing in a second function.
For example, the qsort function in C’s standard library takes a pointer to a comparator function, which qsort uses to compare the elements to be sorted.
The comparator function takes two parameters, each of which is a pointer to an element.
It returns a negative integer if the element indicated by the first parameter is less than the one indicated by the second, zero if the two elements are equal, and a positive integer if the element indicated by the first parameter is greater than the one indicated by the second.
Different sort orders can be obtained by passing in different comparator functions.
Java does not provide function pointers, but object references can be used to achieve a similar effect.
Invoking a method on an object typically performs some operation on that object.
However, it is possible to define an object whose methods perform operations on other objects, passed explicitly to the methods.
An instance of a class that exports exactly one such method is effectively a pointer to that method.
This class exports a single method that takes two strings and returns a negative integer if the first string is shorter than the second, zero if the two strings are of equal length, and a positive integer if the first string is longer.
This method is a comparator that orders strings based on their length instead of the more typical lexicographic ordering.
In other words, we need to define a strategy interface to go with the concrete strategy class.
This definition of the Comparator interface happens to come from the java.util package, but there’s nothing magic about it: you could just as well have written it yourself.
The Comparator interface is generic (Item 26) so that it is applicable to comparators for objects other than strings.
Its compare method takes two parameters of type T (its formal type parameter) rather than String.
Concrete strategy classes are often declared using anonymous classes (Item 22)
The following statement sorts an array of strings according to length:
But note that using an anonymous class in this way will create a new instance each time the call is executed.
If it is to be executed repeatedly, consider storing the function object in a private static final field and reusing it.
Another advantage of doing this is that you can give the field a descriptive name for the function object.
Because the strategy interface serves as a type for all of its concrete strategy instances, a concrete strategy class needn’t be made public to export a concrete strategy.
Instead, a “host class” can export a public static field (or static factory method) whose type is the strategy interface, and the concrete strategy class can be a private nested class of the host.
In the example that follows, a static member class is used in preference to an anonymous class to allow the concrete strategy class to implement a second interface, Serializable:
To summarize, a primary use of function pointers is to implement the Strategy pattern.
To implement this pattern in Java, declare an interface to represent the strategy, and a class that implements this interface for each concrete strategy.
When a concrete strategy is used only once, it is typically declared and instantiated as an anonymous class.
When a concrete strategy is designed for repeated use, it is generally implemented as a private static member class and exported in a public static final field whose type is the strategy interface.
A nested class is a class defined within another class.
A nested class should exist only to serve its enclosing class.
If a nested class would be useful in some other context, then it should be a top-level class.
There are four kinds of nested classes: static member classes, nonstatic member classes, anonymous classes, and local classes.
All but the first kind are known as inner classes.
This item tells you when to use which kind of nested class and why.
A static member class is the simplest kind of nested class.
It is best thought of as an ordinary class that happens to be declared inside another class and has access to all of the enclosing class’s members, even those declared private.
A static member class is a static member of its enclosing class and obeys the same accessibility rules as other static members.
If it is declared private, it is accessible only within the enclosing class, and so forth.
One common use of a static member class is as a public helper class, useful only in conjunction with its outer class.
For example, consider an enum describing the operations supported by a calculator (Item 30)
The Operation enum should be a public static member class of the Calculator class.
Syntactically, the only difference between static and nonstatic member classes is that static member classes have the modifier static in their declarations.
Despite the syntactic similarity, these two kinds of nested classes are very different.
Each instance of a nonstatic member class is implicitly associated with an enclosing instance of its containing class.
Within instance methods of a nonstatic member class, you can invoke methods on the enclosing instance or obtain a reference to the enclosing instance using the qualified this construct [JLS, 15.8.4]
If an instance of a nested class can exist in isolation from an instance of its enclosing class, then the nested class must be a static member class: it is impossible to create an instance of a nonstatic member class without an enclosing instance.
The association between a nonstatic member class instance and its enclosing instance is established when the former is created; it cannot be modified thereafter.
Normally, the association is established automatically by invoking a nonstatic member class constructor from within an instance method of the enclosing class.
As you would expect, the association takes up space in the nonstatic member class instance and adds time to its construction.
For example, implementations of the Map interface typically use nonstatic member classes to implement their collection views, which are returned by Map’s keySet, entrySet, and values methods.
Similarly, implementations of the collection interfaces, such as Set and List, typically use nonstatic member classes to implement their iterators:
If you declare a member class that does not require access to an enclosing instance, always put the static modifier in its declaration, making it a static rather than a nonstatic member class.
If you omit this modifier, each instance will have an extraneous reference to its enclosing instance.
Storing this reference costs time and space, and can result in the enclosing instance being retained when it would otherwise be eligible for garbage collection (Item 6)
And should you ever need to allocate an instance without an enclosing instance, you’ll be unable to do so, as nonstatic member class instances are required to have an enclosing instance.
A common use of private static member classes is to represent components of the object represented by their enclosing class.
For example, consider a Map instance, which associates keys with values.
Many Map implementations have an internal Entry object for each key-value pair in the map.
While each entry is associated with a map, the methods on an entry (getKey, getValue, and setValue) do not need access to the map.
Therefore, it would be wasteful to use a nonstatic member class to represent entries: a private static member class is best.
If you accidentally omit the static modifier in the entry declaration, the map will still work, but each entry will contain a superfluous reference to the map, which wastes space and time.
It is doubly important to choose correctly between a static and a nonstatic member class if the class in question is a public or protected member of an.
In this case, the member class is an exported API element and cannot be changed from a nonstatic to a static member class in a subsequent release without violating binary compatibility.
Anonymous classes are unlike anything else in the Java programming language.
As you would expect, an anonymous class has no name.
Rather than being declared along with other members, it is simultaneously declared and instantiated at the point of use.
Anonymous classes are permitted at any point in the code where an expression is legal.
Anonymous classes have enclosing instances if and only if they occur in a nonstatic context.
But even if they occur in a static context, they cannot have any static members.
There are many limitations on the applicability of anonymous classes.
You can’t instantiate them except at the point they’re declared.
You can’t perform instanceof tests or do anything else that requires you to name the class.
You can’t declare an anonymous class to implement multiple interfaces, or to extend a class and implement an interface at the same time.
Clients of an anonymous class can’t invoke any members except those it inherits from its supertype.
Because anonymous classes occur in the midst of expressions, they must be kept shortabout ten lines or fewer—or readability will suffer.
One common use of anonymous classes is to create function objects (Item 21) on the fly.
For example, the sort method invocation on page 104 sorts an array of strings according to their length using an anonymous Comparator instance.
Another common use of anonymous classes is to create process objects, such as Runnable, Thread, or TimerTask instances.
A third common use is within static factory methods (see the intArrayAsList method in Item 18)
Local classes are the least frequently used of the four kinds of nested classes.
A local class can be declared anywhere a local variable can be declared and obeys the same scoping rules.
Local classes have attributes in common with each of the other kinds of nested classes.
Like member classes, they have names and can be used repeatedly.
Like anonymous classes, they have enclosing instances only if they are defined in a nonstatic context, and they cannot contain static members.
And like anonymous classes, they should be kept short so as not to harm readability.
To recap, there are four different kinds of nested classes, and each has its place.
If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class.
If each instance of the member class needs a reference to its enclosing instance, make it nonstatic; otherwise, make it static.
Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make it an anonymous class; otherwise, make it a local class.
Before generics, you had to cast every object you read from a collection.
If someone accidentally inserted an object of the wrong type, casts could fail at runtime.
With generics, you tell the compiler what types of objects are permitted in each collection.
The compiler inserts casts for you automatically and tells you at compile time if you try to insert an object of the wrong type.
This results in programs that are both safer and clearer, but these benefits come with complications.
This chapter tells you how to maximize the benefits and minimize the complications.
For example, as of release 1.5, the List interface has a single type parameter, E, representing the element type of the list.
Technically the name of the interface is now List<E> (read “list of E”), but people often call it List for short.
Generic classes and interfaces are collectively known as generic types.
For example, List<String> (read “list of string”) is a parameterized type representing a list whose elements are of type String.
String is the actual type parameter corresponding to the formal type parameter E.
Finally, each generic type defines a raw type, which is the name of the generic type used without any accompanying actual type parameters [JLS, 4.8]
Raw types behave as if all of the generic type information were erased from the type declaration.
For all practical purposes, the raw type List behaves the same way as the interface type List did before generics were added to the platform.
Before release 1.5, this would have been an exemplary collection declaration:
If you accidentally put a coin into your stamp collection, the erroneous insertion compiles and runs without error:
You don’t get an error until you retrieve the coin from the stamp collection:
As mentioned throughout this book, it pays to discover errors as soon as possible after they are made, ideally at compile time.
In this case, you don’t discover the error till runtime, long after it has happened, and in code that is far removed from the code containing the error.
The compiler can’t help you, because it can’t understand the comment that says, “Contains only Stamp instances.”
With generics, you replace the comment with an improved type declaration for the collection that tells the compiler the information that was previously hidden in the comment:
Parameterized collection type - typesafe private final Collection<Stamp> stamps = ...
When stamps is declared with a parameterized type, the erroneous insertion generates a compile-time error message that tells you exactly what is wrong:
As an added benefit, you no longer have to cast manually when removing elements from collections.
The compiler inserts invisible casts for you and guarantees that they won’t fail (assuming, again, that all of your code was compiled with a generics-aware compiler and did not produce or suppress any warnings)
This is true whether you use a for-each loop (Item 46):
While the prospect of accidentally inserting a coin into a stamp collection may appear far-fetched, the problem is real.
For example, it is easy to imagine someone putting a java.util.Date instance into a collection that is supposed to contain only java.sql.Date instances.
As noted above, it is still legal to use collection types and other generic types without supplying type parameters, but you should not do it.
If you use raw types, you lose all the safety and expressiveness benefits of generics.
Given that you shouldn’t use raw types, why did the language designers allow them? To provide compatibility.
The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in.
It was deemed critical that all of this code remain legal and interoperable with new code that does use generics.
It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa.
This requirement, known as migration compatibility, drove the decision to support raw types.
While you shouldn’t use raw types such as List in new code, it is fine to use types that are parameterized to allow insertion of arbitrary objects, such as List<Object>
Just what is the difference between the raw type List and the parameterized type List<Object>? Loosely speaking, the former has opted out of generic type checking, while the latter has explicitly told the compiler that it is capable of holding objects of any type.
As a consequence, you lose type safety if you use a raw type like List, but not if you use a parameterized type like List<Object>
This program compiles, but because it uses the raw type List, you get a warning:
And indeed, if you run the program, you get a ClassCastException when the program tries to cast the result of the invocation strings.get(0) to a String.
This is a compiler-generated cast, so it’s normally guaranteed to succeed, but in this case we ignored a compiler warning and paid the price.
If you replace the raw type List with the parameterized type List<Object> in the unsafeAdd declaration and try to recompile the program, you’ll find that it no longer compiles.
You might be tempted to use a raw type for a collection whose element type is unknown and doesn’t matter.
For example, suppose you want to write a method that takes two sets and returns the number of elements they have in common.
Here’s how you might write such a method if you were new to generics:
This method works but it uses raw types, which are dangerous.
Since release 1.5, Java has provided a safe alternative known as unbounded wildcard types.
If you want to use a generic type but you don’t know or care what the actual type parameter is, you can use a question mark instead.
It is the most general parameterized Set type, capable of holding any set.
What is the difference between the unbounded wildcard type Set<?> and the raw type Set? Do the question marks really buy you anything? Not to belabor the point, but the wildcard type is safe and the raw type isn’t.
Admittedly this error message leaves something to be desired, but the compiler has done its job, preventing you from corrupting the collection’s type invariant.
Not only can’t you put any element (other than null) into a Collection<?>, but you can’t assume anything about the type of the objects that you get out.
There are two minor exceptions to the rule that you should not use raw types in new code, both of which stem from the fact that generic type information is erased at runtime (Item 25)
The specification does not permit the use of parameterized types (though it does permit array types and primitive types) [JLS, 15.8.2]
The second exception to the rule concerns the instanceof operator.
Because generic type information is erased at runtime, it is illegal to use the instanceof operator on parameterized types other than unbounded wildcard types.
The use of unbounded wildcard types in place of raw types does not affect the behavior of the instanceof operator in any way.
In this case, the angle brackets and question marks are just noise.
This is the preferred way to use the instanceof operator with generic types:
Note that once you’ve determined that o is a Set, you must cast it to the wildcard type Set<?>, not the raw type Set.
This is a checked cast, so it will not cause a compiler warning.
In summary, using raw types can lead to exceptions at runtime, so don’t use them in new code.
They are provided only for compatibility and interoperability with legacy code that predates the introduction of generics.
The first two are safe and the last is not.
For quick reference, the terms introduced in this item (and a few introduced elsewhere in this chapter) are summarized in the following table:
When you program with generics, you will see many compiler warnings: unchecked cast warnings, unchecked method invocation warnings, unchecked generic array creation warnings, and unchecked conversion warnings.
The more experience you acquire with generics, the fewer warnings you’ll get, but don’t expect newly written code that uses generics to compile cleanly.
The compiler will gently remind you what you did wrong:
You can then make the indicated correction, causing the warning to disappear:
When you get warnings that require some thought, persevere! Eliminate every unchecked warning that you can.
If you eliminate all warnings, you are assured that your code is typesafe, which is a very good thing.
It means that you won’t get a ClassCastException at runtime, and it increases your confidence that your program is behaving as you intended.
If you suppress warnings without first proving that the code is typesafe, you are only giving yourself a false sense of security.
The code may compile without emitting any warnings, but it can still throw a ClassCastException at runtime.
If, however, you ignore unchecked warnings that you know to be safe (instead of suppressing them), you won’t notice when a new warning crops up that represents a real problem.
The new warning will get lost amidst all the false alarms that you didn’t silence.
The SuppressWarnings annotation can be used at any granularity, from an individual local variable declaration to an entire class.
Always use the SuppressWarnings annotation on the smallest scope possible.
Typically this will be a variable declaration or a very short method or constructor.
If you find yourself using the SuppressWarnings annotation on a method or constructor that’s more than one line long, you may be able to move it onto a local variable declaration.
You may have to declare a new local variable, but it’s worth it.
For example, consider this toArray method, which comes from ArrayList:
It is illegal to put a SuppressWarnings annotation on the return statement, because it isn’t a declaration [JLS, 9.7]
You might be tempted to put the annotation on the entire method, but don’t.
Instead, declare a local variable to hold the return value and annotate its declaration, like so:
This method compiles cleanly and minimizes the scope in which unchecked warnings are suppressed.
This will help others understand the code, and more importantly, it will decrease the odds that someone will modify the code so as to make the computation unsafe.
If you find it hard to write such a comment, keep thinking.
You may end up figuring out that the unchecked operation isn’t safe after all.
Every unchecked warning represents the potential for a ClassCastException at runtime.
Record the rationale for your decision to suppress the warning in a comment.
This scary-sounding word means simply that if Sub is a subtype of Super, then the array type Sub[] is a subtype of Super[]
You might think this means that generics are deficient, but arguably it is arrays that are deficient.
Either way you can’t put a String into a Long container, but with an array you find out that you’ve made a mistake at runtime; with a list, you find out at compile time.
The second major difference between arrays and generics is that arrays are reified [JLS, 4.7]
This means that arrays know and enforce their element types at runtime.
This means that they enforce their type constraints only at compile time and discard (or erase) their element type information at runtime.
Erasure is what allows generic types to interoperate freely with legacy code that does not use generics (Item 23)
Because of these fundamental differences, arrays and generics do not mix well.
For example, it is illegal to create an array of a generic type, a parameterized type, or a type parameter.
All will result in generic array creation errors at compile time.
Why is it illegal to create a generic array? Because it isn’t typesafe.
If it were legal, casts generated by the compiler in an otherwise correct program could fail at runtime with a ClassCastException.
This would violate the fundamental guarantee provided by the generic type system.
To make this more concrete, consider the following code fragment:
Let’s pretend that line 1, which creates a generic array, is legal.
In line 5, we retrieve the sole element from the sole list in this array.
The compiler automatically casts the retrieved element to String, but it’s an Integer, so we get a ClassCastException at runtime.
In order to prevent this from happening, line 1 (which creates a generic array) generates a compile-time error.
Intuitively speaking, a non-reifiable type is one whose runtime representation contains less information than its compile-time representation.
It is legal, though infrequently useful, to create arrays of unbounded wildcard types.
It means, for example, that it’s not generally possible for a generic type to return an array of its element type (but see Item 29 for a partial solution)
It also means that you can get confusing warnings when using varargs methods (Item 42) in combination with generic types.
This is because every time you invoke a varargs method, an array is created to hold the varargs parameters.
If the element type of this array is not reifiable, you get a warning.
There is little you can do about these warnings other than to suppress them (Item 24), and to avoid mixing generics and varargs in your APIs.
When you get a generic array creation error, the best solution is often to use the collection type List<E> in preference to the array type E[]
You might sacrifice some performance or conciseness, but in exchange you get better type safety and interoperability.
Now suppose you want to write a method to “reduce” the list by applying the function across it.
If the list contains integers and the function adds two integer values, the reduce method returns the sum of all the values in the list.
If the function multiplies two integer values, the method returns the product of the values in the list.
If the list contains strings and the function concatenates two strings, the method returns a string consisting of all the strings in the list in sequence.
In addition to a list and a function, the reduce method takes an initial value for the reduction, which is returned if the list is empty.
Now, suppose you’ve read Item 67, which tells you not to call “alien methods” from a synchronized region.
So, you modify the reduce method to copy the contents of the list while holding the lock, which allows you to perform the reduction on the copy.
Prior to release 1.5, the natural way to do this would have been using List’s toArray method (which locks the list internally):
If you try to do this with generics you’ll get into trouble of the sort that we discussed above.
And here’s a naive attempt to apply generics to the revised version of the reduce method.
For the purposes of this item, you should concentrate on the method body:
If you try to compile this method, you’ll get the following error:
No big deal, you say, I’ll cast the Object array to an E array:
That gets rid of the error, but now you get a warning:
Reduce.java:12: warning: [unchecked] unchecked cast found : Object[], required: E[]
The compiler is telling you that it can’t check the safety of the cast at runtime because it doesn’t know what E is at runtime—remember, element type information is erased from generics at runtime.
Will this program work? Yes, it turns out that it will, but it isn’t safe.
With minor modifications, you could get it to throw a.
ClassCastException on a line that doesn’t contain an explicit cast.
The compiletime type of snapshot is E[] which could be String[], Integer[], or any other kind of array.
Casts to arrays of non-reifiable types should be used only under special circumstances (Item 26)
So what should you do? Use a list instead of an array.
Here is a version of the reduce method that compiles without error or warning:
This version is a tad more verbose than the array version, but it’s worth it for the peace of mind that comes from knowing you won’t get a ClassCastException at runtime.
In summary, arrays and generics have very different type rules.
As a consequence, arrays provide runtime type safety but not compile-time type safety and vice versa for generics.
If you find yourself mixing them and getting compile-time errors or warnings, your first impulse should be to replace the arrays with lists.
It is generally not too difficult to parameterize your collection declarations and make use of the generic types and methods provided by the JDK.
Writing your own generic types is a bit more difficult, but it’s worth the effort to learn how.
This class is a prime candidate for generification, in other words, for being compatibly enhanced to take advantage of generic types.
As it stands, you have to cast objects that are popped off the stack, and those casts might fail at runtime.
In this case there is one type parameter, representing the element type of the stack, and the conventional name for this parameter is E (Item 44)
The next step is to replace all the uses of the type Object with the appropriate type parameter, and then try to compile the resulting program:
You’ll generally get at least one error or warning, and this class is no exception.
As explained in Item 25, you can’t create an array of a non-reifiable type, such as E.
This problem arises every time you write a generic type that is backed by an array.
The first solution directly circumvents the prohibition on generic array creation: create an array of Object and cast it to the.
Now in place of an error, the compiler will emit a warning.
This usage is legal, but it’s not (in general) typesafe:
Stack.java:8: warning: [unchecked] unchecked cast found : Object[], required: E[]
The compiler may not be able to prove that your program is typesafe, but you can.
You must convince yourself that the unchecked cast will not compromise the type safety of the program.
The array in question (elements) is stored in a private field and never returned to the client or passed to any other method.
The only elements stored in the array are those passed to the push method, which are of type E, so the unchecked cast can do no harm.
Once you’ve proved that an unchecked cast is safe, suppress the warning in as narrow a scope as possible (Item 24)
In this case, the constructor contains only the unchecked array creation, so it’s appropriate to suppress the warning in the entire constructor.
The second way to eliminate the generic array creation error in Stack is to change the type of the field elements from E[] to Object[]
You can change this error into a warning by casting the element retrieved from the array from Object to E:
Stack.java:19: warning: [unchecked] unchecked cast found : Object, required: E.
Because E is a non-reifiable type, there’s no way the compiler can check the cast at runtime.
Again, you can easily prove to yourself that the unchecked cast is safe, so it’s appropriate to suppress the warning.
In line with the advice of Item 24, we suppress the warning only on the assignment that contains the unchecked cast, not on the entire pop method:
Which of the two techniques you choose for dealing with the generic array creation error is largely a matter of taste.
All other things being equal, it is riskier to suppress an unchecked cast to an array type than to a scalar type, which would suggest the second solution.
The following program demonstrates the use of our generic Stack class.
The program prints its command line arguments in reverse order and converted to uppercase.
No explicit cast is necessary to invoke String’s toUpperCase method on the elements popped from the stack, and the automatically generated cast is guaranteed to succeed:
The foregoing example may appear to contradict Item 25, which encourages the use of lists in preference to arrays.
It is not always possible or desirable to use lists inside your generic types.
Java doesn’t support lists natively, so some generic types, such as ArrayList, must be implemented atop arrays.
Other generic types, such as HashMap, are implemented atop arrays for performance.
This is a fundamental limitation of Java’s generic type system.
You can work around this restriction by using boxed primitive types (Item 49)
There are some generic types that restrict the permissible values of their type parameters.
This allows the DelayQueue implementation and its clients to take advantage of Delayed methods on the elements of a DelayQueue, without the need for explicit casting or the risk of a ClassCastException.
The type parameter E is known as a bounded type parameter.
In summary, generic types are safer and easier to use than types that require casts in client code.
When you design new types, make sure that they can be used without such casts.
This will make life easier for new users of these types without breaking existing clients (Item 23)
Just as classes can benefit from generification, so can methods.
All of the “algorithm” methods in Collections (such as binarySearch and sort) have been generified.
Consider this method, which returns the union of two sets:
To fix these warnings and make the method typesafe, modify the method declaration to declare a type parameter representing the element type for the three sets (two arguments and the return value) and use the type parameter in the method.
The type parameter list, which declares the type parameter, goes between the method’s modifiers and its return type.
At least for simple generic methods, that’s all there is to it.
Now the method compiles without generating any warnings and provides type safety as well as ease.
The program contains no casts and compiles without errors or warnings:
A limitation of the union method is that the types of all three sets (both input parameters and the return value) have to be the same.
You can make the method more flexible by using bounded wildcard types (Item 28)
One noteworthy feature of generic methods is that you needn’t specify the value of the type parameter explicitly as you must when invoking generic constructors.
The compiler figures out the value of the type parameters by examining the types of the method arguments.
In the case of the program above, the compiler sees that both arguments to union are of type Set<String>, so it knows that the type parameter E must be String.
As discussed in Item 1, you can exploit the type inference provided by generic method invocation to ease the process of creating parameterized type instances.
To refresh your memory, the need to pass the values of type parameters explicitly when invoking generic constructors can be annoying.
The type parameters appear redundantly on the left- and right-hand sides of variable declarations:
To eliminate this redundancy, write a generic static factory method corresponding to each constructor that you want to use.
For example, here is a generic static factory method corresponding to the parameterless HashMap constructor:
With this generic static factory method, you can replace the repetitious declaration above with this concise one:
It would be nice if the language did the same kind of type inference when invoking constructors on generic types as it does when invoking generic methods.
Someday it might, but as of release 1.6, it does not.
On occasion, you will need to create an object that is immutable but applicable to many different types.
Because generics are implemented by erasure (Item 25), you can use a single object for all required type parameterizations, but you need to write a static factory method to repeatedly dole out the object for each requested type parameterization.
Suppose you have an interface that describes a function that accepts and returns a value of some type T:
Now suppose that you want to provide an identity function.
It would be wasteful to create a new one each time it’s required, as it’s stateless.
If generics were reified, you would need one identity function per type, but since they’re erased you need only a generic singleton.
But the identity function is special: it returns its argument unmodified, so we know that it is typesafe to use it as a UnaryFunction<T> whatever the value of T.
Therefore, we can confidently suppress the unchecked cast warning that is generated by this cast.
Once we’ve done this, the code compiles without error or warning.
As usual, it contains no casts and compiles without errors or warnings:
It is permissible, though relatively rare, for a type parameter to be bounded by some expression involving that type parameter itself.
The most common use of recursive type bounds is in connection with the Comparable interface, which defines a type’s natural ordering:
The type parameter T defines the type to which elements of the type implementing Comparable<T> can be compared.
In practice, nearly all types can be compared only to elements of their own type.
There are many methods that take a list of elements that implement Comparable, in order to sort the list, search within it, calculate its minimum or maximum, and the like.
To do any of these things, it is required that every element in the list.
Here is a method to go with the declaration above.
It calculates the maximum value of a list according to its elements’ natural order, and it compiles without errors or warnings:
Recursive type bounds can get much more complex than this, but luckily it doesn’t happen too often.
If you understand this idiom, and its wildcard variant (Item 28), you’ll be able to deal with many of the recursive type bounds that you see in practice.
In summary, generic methods, like generic types, are safer and easier to use than methods that require their clients to cast input parameters and return values.
Like types, you should make sure that your new methods can be used without casts, which will often mean making them generic.
And like types, you should generify your existing methods to make life easier for new users without breaking existing clients (Item 23)
Sometimes you need more flexibility than invariant typing can provide.
Suppose we want to add a method that takes a sequence of elements and pushes them all onto the stack.
If the element type of the Iterable src exactly matches that of the stack, it works fine.
But suppose you have a Stack<Number> and you invoke push(intVal), where intVal is of type Integer.
If you try it, however, you’ll get this error message because, as noted above, parameterized types are invariant:
The language provides a special kind of parameterized type call a bounded wildcard type to deal with situations like this.
The use of the keyword extends is slightly misleading: recall from Item 26 that subtype is defined so that every type is a subtype of itself, even though it does not extend itself.
With this change, not only does Stack compile cleanly, but so does the client code that wouldn’t compile with the original pushAll declaration.
Because Stack and its client compile cleanly, you know that everything is typesafe.
Now suppose you want to write a popAll method to go with pushAll.
The popAll method pops each element off the stack and adds the elements to the given collection.
Here’s how a first attempt at writing the popAll method might look:
Again, this compiles cleanly and works fine if the element type of the destination collection exactly matches that of the stack.
Suppose you have a Stack<Number> and variable of type Object.
If you pop an element from the stack and store it in the variable, it compiles and runs without error.
With this change, both Stack and the client code compile cleanly.
If an input parameter is both a producer and a consumer, then wildcard types will do you no good: you need an exact type match, which is what you get without any wildcards.
Here is a mnemonic to help you remember which wildcard type to use:
The PECS mnemonic captures the fundamental principle that guides the use of wildcard types.
With this mnemonic in mind, let’s take a look at some method declarations from previous items.
Although lists can both consume and produce values, the reduce method uses its list parameter only as an E producer, so its declaration should use a wildcard type that extends E.
The parameter f represents a function that both consumes and produces E instances, so a wildcard type would be inappropriate for it.
And would this change make any difference in practice? As it turns out, it would.
This would not compile with the original declaration, but it does once you add the bounded wildcard type.
Rather than providing additional flexibility for your users, it would force them to use wildcard types in client code.
Properly used, wildcard types are nearly invisible to users of a class.
They cause methods to accept the parameters they should accept and reject those they should reject.
If the user of a class has to think about wildcard types, there is probably something wrong with the class’s API.
Looking at the revised declaration for union, you might think that you could do this:
Luckily there is a way to deal with this sort of error.
If the compiler doesn’t infer the type that you wish it had, you can tell it what type to use with an explicit.
This is not something that you have to do very often, which is a good thing, as explicit type parameters aren’t very pretty.
With the addition of this explicit type parameter, the program compiles cleanly:
To get the revised declaration from the original one, we apply the PECS transformation twice.
This is the first time we’ve seen a wildcard applied to a type parameter.
The revised max declaration is probably the most complex method declaration in the entire book.
Does the added complexity really buy you anything? Yes, it does.
Here is a simple example of a list that would be excluded by the original declaration but is permitted by the revised one:
In other words, a ScheduledFuture instance isn’t merely comparable to other ScheduledFuture instances; it’s comparable to any Delayed instance, and that’s enough to cause the original declaration to reject it.
There is one slight problem with the revised declaration for max: it prevents the method from compiling.
It returns an iterator of some subtype of T, so we replace the iterator declaration with this one, which uses a bounded wildcard type:
That is the only change that we have to make to the body of the method.
The elements returned by the iterator’s next method are of some subtype of T, so they can be safely stored in a variable of type T.
There is a duality between type parameters and wildcards, and many methods can be declared using one or the other.
For example, here are two possible declarations for a static method to swap two indexed items in a list.
The first uses an unbounded type parameter (Item 27) and the second an unbounded wildcard:
Which of these two declarations is preferable, and why? In a public API, the second is better because it’s simpler.
You pass in a list—any list—and the method swaps the indexed elements.
As a rule, if a type parameter appears only once in a method declaration, replace it with a wildcard.
If it’s an unbounded type parameter, replace it with an unbounded wildcard; if it’s a bounded type parameter, replace it with a bounded wildcard.
There’s one problem with the second declaration for swap, which uses a wildcard in preference to a type parameter: the straightforward implementation won’t compile:
It doesn’t seem right that we can’t put an element back into the list that we just took it out of.
Fortunately, there is a way to implement this method without resorting to an unsafe cast or a raw type.
The idea is to write a private helper method to capture the wildcard type.
The helper method must be a generic method in order to capture the type.
Therefore, it knows that any value it gets out of this list is of type E, and that it’s safe to put any value of type E into the list.
It allows us to export the nice wildcard-based declaration of swap, while taking advantage of the more complex generic method internally.
In summary, using wildcard types in your APIs, while tricky, makes the APIs far more flexible.
If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory.
The most common use of generics is for collections, such as Set and Map, and single-element containers, such as ThreadLocal and AtomicReference.
In all of these uses, it is the container that is parameterized.
This limits you to a fixed number of type parameters per container.
A Set has a single type parameter, representing its element type; a Map has two, representing its key and value types; and so forth.
For example, a database row can have arbitrarily many columns, and it would be nice to be able to access all of them in a typesafe manner.
Luckily, there is an easy way to achieve this effect.
The idea is to parameterize the key instead of the container.
Then present the parameterized key to the container to insert or retrieve a value.
The generic type system is used to guarantee that the type of the value agrees with its key.
As a simple example of this approach, consider a Favorites class that allows its clients to store and retrieve a “favorite” instance of arbitrarily many other classes.
The Class object will play the part of the parameterized key.
The reason this works is that class Class was generified in release 1.5
The type of a class literal is no longer simply Class, but Class<T>
When a class literal is passed among methods to communicate both compile-time and runtime type information, it is called a type token [Bracha04]
It looks just like a simple map, except that the key is parameterized instead of the map.
The client presents a Class object when setting and getting favorites.
Here is a sample program that exercises the Favorites class, storing, retrieving, and printing a favorite String, Integer, and Class instance:
As you might expect, this program prints Java cafebabe Favorites.
A Favorites instance is typesafe: it will never return an Integer when you.
It is also heterogeneous: unlike an ordinary map, all the keys are of different types.
You might think that you couldn’t put anything into this Map because of the unbounded wildcard type, but the truth is quite the opposite.
The thing to notice is that the wildcard type is nested: it’s not the type of the Map that’s a wildcard type but the type of its key.
The next thing to notice is that the value type of the favorites Map is simply Object.
In other words, the Map does not guarantee the type relationship between keys and values, which is that every value is of the type represented by its key.
In fact, Java’s type system is not powerful enough to express this.
But we know that it’s true, and we take advantage of it when it comes time to retrieve a favorite.
The putFavorite implementation is trivial: it simply puts into favorites a mapping from the given Class object to the given favorite instance.
As noted, this discards the “type linkage” between the key and the value; it loses the knowledge that the value is an instance of the key.
But that’s OK, because the getFavorites method can and does reestablish this linkage.
The implementation of the getFavorite method is trickier than that of putFavorite.
First it gets from the favorites map the value corresponding to the given Class object.
This is the correct object reference to return, but it has the wrong compile-time type.
Its type is simply Object (the value type of the favorites map) and we need to return a T.
So, the getFavorite implementation dynamically casts the object reference to the type represented by the Class object, using Class’s cast method.
The cast method is the dynamic analog of Java’s cast operator.
It simply checks that its argument is an instance of the type represented by the Class object.
If so, it returns the argument; otherwise it throws a ClassCastException.
That is to say, we know that the values in the favorites map always match the types of the keys.
So what does the cast method do for us, given that it simply returns its argument? The signature of the cast method takes full advantage of the fact that class Class has been generified.
Its return type is the type parameter of the Class object:
It is what allows us to make Favorites typesafe without resorting to an unchecked cast to T.
There are two limitations to the Favorites class that are worth noting.
First, a malicious client could easily corrupt the type safety of a Favorites instance, simply by using a Class object in its raw form.
But the resulting client code would generate an unchecked warning when it was compiled.
This is no different from the normal collection implementations such as HashSet and HashMap.
That said, you can have runtime type safety if you’re willing to pay for it.
The way to ensure that Favorites never violates its type invariant is to have the.
Their static factories take a Class object (or two) in addition to a collection (or map)
The static factories are generic methods, ensuring that the compile-time types of the Class object and the collection match.
For example, the wrapper throws a ClassCastException at runtime if someone tries to put Coin into your Collection<Stamp>
These wrappers are useful for tracking down who adds an incorrectly typed element to a collection in an application that mixes generic and legacy code.
The second limitation of the Favorites class is that it cannot be used on a non-reifiable type (Item 25)
In other words, you can store your favorite String or String[], but not your favorite List<String>
If you try to store your favorite List<String>, your program won’t compile.
There is no entirely satisfactory workaround for the second limitation.
There is a technique called super type tokens that goes a long way toward addressing the limitation, but this technique has limitations of its own [Gafter07]
The type tokens used by Favorites are unbounded: getFavorite and putFavorite accept any Class object.
Sometimes you may need to limit the types that can be passed to a method.
The annotations API (Item 35) makes extensive use of bounded type tokens.
For example, here is the method to read an annotation at runtime.
The argument annotationType is a bounded type token representing an annotation type.
The method returns the element’s annotation of that type, if it has one, or null, if it doesn’t.
In essence, an annotated element is a typesafe heterogeneous container whose keys are annotation types.
Suppose you have an object of type Class<?> and you want to pass it to a method that requires a bounded type token, such as getAnnotation.
Luckily, class Class provides an instance method that performs this sort of cast safely (and dynamically)
The method is called asSubclass, and it casts the Class object on which it’s called to represent a subclass of the class represented by its argument.
If the cast succeeds, the method returns its argument; if it fails, it throws a ClassCastException.
Here’s how you use the asSubclass method to read an annotation whose type is unknown at compile time.
In summary, the normal use of generics, exemplified by the collections APIs, restricts you to a fixed number of type parameters per container.
You can get around this restriction by placing the type parameter on the key rather than the container.
You can use Class objects as keys for such typesafe heterogeneous containers.
A Class object used in this fashion is called a type token.
For example, you could have a DatabaseRow type representing a database row (the container), and a generic type Column<T> as its key.
This chapter discusses best practices for using these new type families.
An enumerated type is a type whose legal values consist of a fixed set of constants, such as the seasons of the year, the planets in the solar system, or the suits in a deck of playing cards.
Before enum types were added to the language, a common pattern for representing enumerated types was to declare a group of named int constants, one for each member of the type:
This technique, known as the int enum pattern, has many shortcomings.
It provides nothing in the way of type safety and little in the way of convenience.
The compiler won’t complain if you pass an apple to a method that expects an orange, compare apples to oranges with the == operator, or worse:
This is because Java doesn’t provide namespaces for int enum groups.
Prefixes prevent name clashes when two int enum groups have identically named constants.
Because int enums are compile-time constants, they are compiled into the clients that use them.
If the int associated with an enum constant is changed, its clients must be recompiled.
If they aren’t, they will still run, but their behavior will be undefined.
There is no easy way to translate int enum constants into printable strings.
If you print such a constant or display it from a debugger, all you see is a number, which isn’t very helpful.
There is no reliable way to iterate over all the int enum constants in a group, or even to obtain the size of an int enum group.
You may encounter a variant of this pattern in which String constants are used in place of int constants.
This variant, known as the String enum pattern, is even less desirable.
While it does provide printable strings for its constants, it can lead to performance problems because it relies on string comparisons.
Worse, it can lead naive users to hard-code string constants into client code instead of using field names.
If such a hard-coded string constant contains a typographical error, it will escape detection at compile time and result in bugs at runtime.
Luckily, as of release 1.5, the language provides an alternative that avoids the shortcomings of the int and string enum patterns and provides many added benefits.
On the surface, these enum types may appear similar to those of other languages, such as C, C++, and C#, but appearances are deceiving.
Java’s enum types are full-fledged classes, far more powerful than their counterparts in these other languages, where enums are essentially int values.
The basic idea behind Java’s enum types is simple: they are classes that export one instance for each enumeration constant via a public static final field.
Enum types are effectively final, by virtue of having no accessible constructors.
Because clients can neither create instances of an enum type nor extend it, there can be no instances but the declared enum constants.
They are a generalization of singletons (Item 3), which are essentially single-element enums.
If you declare a parameter to be of type Apple, you are guaranteed that any non-null object reference passed to the parameter is one of the three valid Apple values.
Attempts to pass values of the wrong type will result in compile-time errors, as will attempts to assign an expression of one enum type to a variable of another, or to use the == operator to compare values of different enum types.
Enum types with identically named constants coexist peacefully because each type has its own namespace.
You can add or reorder constants in an enum type without recompiling its clients because the fields that export the constants provide a layer of insulation between an enum type and its clients: the constant values are not compiled into the clients as they are in the int enum pattern.
Finally, you can translate enums into printable strings by calling their toString method.
In addition to rectifying the deficiencies of int enums, enum types let you add arbitrary methods and fields and implement arbitrary interfaces.
So why would you want to add methods or fields to an enum type? For starters, you might want to associate data with its constants.
Our Apple and Orange types, for example, might benefit from a method that returns the color of the fruit, or one that returns an image of it.
You can augment an enum type with any method that seems appropriate.
An enum type can start life as a simple collection of enum constants and evolve over time into a full-featured abstraction.
For a nice example of a rich enum type, consider the eight planets of our solar system.
Each planet has a mass and a radius, and from these two attributes you can compute its surface gravity.
This in turn lets you compute the weight of an object on the planet’s surface, given the mass of the object.
The numbers in parentheses after each enum constant are parameters that are passed to its constructor.
In this case, they are the planet’s mass and radius:
It is easy to write a rich enum type such as Planet.
To associate data with enum constants, declare instance fields and write a constructor that takes the data and stores it in the fields.
Enums are by their nature immutable, so all fields should be final (Item 15)
They can be public, but it is better to make them private and provide public accessors (Item 14)
In the case of Planet, the constructor also computes and stores the surface gravity, but this is just an optimization.
The gravity could be recomputed from the mass and radius each time it was used by the surfaceWeight method, which takes an object’s mass and returns its weight on the planet represented by the constant.
While the Planet enum is simple, it is surprisingly powerful.
Here is a short program that takes the earth-weight of an object (in any unit) and prints a nice table of the object’s weight on all eight planets (in the same unit):
Note that Planet, like all enums, has a static values method that returns an array of its values in the order they were declared.
Note also that the toString method returns the declared name of each enum value, enabling easy printing by println and printf.
If you’re dissatisfied with this string representation, you can change it by overriding the toString method.
Here is the result of running our little WeightTable program with the command line argument 175:
If this is the first time you’ve seen Java’s printf method in action, note that it differs from C’s in that you use %n where you’d use \n in C.
Some behaviors associated with enum constants may need to be used only from within the class or package in which the enum is defined.
Such behaviors are best implemented as private or package-private methods.
Each constant then carries with it a hidden collection of behaviors that allows the class or package containing the enum to react appropriately when presented with the constant.
Just as with other classes, unless you have a compelling reason to expose an enum method to its clients, declare it private or, if need be, package-private (Item 13)
If an enum is generally useful, it should be a top-level class; if its use is tied to a specific top-level class, it should be a member class of that top-level class (Item 22)
These rounding modes are used by the BigDecimal class, but they provide a useful abstraction that is not fundamentally tied to BigDecimal.
By making RoundingMode a top-level enum, the library designers encourage any programmer who needs rounding modes to reuse this enum, leading to increased consistency across APIs.
The techniques demonstrated in the Planet example are sufficient for most enum types, but sometimes you need more.
There is different data associated with each Planet constant, but sometimes you need to associate fundamentally different behavior with each constant.
For example, suppose you are writing an enum type to represent the operations on a basic four-function calculator, and you want.
One way to achieve this is to switch on the value of the enum:
It won’t compile without the throw statement because the end of the method is technically reachable, even though it will never be reached [JLS, 14.2.1]
If you add a new enum constant but forget to add a corresponding case to the switch, the enum will still compile, but it will fail at runtime when you try to apply the new operation.
Luckily, there is a better way to associate a different behavior with each enum constant: declare an abstract apply method in the enum type, and override it with a concrete method for each constant in a constant-specific class body.
If you add a new constant to the second version of Operation, it is unlikely that you’ll forget to provide an apply method, as the method immediately follows each constant declaration.
In the unlikely event that you do forget, the compiler will remind you, as abstract methods in an enum type must be overridden with concrete methods in all of its constants.
For example, here is a version of Operation that overrides the toString method to return the symbol commonly associated with the operation:
In some cases, overriding toString in an enum is very useful.
For example, the toString implementation above makes it easy to print arithmetic expressions, as demonstrated by this little program:
Enum types have an automatically generated valueOf(String) method that translates a constant’s name into the constant itself.
If you override the toString method in an enum type, consider writing a fromString method to translate the custom string representation back to the corresponding enum.
The following code (with the type name changed appropriately) will do the trick for any enum, so long as each constant has a unique string representation:
Note that the Operation constants are put into the stringToEnum map from a static block that runs after the constants have been created.
Trying to make each constant put itself into the map from its own constructor would cause a compilation error.
Enum constructors aren’t permitted to access the enum’s static fields, except for compile-time constant fields.
This restriction is necessary because these static fields have not yet been initialized when the constructors run.
A disadvantage of constant-specific method implementations is that they make it harder to share code among enum constants.
For example, consider an enum representing the days of the week in a payroll package.
This enum has a method that calculates a worker’s pay for that day given the worker’s base salary (per hour) and the number of hours worked on that day.
On the five weekdays, any time worked in excess of a normal shift generates overtime pay; on the two weekend days, all work generates overtime pay.
With a switch statement, it’s easy to do this calculation by applying multiple case labels to each of two code fragments.
For brevity’s sake, the code in this example uses double, but note that double is not an appropriate data type for a payroll application (Item 48):
This code is undeniably concise, but it is dangerous from a maintenance perspective.
Suppose you add an element to the enum, perhaps a special value to represent a vacation day, but forget to add a corresponding case to the switch statement.
The program will still compile, but the pay method will silently pay the worker the same amount for a vacation day as for an ordinary weekday.
To perform the pay calculation safely with constant-specific method implementations, you would have to duplicate the overtime pay computation for each constant, or move the computation into two helper methods (one for weekdays and one for weekend days) and invoke the appropriate helper method from each constant.
Either approach would result in a fair amount of boilerplate code, substantially reducing readability and increasing the opportunity for error.
The boilerplate could be reduced by replacing the abstract overtimePay method on PayrollDay with a concrete method that performs the overtime calculation for weekdays.
Then only the weekend days would have to override the method.
But this would have the same disadvantage as the switch statement: if you added another day without overriding the overtimePay method, you would silently inherit the weekday calculation.
What you really want is to be forced to choose an overtime pay strategy each time you add an enum constant.
The idea is to move the overtime pay computation into a private nested enum, and to pass an instance of this strategy enum to the constructor for the PayrollDay enum.
The PayrollDay enum then delegates the overtime pay calculation to the strategy enum, eliminating the need for a switch statement or constant-specific method.
While this pattern is less concise than the switch statement, it is safer and more flexible:
If switch statements on enums are not a good choice for implementing constant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting external enum types with constant-specific behavior.
For example, suppose the Operation enum is not under your control, and you.
You can simulate the effect with the following static method:
Enums are, generally speaking, comparable in performance to int constants.
A minor performance disadvantage of enums over int constants is that there is a space and time cost to load and initialize enum types.
So when should you use enums? Anytime you need a fixed set of constants.
Of course, this includes “natural enumerated types,” such as the planets, the days of the week, and the chess pieces.
But it also includes other sets for which you know all the possible values at compile time, such as choices on a menu, operation codes, and command line flags.
It is not necessary that the set of constants in an enum type stay fixed for all time.
The enum feature was specifically designed to allow for binary compatible evolution of enum types.
In summary, the advantages of enum types over int constants are compelling.
Many enums require no explicit constructors or members, but many others benefit from associating data with each constant and providing methods whose behavior is affected by this data.
Far fewer enums benefit from associating multiple behaviors with a single method.
In this relatively rare case, prefer constant-specific methods to enums that switch on their own values.
Consider the strategy enum pattern if multiple enum constants share common behaviors.
Many enums are naturally associated with a single int value.
All enums have an ordinal method, which returns the numerical position of each enum constant in its type.
You may be tempted to derive an associated int value from the ordinal:
If the constants are reordered, the numberOfMusicians method will break.
If you want to add a second enum constant associated with an int value that you’ve already used, you’re out of luck.
For example, it might be nice to add a constant for double quartet, which, like an octet, consists of eight musicians, but there is no way to do it.
Also, you can’t add a constant for an int value without adding constants for all intervening int values.
For example, suppose you want to add a constant representing a triple quartet, which consists of twelve musicians.
There is no standard term for an ensemble consisting of eleven musicians, so you are forced to add a dummy constant for the unused int value (11)
Never derive a value associated with an enum from its ordinal; store it in an instance field instead:
This representation lets you use the bitwise OR operation to combine several constants into a set, known as a bit field:
The bit field representation also lets you perform set operations such as union and intersection efficiently using bitwise arithmetic.
But bit fields have all the disadvantages of int enum constants and more.
It is even harder to interpret a bit field than a simple int enum constant when it is printed as a number.
Also, there is no easy way to iterate over all of the elements represented by a bit field.
Some programmers who use enums in preference to int constants still cling to the use of bit fields when they need to pass around sets of constants.
There is no reason to do this; a better alternative exists.
The java.util package provides the EnumSet class to efficiently represent sets of values drawn from a single enum type.
This class implements the Set interface, providing all of the richness, type safety, and interoperability you get with any other Set implementation.
But internally, each EnumSet is represented as a bit vector.
If the underlying enum type has sixty-four or fewer elements—and most do—the entire EnumSet is represented with a single long (page 7), so its performance is comparable to that of a bit field.
Bulk operations, such as removeAll and retainAll, are implemented using bitwise arithmetic, just as you’d do manually for bit fields.
But you are insulated from the ugliness and error-proneness of manual bit twiddling: the EnumSet does the hard work for you.
Here is how the previous example looks when modified to use enums instead of bit fields.
Here is client code that passes an EnumSet instance to the applyStyles method.
EnumSet provides a rich set of static factories for easy set creation, one of which is illustrated in this code:
While it seems likely that all clients would pass an EnumSet to the method, it is good practice to accept the interface type rather than the implementation type.
This allows for the possibility of an unusual client to pass in some other Set implementation and has no disadvantages to speak of (page 190)
In summary, just because an enumerated type will be used in sets, there is no reason to represent it with bit fields.
The one real disadvantage of EnumSet is that it is not, as of release 1.6, possible to create an immutable EnumSet, but this will likely be remedied in an upcoming release.
Occasionally you may see code that uses the ordinal method (Item 31) to index into an array.
For example, consider this simplistic class meant to represent a culinary herb:
Now suppose you have an array of herbs representing the plants in a garden, and you want to list these plants organized by type (annual, perennial, or biennial)
To do this, you construct three sets, one for each type, and iterate through the garden, placing each herb in the appropriate set.
Some programmers would do this by putting the sets into an array indexed by the type’s ordinal:
Using ordinal() to index an array - DON'T DO THIS! Herb[] garden = ...
Because arrays are not compatible with generics (Item 25), the program requires an unchecked cast and will not compile cleanly.
Because the array does not know what its index represents, you have to label the output manually.
But the most serious problem with this technique is that when you access an array that is indexed by an enum’s ordinal, it is your responsibility to use the correct int value; ints do not provide the type safety of enums.
Luckily, there is a much better way to achieve the same effect.
The array is effectively serving as a map from the enum to a value, so you might as well use a Map.
Here is how the program looks when it is rewritten to use EnumMap:
This program is shorter, clearer, safer, and comparable in speed to the original version.
There is no unsafe cast; no need to label the output manually, as the map keys are enums that know how to translate themselves to printable strings; and no possibility for error in computing array indices.
The reason that EnumMap is comparable in speed to an ordinal-indexed array is that EnumMap uses such an array internally.
But it hides this implementation detail from the programmer, combining the richness and type safety of a Map with the speed of an array.
Note that the EnumMap constructor takes the Class object of the key type: this is a bounded type token, which provides runtime generic type information (Item 29)
For example, this program uses such an array to map two phases to a phase transition (liquid to solid is freezing, liquid to gas is boiling, and so forth):
This program works and may even appear elegant, but appearances can be deceiving.
Like the simpler herb garden example above, the compiler has no way of knowing the relationship between ordinals and array indices.
If you make a mistake in the transition table, or forget to update it when you modify the Phase or Phase.Transition enum type, your program will fail at runtime.
And the size of the table is quadratic in the number of phases, even if the number of non-null entries is smaller.
Because each phase transition is indexed by a pair of phase enums, you are best off representing the relationship as a map from one enum (the source phase) to a map from the second enum (the destination phase) to the result (the phase transition)
The two phases associated with a phase transition are best captured by associating data with the phase transition enum, which is then used to initialize the nested EnumMap:
The code to initialize the phase transition map may look a bit complicated but it isn’t too bad.
The second loop in the block initializes the inner maps using the source and destination information provided by each state transition constant.
Now suppose you want to add a new phase to the system: the plasma, or ionized gas.
There are only two transitions associated with this phase: ionization, which takes a gas to a plasma; and deionization, which takes a plasma to a gas.
If you add too many or too few elements to the array, or place an element out of order, you are out of luck: the program will compile, but it will fail at runtime.
To update the EnumMap-based version, all you have to do is add PLASMA to the list of phases, and IONIZE(GAS, PLASMA) and DEIONIZE(PLASMA, GAS) to the list of phase transitions.
The program takes care of everything else, and you have virtually no opportunity for error.
Internally, the map of maps is implemented as an array of arrays, so you pay little in space or time cost for the added clarity, safety, and ease of maintenance.
In summary, it is rarely appropriate to use ordinals to index arrays: use EnumMap instead.
This is a special case of the general principle that application programmers should rarely, if ever, use Enum.ordinal (Item 31)
In almost all respects, enum types are superior to the typesafe enum pattern described in the first edition of this book [Bloch01]
On the face of it, one exception concerns extensibility, which was possible under the original pattern but is not supported by the language construct.
In other words, using the pattern, it was possible to have one enumerated type extend another; using the language feature, it is not.
For the most part, extensibility of enums turns out to be a bad idea.
It is confusing that elements of an extension type are instances of the base type and not vice versa.
There is no good way to enumerate over all of the elements of a base type and its extension.
Finally, extensibility would complicate many aspects of the design and implementation.
That said, there is at least one compelling use case for extensible enumerated types, which is operation codes, also known as opcodes.
An opcode is an enumerated type whose elements represent operations on some machine, such as the Operation type in Item 30, which represents the functions on a simple calculator.
Sometimes it is desirable to let the users of an API provide their own operations, effectively extending the set of operations provided by the API.
Luckily, there is a nice way to achieve this effect using enum types.
The basic idea is to take advantage of the fact that enum types can implement arbitrary interfaces by defining an interface for the opcode type and an enum that is the standard implementation of the interface.
For example, here is an extensible version of Operation type from Item 30:
While the enum type (BasicOperation) is not extensible, the interface type (Operation) is, and it is the interface type that is used to represent operations in APIs.
You can define another enum type that implements this interface and use instances of this new type in place of the base type.
For example, suppose you want to define an extension to the operation type above, consisting of the exponentiation and remainder operations.
All you have to do is write an enum type that implements the Operation interface:
You can use your new operations anywhere you could use the basic operations, provided that APIs are written to take the interface type (Operation), not the implementation (BasicOperation)
Note that you don’t have to declare the abstract apply method in the enum as you do in a nonextensible enum with instance-specific method implementations (page 152)
This is because the abstract method (apply) is a member of the interface (Operation)
Not only is it possible to pass a single instance of an “extension enum” anywhere a “base enum” is expected; it is possible to pass in an entire extension enum type and use its elements in addition to or instead of those of the base type.
For example, here is a version of the test program on page 153 that exercises all of the extended operations defined above:
The class literal serves as a bounded type token (Item 29)
The resulting code is a bit less complex, and the test method is a bit more flexible: it allows the caller to combine operations from multiple implementation.
A minor disadvantage of the use of interfaces to emulate extensible enums is that implementations cannot be inherited from one enum type to another.
In the case of our Operation example, the logic to store and retrieve the symbol associated with an operation is duplicated in BasicOperation and ExtendedOperation.
In this case it doesn’t matter because very little code is duplicated.
If there were a larger amount of shared functionality, you could encapsulate it in a helper class or a static helper method to eliminate the code duplication.
In summary, while you cannot write an extensible enum type, you can emulate it by writing an interface to go with a basic enum type that implements the interface.
This allows clients to write their own enums that implement the interface.
These enums can then be used wherever the basic enum type can be used, assuming APIs are written in terms of the interface.
Prior to release 1.5, it was common to use naming patterns to indicate that some program elements demanded special treatment by a tool or framework.
For example, the JUnit testing framework originally required its users to designate test methods by beginning their names with the characters test [Beck04]
For example, suppose you accidentally name a test method tsetSafetyOverride instead of testSafetyOverride.
JUnit will not complain, but it will not execute the test either, leading to a false sense of security.
A second disadvantage of naming patterns is that there is no way to ensure that they are used only on appropriate program elements.
Again, JUnit won’t complain, but it won’t execute the tests either.
A third disadvantage of naming patterns is that they provide no good way to associate parameter values with program elements.
For example, suppose you want to support a category of test that succeeds only if it throws a particular exception.
The exception type is essentially a parameter of the test.
You could encode the exception type name into the test method name using some elaborate naming pattern, but this would be ugly and fragile (Item 50)
The compiler would have no way of knowing to check that the string that was supposed to name an exception actually did.
If the named class didn’t exist or wasn’t an exception, you wouldn’t find out until you tried to run the test.
Suppose you want to define an annotation type to designate simple tests that are run automatically and fail if they throw an exception.
Here’s how such an annotation type, named Test, might look:
The declaration for the Test annotation type is itself annotated with Retention and Target annotations.
Such annotations on annotation type declarations are known as meta-annotations.
Without it, Test annotations would be invisible to the test tool.
Note the comment above the Test annotation declaration that says, “Use only on parameterless static methods.” It would be nice if the compiler could enforce this restriction, but it can’t.
There are limits to how much error checking the compiler can do for you even with annotations.
If you put a Test annotation on the declaration of an instance method or a method with one or more parameters, the test program will still compile, leaving it to the testing tool to deal with the problem at runtime.
It is called a marker annotation, because it has no parameters but simply “marks” the annotated element.
If the programmer were to misspell Test, or to apply the Test annotation to a program element other than a method declaration, the program wouldn’t compile:
The Sample class has eight static methods, four of which are annotated as tests.
But one of the annotated methods that does not throw an exception, m5, is an instance method, so it is not a valid use of the annotation.
In sum, Sample contains four tests: one will pass, two will fail, and one is invalid.
The four methods that are not annotated with the Test annotation will be ignored by the testing tool.
The Test annotations have no direct effect on the semantics of the Sample class.
They serve only to provide information for use by interested programs.
More generally, annotations never change the semantics of the annotated code, but enable it for special treatment by tools such as this simple test runner:
The test runner tool takes a fully qualified class name on the command line and runs all of the class’s Test-annotated methods reflectively, by calling Method.invoke.
Such uses include annotation of an instance method, of a method with one or more parameters, or of an inaccessible method.
The second catch block in the test runner catches these Test usage errors.
Here is the output that is printed if RunTests is run on Sample:
Now let’s add support for tests that succeed only if they throw a particular exception.
In English, it means “the Class object for some class that extends Exception,” and it allows the user of the annotation to specify any exception type.
This usage is an example of a bounded type token (Item 29)
Note that class literals are used as the values for the annotation parameter:
Now let’s modify the test runner tool to process the new annotation.
Doing so consists of adding the following code to the main method:
This code is similar to the code we used to process Test annotations, with one exception: this code extracts the value of the annotation parameter and uses it to check if the exception thrown by the test is of the right type.
There are no explicit casts, hence no danger of a ClassCastException.
That the test program compiled guarantees that its annotation parameters represent valid exception types, with one caveat: it is possible that the annotation parameters were valid at compile time but a class file representing a specified exception type is no longer present at runtime.
Taking our exception testing example one step further, it is possible to envision a test that passes if it throws any one of several specified exceptions.
The annotation mechanism has a facility that makes it easy to support this usage.
Suppose we change the parameter type of the ExceptionTest annotation to be an array of Class objects:
All of the previous ExceptionTest annotations are still valid with the new array-parameter version of ExceptionTest and result in single-element arrays.
To specify a multiple-element array, surround the elements with curly braces and separate them with commas:
It is reasonably straightforward to modify the test runner tool to process the new version of ExceptionTest.
The testing framework developed in this item is just a toy, but it clearly demonstrates the superiority of annotations over naming patterns.
And it only scratches the surface of what you can do with annotations.
If you write a tool that requires programmers to add information to source files, define an appropriate set.
There is simply no reason to use naming patterns now that we have annotations.
That said, with the exception of toolsmiths, most programmers will have no need to define annotation types.
Also, consider using any annotations provided by your IDE or static analysis tools.
Such annotations can improve the quality of the diagnostic information provided by these tools.
Note, however, that these annotations have yet to be standardized, so you will have some work to do if you switch tools, or if a standard emerges.
For the typical programmer, the most important of these is Override.
This annotation can be used only on method declarations, and it indicates that the annotated method declaration overrides a declaration in a supertype.
If you consistently use this annotation, it will protect you from a large class of nefarious bugs.
Consider this program, in which the class Bigram represents a bigram, or ordered pair of letters:
The main program repeatedly adds twenty-six bigrams, each consisting of two identical lowercase letters, to a set.
You might expect the program to print 26, as sets cannot contain duplicates.
Unfortunately, our hapless programmer failed to override equals, overloading it instead (Item 41)
To override Object.equals, you must define an equals method whose parameter is of type Object, but the parameter of Bigram’s equals.
This equals method tests for object identity, just like the == operator.
Luckily, the compiler can help you find this error, but only if you help the compiler by telling it that you intend to override Object.equals.
To do this, annotate Bigram.equals with @Override, as shown below:
If you insert this annotation and try to recompile the program, the compiler will generate an error message like this:
Bigram.java:10: method does not override or implement a method from a supertype.
You will immediately realize what you did wrong, slap yourself on the forehead, and replace the broken equals implementation with a correct one (Item 8):
Therefore, you should use the Override annotation on every method declaration that you believe to override a superclass declaration.
If you are writing a class that is not labeled abstract, and you believe that it overrides an abstract method, you needn’t bother putting the Override annotation on that method.
In a class that is not declared abstract, the compiler will emit an error message if you fail to override an abstract superclass method.
However, you might wish to draw attention to all of the methods in your class that override superclass methods, in which case you should feel free to annotate these methods too.
Modern IDEs provide another reason to use the Override annotation consistently.
If you use the Override annotation consistently, these warnings will alert you to unintentional overriding.
These warnings complement the compiler’s error messages, which alert you to unintentional failure to override.
Between the IDE and the compiler, you can be sure that you’re overriding methods everywhere you want to override them and nowhere else.
If you are using release 1.6 or a later release, the Override annotation provides even more help in finding bugs.
In release 1.6, it became legal to use the Override annotation on method declarations that override declarations from interfaces as well as classes.
In a concrete class that is declared to implement an interface, you needn’t annotate methods that you believe to override interface methods, because the compiler will emit an error message if your class fails to implement every interface method.
Again, you may choose to include these annotations simply to draw attention to interface methods, but it isn’t strictly necessary.
In an abstract class or an interface, however, it is worth annotating all methods that you believe to override superclass or superinterface methods, whether concrete or abstract.
For example, the Set interface adds no new methods to the Collection interface, so it should include Override annotations on all of its method declarations, to ensure that it does not accidentally add any new methods to the Collection interface.
In summary, the compiler can protect you from a great many errors if you use the Override annotation on every method declaration that you believe to override a supertype declaration, with one exception.
In concrete classes, you need not annotate methods that you believe to override abstract method declarations (though it is not harmful to do so)
A marker interface is an interface that contains no method declarations, but merely designates (or “marks”) a class that implements the interface as having some property.
By implementing this interface, a class indicates that its instances can be written to an ObjectOutputStream (or “serialized”)
You may hear it said that marker annotations (Item 35) make marker interfaces obsolete.
First and foremost, marker interfaces define a type that is implemented by instances of the marked class; marker annotations do not.
The existence of this type allows you to catch errors at compile time that you couldn’t catch until runtime if you used a marker annotation.
Inexplicably, the authors of the ObjectOutputStream API did not take advantage of the Serializable interface in declaring the write method.
The method’s argument type should have been Serializable rather than Object.
Another advantage of marker interfaces over marker annotations is that they can be targeted more precisely.
Suppose you have a marker that is applicable only to implementations of a particular interface.
If you define it as a marker interface, you can have it extend the sole interface to which it is applicable, guaranteeing that all marked types are also subtypes of the sole interface to which it is applicable.
Arguably, the Set interface is just such a restricted marker interface.
It is applicable only to Collection subtypes, but it adds no methods beyond those defined by Collection.
It is not generally considered to be a marker interface because it refines the contracts of several Collection methods, including add, equals, and hashCode.
But it is easy to imagine a marker interface that is applicable only to subtypes of some particular interface and does not refine the contracts of any of the interface’s methods as such.
The chief advantage of marker annotations over marker interfaces is that it is possible to add more information to an annotation type after it is already in use, by adding one or more annotation type elements with defaults [JLS, 9.6]
What starts life as a mere marker annotation type can evolve into a richer annotation type over time.
Such evolution is not possible with marker interfaces, as it is not generally possible to add methods to an interface after it has been implemented (Item 18)
Another advantage of marker annotations is that they are part of the larger annotation facility.
Therefore, marker annotations allow for consistency in frameworks that permit annotation of a variety of program elements.
So when should you use a marker annotation and when should you use a marker interface? Clearly you must use an annotation if the marker applies to any program element other than a class or interface, as only classes and interfaces can be made to implement or extend an interface.
If the marker applies only to classes and interfaces, ask yourself the question, Might I want to write one or more methods that accept only objects that have this marking? If so, you should use a marker interface in preference to an annotation.
This will make it possible for you to use the interface as a parameter type for the methods in question, which will result in the very real benefit of compile-time type checking.
If you answered no to the first question, ask yourself one more: Do I want to limit the use of this marker to elements of a particular interface, forever? If so, it makes sense to define the marker as a subinterface of that interface.
If you answered no to both questions, you should probably use a marker annotation.
In summary, marker interfaces and marker annotations both have their uses.
If you want to define a type that does not have any new methods associated with it, a marker interface is the way to go.
If you want to mark program elements other than classes and interfaces, to allow for the possibility of adding more information to the marker in the future, or to fit the marker into a framework that already makes heavy use of annotation types, then a marker annotation is the correct choice.
In a sense, this item is the inverse of Item 19, which says, “If you don’t want to define a type, don’t use an interface.” To a first approximation, this item says, “If you do want to define a type, do use an interface.”
Much of the material in this chapter applies to constructors as well as to methods.
Like Chapter 5, this chapter focuses on usability, robustness, and flexibility.
Most methods and constructors have some restrictions on what values may be passed into their parameters.
For example, it is not uncommon that index values must be non-negative and object references must be non-null.
You should clearly document all such restrictions and enforce them with checks at the beginning of the method body.
This is a special case of the general principle that you should attempt to detect errors as soon as possible after they occur.
Failing to do so makes it less likely that an error will be detected and makes it harder to determine the source of an error once it has been detected.
If an invalid parameter value is passed to a method and the method checks its parameters before execution, it will fail quickly and cleanly with an appropriate exception.
If the method fails to check its parameters, several things could happen.
The method could fail with a confusing exception in the midst of processing.
Worse, the method could return normally but silently compute the wrong result.
Worst of all, the method could return normally but leave some object in a compromised state, causing an error at some unrelated point in the code at some undetermined time in the future.
Once you’ve documented the restrictions on a method’s parameters and you’ve documented the exceptions that will be thrown if these restrictions are violated, it is a simple matter to enforce the restrictions.
For an unexported method, you as the package author control the circumstances under which the method is called, so you can and should ensure that only valid parameter values are ever passed in.
Therefore, nonpublic methods should generally check their parameters using assertions, as shown below:
In essence, these assertions are claims that the asserted condition will be true, regardless of how the enclosing package is used by its clients.
Unlike normal validity checks, assertions throw AssertionError if they fail.
And unlike normal validity checks, they have no effect and essentially no cost unless you enable them, which you do by passing the -ea (or -enableassertions) flag to the java interpreter.
It is particularly important to check the validity of parameters that are not used by a method but are stored away for later use.
For example, consider the static factory method on page 95, which takes an int array and returns a List view of the array.
If a client of this method were to pass in null, the method.
By that time, the origin of the List instance might be difficult to determine, which could greatly complicate the task of debugging.
Constructors represent a special case of the principle that you should check the validity of parameters that are to be stored away for later use.
It is critical to check the validity of constructor parameters to prevent the construction of an object that violates its class invariants.
There are exceptions to the rule that you should check a method’s parameters before performing its computation.
An important exception is the case in which the validity check would be expensive or impractical and the validity check is performed implicitly in the process of doing the computation.
All of the objects in the list must be mutually comparable.
In the process of sorting the list, every object in the list will be compared to some other object in the list.
Therefore, there would be little point in checking ahead of time that the elements in the list were mutually comparable.
Note, however, that indiscriminate reliance on implicit validity checks can result in a loss of failure atomicity (Item 64)
Occasionally, a computation implicitly performs a required validity check but throws the wrong exception if the check fails.
In other words, the exception that the computation would naturally throw as the result of an invalid parameter value doesn’t match the exception that the method is documented to throw.
Under these circumstances, you should use the exception translation idiom, described in Item 61, to translate the natural exception into the correct one.
Do not infer from this item that arbitrary restrictions on parameters are a good thing.
On the contrary, you should design methods to be as general as it is practical to make them.
The fewer restrictions that you place on parameters, the better, assuming the method can do something reasonable with all of the parameter values that it accepts.
Often, however, some restrictions are intrinsic to the abstraction being implemented.
To summarize, each time you write a method or constructor, you should think about what restrictions exist on its parameters.
You should document these restrictions and enforce them with explicit checks at the beginning of the method body.
It is important to get into the habit of doing this.
The modest work that it entails will be paid back with interest the first time a validity check fails.
One thing that makes Java such a pleasure to use is that it is a safe language.
This means that in the absence of native methods it is immune to buffer overruns, array overruns, wild pointers, and other memory corruption errors that plague unsafe languages such as C and C++
In a safe language, it is possible to write classes and to know with certainty that their invariants will remain true, no matter what happens in any other part of the system.
This is not possible in languages that treat all of memory as one giant array.
Even in a safe language, you aren’t insulated from other classes without some effort on your part.
You must program defensively, with the assumption that clients of your class will do their best to destroy its invariants.
This may actually be true if someone tries to break the security of your system, but more likely your class will have to cope with unexpected behavior resulting from honest mistakes on the part of programmers using your API.
Either way, it is worth taking the time to write classes that are robust in the face of ill-behaved clients.
While it is impossible for another class to modify an object’s internal state without some assistance from the object, it is surprisingly easy to provide such assistance without meaning to do so.
For example, consider the following class, which purports to represent an immutable time period:
At first glance, this class may appear to be immutable and to enforce the invariant that the start of a period does not follow its end.
It is, however, easy to violate this invariant by exploiting the fact that Date is mutable:
To protect the internals of a Period instance from this sort of attack, it is essential to make a defensive copy of each mutable parameter to the constructor and to use the copies as components of the Period instance in place of the originals:
With the new constructor in place, the previous attack will have no effect on the Period instance.
Note that defensive copies are made before checking the validity of the parameters (Item 38), and the validity check is performed on the copies rather than on the originals.
It protects the class against changes to the parameters from another thread during the “window of vulnerability” between the time the parameters are checked and the time they are copied.
Note also that we did not use Date’s clone method to make the defensive copies.
Such a subclass could, for example, record a reference to each instance in a private static list at the time of its creation and allow the attacker to access this list.
This would give the attacker free reign over all instances.
To prevent this sort of attack, do not use the clone method to make a defensive copy of a parameter whose type is subclassable by untrusted parties.
While the replacement constructor above successfully defends against the previous attack, it is still possible to mutate a Period instance, because its accessors offer access to its mutable internals:
To defend against the second attack, merely modify the accessors to return defensive copies of mutable internal fields:
With the new constructor and the new accessors in place, Period is truly immutable.
No matter how malicious or incompetent a programmer, there is simply no way to violate the invariant that the start of a period does not follow its end.
This is true because there is no way for any class other than Period itself to gain access to either of the mutable fields in a Period instance.
In the accessors, unlike the constructor, it would be permissible to use the clone method to make the defensive copies.
Defensive copying of parameters is not just for immutable classes.
Anytime you write a method or constructor that enters a client-provided object into an.
If it is, think about whether your class could tolerate a change in the object after it was entered into the data structure.
If the answer is no, you must defensively copy the object and enter the copy into the data structure in place of the original.
For example, if you are considering using a client-provided object reference as an element in an internal Set instance or as a key in an internal Map instance, you should be aware that the invariants of the set or map would be destroyed if the object were modified after it is inserted.
The same is true for defensive copying of internal components prior to returning them to clients.
Whether or not your class is immutable, you should think twice before returning a reference to an internal component that is mutable.
Therefore, you should always make a defensive copy of an internal array before returning it to a client.
Alternatively, you could return an immutable view of the array.
Arguably, the real lesson in all of this is that you should, where possible, use immutable objects as components of your objects, so that you that don’t have to worry about defensive copying (Item 15)
In the case of our Period example, it is worth pointing out that experienced programmers often use the primitive long returned by Date.getTime() as an internal time representation instead of using a Date reference.
Defensive copying can have a performance penalty associated with it and isn’t always justified.
If a class trusts its caller not to modify an internal component, perhaps because the class and its client are both part of the same package, then it may be appropriate to dispense with defensive copying.
Under these circumstances, the class documentation must make it clear that the caller must not modify the affected parameters or return values.
Even across package boundaries, it is not always appropriate to make a defensive copy of a mutable parameter before integrating it into an object.
There are some methods and constructors whose invocation indicates an explicit handoff of the object referenced by a parameter.
When invoking such a method, the client promises that it will no longer modify the object directly.
A method or constructor that expects to take ownership of a client-provided mutable object must make this clear in its documentation.
Classes containing methods or constructors whose invocation indicates a transfer of control cannot defend themselves against malicious clients.
Such classes are acceptable only when there is mutual trust between the class and its client or when damage to the class’s invariants would harm no one but the client.
Depending on the nature of the wrapper class, the client could destroy the class’s invariants by directly accessing an object after it has been wrapped, but this typically would harm only the client.
In summary, if a class has mutable components that it gets from or returns to its clients, the class must defensively copy these components.
If the cost of the copy would be prohibitive and the class trusts its clients not to modify the components inappropriately, then the defensive copy may be replaced by documentation outlining the client’s responsibility not to modify the affected components.
This item is a grab bag of API design hints that don’t quite deserve items of their own.
Taken together, they’ll help make your API easier to learn and use and less prone to errors.
Names should always obey the standard naming conventions (Item 56)
Your primary goal should be to choose names that are understandable and consistent with other names in the same package.
Your secondary goal should be to choose names consistent with the broader consensus, where it exists.
When in doubt, look to the Java library APIs for guidance.
Every method should “pull its weight.” Too many methods make a class difficult to learn, use, document, test, and maintain.
This is doubly true for interfaces, where too many methods complicate life for implementors as well as users.
For each action supported by your class or interface, provide a fully functional method.
Consider providing a “shorthand” only if it will be used often.
If many of your methods exceed this limit, your API won’t be usable without constant reference to its documentation.
Modern IDEs help, but you’re still much better off with short parameter lists.
Not only won’t users be able to remember the order of the parameters, but when they transpose parameters accidentally, their programs will still compile and run.
There are three techniques for shortening overly long parameter lists.
One is to break the method up into multiple methods, each of which requires only a subset of the parameters.
If done carelessly, this can lead to too many methods, but it can also help reduce the method count by increasing orthogonality.
It does not provide methods to find the first or last index of an element in a sublist, both of which would require three parameters.
Instead it provides the subList method, which takes two parameters and returns a view of a sublist.
This method can be combined with the indexOf or lastIndexOf methods, each of which has a single parameter, to yield the desired functionality.
Moreover, the subList method can be combined with any method that operates on a List instance to perform arbitrary computations on sublists.
A second technique for shortening long parameter lists is to create helper classes to hold groups of parameters.
Typically these helper classes are static member classes (Item 22)
This technique is recommended if a frequently occurring sequence of parameters is seen to represent some distinct entity.
For example, suppose you are writing a class representing a card game, and you find yourself constantly passing a sequence of two parameters representing a card’s rank and its suit.
Your API, as well as the internals of your class, would probably benefit if you added a helper class to represent a card and replaced every occurrence of the parameter sequence with a single parameter of the helper class.
A third technique that combines aspects of the first two is to adapt the Builder pattern (Item 2) from object construction to method invocation.
If you have a method with many parameters, especially if some of them are optional, it can be beneficial to define an object that represents all of the parameters, and to allow the client to make multiple “setter” calls on this object, each of which sets a single parameter or a small, related group.
Once the desired parameters have been set, the client invokes the object’s “execute” method, which does any final validity checks on the parameters and performs the actual computation.
If there is an appropriate interface to define a parameter, use it in favor of a class that implements the interface.
For example, there is no reason ever to write a method that takes HashMap on input—use Map instead.
This lets you pass in a Hashtable, a HashMap, a TreeMap, a submap of a TreeMap, or any Map implementation yet to be written.
By using a class instead of an interface, you restrict your client to a particular implementation and force an unnecessary and potentially expensive copy operation if the input data happens to exist in some other form.
It makes your code easier to read and to write, especially if you’re using an IDE that supports autocompletion.
Also, it makes it easy to add more options later.
For example, you might have a Thermometer type with a static factory that takes a value of this enum:
Also, you can refactor temperature-scale dependencies into methods on the enum constants (Item 30)
For example, each scale constant could have a method that took a double value and normalized it to Celsius.
Item 41: Use overloading judiciously The following program is a well-intentioned attempt to classify collections according to whether they are sets, lists, or some other kind of collection:
You might expect this program to print Set, followed by List and Unknown Collection, but it doesn’t.
Why does this happen? Because the classify method is overloaded, and the choice of which overloading to invoke is made at compile time.
For all three iterations of the loop, the compile-time type of the parameter is the same: Collection<?>
The runtime type is different in each iteration, but this does not affect the choice of overloading.
The behavior of this program is counterintuitive because selection among overloaded methods is static, while selection among overridden methods is dynamic.
As a reminder, a method is overridden when a subclass contains a method declaration with the same signature as a method declaration in an ancestor.
If an instance method is overridden in a subclass and this method is invoked on an instance of the subclass, the subclass’s overriding method executes, regardless of the compiletime type of the subclass instance.
The name method is declared in class Wine and overridden in classes SparklingWine and Champagne.
As you would expect, this program prints out wine, sparkling wine, and champagne, even though the compile-time type of the instance is Wine in each iteration of the loop.
The compile-time type of an object has no effect on which method is executed when an overridden method is invoked; the “most specific” overriding method always gets executed.
Compare this to overloading, where the runtime type of an object has no effect on which overloading is executed; the selection is made at compile time, based entirely on the compile-time types of the parameters.
Assuming a static method is required, the best way to fix the program is to replace all three overloadings of classify with a single method that does an explicit instanceof test:
Because overriding is the norm and overloading is the exception, overriding sets people’s expectations for the behavior of method invocation.
It is bad practice to write code whose behavior is likely to confuse programmers.
If the typical user of an API does not know which of several method overloadings will get invoked for a given set of parameters, use of the API is likely to result in errors.
These errors will likely manifest themselves as erratic behavior at runtime, and many programmers will be unable to diagnose them.
Exactly what constitutes a confusing use of overloading is open to some debate.
A safe, conservative policy is never to export two overloadings with the same number of parameters.
If you adhere to these restrictions, programmers will never be in doubt as to which overloading applies to any set of actual parameters.
The restrictions are not terribly onerous because you can always give methods different names instead of overloading them.
It has a variant of its write method for every primitive type and for several reference types.
An added benefit of this naming pattern, when compared to overloading, is that it is possible to provide read methods with corresponding names, for example, readBoolean(), readInt(), and readLong()
The ObjectInputStream class does, in fact, provide such read methods.
For constructors, you don’t have the option of using different names: multiple constructors for a class are always overloaded.
You do, in many cases, have the option of exporting static factories instead of constructors (Item 1)
Also, with constructors you don’t have to worry about interactions between overloading and overriding, because constructors can’t be overridden.
Exporting multiple overloadings with the same number of parameters is unlikely to confuse programmers if it is always clear which overloading will apply to any given set of actual parameters.
This is the case when at least one corresponding formal parameter in each pair of overloadings has a “radically different” type in the two overloadings.
Two types are radically different if it is clearly impossible to cast an instance of either type to the other.
Under these circumstances, which overloading applies to a given set of actual parameters is fully determined by the runtime types of the parameters and cannot be affected by their compile-time types, so the major source of confusion goes away.
For example, ArrayList has one constructor that takes an int and a second constructor that takes a Collection.
It is hard to imagine any confusion over which of these two constructors will be invoked under any circumstances.
Prior to release 1.5, all primitive types were radically different from all reference types, but this is no longer true in the presence of autoboxing, and it has caused real trouble.
Here’s what’s happening: The call to set.remove(i) selects the overloading remove(E), where E is the element type of the set (Integer), and autoboxes i from int to Integer.
This is the behavior you’d expect, so the program ends up removing the positive values from the set.
The call to list.remove(i), on the other hand, selects the overloading remove(int i), which removes the element at the specified position from a list.
To fix the problem, cast list.remove’s argument to Integer, forcing the correct overloading to be selected.
Alternatively, you could invoke Integer.valueOf on i and pass the result to list.remove.
The confusing behavior demonstrated by the previous example came about because the List<E> interface has two overloadings of the remove method: remove(E) and remove(int)
Prior to release 1.5 when it was “generified,” the List interface had a remove(Object) method in place of remove(E), and the corresponding parameter types, Object and int, were radically different.
But in the presence of generics and autoboxing, the two parameter types are no longer radically different.
In other words, adding generics and autoboxing to the language damaged the List interface.
Luckily, few if any other APIs in the Java libraries were similarly damaged, but this tale makes it clear that it is even more important to overload with care now that autoboxing and generics are part of the language.
Array types and classes other than Object are radically different.
Also, array types and interfaces other than Serializable and Cloneable are radically different.
Two distinct classes are said to be unrelated if neither class is a descendant of the other [JLS, 5.5]
It is impossible for any object to be an instance of two unrelated classes, so unrelated classes are radically different.
There are other pairs of types that can’t be converted in either direction [JLS, 5.1.12], but once you go beyond the simple cases described above, it becomes very difficult for most programmers to discern which, if any, overloading applies to a set of actual parameters.
The rules that determine which overloading is selected are extremely complex.
They take up thirty-three pages in the language specification [JLS, 15.12.1-3], and few programmers understand all of their subtleties.
There may be times when you feel the need to violate the guidelines in this item, especially when evolving existing classes.
In release 1.5, a new interface called CharSequence was added to provide a common interface for StringBuffer, StringBuilder, String, CharBuffer, and other similar types, all of which were retrofitted to implement this interface.
At the same time that CharSequence was added to the platform, String was outfitted with an overloading of the contentEquals method that takes a CharSequence.
While the resulting overloading clearly violates the guidelines in this item, it causes no harm as long as both overloaded methods always do exactly the same thing when they are invoked on the same object reference.
The programmer may not know which overloading will be invoked, but it is of no consequence so long as they behave identically.
The standard way to ensure this behavior is to have the more specific overloading forward to the more general:
While the Java platform libraries largely adhere to the spirit of the advice in this item, there are a number of classes that violate it.
For example, the String class exports two overloaded static factory methods, valueOf(char[]) and valueOf(Object), that do completely different things when passed the same object reference.
There is no real justification for this, and it should be regarded as an anomaly with the potential for real confusion.
To summarize, just because you can overload methods doesn’t mean you should.
You should generally refrain from overloading methods with multiple signatures that have the same number of parameters.
In some cases, especially where constructors are involved, it may be impossible to follow this advice.
In that case, you should at least avoid situations where the same set of parameters can be passed to different overloadings by the addition of casts.
If such a situation cannot be avoided, for example, because you are retrofitting an existing class to implement a new interface, you should ensure that all overloadings behave identically when passed the same parameters.
If you fail to do this, programmers will be hard pressed to make effective use of the overloaded method or constructor, and they won’t understand why it doesn’t work.
Varargs methods accept zero or more arguments of a specified type.
The varargs facility works by first creating an array whose size is the number of arguments passed at the call site, then putting the argument values into the array, and finally passing the array to the method.
For example, here is a varargs method that takes a sequence of int arguments and returns their sum.
Sometimes it’s appropriate to write a method that requires one or more arguments of some type, rather than zero or more.
For example, suppose you want to compute the minimum of a number of int arguments.
This function is not well defined if the client passes no arguments.
The most serious is that if the client invokes this method with no arguments, it fails at runtime rather than compile time.
Luckily there’s a much better way to achieve the desired effect.
Declare the method to take two parameters, one normal parameter of the specified type and one varargs parameter of this type.
This solution corrects all the deficiencies of the previous one:
As you can see from this example, varargs are effective in circumstances where you really do want a method with a variable number of arguments.
You can retrofit an existing method that takes an array as its final parameter to take a varargs parameter instead with no effect on existing clients.
But just because you can doesn’t mean that you should! Consider the case of Arrays.asList.
This method was never designed to gather multiple arguments into a list, but it seemed like a good idea to retrofit it to do so when varargs were added to the platform.
As a result, it became possible to do things like this:
This usage works, but it was a big mistake to enable it.
Prior to release 1.5, this was a common idiom to print the contents of an array:
Because of the unfortunate decision to retrofit Arrays.asList as a varargs method in release 1.5, this program now compiles without error or warning.
The Arrays.asList method, now “enhanced” to use varargs, gathers up the object reference to the int array digits into a one-element array of arrays and dutifully wraps it into a List<int[]> instance.
Printing this list causes toString to be invoked on the list, which in turn causes toString to be invoked on its sole element, the int array, with the unfortunate result described above.
On the bright side, the Arrays.asList idiom for translating arrays to strings is now obsolete, and the current idiom is far more robust.
If you use Arrays.toString in place of Arrays.asList, the program produces the intended result:
Instead of retrofitting Arrays.asList, it would have been better to add a new method to Collections specifically for the purpose of gathering its arguments into a list:
Such a method would have provided the capability to gather without compromising the type-checking of the existing Arrays.asList method.
Don’t retrofit every method that has a final array parameter; use varargs only when a call really operates on a variable-length sequence of values.
Methods with either of these signatures will accept any parameter list.
Any compile-time type-checking that you had prior to the retrofit will be lost, as demonstrated by what happened to Arrays.asList.
Every invocation of a varargs method causes an array allocation and initialization.
If you have determined empirically that you can’t afford this cost but you need the flexibility of varargs, there is a pattern that lets you have your cake and eat it too.
Suppose you’ve determined that 95 percent of the calls to a method have three or fewer parameters.
Then declare five overloadings of the method, one each with zero through three ordinary parameters, and a single varargs method for use when the number of arguments exceeds three:
Now you know that you’ll pay the cost of the array creation only in the 5 percent of all invocations where the number of parameters exceeds three.
Like most performance optimizations, this technique usually isn’t appropriate, but when it is, it’s a lifesaver.
The EnumSet class uses this technique for its static factories to reduce the cost of creating enum sets to a bare minimum.
In summary, varargs methods are a convenient way to define methods that require a variable number of arguments, but they should not be overused.
It is not uncommon to see methods that look something like this:
There is no reason to make a special case for the situation where no cheeses are available for purchase.
Doing so requires extra code in the client to handle the null return value, for example:
This sort of circumlocution is required in nearly every use of a method that returns null in place of an empty (zero-length) array or collection.
It is errorprone, because the programmer writing the client might forget to write the specialcase code to handle a null return.
Such an error may go unnoticed for years, as such methods usually return one or more objects.
Less significant, but still worthy of note, returning null in place of an empty array also complicates the method that returns the array or collection.
It is sometimes argued that a null return value is preferable to an empty array because it avoids the expense of allocating the array.
First, it is inadvisable to worry about performance at this level unless profiling has shown that the method in question is a real contributor to performance problems (Item 55)
Second, it is possible to return the same zero-length array.
In fact, this is exactly what happens when you use the standard idiom for dumping items from a collection into a typed array:
The right way to return an array from a collection private final List<Cheese> cheesesInStock = ...;
In this idiom, an empty-array constant is passed to the toArray method to indicate the desired return type.
In similar fashion, a collection-valued method can be made to return the same immutable empty collection every time it needs to return an empty collection.
In summary, there is no reason ever to return null from an array- or collection-valued method instead of returning an empty array or collection.
The null-return idiom is likely a holdover from the C programming language, in which array lengths are returned separately from actual arrays.
In C, there is no advantage to allocating an array if zero is returned as the length.
Item 44: Write doc comments for all exposed API elements.
If an API is to be usable, it must be documented.
Traditionally API documentation was generated manually, and keeping it in sync with code was a chore.
The Java programming environment eases this task with the Javadoc utility.
Javadoc generates API documentation automatically from source code with specially formatted documentation comments, more commonly known as doc comments.
To document your API properly, you must precede every exported class, interface, constructor, method, and field declaration with a doc comment.
If a class is serializable, you should also document its serialized form (Item 75)
In the absence of a doc comment, the best that Javadoc can do is to reproduce the declaration as the sole documentation for the affected API element.
It is frustrating and error-prone to use an API with missing documentation comments.
To write maintainable code, you should also write doc comments for most unexported classes, interfaces, constructors, methods, and fields.
The doc comment for a method should describe succinctly the contract between the method and its client.
With the exception of methods in classes designed for inheritance (Item 17), the contract should say what the method does rather than how it does its job.
The doc comment should enumerate all of the method’s preconditions, which are the things that have to be true in order for a client to invoke it, and its postconditions, which are the things that will be true after the invocation has completed successfully.
Typically, preconditions are described implicitly by the @throws tags for unchecked exceptions; each unchecked exception corresponds to a precondition violation.
Also, preconditions can be specified along with the affected parameters in their @param tags.
In addition to preconditions and postconditions, methods should document any side effects.
A side effect is an observable change in the state of the system that is not obviously required in order to achieve the postcondition.
For example, if a method starts a background thread, the documentation should make note of it.
The text following an @throws tag should consist of the word “if,” followed by a clause describing the conditions under which the exception is thrown.
Occasionally, arithmetic expressions are used in place of noun phrases.
All of these conventions are illustrated by the following short doc comment:
The Javadoc utility translates doc comments into HTML, and arbitrary HTML elements in doc comments end up in the resulting HTML document.
Occasionally, programmers go so far as to embed HTML tables in their doc comments, although this is rare.
Finally, notice the use of the word “this” in the doc comment.
By convention, the word “this” always refers to the object on which the method is invoked when it is used in the doc comment for an instance method.
The first “sentence” of each doc comment (as defined below) becomes the summary description of the element to which the comment pertains.
For example, the summary description in the doc comment on page 204 is “Returns the element at the specified position in this list.” The summary description must stand on its own to describe the functionality of the element it summarizes.
To avoid confusion, no two members or constructors in a class or interface should have the same summary description.
Pay particular attention to overloadings, for which it is often natural to use the same first sentence in a prose description (but unacceptable in doc comments)
It is somewhat misleading to say that the summary description is the first sentence in a doc comment.
Convention dictates that it should seldom be a complete sentence.
For methods and constructors, the summary description should be a full verb phrase (including any object) describing the action performed by the method.
For classes, interfaces, and fields, the summary description should be a noun phrase describing the thing represented by an instance of the class or interface or by the field itself.
TimerTask—A task that can be scheduled for one-time or repeated execution by a Timer.
Math.PI—The double value that is closer than any other to pi, the ratio of the circumference of a circle to its diameter.
Three features added to the language in release 1.5 require special care in doc comments: generics, enums, and annotations.
When documenting a generic type or method, be sure to document all type parameters:
When documenting an enum type, be sure to document the constants as well as the type and any public methods.
Note that you can put an entire doc comment on one line if it’s short:
When documenting an annotation type, be sure to document any members as well as the type itself.
Document members with noun phrases, as if they were fields.
For the summary description of the type, use a verb phrase that says what it means when a program element has an annotation of this type:
Two aspects of a class’s exported API that are often neglected are threadsafety and serializability.
A simple way to reduce the likelihood of errors in documentation comments is to run the HTML files generated by Javadoc through an HTML validity checker.
This will detect many incorrect uses of HTML tags, as well as HTML metacharacters that should have been escaped.
Several HTML validity checkers are available for download and you can validate HTML online [W3C-validator]
While it is necessary to provide documentation comments for all exported API elements, it is not always sufficient.
For complex APIs consisting of multiple interrelated classes, it is often necessary to supplement the documentation comments with an external document describing the overall architecture of the API.
If such a document exists, the relevant class or package documentation comments should include a link to it.
The definitive guide to writing doc comments is Sun’s How to Write Doc Comments [Javadoc-guide]
There are IDE plug-ins that check for adherence to many of these rules [Burn01]
To summarize, documentation comments are the best, most effective way to document your API.
Their use should be considered mandatory for all exported API elements.
Remember that arbitrary HTML is permissible within documentation comments and that HTML metacharacters must be escaped.
It discusses the treatment of local variables, control structures, the use of libraries, the use of various data types, and the use of two extralinguistic facilities: reflection and native methods.
This item is similar in nature to Item 13, “Minimize the accessibility of classes and members.” By minimizing the scope of local variables, you increase the readability and maintainability of your code and reduce the likelihood of error.
Older programming languages, such as C, mandated that local variables must be declared at the head of a block, and some programmers continue to do this out of habit.
As a gentle reminder, Java lets you declare variables anywhere a statement is legal.
The most powerful technique for minimizing the scope of a local variable is to declare it where it is first used.
If a variable is declared before it is used, it’s just clutter—one more thing to distract the reader who is trying to figure out what the program does.
By the time the variable is used, the reader might not remember the variable’s type or initial value.
Declaring a local variable prematurely can cause its scope not only to extend too early, but also to end too late.
The scope of a local variable extends from the point where it is declared to the end of the enclosing block.
If a variable is declared outside of the block in which it is used, it remains visible after the program exits that block.
If a variable is used accidentally before or after its region of intended use, the consequences can be disastrous.
If you don’t yet have enough information to initialize a variable sensibly, you should.
If a variable is initialized by a method that throws a checked exception, it must be initialized inside a try block.
Loops present a special opportunity to minimize the scope of variables.
The for loop, in both its traditional and for-each forms, allows you to declare loop variables, limiting their scope to the exact region where they’re needed.
This region consists of the body of the loop as well as the initialization, test, and update preceding the body.
Therefore, prefer for loops to while loops, assuming the contents of the loop variable aren’t needed after the loop terminates.
For example, here is the preferred idiom for iterating over a collection (Item 46):
Before release 1.5, this was the preferred idiom (and it still has valid uses):
To see why these for loops are preferable to a while loop, consider the following code fragment, which contains two while loops and one bug:
The second loop contains a cut-and-paste error: it initializes a new loop variable, i2, but uses the old one, i, which is, unfortunately, still in scope.
The resulting code compiles without error and runs without throwing an exception, but it does the wrong thing.
Because the program errs silently, the error can remain undetected for a long time.
If a similar cut-and-paste error were made in conjunction with either of the for loops (for-each or traditional), the resulting code wouldn’t even compile.
The element (or iterator) variable from the first loop would not be in scope at the point where the second loop occurred.
Moreover, if you use a for loop, it’s much less likely that you’ll make the cutand-paste error, as there’s no incentive to use different variable names in the two loops.
The loops are completely independent, so there’s no harm in reusing the element (or iterator) variable name.
The for loop has one more advantage over the while loop: it is shorter, which enhances readability.
Here is another loop idiom that minimizes the scope of local variables:
The important thing to notice about this idiom is that it has two loop variables, i and n, both of which have exactly the right scope.
The second variable, n, is used to store the limit of the first, thus avoiding the cost of a redundant computation on every iteration.
As a rule, you should use this idiom if the loop test involves a method invocation that is guaranteed to return the same result on each iteration.
A final technique to minimize the scope of local variables is to keep methods small and focused.
If you combine two activities in the same method, local variables relevant to one activity may be in the scope of the code performing the other activity.
To prevent this from happening, simply separate the method into two: one for each activity.
Prior to release 1.5, this was the preferred idiom for iterating over a collection:
This was the preferred idiom for iterating over an array:
These idioms are better than while loops (Item 45), but they aren’t perfect.
The iterator and the index variables are both just clutter.
The iterator and the index variable occur three times in each loop, which gives you two chances to get them wrong.
If you do, there is no guarantee that the compiler will catch the problem.
The for-each loop, introduced in release 1.5, gets rid of the clutter and the opportunity for error by hiding the iterator or index variable completely.
When you see the colon (:), read it as “in.” Thus, the loop above reads as “for each element e in elements.” Note that there is no performance penalty for using the for-each loop, even for arrays.
In fact, it may offer a slight performance advantage over an ordinary for loop in some circumstances, as it computes the limit of the array index only once.
While you can do this by hand (Item 45), programmers don’t always do so.
The advantages of the for-each loop over the traditional for loop are even greater when it comes to nested iteration over multiple collections.
Here is a common mistake that people make when they try to do nested iteration over two collections:
Many expert programmers have made this mistake at one time or another.
The problem is that the next method is called too many times on the iterator for the outer collection (suits)
It should be called from the outer loop, so that it is called once per suit, but instead it is called from the inner loop, so it is called once per card.
If you’re really unlucky and the size of the outer collection is a multiple of the size of the inner collection—perhaps because they’re the same collection—the loop will terminate normally, but it won’t do what you want.
For example, consider this ill-conceived attempt to print all of the possible rolls of a pair of dice:
This program doesn’t throw an exception but it prints only the six “doubles” (from “ONE ONE” to “SIX SIX”), instead of the expected thirty-six combinations.
To fix the bugs in these examples, you must add a variable in the scope of the outer loop to hold the outer element:
If instead you use a nested for-each loop, the problem simply disappears.
The resulting code is as succinct as you could wish for:
Preferred idiom for nested iteration on collections and arrays for (Suit suit : suits)
Not only does the for-each loop let you iterate over collections and arrays, it lets you iterate over any object that implements the Iterable interface.
This simple interface, which consists of a single method, was added to the platform at the same time as the for-each loop.
If you are writing a type that represents a group of elements, have it implement Iterable even if you choose not to have it implement Collection.
This will allow your users to iterate over your type using the for-each loop, and they will be forever grateful.
In summary, the for-each loop provides compelling advantages over the traditional for loop in clarity and bug prevention, with no performance penalty.
Unfortunately, there are three common situations where you can’t use a for-each loop:
Filtering—If you need to traverse a collection and remove selected elements, then you need to use an explicit iterator so that you can call its remove method.
Transforming—If you need to traverse a list or array and replace some or all of the values of its elements, then you need the list iterator or array index in order to set the value of an element.
Parallel iteration—If you need to traverse multiple collections in parallel, then you need explicit control over the iterator or index variable, so that all iterators or index variables can be advanced in lockstep (as demonstrated unintentionally in the buggy card and dice examples above)
If you find yourself in any of these situations, use an ordinary for loop, be wary of the traps mentioned in this item, and know that you’re doing the best you can.
Suppose you want to generate random integers between zero and some upper bound.
Faced with this common task, many programmers would write a little method that looks something like this:
This method may look good, but it has three flaws.
The first is that if n is a small power of two, the sequence of random numbers it generates will repeat itself after a fairly short period.
The second flaw is that if n is not a power of two, some numbers will, on average, be returned more frequently than others.
If n is large, this effect can be quite pronounced.
This is graphically demonstrated by the following program, which generates a million random numbers in a carefully chosen range and then prints out how many of the numbers fell in the lower half of the range:
If the random method worked properly, the program would print a number close to half a million, but if you run it, you’ll find that it prints a number close to 666,666
Two-thirds of the numbers generated by the random method fall in the lower half of its range!
The third flaw in the random method is that it can, on rare occasions, fail catastrophically, returning a number outside the specified range.
This is so because the method attempts to map the value returned by rnd.nextInt() to a non-negative int by calling Math.abs.
This will almost certainly cause your program to fail, and the failure may be difficult to reproduce.
To write a version of the random method that corrects these three flaws, you’d have to know a fair amount about pseudorandom number generators, number theory, and two’s complement arithmetic.
Luckily, you don’t have to do this—it’s been done for you.
You don’t have to concern yourself with the details of how nextInt(int) does its job (although you can study the documentation or the source code if you’re curious)
A senior engineer with a background in algorithms spent a good deal of time designing, implementing, and testing this method and then showed it to several experts in the field to make sure it was right.
Then the library was beta tested, released, and used extensively by millions of programmers for the better part of a decade.
No flaws have yet been found in the method, but if a flaw were to be discovered, it would be fixed in the next release.
By using a standard library, you take advantage of the knowledge of the experts who wrote it and the experience of those who used it before you.
A second advantage of using the libraries is that you don’t have to waste your time writing ad hoc solutions to problems that are only marginally related to your work.
If you are like most programmers, you’d rather spend your time working on your application than on the underlying plumbing.
A third advantage of using standard libraries is that their performance tends to improve over time, with no effort on your part.
Because many people use them and because they’re used in industry-standard benchmarks, the organizations that supply these libraries have a strong incentive to make them run faster.
Many of the Java platform libraries have been rewritten over the years, sometimes repeatedly, resulting in dramatic performance improvements.
If a library is missing something, the developer community will make it known, and the missing functionality may get added to a subsequent release.
The Java platform has always been developed with substantial input from the community.
A final advantage of using the standard libraries is that you place your code in the mainstream.
Such code is more easily readable, maintainable, and reusable by the multitude of developers.
Given all these advantages, it seems only logical to use library facilities in preference to ad hoc implementations, yet a significant fraction of programmers don’t.
Numerous features are added to the libraries in every major release, and it pays to keep.
Each time there is a major release of the Java platform, Sun publishes a Web page describing its new features.
The libraries are too big to study all the documentation [JavaSE6], but every programmer should be familiar with the contents of java.lang, java.util, and, to a lesser extent, java.io.
Knowledge of other libraries can be acquired on an as-needed basis.
It is beyond the scope of this item to summarize the facilities in the libraries, but two bear special mention.
In the 1.2 release, a Collections Framework was added to the java.util package.
The Collections Framework is a unified architecture for representing and manipulating collections, allowing them to be manipulated independently of the details of their representation.
It allows for interoperability among unrelated APIs, reduces effort in designing and learning new APIs, and fosters software reuse.
If you want to know more, see the documentation on Sun’s Web site [Collections], or read the tutorial [Bloch06]
This package contains both high-level concurrency utilities to simplify the task of multithreaded programming and low-level concurrency primitives to allow experts to write their own higher-level concurrent abstractions.
Occasionally, a library facility can fail to meet your needs.
The more specialized your needs, the more likely this is to happen.
While your first impulse should be to use the libraries, if you’ve looked at what they have to offer in some area and it doesn’t meet your needs, then use an alternate implementation.
There will always be holes in the functionality provided by any finite set of libraries.
If the functionality that you need is missing, you may have no choice but to implement it yourself.
If you need to do something that seems like it should be reasonably common, there may already be a class in the libraries that does what you want.
If there is, use it; if you don’t know, check.
Generally speaking, library code is likely to be better than code that you’d write yourself and is likely to improve over time.
This is no reflection on your abilities as a programmer.
Economies of scale dictate that library code receives far more attention than most developers could afford to devote to the same functionality.
Item 48: Avoid float and double if exact answers are required.
The float and double types are designed primarily for scientific and engineering calculations.
They perform binary floating-point arithmetic, which was carefully designed to furnish accurate approximations quickly over a broad range of magnitudes.
They do not, however, provide exact results and should not be used where exact results are required.
The float and double types are particularly illsuited for monetary calculations because it is impossible to represent 0.1 (or any other negative power of ten) as a float or double exactly.
Suppose you have a dollar in your pocket, and you buy nine washers priced at ten cents each.
You might think that the problem could be solved merely by rounding results.
This is the wrong answer! The right way to solve this problem is to use BigDecimal, int, or long for monetary calculations.
Here’s a straightforward transformation of the previous program to use the BigDecimal type in place of double:
If you run the revised program, you’ll find that you can afford four pieces of candy, with $0.00 left over.
There are, however, two disadvantages to using BigDecimal: it’s less convenient than using a primitive arithmetic type, and it’s slower.
The latter disadvantage is irrelevant if you’re solving a single short problem, but the former may annoy you.
An alternative to using BigDecimal is to use int or long, depending on the amounts involved, and to keep track of the decimal point yourself.
In this example, the obvious approach is to do all computation in cents instead of dollars.
Here’s a straightforward transformation of the program just shown that takes this approach:
In summary, don’t use float or double for any calculations that require an exact answer.
Use BigDecimal if you want the system to keep track of the decimal point and you don’t mind the inconvenience and cost of not using a primitive type.
Using BigDecimal has the added advantage that it gives you full control over rounding, letting you select from eight rounding modes whenever an operation that entails rounding is performed.
This comes in handy if you’re performing business calculations with legally mandated rounding behavior.
If performance is of the essence, you don’t mind keeping track of the decimal point yourself, and the quantities aren’t too big, use int or long.
If the quantities don’t exceed nine decimal digits, you can use int; if they don’t exceed eighteen digits, you can use long.
If the quantities might exceed eighteen digits, you must use BigDecimal.
Java has a two-part type system, consisting of primitives, such as int, double, and boolean, and reference types, such as String and List.
Every primitive type has a corresponding reference type, called a boxed primitive.
The boxed primitives corresponding to int, double, and boolean are Integer, Double, and Boolean.
In release 1.5, autoboxing and auto-unboxing were added to the language.
As mentioned in Item 5, these features blur but do not erase the distinction between the primitive and boxed primitive types.
There are real differences between the two, and it’s important that you remain aware of which you are using, and that you choose carefully between them.
There are three major differences between primitives and boxed primitives.
First, primitives have only their values, whereas boxed primitives have identities distinct from their values.
In other words, two boxed primitive instances can have the same value and different identities.
Second, primitive types have only fully functional values, whereas each boxed primitive type has one nonfunctional value, which is null, in addition to all of the functional values of its corresponding primitive type.
Last, primitives are generally more time- and space-efficient than boxed primitives.
All three of these differences can get you into real trouble if you aren’t careful.
Consider the following comparator, which is designed to represent ascending numerical order on Integer values.
Recall that a comparator’s compare method returns a number that is negative, zero, or positive, depending on whether its first argument is less than, equal to, or greater than its second.
You would not need to write this comparator in practice, as it implements the natural ordering on Integer, which you get without a comparator, but it makes for an interesting example:
This comparator looks good on the face of it, and it will pass many tests.
For example, it can be used with Collections.sort to correctly sort a million-element list, whether or not the list contains duplicate elements.
So what’s the problem? The first test in naturalOrder works fine.
Evaluating the expression first < second causes the Integer instances referred to by first and second to be auto-unboxed; that is, it extracts their primitive values.
The evaluation proceeds to check if the first of the resulting int values is less than the second.
Then the next test evaluates the expression first == second, which performs an identity comparison on the two object references.
If first and second refer to distinct Integer instances that represent the same int value, this comparison will return false, and the comparator will incorrectly return 1, indicating that the first Integer value is greater than the second.
Applying the == operator to boxed primitives is almost always wrong.
The clearest way to fix the problem is to add two local variables, to store the primitive int values corresponding to first and second, and to perform all of the comparisons on these variables.
No, it doesn’t print Unbelievable—but what it does is almost as strange.
The problem is that i is an Integer, not an int, and like all object reference fields, its initial value is null.
When the program evaluates the expression (i == 42), it is comparing an Integer to an int.
Fixing the program is as simple as declaring i to be an int instead of an Integer.
This program is much slower than it should be because it accidentally declares a local variable (sum) to be of the boxed primitive type Long instead of the primitive type long.
The program compiles without error or warning, and the variable is repeatedly boxed and unboxed, causing the observed performance degradation.
In all three of the programs discussed in this item, the problem was the same: the programmer ignored the distinction between primitives and boxed primitives and suffered the consequences.
In the first two programs, the consequences were outright failure; in the third, severe performance problems.
So when should you use boxed primitives? They have several legitimate uses.
The first is as elements, keys, and values in collections.
You can’t put primitives in collections, so you’re forced to use boxed primitives.
This is a special case of a more general one.
You must use boxed primitives as type parameters in parameterized types (Chapter 5), because the language does not permit you to use primitives.
Finally, you must use boxed primitives when making reflective method invocations (Item 53)
In summary, use primitives in preference to boxed primitives whenever you have the choice.
If you must use boxed primitives, be careful! Autoboxing reduces the verbosity, but not the danger, of using boxed primitives.
When your program compares two boxed primitives with the == operator, it does an identity comparison, which is almost certainly not what you want.
Finally, when your program boxes primitive values, it can result in costly and unnecessary object creations.
Item 50: Avoid strings where other types are more appropriate.
Strings are designed to represent text, and they do a fine job of it.
Because strings are so common and so well supported by the language, there is a natural tendency to use strings for purposes other than those for which they were designed.
This item discusses a few things that you shouldn’t do with strings.
When a piece of data comes into a program from a file, from the network, or from keyboard input, it is often in string form.
There is a natural tendency to leave it that way, but this tendency is justified only if the data really is textual in nature.
If it’s numeric, it should be translated into the appropriate numeric type, such as int, float, or BigInteger.
If it’s the answer to a yes-or-no question, it should be translated into a boolean.
More generally, if there’s an appropriate value type, whether primitive or object reference, you should use it; if there isn’t, you should write one.
While this advice may seem obvious, it is often violated.
As discussed in Item 30, enums make far better enumerated type constants than strings.
If an entity has multiple components, it is usually a bad idea to represent it as a single string.
For example, here’s a line of code that comes from a real system—identifier names have been changed to protect the guilty:
If the character used to separate fields occurs in one of the fields, chaos may result.
To access individual fields, you have to parse the string, which is slow, tedious, and error-prone.
You can’t provide equals, toString, or compareTo methods but are forced to accept the behavior that String provides.
A better approach is simply to write a class to represent the aggregate, often a private static member class (Item 22)
Occasionally, strings are used to grant access to some functionality.
For example, consider the design of a thread-local variable facility.
Such a facility provides variables for which each thread has its own value.
The Java libraries have had a thread-local variable facility since release 1.2, but prior to that, programmers had to roll their own.
The problem with this approach is that the string keys represent a shared global namespace for thread-local variables.
In order for the approach to work, the client-provided string keys have to be unique: if two clients independently decide to use the same name for their thread-local variable, they unintentionally share a single variable, which will generally cause both clients to fail.
A malicious client could intentionally use the same string key as another client to gain illicit access to the other client’s data.
This API can be fixed by replacing the string with an unforgeable key (sometimes called a capability):
While this solves both of the problems with the string-based API, you can do much better.
They can instead become instance methods on the key, at which point the key is no longer a key for a thread-local variable: it is a thread-local variable.
This API isn’t typesafe, because you have to cast the value from Object to its actual type when you retrieve it from a thread-local variable.
It is impossible to make the original String-based API typesafe and difficult to make the Key-based API typesafe, but it is a simple matter to make this API typesafe by generifying the ThreadLocal class (Item 26):
In addition to solving the problems with the string-based API, it is faster and more elegant than either of the key-based APIs.
To summarize, avoid the natural tendency to represent objects as strings when better data types exist or can be written.
Used inappropriately, strings are more cumbersome, less flexible, slower, and more error-prone than other types.
Types for which strings are commonly misused include primitive types, enums, and aggregate types.
The string concatenation operator (+) is a convenient way to combine a few strings into one.
It is fine for generating a single line of output or for constructing the string representation of a small, fixed-size object, but it does not scale.
Using the string concatenation operator repeatedly to concatenate n strings requires time quadratic in n.
It is an unfortunate consequence of the fact that strings are immutable (Item 15)
When two strings are concatenated, the contents of both are copied.
For example, consider the following method that constructs a string representation of a billing statement by repeatedly concatenating a line for each item:
This method performs abysmally if the number of items is large.
To achieve acceptable performance, use a StringBuilder in place of a String to store the statement under construction.
The StringBuilder class, added in release 1.5, is an unsynchronized replacement for StringBuffer, which is now obsolete.
Because the first method is quadratic in the number of items and the second is linear, the performance difference is even more dramatic for larger numbers of items.
Note that the second method preallocates a StringBuilder large enough to hold the result.
Even if it is detuned to use a default-sized StringBuilder, it is still fifty times faster.
The moral is simple: don’t use the string concatenation operator to combine more than a few strings unless performance is irrelevant.
Alternatively, use a character array, or process the strings one at a time instead of combining them.
More generally, you should favor the use of interfaces rather than classes to refer to objects.
If appropriate interface types exist, then parameters, return values, variables, and fields should all be declared using interface types.
The only time you really need to refer to an object’s class is when you’re creating it with a constructor.
To make this concrete, consider the case of Vector, which is an implementation of the List interface.
If you get into the habit of using interfaces as types, your program will be much more flexible.
If you decide that you want to switch implementations, all you have to do is change the class name in the constructor (or use a different static factory)
For example, the first declaration could be changed to read.
The surrounding code was unaware of the old implementation type, so it would be oblivious to the change.
There is one caveat: if the original implementation offered some special functionality not required by the general contract of the interface and the code depended on that functionality, then it is critical that the new implementation provide the same functionality.
For example, if the code surrounding the first declaration depended on Vector’s synchronization policy, then it would be incorrect to substitute ArrayList for Vector in the declaration.
If you depend on any special properties of an implementation, document these requirements where you declare the variable.
So why would you want to change implementations? Because the new implementation offers better performance or because it offers desirable extra functionality.
Internally, this class uses a package-private map field in Thread to associate per-thread values with.
In the 1.3 release, this field was initialized to a HashMap instance.
In the 1.4 release, a new, special-purpose Map implementation, called IdentityHashMap, was added to the platform.
By changing a single line of code to initialize the field to an IdentityHashMap instead of a HashMap, the ThreadLocal facility was made faster.
The ThreadLocal implementation has since evolved to use a highly optimized store that does not implement the Map interface, but this does nothing to diminish the point.
Had the field been declared as a HashMap instead of a Map, there is no guarantee that a single-line change would have been sufficient.
If the client code had used HashMap operations that were not present on the Map interface or passed the map to a method that demanded a HashMap, the code would no longer compile if the field were changed to an IdentityHashMap.
Declaring the field with the interface type “keeps you honest.”
It is entirely appropriate to refer to an object by a class rather than an interface if no appropriate interface exists.
For example, consider value classes, such as String and BigInteger.
Value classes are rarely written with multiple implementations in mind.
It is perfectly appropriate to use such a value class as a parameter, variable, field, or return type.
More generally, if a concrete class has no associated interface, then you have no choice but to refer to it by its class whether or not it represents a value.
A second case in which there is no appropriate interface type is that of objects belonging to a framework whose fundamental types are classes rather than interfaces.
If an object belongs to such a class-based framework, it is preferable to refer to it by the relevant base class, which is typically abstract, rather than by its implementation class.
A final case in which there is no appropriate interface type is that of classes that implement an interface but provide extra methods not found in the interfacefor example, LinkedHashMap.
Such a class should be used to refer to its instances only if the program relies on the extra methods.
It should rarely be used as a parameter type (Item 40)
These cases are not meant to be exhaustive but merely to convey the flavor of situations where it is appropriate to refer to an object by its class.
In practice, it should be apparent whether a given object has an appropriate interface.
If it does, your program will be more flexible if you use the interface to refer to the object; if not, just use the least specific class in the class hierarchy that provides the required functionality.
Given a Class object, you can obtain Constructor, Method, and Field instances representing the constructors, methods, and fields of the class represented by the Class instance.
These objects provide programmatic access to the class’s member names, field types, method signatures, and so on.
Moreover, Constructor, Method, and Field instances let you manipulate their underlying counterparts reflectively: you can construct instances, invoke methods, and access fields of the underlying class by invoking methods on the Constructor, Method, and Field instances.
For example, Method.invoke lets you invoke any method on any object of any class (subject to the usual security constraints)
Reflection allows one class to use another, even if the latter class did not exist when the former was compiled.
You lose all the benefits of compile-time type checking, including exception checking.
If a program attempts to invoke a nonexistent or inaccessible method reflectively, it will fail at runtime unless you’ve taken special precautions.
The code required to perform reflective access is clumsy and verbose.
Reflective method invocation is much slower than normal method invocation.
Exactly how much slower is hard to say, because there are so many factors at work.
On my machine, the speed difference can be as small as a factor of two or as large as a factor of fifty.
The core reflection facility was originally designed for component-based application builder tools.
Such tools generally load classes on demand and use reflection to find out what methods and constructors they support.
The tools let their users interactively construct applications that access these classes, but the generated applications access the classes normally, not reflectively.
As a rule, objects should not be accessed reflectively in normal applications at runtime.
Examples include class browsers, object inspectors, code analysis tools, and interpretive embedded systems.
Reflection is also appropriate for use in remote procedure call (RPC) systems to eliminate the need for stub compilers.
If you have any doubts as to whether your application falls into one of these categories, it probably doesn’t.
You can obtain many of the benefits of reflection while incurring few of its costs by using it only in a very limited form.
For many programs that must use a class that is unavailable at compile time, there exists at compile time an appropriate interface or superclass by which to refer to the class (Item 52)
If this is the case, you can create instances reflectively and access them normally via their interface or superclass.
For example, here’s a program that creates a Set<String> instance whose class is specified by the first command line argument.
The program inserts the remaining command line arguments into the set and prints it.
Regardless of the first argument, the program prints the remaining arguments with duplicates eliminated.
The order in which these arguments are printed, however, depends on the class specified in the first argument.
While this program is just a toy, the technique it demonstrates is very powerful.
The toy program could easily be turned into a generic set tester that validates the specified Set implementation by aggressively manipulating one or more instances and checking that they obey the Set contract.
Similarly, it could be turned into a generic set performance analysis tool.
In fact, the technique is sufficiently powerful to implement a full-blown service provider framework (Item 1)
Most of the time, this technique is all that you need in the way of reflection.
First, the example can generate three runtime errors, all of which would have been compile-time errors if reflective instantiation were not used.
Second, it takes twenty lines of tedious code to generate an instance of the class from its name, whereas a constructor invocation would fit neatly on a single line.
These disadvantages are, however, restricted to the part of the program that instantiates the object.
Once instantiated, it is indistinguishable from any other Set instance.
In a real program, the great bulk of the code is thus unaffected by this limited use of reflection.
If you try compiling the program, you’ll get the following error message:
This warning concerns the program’s use of generic types, but it does not indicate a real problem.
Another tangential issue that deserves note is this program’s use of System.exit.
It is rarely appropriate to call this method, which terminates the entire VM.
It is, however, appropriate for abnormal termination of a command line utility.
A legitimate, if rare, use of reflection is to manage a class’s dependencies on other classes, methods, or fields that may be absent at runtime.
This can be useful if you are writing a package that must run against multiple versions of some other package.
The technique is to compile your package against the minimal environment required to support it, typically the oldest version, and to access any newer classes or methods reflectively.
To make this work, you have to take appropriate action if a newer class or method that you are attempting to access does not exist at runtime.
Appropriate action might consist of using some alternate means to accomplish the same goal or operating with reduced functionality.
In summary, reflection is a powerful facility that is required for certain sophisticated system programming tasks, but it has many disadvantages.
If you are writing a program that has to work with classes unknown at compile time, you should, if at all possible, use reflection only to instantiate objects, and access the objects using some interface or superclass that is known at compile time.
Item 54: Use native methods judiciously The Java Native Interface (JNI) allows Java applications to call native methods, which are special methods written in native programming languages such as C or C++
Native methods can perform arbitrary computation in native languages before returning to the Java programming language.
They provided access to platform-specific facilities such as registries and file locks.
They provided access to libraries of legacy code, which could in turn provide access to legacy data.
It is legitimate to use native methods to access platform-specific facilities, but as the Java platform matures, it provides more and more features previously found only in host platforms.
It is also legitimate to use native methods to access legacy code.
It is rarely advisable to use native methods for improved performance.
In early releases (prior to 1.3), it was often necessary, but JVM implementations have gotten much faster.
For most tasks, it is now possible to obtain comparable performance without resorting to native methods.
For example, when java.math was added to the platform in release 1.1, BigInteger was implemented atop a fast multiprecision arithmetic library written in C.
In release 1.3, BigInteger was rewritten entirely in Java and carefully tuned.
Even then, the new version was faster than the original, and VMs have become much faster in the intervening years.
Because native languages are not safe (Item 39), applications using native methods are no longer immune to memory corruption errors.
Because native languages are platform dependent, applications using native methods are far less portable.
Applications using native code are far more difficult to debug.
There is a fixed cost associated with going into and out of native code, so native methods can decrease performance if they do only a small amount of work.
Finally, native methods require “glue code” that is difficult to read and tedious to write.
If you must use native methods to access low-level resources or legacy libraries, use as little native code as possible and test it thoroughly.
A single bug in the native code can corrupt your entire application.
Item 55: Optimize judiciously There are three aphorisms concerning optimization that everyone should know.
They are perhaps beginning to suffer from overexposure, but in case you aren’t yet familiar with them, here they are:
More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity.
Knuth [Knuth74] We follow two rules in the matter of optimization:
Don’t do it yet—that is, not until you have a.
All of these aphorisms predate the Java programming language by two decades.
They tell a deep truth about optimization: it is easy to do more harm than good, especially if you optimize prematurely.
In the process, you may produce software that is neither fast nor correct and cannot easily be fixed.
If a good program is not fast enough, its architecture will allow it to be optimized.
Good programs embody the principle of information hiding: where possible, they localize design decisions within individual modules, so individual decisions can be changed without affecting the remainder of the system (Item 13)
This does not mean that you can ignore performance concerns until your program is complete.
Implementation problems can be fixed by later optimization, but pervasive architectural flaws that limit performance can be impossible to fix without rewriting the system.
Changing a fundamental facet of your design after the fact can result in an ill-structured system that is difficult to maintain and evolve.
Therefore you must think about performance during the design process.
The components of a design that are most difficult to change after the fact are those specifying interactions between modules and with the outside world.
Not only are these design components difficult or impossible to change after the fact, but all of them can place significant limitations on the performance that a system can ever achieve.
Making a public type mutable may require a lot of needless defensive copying (Item 39)
Similarly, using inheritance in a public class where composition would have been appropriate ties the class forever to its superclass, which can place artificial limits on the performance of the subclass (Item 16)
As a final example, using an implementation type rather than an interface in an API ties you to a specific implementation, even though faster implementations may be written in the future (Item 52)
The effects of API design on performance are very real.
Even though allocating small objects is inexpensive on a modern VM, allocating millions of objects needlessly can do real harm to performance.
Luckily, it is generally the case that good API design is consistent with good performance.
It is a very bad idea to warp an API to achieve good performance.
The performance issue that caused you to warp the API may go away in a future release of the platform or other underlying software, but the warped API and the support headaches that come with it will be with you for life.
Once you’ve carefully designed your program and produced a clear, concise, and well-structured implementation, then it may be time to consider optimization, assuming you’re not already satisfied with the performance of the program.
The main reason is that it’s difficult to guess where your program is spending its time.
The part of the program that you think is slow may not be at fault, in which case you’d be wasting your time trying to optimize it.
Profiling tools can help you decide where to focus your optimization efforts.
Such tools give you runtime information, such as roughly how much time each method is consuming and how many times it is invoked.
In addition to focusing your tuning efforts, this can alert you to the need for algorithmic changes.
If a quadratic (or worse) algorithm lurks inside your program, no amount of tuning will fix the problem.
You must replace the algorithm with one that is more efficient.
The more code in the system, the more important it is to use a profiler.
It’s like looking for a needle in a haystack: the bigger the haystack, the more useful it is to have a metal detector.
The JDK comes with a simple profiler and modern IDEs provide more sophisticated profiling tools.
The need to measure the effects of attempted optimization is even greater on the Java platform than on more traditional platforms, because the Java programming language does not have a strong performance model.
The relative costs of the various primitive operations are not well defined.
The “semantic gap” between what the programmer writes and what the CPU executes is far greater than in traditional statically compiled languages, which makes it very difficult to reliably predict the performance consequences of any optimization.
There are plenty of performance myths floating around that turn out to be half-truths or outright lies.
Not only is Java’s performance model ill-defined, but it varies from JVM implementation to JVM implementation, from release to release, and from processor to processor.
If you will be running your program on multiple JVM implementations or multiple hardware platforms, it is important that you measure the effects of your optimization on each.
Occasionally you may be forced to make trade-offs between performance on different JVM implementations or hardware platforms.
To summarize, do not strive to write fast programs—strive to write good ones; speed will follow.
Do think about performance issues while you’re designing systems and especially while you’re designing APIs, wire-level protocols, and persistent data formats.
If not, locate the source of the problems with the aid of a profiler, and go to work optimizing the relevant parts of the system.
The first step is to examine your choice of algorithms: no amount of lowlevel optimization can make up for a poor choice of algorithm.
Repeat this process as necessary, measuring the performance after every change, until you’re satisfied.
The Java platform has a well-established set of naming conventions, many of which are contained in The Java Language Specification [JLS, 6.8]
Loosely speaking, naming conventions fall into two categories: typographical and grammatical.
There are only a handful of typographical naming conventions, covering packages, classes, interfaces, methods, fields, and type variables.
You should rarely violate them and never without a very good reason.
If an API violates these conventions, it may be difficult to use.
If an implementation violates them, it may be difficult to maintain.
In both cases, violations have the potential to confuse and irritate other programmers who work with the code and can cause faulty assumptions that lead to errors.
Package names should be hierarchical with the components separated by periods.
Components should consist of lowercase alphabetic characters and, rarely, digits.
The name of any package that will be used outside your organization should begin with your organization’s Internet domain name with the top-level domain first, for example, edu.cmu, com.sun, gov.nsa.
The standard libraries and optional packages, whose names begin with java and javax, are exceptions to this rule.
Users must not create packages whose names begin with java or javax.
Detailed rules for converting Internet domain names to package name prefixes can be found in The Java Language Specification [JLS, 7.7]
The remainder of a package name should consist of one or more components describing the package.
Meaningful abbreviations are encouraged, for example, util rather than utilities.
Components should generally consist of a single word or abbreviation.
Many packages have names with just one component in addition to the Internet domain name.
Additional components are appropriate for large facilities whose size demands that they be broken up into an informal hierarchy.
Such packages are known as subpackages, although there is no linguistic support for package hierarchies.
Class and interface names, including enum and annotation type names, should consist of one or more words, with the first letter of each word capitalized, for example, Timer or FutureTask.
Abbreviations are to be avoided, except for acronyms and certain common abbreviations like max and min.
There is little consensus as to whether acronyms should be uppercase or have only their first letter capitalized.
While uppercase may be more common, a strong argument can be.
Which class name would you rather see, HTTPURL or HttpUrl?
Method and field names follow the same typographical conventions as class and interface names, except that the first letter of a method or field name should be lowercase, for example, remove or ensureCapacity.
If an acronym occurs as the first word of a method or field name, it should be lowercase.
The sole exception to the previous rule concerns “constant fields,” whose names should consist of one or more uppercase words separated by the underscore character, for example, VALUES or NEGATIVE_INFINITY.
A constant field is a static final field whose value is immutable.
If a static final field has a primitive type or an immutable reference type (Item 15), then it is a constant field.
If a static final field has a mutable reference type, it can still be a constant field if the referenced object is immutable.
Note that constant fields constitute the only recommended use of underscores.
Local variable names have similar typographical naming conventions to member names, except that abbreviations are permitted, as are individual characters and short sequences of characters whose meaning depends on the context in which the local variable occurs, for example, i, xref, houseNumber.
Most commonly it is one of these five: T for an arbitrary type, E for the element type of a collection, K and V for the key and value types of a map, and X for an exception.
For quick reference, the following table shows examples of typographical conventions.
Grammatical naming conventions are more flexible and more controversial than typographical conventions.
There are no grammatical naming conventions to speak of for packages.
Classes, including enum types, are generally named with a singular noun or noun phrase, for example, Timer, BufferedWriter, or ChessPiece.
Interfaces are named like classes, for example, Collection or Comparator, or with an adjective ending in able or ible, for example, Runnable, Iterable, or Accessible.
Because annotation types have so many uses, no part of speech predominates.
Nouns, verbs, prepositions, and adjectives are all common, for example, BindingAnnotation, Inject, ImplementedBy, or Singleton.
Methods that perform some action are generally named with a verb or verb phrase (including object), for example, append or drawImage.
Methods that return a boolean value usually have names that begin with the word is or, less commonly, has, followed by a noun, noun phrase, or any word or phrase that functions as an adjective, for example, isDigit, isProbablePrime, isEmpty, isEnabled, or hasSiblings.
Methods that return a non-boolean function or attribute of the object on which they’re invoked are usually named with a noun, a noun phrase, or a verb phrase beginning with the verb get, for example, size, hashCode, or getTime.
There is a vocal contingent that claims that only the third form (beginning with get) is acceptable, but there is little basis for this claim.
The first two forms usually lead to more readable code, for example:
The form beginning with get is mandatory if the class containing the method is a Bean [JavaBeans], and it’s advisable if you’re considering turning the class into a Bean at a later time.
Also, there is strong precedent for this form if the class contains a method to set the same attribute.
In this case, the two methods should be named getAttribute and setAttribute.
Methods that convert the type of an object, returning an independent object of a different type, are often called toType, for example, toString, toArray.
Methods that return a view (Item 5) whose type differs from that of the receiving object are often called asType, for example, asList.
Methods that return a primitive with the same value as the object on which they’re invoked are often called typeValue, for example, intValue.
Grammatical conventions for field names are less well established and less important than those for class, interface, and method names, as well-designed APIs contain few if any exposed fields.
Fields of type boolean are often named like boolean accessor methods with the initial is omitted, for example, initialized, composite.
Fields of other types are usually named with nouns or noun phrases, such as height, digits, or bodyStyle.
Grammatical conventions for local variables are similar to those for fields, but even weaker.
To summarize, internalize the standard naming conventions and learn to use them as second nature.
The typographical conventions are straightforward and largely unambiguous; the grammatical conventions are more complex and looser.
To quote from The Java Language Specification [JLS, 6.8], “These conventions should not be followed slavishly if long-held conventional usage dictates otherwise.” Use common sense.
Someday, if you are unlucky, you may stumble across a piece of code that looks something like this:
What does this code do? It’s not at all obvious from inspection, and that’s reason enough not to use it (Item 55)
It turns out to be a horribly ill-conceived idiom for looping through the elements of an array.
It’s supposed to be equivalent to the standard idiom for looping through an array, which is instantly recognizable to any Java programmer:
Because exceptions are designed for exceptional circumstances, there is little incentive for JVM implementors to make them as fast as explicit tests.
Placing code inside a try-catch block inhibits certain optimizations that modern JVM implementations might otherwise perform.
The standard idiom for looping through an array doesn’t necessarily result in redundant checks.
In fact, the exception-based idiom is far slower than the standard one on modern JVM implementations.
On my machine, the exception-based idiom is more than twice as slow as the standard one for arrays of one hundred elements.
Not only does the exception-based loop obfuscate the purpose of the code and reduce its performance, but it’s not guaranteed to work! In the presence of an unrelated bug, the loop can fail silently and mask the bug, greatly complicating the debugging process.
Suppose the computation in the body of the loop invokes a method that performs an out-of-bounds access to some unrelated array.
If a reasonable loop idiom were used, the bug would generate an uncaught exception, resulting in immediate thread termination with a full stack trace.
If the misguided exception-based loop were used, the bug-related exception would be caught and misinterpreted as a normal loop termination.
The moral of this story is simple: exceptions are, as their name implies, to be used only for exceptional conditions; they should never be used for ordinary control flow.
More generally, you should use standard, easily recognizable idioms in preference to overly clever techniques that purport to offer better performance.
Even if the performance advantage is real, it may not remain in the face of steadily improving platform implementations.
The subtle bugs and maintenance headaches that come from overly clever techniques, however, are sure to remain.
A well-designed API must not force its clients to use exceptions for ordinary control flow.
A class with a “state-dependent” method that can be invoked only under certain unpredictable conditions should generally have a separate “state-testing” method indicating whether it is appropriate to invoke the state-dependent method.
For example, the Iterator interface has the state-dependent method next and the corresponding state-testing method hasNext.
If Iterator lacked the hasNext method, clients would be forced to do this instead:
This should look very familiar after the array iteration example that began this item.
In addition to being wordy and misleading, the exception-based loop is likely to perform poorly and can mask bugs in unrelated parts of the system.
An alternative to providing a separate state-testing method is to have the statedependent method return a distinguished value such as null if it is invoked with the object in an inappropriate state.
This technique would not be appropriate for Iterator, as null is a legitimate return value for the next method.
Here are some guidelines to help you choose between a state-testing method and a distinguished return value.
If an object is to be accessed concurrently without external synchronization or is subject to externally induced state transitions, you must use a distinguished return value, as the object’s state could change in the interval between the invocation of a state-testing method and its state-dependent method.
Performance concerns may dictate that a distinguished return value be used if a separate state-testing method would duplicate the work of the statedependent method.
All other things being equal, a state-testing method is mildly preferable to a distinguished return value.
It offers slightly better readability, and incorrect use may be easier to detect: if you forget to call a state-testing method, the state-dependent method will throw an exception, making the bug obvious; if you forget to check for a distinguished return value, the bug may be subtle.
In summary, exceptions are designed for use in exceptional conditions.
Don’t use them for ordinary control flow, and don’t write APIs that force others to do so.
Item 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors.
The Java programming language provides three kinds of throwables: checked exceptions, runtime exceptions, and errors.
There is some confusion among programmers as to when it is appropriate to use each kind of throwable.
While the decision is not always clear-cut, there are some general rules that provide strong guidance.
The cardinal rule in deciding whether to use a checked or an unchecked exception is this: use checked exceptions for conditions from which the caller can reasonably be expected to recover.
By throwing a checked exception, you force the caller to handle the exception in a catch clause or to propagate it outward.
Each checked exception that a method is declared to throw is therefore a potent indication to the API user that the associated condition is a possible outcome of invoking the method.
By confronting the API user with a checked exception, the API designer presents a mandate to recover from the condition.
The user can disregard the mandate by catching the exception and ignoring it, but this is usually a bad idea (Item 65)
There are two kinds of unchecked throwables: runtime exceptions and errors.
They are identical in their behavior: both are throwables that needn’t, and generally shouldn’t, be caught.
If a program throws an unchecked exception or an error, it is generally the case that recovery is impossible and continued execution would do more harm than good.
If a program does not catch such a throwable, it will cause the current thread to halt with an appropriate error message.
A precondition violation is simply a failure by the client of an API to adhere to the contract established by the API specification.
For example, the contract for array access specifies that the array index must be between zero and the array length minus one.
While the Java Language Specification does not require it, there is a strong convention that errors are reserved for use by the JVM to indicate resource deficiencies, invariant failures, or other conditions that make it impossible to continue execution.
Given the almost universal acceptance of this convention, it’s best not to implement any new Error subclasses.
Therefore, all of the unchecked throwables you implement should subclass RuntimeException (directly or indirectly)
It is possible to define a throwable that is not a subclass of Exception, RuntimeException, or Error.
So when should you use such a beast? In a word, never.
It has no benefits over an ordinary checked exception and would merely serve to confuse the user of your API.
To summarize, use checked exceptions for recoverable conditions and runtime exceptions for programming errors.
Of course, the situation is not always black and white.
For example, consider the case of resource exhaustion, which can be caused by a programming error such as allocating an unreasonably large array or by a genuine shortage of resources.
If resource exhaustion is caused by a temporary shortage or by temporarily heightened demand, the condition may well be recoverable.
It is a matter of judgment on the part of the API designer whether a given instance of resource exhaustion is likely to allow for recovery.
If you believe a condition is likely to allow for recovery, use a checked exception; if not, use a runtime exception.
The primary use of such methods is to provide the code that catches the exception with additional information concerning the condition that caused the exception to be thrown.
In the absence of such methods, programmers have been known to parse the string representation of an exception to ferret out additional information.
Classes seldom specify the details of their string representations, so string representations can differ from implementation to implementation and release to release.
Therefore, code that parses the string representation of an exception is likely to be nonportable and fragile.
Because checked exceptions generally indicate recoverable conditions, it’s especially important for such exceptions to provide methods that furnish information that could help the caller to recover.
For example, suppose a checked exception is thrown when an attempt to make a purchase with a gift card fails because the card doesn’t have enough money left on it.
The exception should provide an accessor method to query the amount of the shortfall, so the amount can be relayed to the shopper.
Checked exceptions are a wonderful feature of the Java programming language.
Unlike return codes, they force the programmer to deal with exceptional conditions, greatly enhancing reliability.
That said, overuse of checked exceptions can make an API far less pleasant to use.
If a method throws one or more checked exceptions, the code that invokes the method must handle the exceptions in one or more catch blocks, or it must declare that it throws the exceptions and let them propagate outward.
Either way, it places a nontrivial burden on the programmer.
The burden is justified if the exceptional condition cannot be prevented by proper use of the API and the programmer using the API can take some useful action once confronted with the exception.
Unless both of these conditions hold, an unchecked exception is more appropriate.
As a litmus test, ask yourself how the programmer will handle the exception.
If the programmer using the API can do no better, an unchecked exception would be more appropriate.
It is thrown by Object.clone, which should be invoked only on objects that implement Cloneable (Item 11)
In practice, the catch block almost always has the character of an assertion failure.
The checked nature of the exception provides no benefit to the programmer, but it requires effort and complicates programs.
The additional burden on the programmer caused by a checked exception is substantially higher if it is the sole checked exception thrown by a method.
If there are others, the method must already appear in a try block, and this exception merely requires another catch block.
If a method throws a single checked exception, this exception alone is responsible for the fact that the method must appear in a try block.
Under these circumstances, it pays to ask yourself whether there isn’t some way to avoid the checked exception.
One technique for turning a checked exception into an unchecked exception is to break the method that throws the exception into two methods, the first of which returns a boolean that indicates whether the exception would be thrown.
This refactoring is not always appropriate, but where it is appropriate, it can make an API more pleasant to use.
While the latter calling sequence is no prettier than the former, the resulting API is more flexible.
In cases where the programmer knows the call will succeed or is content to let the thread terminate if the call fails, the refactoring also allows this simple calling sequence:
If you suspect that the simple calling sequence will be the norm, then this API refactoring may be appropriate.
The API resulting from this refactoring is essentially identical to the state-testing method API in Item 57 and the same caveats apply: if an object is to be accessed concurrently without external synchronization or it is subject to externally induced state transitions, this refactoring is inappropriate, as the object’s state may change between the invocations of actionPermitted and action.
If a separate actionPermitted method would, of necessity, duplicate the work of the action method, the refactoring may be ruled out by performance concerns.
One of the attributes that most strongly distinguishes expert programmers from less experienced ones is that experts strive for and usually achieve a high degree of code reuse.
Exceptions are no exception to the general rule that code reuse is good.
The Java platform libraries provide a basic set of unchecked exceptions that cover a large fraction of the exception-throwing needs of most APIs.
Chief among these, it makes your API easier to learn and use because it matches established conventions with which programmers are already familiar.
A close second is that programs using your API are easier to read because they aren’t cluttered with unfamiliar exceptions.
Last (and least), fewer exception classes mean a smaller memory footprint and less time spent loading classes.
This is generally the exception to throw when the caller passes in an argument whose value is inappropriate.
For example, this would be the exception to throw if the caller passed a negative number in a parameter representing the number of times some action was to be repeated.
This is generally the exception to throw if the invocation is illegal because of the state of the receiving object.
For example, this would be the exception to throw if the caller attempted to use some object before it had been properly initialized.
Arguably, all erroneous method invocations boil down to an illegal argument or illegal state, but other exceptions are standardly used for certain kinds of illegal arguments and states.
This exception should be thrown if an object that was designed for use by a single thread or with external synchronization detects that it is being (or has been) concurrently modified.
This is the exception to throw if an object does not support an attempted operation.
Its use is rare compared to the other exceptions discussed in this item, as most objects support all the methods they implement.
For example, an append-only List implementation would throw this exception if someone tried to delete an element from the list.
While these are by far the most commonly reused exceptions in the Java platform libraries, other exceptions may be reused where circumstances warrant.
If an exception fits your needs, go ahead and use it, but only if the conditions under which you would throw it are consistent with the exception’s documentation.
Reuse must be based on semantics, not just on name.
Also, feel free to subclass an existing exception if you want to add a bit more failure-capture information (Item 63)
Finally, be aware that choosing which exception to reuse is not always an exact science, as the occasions for use in the table above are not mutually exclusive.
Consider, for example, the case of an object representing a deck of cards.
Suppose there were a method to deal a hand from the deck that took as an argument the size of the hand.
Suppose the caller passed in this parameter a value that was larger than the number of cards remaining in the deck.
It is disconcerting when a method throws an exception that has no apparent connection to the task that it performs.
This often happens when a method propagates an exception thrown by a lower-level abstraction.
Not only is this disconcerting, but it pollutes the API of the higher layer with implementation details.
If the implementation of the higher layer changes in a subsequent release, the exceptions that it throws will change too, potentially breaking existing client programs.
To avoid this problem, higher layers should catch lower-level exceptions and, in their place, throw exceptions that can be explained in terms of the higher-level abstraction.
In this example, exception translation is mandated by the specification of the get method in the List<E> interface:
A special form of exception translation called exception chaining is appropriate in cases where the lower-level exception might be helpful to someone debugging the problem that caused the higher-level exception.
For exceptions that don’t, you can set the cause using Throwable’s initCause method.
Not only does exception chaining let you access the cause programmatically (with getCause), but it integrates the cause’s stack trace into that of the higher-level exception.
While exception translation is superior to mindless propagation of exceptions from lower layers, it should not be overused.
Where possible, the best way to deal with exceptions from lower layers is to avoid them, by ensuring that lower-level methods succeed.
Sometimes you can do this by checking the validity of the higher-level method’s parameters before passing them on to lower layers.
If it is impossible to prevent exceptions from lower layers, the next best thing is to have the higher layer silently work around these exceptions, insulating the caller of the higher-level method from lower-level problems.
This allows an administrator to investigate the problem, while insulating the client code and the end user from it.
In summary, if it isn’t feasible to prevent or to handle exceptions from lower layers, use exception translation, unless the lower-level method happens to guarantee that all of its exceptions are appropriate to the higher level.
Chaining provides the best of both worlds: it allows you to throw an appropriate higher-level exception, while capturing the underlying cause for failure analysis (Item 63)
A description of the exceptions thrown by a method is an important part of the documentation required to use the method properly.
Therefore, it is critically important that you take the time to carefully document all of the exceptions thrown by each method.
Always declare checked exceptions individually, and document precisely the conditions under which each one is thrown using the Javadoc @throws tag.
Don’t take the shortcut of declaring that a method throws some superclass of multiple exception classes that it can throw.
As an extreme example, never declare that a method “throws Exception” or, worse yet, “throws Throwable.” In addition to denying any guidance to the method’s user concerning the exceptions that it is capable of throwing, such a declaration greatly hinders the use of the method, as it effectively obscures any other exception that may be thrown in the same context.
While the language does not require programmers to declare the unchecked exceptions that a method is capable of throwing, it is wise to document them as carefully as the checked exceptions.
Unchecked exceptions generally represent programming errors (Item 58), and familiarizing programmers with all of the errors they can make helps them avoid making these errors.
A well-documented list of the unchecked exceptions that a method can throw effectively describes the preconditions for its successful execution.
It is essential that each method’s documentation describe its preconditions, and documenting its unchecked exceptions is the best way to satisfy this requirement.
It is particularly important that methods in interfaces document the unchecked exceptions they may throw.
This documentation forms a part of the interface’s general contract and enables common behavior among multiple implementations of the interface.
Use the Javadoc @throws tag to document each unchecked exception that a method can throw, but do not use the throws keyword to include unchecked exceptions in the method declaration.
It is important that the programmers using your API be aware of which exceptions are checked and which are unchecked, as their responsibilities differ in these two cases.
The documentation generated by the Javadoc @throws tag in the absence of the method header generated by the throws declaration provides a strong visual cue to help the programmer distinguish checked exceptions from unchecked.
It should be noted that documenting all of the unchecked exceptions that each method can throw is an ideal, not always achievable in the real world.
When a class undergoes revision, it is not a violation of source or binary compatibility if an exported method is modified to throw additional unchecked exceptions.
Suppose a class invokes a method from another, independently written class.
The authors of the former class may carefully document all of the unchecked exceptions that each method throws, but if the latter class is revised to throw additional unchecked exceptions, it is quite likely that the former class (which has not undergone revision) will propagate the new unchecked exceptions even though it does not declare them.
If an exception is thrown by many methods in a class for the same reason, it is acceptable to document the exception in the class’s documentation comment rather than documenting it individually for each method.
In summary, document every exception that can be thrown by each method that you write.
This is true for unchecked as well as checked exceptions, and for abstract as well as concrete methods.
Provide individual throws clauses for each checked exception and do not provide throws clauses for unchecked exceptions.
If you fail to document the exceptions that your methods can throw, it will be difficult or impossible for others to make effective use of your classes and interfaces.
When a program fails due to an uncaught exception, the system automatically prints out the exception’s stack trace.
The stack trace contains the exception’s string representation, the result of invoking its toString method.
This typically consists of the exception’s class name followed by its detail message.
Frequently this is the only information that programmers or field service personnel will have when investigating a software failure.
If the failure is not easily reproducible, it may be difficult or impossible to get any more information.
Therefore, it is critically important that the exception’s toString method return as much information as possible concerning the cause of the failure.
In other words, the detail message of an exception should capture the failure for subsequent analysis.
Any or all of the three values could be wrong.
The actual index could be one less than the lower bound or equal to the upper bound (a “fencepost error”), or it could be a wild value, far too low or high.
The lower bound could be greater than the upper bound (a serious internal invariant failure)
Each of these situations points to a different problem, and it greatly aids in the diagnosis if the programmer knows what sort of error to look for.
While it is critical to include all of the pertinent “hard data” in the detail message of an exception, it is generally unimportant to include a lot of prose.
The stack trace is intended to be analyzed in conjunction with the source files and generally contains the exact file and line number from which the exception was thrown, as well as the files and line numbers of all other method invocations on the stack.
Lengthy prose descriptions of the failure are generally superfluous; the information can be gleaned by reading the source code.
The detail message of an exception should not be confused with a user-level error message, which must be intelligible to end users.
Unlike a user-level error message, it is primarily for the benefit of programmers or field service personnel for use when analyzing a failure.
One way to ensure that exceptions contain adequate failure-capture information in their detail messages is to require this information in their constructors instead of a string detail message.
Save failure information for programmatic access this.lowerBound = lowerBound; this.upperBound = upperBound; this.index = index;
Unfortunately, the Java platform libraries do not make heavy use of this idiom, but it is highly recommended.
It makes it easy for the programmer throwing an exception to capture the failure.
In fact, it makes it hard for the programmer not to capture the failure! In effect, the idiom centralizes the code to generate a high-quality detail message for an exception in the exception class itself, rather than requiring each user of the class to generate the detail message redundantly.
As suggested in Item 58, it may be appropriate for an exception to provide accessor methods for its failure-capture information (lowerBound, upperBound, and index in the above example)
It is more important to provide such accessor methods on checked exceptions than on unchecked exceptions, because the failure-capture information could be useful in recovering from the failure.
It is rare (although not inconceivable) that a programmer might want programmatic access to the details of an unchecked exception.
After an object throws an exception, it is generally desirable that the object still be in a well-defined, usable state, even if the failure occurred in the midst of performing an operation.
This is especially true for checked exceptions, from which the caller is expected to recover.
Generally speaking, a failed method invocation should leave the object in the state that it was in prior to the invocation.
A method with this property is said to be failure atomic.
If an operation fails, it may prevent a new object from getting created, but it will never leave an existing object in an inconsistent state, because the state of each object is consistent when it is created and can’t be modified thereafter.
For methods that operate on mutable objects, the most common way to achieve failure atomicity is to check parameters for validity before performing the operation (Item 38)
This causes any exception to get thrown before object modification commences.
If the initial size check were eliminated, the method would still throw an exception when it attempted to pop an element from an empty stack.
It would, however, leave the size field in an inconsistent (negative) state, causing any future method invocations on the object to fail.
Additionally, the exception thrown by the pop method would be inappropriate to the abstraction (Item 61)
A closely related approach to achieving failure atomicity is to order the computation so that any part that may fail takes place before any part that modifies the object.
This approach is a natural extension of the previous one when arguments cannot be checked without performing a part of the computation.
For example, consider the case of TreeMap, whose elements are sorted according to some ordering.
In order to add an element to a TreeMap, the element must be of a type that can be compared using the TreeMap’s ordering.
Attempting to add an incorrectly typed element will naturally fail with a ClassCastException as a result of searching for the element in the tree, before the tree has been modified in any way.
A third and far less common approach to achieving failure atomicity is to write recovery code that intercepts a failure that occurs in the midst of an operation and causes the object to roll back its state to the point before the operation began.
This approach is used mainly for durable (disk-based) data structures.
A final approach to achieving failure atomicity is to perform the operation on a temporary copy of the object and to replace the contents of the object with the temporary copy once the operation is complete.
This approach occurs naturally when the computation can be performed more quickly once the data has been stored in a temporary data structure.
For example, Collections.sort dumps its input list into an array prior to sorting to reduce the cost of accessing elements in the inner loop of the sort.
This is done for performance, but as an added benefit, it ensures that the input list will be untouched if the sort fails.
While failure atomicity is generally desirable, it is not always achievable.
For example, if two threads attempt to modify the same object concurrently without proper synchronization, the object may be left in an inconsistent state.
As a rule, errors (as opposed to exceptions) are unrecoverable, and methods need not even attempt to preserve failure atomicity when throwing errors.
Even where failure atomicity is possible, it is not always desirable.
For some operations, it would significantly increase the cost or complexity.
That said, it is often both free and easy to achieve failure atomicity once you’re aware of the issue.
As a rule, any generated exception that is part of a method’s specification should leave the object in the same state it was in prior to the method invocation.
Where this rule is violated, the API documentation should clearly indicate what state the object will be left in.
Unfortunately, plenty of existing API documentation fails to live up to this ideal.
While this advice may seem obvious, it is violated often enough that it bears repeating.
When the designers of an API declare a method to throw an exception, they are trying to tell you something.
Don’t ignore it! It is easy to ignore exceptions by surrounding a method invocation with a try statement with an empty catch block:
An empty catch block defeats the purpose of exceptions, which is to force you to handle exceptional conditions.
Ignoring an exception is analogous to ignoring a fire alarm—and turning it off so no one else gets a chance to see if there’s a real fire.
You may get away with it, or the results may be disastrous.
Whenever you see an empty catch block, alarm bells should go off in your head.
At the very least, the catch block should contain a comment explaining why it is appropriate to ignore the exception.
An example of the sort of situation where it might be appropriate to ignore an exception is when closing a FileInputStream.
You haven’t changed the state of the file, so there’s no need to perform any recovery action, and you’ve already read the information that you need from the file, so there’s no reason to abort the operation in progress.
Even in this case, it is wise to log the exception, so that you can investigate the matter if these exceptions happen often.
The advice in this item applies equally to checked and unchecked exceptions.
Whether an exception represents a predictable exceptional condition or a programming error, ignoring it with an empty catch block will result in a program that continues silently in the face of error.
The program might then fail at an arbitrary time in the future, at a point in the code that bears no apparent relation to the source of the problem.
Merely letting an exception propagate outward can at least cause the program to fail swiftly, preserving information to aid in debugging the failure.
Concurrent programming is harder than single-threaded programming, because more things can go wrong, and failures can be hard to reproduce.
It is inherent in much of what we do, and a requirement if you are to obtain good performance from multicore processors, which are now commonplace.
This chapter contains advice to help you write clear, correct, well-documented concurrent programs.
The synchronized keyword ensures that only a single thread can execute a method or block at one time.
Many programmers think of synchronization solely as a means of mutual exclusion, to prevent an object from being observed in an inconsistent state while it’s being modified by another thread.
In this view, an object is created in a consistent state (Item 15) and locked by the methods that access it.
These methods observe the state and optionally cause a state transition, transforming the object from one consistent state to another.
Proper use of synchronization guarantees that no method will ever observe the object in an inconsistent state.
This view is correct, but it’s only half the story.
Without synchronization, one thread’s changes might not be visible to other threads.
Not only does synchronization prevent a thread from observing an object in an inconsistent state, but it ensures that each thread entering a synchronized method or block sees the effects of all previous modifications that were guarded by the same lock.
The language specification guarantees that reading or writing a variable is atomic unless the variable is of type long or double [JLS, 17.4.7]
In other words, reading a variable other than a long or double is guaranteed to return a value that was stored into that variable by some thread, even if multiple threads modify the variable concurrently and without synchronization.
You may hear it said that to improve performance, you should avoid synchronization when reading or writing atomic data.
While the language specification guarantees that a thread will not see an arbitrary value when reading a field, it does not guarantee that a value written by one thread will be visible to another.
Synchronization is required for reliable communication between threads as well as for mutual exclusion.
The consequences of failing to synchronize access to shared mutable data can be dire even if the data is atomically readable and writable.
The libraries provide the Thread.stop method, but this method was deprecated long ago because it is inherently unsafe—its use can result in data corruption.
A recommended way to stop one thread from another is to have the first thread poll a boolean field that is initially false but can be set to true by the second thread to indicate that the first thread is to stop itself.
Because reading and writing a boolean field is atomic, some programmers dispense with synchronization when accessing the field:
You might expect this program to run for about a second, after which the main thread sets stopRequested to true, causing the background thread’s loop to terminate.
On my machine, however, the program never terminates: the background thread loops forever!
The problem is that in the absence of synchronization, there is no guarantee as to when, if ever, the background thread will see the change in the value of stopRequested that was made by the main thread.
In the absence of synchronization, it’s quite acceptable for the virtual machine to transform this code:
This optimization is known as hoisting, and it is precisely what the HotSpot server VM does.
The result is a liveness failure: the program fails to make progress.
One way to fix the problem is to synchronize access to the stopRequested field.
Note that both the write method (requestStop) and the read method (stopRequested) are synchronized.
It is not sufficient to synchronize only the write method! In fact, synchronization has no effect unless both read and write operations are synchronized.
The actions of the synchronized methods in StopThread would be atomic even without synchronization.
In other words, the synchronization on these methods is used solely for its communication effects, not for mutual exclusion.
While the cost of synchronizing on each iteration of the loop is small, there is a correct alternative that is less verbose and whose performance is likely to be better.
The locking in the second version of StopThread can be omitted if stopRequested is declared volatile.
While the volatile modifier performs no mutual exclusion, it guarantees that any thread that reads the field will see the most recently written value:
Consider the following method, which is supposed to generate serial numbers:
Broken - requires synchronization! private static volatile int nextSerialNumber = 0;
The intent of the method is to guarantee that every invocation returns a different value (so long as there are no more than 232 invocations)
The method’s state consists of a single atomically accessible field, nextSerialNumber, and all possible values of this field are legal.
The problem is that the increment operator (++) is not atomic.
It performs two operations on the nextSerialNumber field: first it reads the value, then it writes back a new value, equal to the old value plus one.
If a second thread reads the field between the time a thread reads the old value and writes back a new one, the second thread will see the same value as the first and return the same serial number.
This is a safety failure: the program computes the wrong results.
This ensures that multiple invocations won’t be interleaved, and that each invocation will see the effects of all previous invocations.
Once you’ve done that, you can and should remove the volatile modifier from nextSerialNumber.
To bulletproof the method, use long instead of int, or throw an exception if nextSerialNumber is about to wrap.
The best way to avoid the problems discussed in this item is not to share mutable data.
Either share immutable data (Item 15), or don’t share at all.
In other words, confine mutable data to a single thread.
If you adopt this policy, it is important to document it, so that it is maintained as your program evolves.
It is also important to have a deep understanding of the frameworks and libraries you’re using, as they may introduce threads that you are unaware of.
It is acceptable for one thread to modify a data object for a while and then to share it with other threads, synchronizing only the act of sharing the object reference.
Other threads can then read the object without further synchronization, so long as it isn’t modified again.
There are many ways to safely publish an object reference: you can store it in a static field as part of class initialization; you.
In summary, when multiple threads share mutable data, each thread that reads or writes the data must perform synchronization.
Without synchronization, there is no guarantee that one thread’s changes will be visible to another.
The penalties for failing to synchronize shared mutable data are liveness and safety failures.
They can be intermittent and timing-dependent, and program behavior can vary radically from one VM to another.
If you need only inter-thread communication, and not mutual exclusion, the volatile modifier is an acceptable form of synchronization, but it can be tricky to use correctly.
Depending on the situation, excessive synchronization can cause reduced performance, deadlock, or even nondeterministic behavior.
To avoid liveness and safety failures, never cede control to the client within a synchronized method or block.
In other words, inside a synchronized region, do not invoke a method that is designed to be overridden, or one provided by a client in the form of a function object (Item 21)
From the perspective of the class with the synchronized region, such methods are alien.
The class has no knowledge of what the method does and has no control over it.
Depending on what an alien method does, calling it from a synchronized region can cause exceptions, deadlocks, or data corruption.
To make this concrete, consider the following class, which implements an observable set wrapper.
It allows clients to subscribe to notifications when elements are added to the set.
For brevity’s sake, the class does not provide notifications when elements are removed from the set, but it would be a simple matter to provide them.
Observers subscribe to notifications by invoking the addObserver method and unsubscribe by invoking the removeObserver method.
In both cases, an instance of this callback interface is passed to the method:
Suppose we replace the addObserver call with one that passes an observer that prints the Integer value that was added to the set and removes itself if the value is 23:
The problem is that notifyElementAdded is in the process of iterating over the observers list when it invokes the observer’s added method.
The added method calls the observable set’s removeObserver method, which in turn calls observers.remove.
We are trying to remove an element from a list in the midst of iterating over it, which is illegal.
The iteration in the notifyElementAdded method is in a synchronized block to prevent concurrent modification, but it doesn’t prevent the iterating thread itself from calling back into the observable set and modifying its observers list.
Now let’s try something odd: let’s write an observer that attempts to unsubscribe, but instead of calling removeObserver directly, it engages the services of another thread to do the deed.
This time we don’t get an exception; we get a deadlock.
All the while, the main thread is waiting for the background thread to finish removing the observer, which explains the deadlock.
This example is contrived because there is no reason for the observer to use a background thread, but the problem is real.
Invoking alien methods from synchronized regions has caused many deadlocks in real systems, such as GUI toolkits.
In both of the previous examples (the exception and the deadlock) we were lucky.
The resource that was guarded by the synchronized region (observers) was in a consistent state when the alien method (added) was invoked.
Suppose you were to invoke an alien method from within a synchronized region while the invariant protected by the synchronized region was temporarily invalid.
Because locks in the Java programming language are reentrant, such calls won’t deadlock.
As in the first example, which resulted in an exception, the calling thread already holds the lock, so the thread will succeed when it tries to reacquire the lock, even though another conceptually unrelated operation is in progress on the data guarded by the lock.
In essence, the lock has failed to do its job.
Reentrant locks simplify the construction of multithreaded object-oriented programs, but they can turn liveness failures into safety failures.
Luckily, it is usually not too hard to fix this sort of problem by moving alien method invocations out of synchronized blocks.
For the notifyElementAdded method, this involves taking a “snapshot” of the observers list that can then be safely traversed without a lock.
With this change, both of the previous examples run without exception or deadlock:
In fact, there’s a better way to move the alien method invocations out of the synchronized block.
It is a variant of ArrayList in which all write operations are implemented by making a fresh copy of the entire underlying array.
Because the internal array is never modified, iteration requires no locking and is very fast.
An alien method might run for an arbitrarily long period.
If the alien method were invoked from a synchronized region, other threads would be denied access to the protected resource unnecessarily.
As a rule, you should do as little work as possible inside synchronized regions.
Obtain the lock, examine the shared data, transform it as necessary, and drop the lock.
While the cost of synchronization has plummeted since the early days of Java, it is more important than ever not to oversynchronize.
In a multicore world, the real cost of excessive synchronization is not the CPU time spent obtaining locks; it is the lost opportunities for parallelism and the delays imposed by the need to ensure that every core has a consistent view of memory.
You should make a mutable class thread-safe (Item 70) if it is intended for concurrent use and you can achieve significantly higher concurrency by synchronizing internally than you could by locking the entire object externally.
In the early days of the Java platform, many classes violated these guidelines.
For example, StringBuffer instances are almost always used by a single thread, yet they perform internal synchronization.
It is for this reason that StringBuffer was essentially replaced by StringBuilder, which is an unsynchronized StringBuffer, in release 1.5
When in doubt, do not synchronize your class, but document that it is not thread-safe (Item 70)
If you do synchronize your class internally, you can use various techniques to achieve high concurrency, such as lock splitting, lock striping, and nonblocking concurrency control.
If a method modifies a static field, you must synchronize access to this field, even if the method is typically used only by a single thread.
It is not possible for clients to perform external synchronization on such a method because there can be no guarantee that unrelated clients will do likewise.
In summary, to avoid deadlock and data corruption, never call an alien method from within a synchronized region.
More generally, try to limit the amount of work that you do from within synchronized regions.
When you are designing a mutable class, think about whether it should do its own synchronization.
In the modern multicore era, it is more important than ever not to synchronize excessively.
Synchronize your class internally only if there is a good reason to do so, and document your decision clearly (Item 70)
This class allowed clients to enqueue work items for asynchronous processing by a background thread.
When the work queue was no longer needed, the client could invoke a method to ask the background thread to terminate itself gracefully after completing any work that was already on the queue.
The implementation was little more than a toy, but even so, it required a full page of subtle, delicate code, of the sort that is prone to safety and liveness failures if you don’t get it just right.
Luckily, there is no reason to write this sort of code anymore.
This package contains an Executor Framework, which is a flexible interface-based task execution facility.
Creating a work queue that is better in every way than the one in the first edition of this book requires but a single line of code:
And here is how to tell the executor to terminate gracefully (if you fail to do this, it is likely that your VM will not exit):
You can do many more things with an executor service.
If you want more than one thread to process requests from the queue, simply call a different static factory that creates a different kind of executor service called a thread pool.
You can create a thread pool with a fixed or variable number of threads.
This class lets you control nearly every aspect of a thread pool’s operation.
Choosing the executor service for a particular application can be tricky.
If no threads are available, a new one is created.
If a server is so heavily loaded that all of its CPUs are fully utilized, and more tasks arrive, more threads will be created, which will only make matters worse.
Not only should you refrain from writing your own work queues, but you should generally refrain from working directly with threads.
The key abstraction is no longer Thread, which served as both the unit of work and the mechanism for executing it.
The key abstraction is the unit of work, which is called a task.
There are two kinds of tasks: Runnable and its close cousin, Callable (which is like Runnable, except that it returns a value)
The general mechanism for executing tasks is the executor service.
If you think in terms of tasks and let an executor service execute them for you, you gain great flexibility in terms of selecting appropriate execution policies.
In essence, the Executor Framework does for execution what the Collections Framework did for aggregation.
While it is easier to use a timer, a scheduled thread pool executor is much more flexible.
A timer uses only a single thread for task execution, which can hurt timing accuracy in the presence of longrunning tasks.
If a timer’s sole thread throws an uncaught exception, the timer ceases to operate.
A scheduled thread pool executor supports multiple threads and recovers gracefully from tasks that throw unchecked exceptions.
A complete treatment of the Executor Framework is beyond the scope of this book, but the interested reader is directed to Java Concurrency in Practice [Goetz06]
Its advice is still valid and is summarized at end of this item, but this advice is far less important than it once was.
This is because there is far less reason to use wait and notify.
As of release 1.5, the Java platform provides higher-level concurrency utilities that do the sorts of things you formerly had to hand-code atop wait and notify.
Given the difficulty of using wait and notify correctly, you should use the higher-level concurrency utilities instead.
Concurrent collections and synchronizers are covered briefly in this item.
The concurrent collections provide high-performance concurrent implementations of standard collection interfaces such as List, Queue, and Map.
To provide high concurrency, these implementations manage their own synchronization internally (Item 67)
Therefore, it is impossible to exclude concurrent activity from a concurrent collection; locking it will have no effect but to slow the program.
This means that clients can’t atomically compose method invocations on concurrent collections.
Some of the collection interfaces have therefore been extended with state-dependent modify operations, which combine several primitives into a single atomic operation.
For example, ConcurrentMap extends Map and adds several methods, including putIfAbsent(key, value), which inserts a mapping for a key if none was present and returns the previous value associated with the key, or null if there was none.
Therefore, it is worth invoking get initially and calling putIfAbsent only if get indicates that it is necessary:
On my machine the optimized intern method above is over six times faster than String.intern (but keep in mind that String.intern must use some sort of weak reference to keep from leaking memory over time)
Simply replacing old-style synchronized maps with concurrent maps can dramatically increase the performance of concurrent applications.
More generally, use concurrent collections in preference to externally synchronized collections.
Some of the collection interfaces have been extended with blocking operations, which wait (or block) until they can be successfully performed.
For example, BlockingQueue extends Queue and adds several methods, including take, which removes and returns the head element from the queue, waiting if the queue is empty.
This allows blocking queues to be used for work queues (also known as producer-consumer queues), to which one or more producer threads enqueue work items and from which one or more consumer threads dequeue and process items as they become available.
Synchronizers are objects that enable threads to wait for one another, allowing them to coordinate their activities.
Countdown latches are single-use barriers that allow one or more threads to wait for one or more other threads to do something.
The sole constructor for CountDownLatch takes an int that is the number of times the countDown method must be invoked on the latch before all waiting threads are allowed to proceed.
It is surprisingly easy to build useful things atop this simple primitive.
For example, suppose you want to build a simple framework for timing the concurrent execution of an action.
This framework consists of a single method that takes an executor to execute the action, a concurrency level representing the number of.
All of the worker threads ready themselves to run the action before the timer thread starts the clock (this is necessary to get an accurate timing)
When the last worker thread is ready to run the action, the timer thread “fires the starting gun,” allowing the worker threads to perform the action.
As soon as the last worker thread finishes performing the action, the timer thread stops the clock.
Implementing this logic directly on top of wait and notify would be messy to say the least, but it is surprisingly straightforward on top of CountDownLatch:
The first, ready, is used by worker threads to tell the timer thread when they’re ready.
The worker threads then wait on the second latch, which is start.
When the last worker thread invokes ready.countDown, the timer thread records the start time and invokes start.countDown, allowing all of the worker threads to proceed.
Then the timer thread waits on the third latch, done, until the last of the worker threads finishes running the action and calls done.countDown.
As soon as this happens, the timer thread awakens and records the end time.
The executor that is passed to the time method must allow for the creation of at least as many threads as the given concurrency level, or the test will never complete.
This allows the executor to deal with the interrupt as it sees fit, which is as it should be.
System.nanoTime is both more accurate and more precise, and it is not affected by adjustments to the system’s real-time clock.
This item only scratches the surface of the concurrency utilities.
For example, the three countdown latches in the previous example can be replaced by a single cyclic barrier.
The resulting code is even more concise, but it is more difficult to understand.
While you should always use the concurrency utilities in preference to wait and notify, you might have to maintain legacy code that uses wait and notify.
The wait method is used to make a thread wait for some condition.
It must be invoked inside a synchronized region that locks the object on which it is invoked.
Here is the standard idiom for using the wait method:
Always use the wait loop idiom to invoke the wait method; never invoke it outside of a loop.
The loop serves to test the condition before and after waiting.
Testing the condition before waiting and skipping the wait if the condition already holds are necessary to ensure liveness.
If the condition already holds and the notify (or notifyAll) method has already been invoked before a thread waits, there is no guarantee that the thread will ever wake from the wait.
Testing the condition after waiting and waiting again if the condition does not hold are necessary to ensure safety.
If the thread proceeds with the action when the condition does not hold, it can destroy the invariant guarded by the lock.
There are several reasons a thread might wake up when the condition does not hold:
Another thread could have obtained the lock and changed the guarded state between the time a thread invoked notify and the time the waiting thread woke.
Another thread could have invoked notify accidentally or maliciously when the condition did not hold.
Classes expose themselves to this sort of mischief by waiting on publicly accessible objects.
Any wait contained in a synchronized method of a publicly accessible object is susceptible to this problem.
The notifying thread could be overly “generous” in waking waiting threads.
For example, the notifying thread might invoke notifyAll even if only some of the waiting threads have their condition satisfied.
The waiting thread could (rarely) wake up in the absence of a notify.
A related issue is whether you should use notify or notifyAll to wake waiting threads.
Recall that notify wakes a single waiting thread, assuming such a thread exists, and notifyAll wakes all waiting threads.
It is often said that you should always use notifyAll.
It will always yield correct results because it guarantees that you’ll wake the threads that need to be awakened.
You may wake some other threads, too, but this won’t affect the correctness of your program.
These threads will check the condition for which they’re waiting and, finding it false, will continue waiting.
As an optimization, you may choose to invoke notify instead of notifyAll if all threads that could be in the wait-set are waiting for the same condition and only one thread at a time can benefit from the condition becoming true.
Even if these conditions appear true, there may be cause to use notifyAll in place of notify.
Just as placing the wait invocation in a loop protects against accidental or malicious notifications on a publicly accessible object, using notifyAll in place of notify protects against accidental or malicious waits by an unrelated thread.
Such waits could otherwise “swallow” a critical notification, leaving its intended recipient waiting indefinitely.
There is seldom, if ever, a reason to use wait and notify in new code.
If you maintain code that uses wait and notify, make sure that it always invokes wait from within a while loop using the standard idiom.
The notifyAll method should generally be used in preference to notify.
If notify is used, great care must be taken to ensure liveness.
How a class behaves when its instances or static methods are subjected to concurrent use is an important part of the contract the class makes with its clients.
If you don’t document this facet of a class’s behavior, programmers who use the class will be forced to make assumptions.
You might hear it said that you can tell if a method is thread-safe by looking for the synchronized modifier in its documentation.
In normal operation, Javadoc does not include the synchronized modifier in its output, and with good reason.
The presence of the synchronized modifier in a method declaration is an implementation detail, not a part of its exported API.
It does not reliably indicate that a method is thread-safe.
Moreover, the claim that the presence of the synchronized modifier is sufficient to document thread safety embodies the misconception that thread safety is an all-or-nothing property.
To enable safe concurrent use, a class must clearly document what level of thread safety it supports.
To use them concurrently, clients must surround each method invocation (or invocation sequence) with external synchronization of the clients’ choosing.
Thread hostility usually results from modifying static data without synchronization.
No one writes a thread-hostile class on purpose; such classes result from the failure to consider concurrency.
Luckily, there are very few thread-hostile classes or methods in the Java libraries.
These categories (apart from thread-hostile) correspond roughly to the thread safety annotations in Java Concurrency in Practice, which are Immutable, ThreadSafe, and NotThreadSafe [Goetz06, Appendix A]
The unconditionally and conditionally thread-safe categories in the above taxonomy are both covered under the ThreadSafe annotation.
You must indicate which invocation sequences require external synchronization, and which lock (or in rare cases, which locks) must be acquired to execute these sequences.
Typically it is the lock on the instance itself, but there are exceptions.
If an object represents a view on some other object, the client generally must synchronize on the backing object, so as to prevent its direct modification.
Failure to follow this advice may result in non-deterministic behavior.
The description of a class’s thread safety generally belongs in its documentation comment, but methods with special thread safety properties should describe these properties in their own documentation comments.
It is not necessary to document the immutability of enum types.
When a class commits to using a publicly accessible lock, it enables clients to execute a sequence of method invocations atomically, but this flexibility comes at a price.
Also, a client can mount a denial-of-service attack by holding the publicly accessible lock for a prolonged period.
To prevent this denial-of-service attack, you can use a private lock object instead of using synchronized methods (which imply a publicly accessible lock):
Because the private lock object is inaccessible to clients of the class, it is impossible for them to interfere with the object’s synchronization.
In effect, we are applying the advice of Item 13 by encapsulating the lock object within the object it synchronizes.
This prevents you from inadvertently changing its contents, which could result in catastrophic unsynchronized access to the containing object (Item 66)
We are applying the advice of Item 15, by minimizing the mutability of the lock field.
To reiterate, the private lock object idiom can be used only on unconditionally thread-safe classes.
Conditionally thread-safe classes can’t use this idiom because they must document which lock their clients are to acquire when performing certain method invocation sequences.
The private lock object idiom is particularly well-suited to classes designed for inheritance (Item 17)
If such a class were to use its instances for locking, a subclass could easily and unintentionally interfere with the operation of the base class, or vice versa.
By using the same lock for different purposes, the subclass and the base class could end up “stepping on each other’s toes.” This is not just a theoretical problem.
To summarize, every class should clearly document its thread safety properties with a carefully worded prose description or a thread safety annotation.
Conditionally thread-safe classes must document which method invocation sequences require external synchronization, and which lock to acquire when executing these sequences.
If you write an unconditionally thread-safe class, consider using a private lock object in place of synchronized methods.
This protects you against synchronization interference by clients and subclasses and gives you the flexibility to adopt a more sophisticated approach to concurrency control in a later release.
Item 71: Use lazy initialization judiciously Lazy initialization is the act of delaying the initialization of a field until its.
If the value is never needed, the field is never initialized.
This technique is applicable to both static and instance fields.
As is the case for most optimizations, the best advice for lazy initialization is “don’t do it unless you need to” (Item 55)
It decreases the cost of initializing a class or creating an instance, at the expense of increasing the cost of accessing the lazily initialized field.
Depending on what fraction of lazily initialized fields eventually require initialization, how expensive it is to initialize them, and how often each field is accessed, lazy initialization can (like many “optimizations”) actually harm performance.
If a field is accessed only on a fraction of the instances of a class and it is costly to initialize the field, then lazy initialization may be worthwhile.
The only way to know for sure is to measure the performance of the class with and without lazy initialization.
In the presence of multiple threads, lazy initialization is tricky.
If two or more threads share a lazily initialized field, it is critical that some form of synchronization be employed, or severe bugs can result (Item 66)
All of the initialization techniques discussed in this item are thread-safe.
Under most circumstances, normal initialization is preferable to lazy initialization.
Here is a typical declaration for a normally initialized instance field.
If you use lazy initialization to break an initialization circularity, use a synchronized accessor, as it is the simplest, clearest alternative:
Lazy initialization of instance field - synchronized accessor private FieldType field;
Both of these idioms (normal initialization and lazy initialization with a synchronized accessor) are unchanged when applied to static fields, except that you add the static modifier to the field and accessor declarations.
If you need to use lazy initialization for performance on a static field, use the lazy initialization holder class idiom.
The beauty of this idiom is that the getField method is not synchronized and performs only a field access, so lazy initialization adds practically nothing to the cost of access.
A modern VM will synchronize field access only to initialize the class.
Once the class is initialized, the VM will patch the code so that subsequent access to the field does not involve any testing or synchronization.
If you need to use lazy initialization for performance on an instance field, use the double-check idiom.
This idiom avoids the cost of locking when accessing the field after it has been initialized (Item 67)
The idea behind the idiom is to check the value of the field twice (hence the name double-check): once without locking, and then, if the field appears to be uninitialized, a second time with locking.
Only if the second check indicates that the field is uninitialized does the call initialize the field.
Because there is no locking if the field is already initialized, it is critical that the field be declared volatile (Item 66)
In particular, the need for the local variable result may be unclear.
What this variable does is to ensure that field is read only once in the common case where it’s already initialized.
While not strictly necessary, this may improve performance and is more elegant by the standards applied to low-level concurrent programming.
On my machine, the method above is about 25 percent faster than the obvious version without a local variable.
Today, the double-check idiom is the technique of choice for lazily initializing an instance field.
While you can apply the double-check idiom to static fields as well, there is no reason to do so: the lazy initialization holder class idiom is a better choice.
Occasionally, you may need to lazily initialize an instance field that can tolerate repeated initialization.
If you find yourself in this situation, you can use a variant of the double-check idiom that dispenses with the second check.
Single-check idiom - can cause repeated initialization! private volatile FieldType field;
All of the initialization techniques discussed in this item apply to primitive fields as well as object reference fields.
When the double-check or single-check idiom is applied to a numerical primitive field, the field’s value is checked against 0 (the default value for numerical primitive variables) rather than null.
If you don’t care whether every thread recalculates the value of a field, and the type of the field is a primitive other than long or double, then you may choose to remove the volatile modifier from the field declaration in the single-check idiom.
It speeds up field access on some architectures, at the expense of additional initializations (up to one per thread that accesses the field)
This is definitely an exotic technique, not for everyday use.
It is, however, used by String instances to cache their hash codes.
In summary, you should initialize most fields normally, not lazily.
If you must initialize a field lazily in order to achieve your performance goals, or to break a harmful initialization circularity, then use the appropriate lazy initialization technique.
For instance fields, it is the double-check idiom; for static fields, the lazy initialization holder class idiom.
For instance fields that can tolerate repeated initialization, you may also consider the single-check idiom.
When many threads are runnable, the thread scheduler determines which ones get to run, and for how long.
Any reasonable operating system will try to make this determination fairly, but the policy can vary.
Therefore, well-written programs shouldn’t depend on the details of this policy.
Any program that relies on the thread scheduler for correctness or performance is likely to be nonportable.
The best way to write a robust, responsive, portable program is to ensure that the average number of runnable threads is not significantly greater than the number of processors.
This leaves the thread scheduler with little choice: it simply runs the runnable threads till they’re no longer runnable.
The program’s behavior doesn’t vary too much, even under radically different thread-scheduling policies.
Note that the number of runnable threads isn’t the same as the total number of threads, which can be much higher.
The main technique for keeping the number of runnable threads down is to have each thread do some useful work and then wait for more.
Threads should not run if they aren’t doing useful work.
Tasks shouldn’t be too small, or dispatching overhead will harm performance.
Threads should not busy-wait, repeatedly checking a shared object waiting for something to happen.
Besides making the program vulnerable to the vagaries of the scheduler, busy-waiting greatly increases the load on the processor, reducing the amount of useful work that others can accomplish.
As an extreme example of what not to do, consider this perverse reimplementation of CountDownLatch:
While this example may seem a bit far-fetched, it’s not uncommon to see systems with one or more threads that are unnecessarily runnable.
When faced with a program that barely works because some threads aren’t getting enough CPU time relative to others, resist the temptation to “fix” the program by putting in calls to Thread.yield.
You may succeed in getting the program to work after a fashion, but it will not be portable.
The same yield invocations that improve performance on one JVM implementation might make it worse on a second and have no effect on a third.
A better course of action is to restructure the application to reduce the number of concurrently runnable threads.
A related technique, to which similar caveats apply, is adjusting thread priorities.
Thread priorities are among the least portable features of the Java platform.
It is not unreasonable to tune the responsiveness of an application by tweaking a few thread priorities, but it is rarely necessary and is not portable.
It is unreasonable to solve a serious liveness problem by adjusting thread priorities.
The problem is likely to return until you find and fix the underlying cause.
In the first edition of this book, it was said that the only use most programmers would ever have for Thread.yield was to artificially increase the concurrency for testing.
The idea was to shake out bugs by exploring a larger fraction of the program’s statespace.
This technique was once quite effective, but it was never guaranteed to work.
It is within specification for Thread.yield to do nothing at all, simply returning control to its caller.
Therefore, you should use Thread.sleep(1) instead of Thread.yield for concurrency testing.
In summary, do not depend on the thread scheduler for the correctness of your program.
As a corollary, do not rely on Thread.yield or thread priorities.
Thread priorities may be used sparingly to improve the quality of service of an already working program, but they should never be used to “fix” a program that barely works.
Along with threads, locks, and monitors, a basic abstraction offered by the threading system is thread groups.
Thread groups were originally envisioned as a mechanism for isolating applets for security purposes.
They never really fulfilled this promise, and their security importance has waned to the extent that they aren’t even mentioned in the standard work on the Java security model [Gong03]
Given that thread groups don’t provide any security functionality to speak of, what functionality do they provide? Not much.
They allow you to apply certain Thread primitives to a bunch of threads at once.
Several of these primitives have been deprecated, and the remainder are infrequently used.
In an ironic twist, the ThreadGroup API is weak from a thread safety standpoint.
To get a list of the active threads in a thread group, you must invoke the enumerate method, which takes as a parameter an array large enough to hold all the active threads.
The activeCount method returns the number of active threads in a thread group, but there is no guarantee that this count will still be accurate once an array has been allocated and passed to the enumerate method.
If the thread count has increased and the array is too small, the enumerate method silently ignores any threads for which there is no room in the array.
The API that lists the subgroups of a thread group is similarly flawed.
While these problems could have been fixed with the addition of new methods, they haven’t, because there is no real need: thread groups are obsolete.
To summarize, thread groups don’t provide much in the way of useful functionality, and much of the functionality they do provide is flawed.
Thread groups are best viewed as an unsuccessful experiment, and you should simply ignore their existence.
If you design a class that deals with logical groups of threads, you should probably use thread pool executors (Item 68)
Encoding an object as a byte stream is known as serializing the object; the reverse process is known as deserializing it.
Once an object has been serialized, its encoding can be transmitted from one running virtual machine to another or stored on disk for later deserialization.
Serialization provides the standard wire-level object representation for remote communication, and the standard persistent data format for the JavaBeans component architecture.
A notable feature of this chapter is the serialization proxy pattern (Item 78), which can help you avoid many of the pitfalls of object serialization.
Item 74: Implement Serializable judiciously Allowing a class’s instances to be serialized can be as simple as adding the words “implements Serializable” to its declaration.
Because this is so easy to do, there is a common misconception that serialization requires little effort on the part of the programmer.
While the immediate cost to make a class serializable can be negligible, the long-term costs are often substantial.
A major cost of implementing Serializable is that it decreases the flexibility to change a class’s implementation once it has been released.
When a class implements Serializable, its byte-stream encoding (or serialized form) becomes part of its exported API.
Once you distribute a class widely, you are generally required to support the serialized form forever, just as you are required to support all other parts of the exported API.
If you do not make the effort to design a custom serialized form, but merely accept the default, the serialized form will forever be tied to the class’s original internal representation.
In other words, if you accept the default serialized form, the class’s private and package-private instance.
If you accept the default serialized form and later change the class’s internal representation, an incompatible change in the serialized form might result.
Clients attempting to serialize an instance using an old version of the class and deserialize it using the new version will experience program failures.
Doing so will add to the initial cost of development, but it is worth the effort.
Even a well-designed serialized form places constraints on the evolution of a class; an ill-designed serialized form can be crippling.
A simple example of the constraints on evolution that accompany serializability concerns stream unique identifiers, more commonly known as serial version UIDs.
Every serializable class has a unique identification number associated with it.
If you do not specify this number explicitly by declaring a static final long field named serialVersionUID, the system automatically generates it at runtime by applying a complex procedure to the class.
The automatically generated value is affected by the class’s name, the names of the interfaces it implements, and all of its public and protected members.
If you change any of these things in any way, for example, by adding a trivial convenience method, the automatically generated serial version UID changes.
A second cost of implementing Serializable is that it increases the likelihood of bugs and security holes.
Normally, objects are created using constructors; serialization is an extralinguistic mechanism for creating objects.
Whether you accept the default behavior or override it, deserialization is a “hidden constructor” with all of the same issues as other constructors.
Because there is no explicit constructor associated with deserialization, it is easy to forget that you must ensure that it guarantees all of the invariants established by the constructors and that it does not allow an attacker to gain access to the internals of the object under construction.
Relying on the default deserialization mechanism can easily leave objects open to invariant corruption and illegal access (Item 76)
A third cost of implementing Serializable is that it increases the testing burden associated with releasing a new version of a class.
When a serializable class is revised, it is important to check that it is possible to serialize an instance in the new release and deserialize it in old releases, and vice versa.
These tests cannot be constructed automatically because, in addition to binary compatibility, you must test for semantic compatibility.
The greater the change to a serializable class, the greater the need for testing.
Implementing the Serializable interface is not a decision to be undertaken lightly.
It is essential if a class is to participate in a framework that relies on serialization for object transmission or persistence.
Also, it greatly eases the use of a class as a component in another class that must implement Serializable.
There are, however, many real costs associated with implementing Serializable.
Each time you design a class, weigh the costs against the benefits.
As a rule of thumb, value classes such as Date and BigInteger should implement Serializable, as should most collection classes.
Classes representing active entities, such as thread pools, should rarely implement Serializable.
Classes designed for inheritance (Item 17) should rarely implement Serializable, and interfaces should rarely extend it.
Violating this rule places a significant burden on anyone who extends the class or implements the interface.
There are times when it is appropriate to violate the rule.
For example, if a class or interface exists primarily to participate in a framework that requires all participants to implement Serializable, then it makes perfect sense for the class or interface to implement or extend Serializable.
Classes designed for inheritance that do implement Serializable include Throwable, Component, and HttpServlet.
Throwable implements Serializable so exceptions from remote method invocation (RMI) can be passed from server to client.
Component implements Serializable so GUIs can be sent, saved, and restored.
If you implement a class with instance fields that is serializable and extendable, there is a caution you should be aware of.
If the class has invariants that would be violated if its instance fields were initialized to their default values (zero for integral types, false for boolean, and null for object reference types), you must add this readObjectNoData method to the class:
In case you’re curious, the readObjectNoData method was added in release 1.4 to cover a corner case involving the addition of a serializable superclass to an existing serializable class.
Details can be found in the serialization specification [Serialization, 3.5]
There is one caveat regarding the decision not to implement Serializable.
If a class that is designed for inheritance is not serializable, it may be impossible to write a serializable subclass.
Specifically, it will be impossible if the superclass does not provide an accessible parameterless constructor.
Therefore, you should consider providing a parameterless constructor on nonserializable classes designed for inheritance.
Often this requires no effort because many classes designed for inheritance have no state, but this is not always the case.
It is best to create objects with their invariants already established (Item 15)
If client-provided data is required to establish these invariants, this precludes the use of a parameterless constructor.
Naively adding a parameterless constructor and a separate initialization method to a class whose remaining constructors establish its invariants would complicate the state space, increasing the likelihood of error.
Here is a way to add a parameterless constructor to a nonserializable extendable class that avoids these deficiencies.
The following transformation adds a protected parameterless constructor and an initialization method.
The initialization method has the same parameters as the normal constructor and establishes the same invariants.
Note that the variables that store the object’s state (x and y) can’t be final, as they are set by the initialize method:
All public and protected instance methods in AbstractFoo must invoke checkInit before doing anything else.
This ensures that method invocations fail quickly and cleanly if a poorly written subclass fails to initialize an instance.
This is necessary to ensure object integrity in the face of a determined adversary.
In the absence of this precaution, if one thread were to invoke initialize on an instance while a second thread attempted to use it, the second thread might see the instance in an inconsistent state.
With this mechanism in place, it is reasonably straightforward to implement a serializable subclass:
They use compiler-generated synthetic fields to store references to enclosing instances and to store values of local variables from enclosing scopes.
How these fields correspond to the class definition is unspecified, as are the names of anonymous and local classes.
Therefore, the default serialized form of an inner class is illdefined.
Unless a class is to be thrown away after a short period of use, implementing Serializable is a serious commitment that should be made with care.
Extra caution is warranted if a class is designed for inheritance.
For such classes, an intermediate design point between implementing Serializable and prohibiting it in subclasses is to provide an accessible parameterless constructor.
This design point permits, but does not require, subclasses to implement Serializable.
When you are producing a class under time pressure, it is generally appropriate to concentrate your efforts on designing the best API.
Sometimes this means releasing a “throwaway” implementation that you know you’ll replace in a future release.
Normally this is not a problem, but if the class implements Serializable and uses the default serialized form, you’ll never be able to escape completely from the throwaway implementation.
It happened to several classes in the Java platform libraries, including BigInteger.
Do not accept the default serialized form without first considering whether it is appropriate.
Accepting the default serialized form should be a conscious decision that this encoding is reasonable from the standpoint of flexibility, performance, and correctness.
Generally speaking, you should accept the default serialized form only if it is largely identical to the encoding that you would choose if you were designing a custom serialized form.
The default serialized form of an object is a reasonably efficient encoding of the physical representation of the object graph rooted at the object.
In other words, it describes the data contained in the object and in every object that is reachable from this object.
It also describes the topology by which all of these objects are interlinked.
The ideal serialized form of an object contains only the logical data represented by the object.
The default serialized form is likely to be appropriate if an object’s physical representation is identical to its logical content.
For example, the default serialized form would be reasonable for the following class, which simplistically represents a person’s name:
Logically speaking, a name consists of three strings that represent a last name, a first name, and a middle name.
The instance fields in Name precisely mirror this logical content.
Even if you decide that the default serialized form is appropriate, you often must provide a readObject method to ensure invariants and security.
In the case of Name, the readObject method must ensure that lastName and firstName are non-null.
Note that there are documentation comments on the lastName, firstName, and middleName fields, even though they are private.
That is because these private fields define a public API, which is the serialized form of the class, and this public API must be documented.
The presence of the @serial tag tells the Javadoc utility to place this documentation on a special page that documents serialized forms.
Near the opposite end of the spectrum from Name, consider the following class, which represents a list of strings (ignoring for the moment that you’d be better off using one of the standard List implementations):
Physically, it represents the sequence as a doubly linked list.
If you accept the default serialized form, the serialized form will painstakingly mirror every entry in the linked list and all the links between the entries, in both directions.
Using the default serialized form when an object’s physical representation differs substantially from its logical data content has four disadvantages:
It permanently ties the exported API to the current internal representation.
In the above example, the private StringList.Entry class becomes part of the public API.
If the representation is changed in a future release, the StringList class will still need to accept the linked list representation on input and generate it on output.
The class will never be rid of all the code dealing with linked list entries, even if it doesn’t use them anymore.
In the above example, the serialized form unnecessarily represents each entry in the linked list and all the links.
These entries and links are mere implementation details, not worthy of inclusion in the serialized form.
Because the serialized form is excessively large, writing it to disk or sending it across the network will be excessively slow.
The serialization logic has no knowledge of the topology of the object graph, so it must go through an expensive graph traversal.
In the example above, it would be sufficient simply to follow the next references.
The default serialization procedure performs a recursive traversal of the object graph, which can cause stack overflows even for moderately sized object graphs.
Serializing a StringList instance with 1,258 elements causes the stack to overflow on my machine.
The number of elements required to cause this problem may vary depending on the JVM implementation and command line flags; some implementations may not have this problem at all.
A reasonable serialized form for StringList is simply the number of strings in the list, followed by the strings themselves.
This constitutes the logical data represented by a StringList, stripped of the details of its physical representation.
Here is a revised version of StringList containing writeObject and readObject methods implementing this serialized form.
As a reminder, the transient modifier indicates that an instance field is to be omitted from a class’s default serialized form:
If all instance fields are transient, it is technically permissible to dispense with invoking defaultWriteObject and defaultReadObject, but it is not recommended.
Even if all instance fields are transient, invoking defaultWriteObject affects the serialized form, resulting in greatly enhanced flexibility.
The resulting serialized form makes it possible to add nontransient instance fields in a later release while preserving backward and forward compatibility.
If an instance is serialized in a later version and deserialized in an earlier version, the added fields will be ignored.
Note that there is a documentation comment on the writeObject method, even though it is private.
This is analogous to the documentation comment on the private fields in the Name class.
This private method defines a public API, which is the serialized form, and that public API should be documented.
To lend some sense of scale to the earlier performance discussion, if the average string length is ten characters, the serialized form of the revised version of StringList occupies about half as much space as the serialized form of the original.
On my machine, serializing the revised version of StringList is over twice as fast as serializing the original version, again with a string length of ten.
Finally, there is no stack overflow problem in the revised form, hence no practical upper limit to the size of a StringList that can be serialized.
While the default serialized form would be bad for StringList, there are classes for which it would be far worse.
For StringList, the default serialized form is inflexible and performs badly, but it is correct in the sense that serializing and deserializing a StringList instance yields a faithful copy of the original object with all of its invariants intact.
The physical representation is a sequence of hash buckets containing key-value entries.
The bucket that an entry resides in is a function of the hash code of its key, which is not, in general, guaranteed to be the same from JVM implementation to JVM implementation.
In fact, it isn’t even guaranteed to be the same from run to run.
Therefore, accepting the default serialized form for a hash table would constitute a serious bug.
Whether or not you use the default serialized form, every instance field that is not labeled transient will be serialized when the defaultWriteObject method is invoked.
Therefore, every instance field that can be made transient should be made so.
This includes redundant fields, whose values can be computed from “primary data fields,” such as a cached hash value.
It also includes fields whose values are tied to one particular run of the JVM, such as a long field representing a pointer to a native data structure.
Before deciding to make a field nontransient, convince yourself that its value is part of the logical state of the object.
If you use a custom serialized form, most or all of the instance fields should be labeled transient, as in the StringList example shown above.
If you are using the default serialized form and you have labeled one or more fields transient, remember that these fields will be initialized to their default values when an instance is deserialized: null for object reference fields, zero for numeric primitive fields, and false for boolean fields [JLS, 4.12.5]
If these values are unacceptable for any transient fields, you must provide a readObject method that invokes the defaultReadObject method and then restores transient fields to acceptable values (Item 76)
Alternatively, these fields can be lazily initialized the first time they are used (Item 71)
Whether or not you use the default serialized form, you must impose any synchronization on object serialization that you would impose on any other method that reads the entire state of the object.
So, for example, if you have a thread-safe object (Item 70) that achieves its thread safety by synchronizing every method, and you elect to use the default serialized form, use the following writeObject method:
Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write.
This eliminates the serial version UID as a potential source of incompatibility (Item 74)
If no serial version UID is provided, an expensive computation is required to generate one at runtime.
If you write a new class, it doesn’t matter what value you choose for randomLongValue.
You can generate the value by running the serialver utility on the class, but it’s also fine to pick a number out of thin air.
If you modify an existing class that lacks a serial version UID, and you want the new version to accept existing serialized instances, you must use the value that was automatically generated for the old version.
You can get this number by running the serialver utility on the old version of the class—the one for which serialized instances exist.
If you ever want to make a new version of a class that is incompatible with existing versions, merely change the value in the serial version UID declaration.
To summarize, when you have decided that a class should be serializable (Item 74), think hard about what the serialized form should be.
Use the default serialized form only if it is a reasonable description of the logical state of the object; otherwise design a custom serialized form that aptly describes the object.
You should allocate as much time to designing the serialized form of a class as you allocate to designing its exported methods (Item 40)
Just as you cannot eliminate exported methods from future versions, you cannot eliminate fields from the serialized form; they must be preserved forever to ensure serialization compatibility.
Choosing the wrong serialized form can have a permanent, negative impact on the complexity and performance of a class.
Item 39 contains an immutable date-range class containing mutable private Date fields.
The class goes to great lengths to preserve its invariants and its immutability by defensively copying Date objects in its constructor and accessors.
Suppose you decide that you want this class to be serializable.
Because the physical representation of a Period object exactly mirrors its logical data content, it is not unreasonable to use the default serialized form (Item 75)
Therefore, it might seem that all you have to do to make the class serializable is to add the words “implements Serializable” to the class declaration.
If you did so, however, the class would no longer guarantee its critical invariants.
The problem is that the readObject method is effectively another public constructor, and it demands all of the same care as any other constructor.
Just as a constructor must check its arguments for validity (Item 38) and make defensive.
If a readObject method fails to do either of these things, it is a relatively simple matter for an attacker to violate the class’s invariants.
Loosely speaking, readObject is a constructor that takes a byte stream as its sole parameter.
In normal use, the byte stream is generated by serializing a normally constructed instance.
The problem arises when readObject is presented with a byte stream that is artificially constructed to generate an object that violates the invariants of its class.
Assume that we simply added implements Serializable to the class declaration for Period.
This ugly program would then generate a Period instance whose end precedes its start:
To fix this problem, provide a readObject method for Period that calls defaultReadObject and then checks the validity of the deserialized object.
While this fix prevents an attacker from creating an invalid Period instance, there is a more subtle problem still lurking.
It is possible to create a mutable Period instance by fabricating a byte stream that begins with a valid Period instance and then appends extra references to the private Date fields internal to the Period instance.
The attacker reads the Period instance from the ObjectInputStream and then reads the “rogue object references” that were appended to the stream.
These references give the attacker access to the objects referenced by the private Date fields within the Period object.
By mutating these Date instances, the attacker can mutate the Period instance.
To see the attack in action, run the following program:
While the Period instance is created with its invariants intact, it is possible to modify its internal components at will.
Once in possession of a mutable Period instance, an attacker might cause great harm by passing the instance on to a class that depends on Period’s immutability for its security.
This is not so far-fetched: there are classes that depend on String’s immutability for their security.
The source of the problem is that Period’s readObject method is not doing enough defensive copying.
When an object is deserialized, it is critical to defensively copy any field containing an object reference that a client must not possess.
Therefore, every serializable immutable class containing private mutable components must defensively copy these components in its readObject method.
The following readObject method suffices to ensure Period’s invariants and to maintain its immutability:
Note that the defensive copy is performed prior to the validity check and that we did not use Date’s clone method to perform the defensive copy.
Both of these details are required to protect Period against attack (Item 39)
Note also that defensive copying is not possible for final fields.
To use the readObject method, we must make the start and end fields nonfinal.
This is unfortunate, but it is the lesser of two evils.
With the new readObject method in place and the final modifier removed from the start and end fields, the MutablePeriod class is rendered ineffective.
In release 1.4, the writeUnshared and readUnshared methods were added to ObjectOutputStream with the goal of thwarting rogue object reference attacks without the cost of defensive copying [Serialization]
They are typically faster than defensive copying, but they don’t provide the necessary safety guarantee.
Here is a simple litmus test for deciding whether the default readObject method is acceptable for a class: would you feel comfortable adding a public constructor that took as parameters the values for each nontransient field in the object and stored the values in the fields with no validation whatsoever? If not, you must provide a readObject method, and it must perform all the validity checking and defensive copying that would be required of a constructor.
Alternatively, you can use the serialization proxy pattern (Item 78)
There is one other similarity between readObject methods and constructors, concerning nonfinal serializable classes.
A readObject method must not invoke an overridable method, directly or indirectly (Item 17)
If this rule is violated and the method is overridden, the overriding method will run before the subclass’s state has been deserialized.
To summarize, anytime you write a readObject method, adopt the mind-set that you are writing a public constructor that must produce a valid instance regardless of what byte stream it is given.
Do not assume that the byte stream represents an actual serialized instance.
While the examples in this item concern a class that uses the default serialized form, all of the issues that were raised apply equally to classes with custom serialized forms.
Here, in summary form, are the guidelines for writing a bulletproof readObject method:
For classes with object reference fields that must remain private, defensively copy each object in such a field.
Do not invoke any overridable methods in the class, directly or indirectly.
Item 77: For instance control, prefer enum types to readResolve.
Item 3 describes the Singleton pattern and gives the following example of a singleton class.
This class restricts access to its constructor to ensure that only a single instance is ever created:
As noted in Item 3, this class would no longer be a singleton if the words “implements Serializable” were added to its declaration.
Any readObject method, whether explicit or default, returns a newly created instance, which will not be the same instance that was created at class initialization time.
The readResolve feature allows you to substitute another instance for the one created by readObject [Serialization, 3.7]
If the class of an object being deserialized defines a readResolve method with the proper declaration, this method is invoked on the newly created object after it is deserialized.
The object reference returned by this method is then returned in place of the newly created object.
In most uses of this feature, no reference to the newly created object is retained, so it immediately becomes eligible for garbage collection.
If the Elvis class is made to implement Serializable, the following readResolve method suffices to guarantee the singleton property:
Return the one true Elvis and let the garbage collector // take care of the Elvis impersonator.
This method ignores the deserialized object, returning the distinguished Elvis instance that was created when the class was initialized.
Therefore, the serialized form of an Elvis instance need not contain any real data; all instance fields should be declared transient.
The attack is a bit complicated, but the underlying idea is simple.
If a singleton contains a nontransient object reference field, the contents of this field will be deserialized before the singleton’s readResolve method is run.
This allows a carefully crafted stream to “steal” a reference to the originally deserialized singleton at the time the contents of the object reference field are deserialized.
First, write a “stealer” class that has both a readResolve method and an instance field that refers to the serialized singleton in which the stealer “hides.” In the serialization stream, replace the singleton’s nontransient field with an instance of the stealer.
You now have a circularity: the singleton contains the stealer and the stealer refers to the singleton.
Because the singleton contains the stealer, the stealer’s readResolve method runs first when the singleton is deserialized.
As a result, when the stealer’s readResolve method runs, its instance field still refers to the partially deserialized (and as yet unresolved) singleton.
The stealer’s readResolve method copies the reference from its instance field into a static field, so that the reference can be accessed after the readResolve method runs.
The method then returns a value of the correct type for the field in which it’s hiding.
If it didn’t do this, the VM would throw a ClassCastException when the serialization system tried to store the stealer reference into this field.
Here is a “stealer” class, constructed as per the description above:
Finally, here is an ugly program that deserializes a handcrafted stream to produce two distinct instances of the flawed singleton.
The deserialize method is omitted from this program because it’s identical to the one on page 303:
Running this program produces the following output, conclusively proving that it’s possible to create two distinct Elvis instances (with different tastes in music):
You could fix the problem by declaring the favorites field transient, but you’re better off fixing it by making Elvis a single-element enum type (Item 3)
As of release 1.5, this is no longer the best way to maintain instance control in a serializable class.
As demonstrated by the ElvisStealer attack, this technique is fragile and demands great care.
The JVM makes this guarantee, and you can depend on it.
The use of readResolve for instance control is not obsolete.
If you place a readResolve method on a final class, it should be private.
If you place a readResolve method on a nonfinal class, you must carefully consider its accessibility.
If it is private, it will not apply to any subclasses.
If it is package-private, it will apply only to subclasses in the same package.
If it is protected or public, it will apply to all subclasses that do not override it.
If a readResolve method is protected or public and a subclass does not override it, deserializing a serialized subclass instance will produce a superclass instance, which is likely to cause a ClassCastException.
To summarize, you should use enum types to enforce instance control invariants wherever possible.
As mentioned in Item 74 and discussed throughout this chapter, the decision to implement Serializable increases the likelihood of bugs and security problems, because it causes instances to be created using an extralinguistic mechanism in place of ordinary constructors.
There is, however, a technique that greatly reduces these risks.
First, design a private static nested class of the serializable class that concisely represents the logical state of an instance of the enclosing class.
This nested class, known as the serialization proxy, should have a single constructor, whose parameter type is the enclosing class.
This constructor merely copies the data from its argument: it need not do any consistency checking or defensive copying.
By design, the default serialized form of the serialization proxy is the perfect serialized form of the enclosing class.
Both the enclosing class and its serialization proxy must be declared to implement Serializable.
Period is so simple that its serialization proxy has exactly the same fields as the class:
Next, add the following writeReplace method to the enclosing class.
This method can be copied verbatim into any class with a serialization proxy:
The presence of this method causes the serialization system to emit a SerializationProxy instance instead of an instance of the enclosing class.
In other words, the writeReplace method translates an instance of the enclosing class to its serialization proxy prior to serialization.
With this writeReplace method in place, the serialization system will never generate a serialized instance of the enclosing class, but an attacker might fabricate one in an attempt to violate the class’s invariants.
To guarantee that such an attack would fail, merely add this readObject method to the enclosing class:
Finally, provide a readResolve method on the SerializationProxy class that returns a logically equivalent instance of the enclosing class.
The presence of this method causes the serialization system to translate the serialization proxy back into an instance of the enclosing class upon deserialization.
This readResolve method creates an instance of the enclosing class using only its public API, and therein lies the beauty of the pattern.
It largely eliminates the extralinguistic character of serialization, because the deserialized instance is created using the same constructors, static factories, and methods as any other instance.
This frees you from having to separately ensure that deserialized instances obey the class’s invariants.
If the class’s static factories or constructors establish these invariants, and its instance methods maintain them, you’ve ensured that the invariants will be maintained by serialization as well.
Unlike the two previous approaches, this one allows the fields of Period to be final, which is required in order for the Period class to be truly immutable (Item 15)
And unlike the two previous approaches, this one doesn’t involve a great deal of thought.
There is another way in which the serialization proxy pattern is more powerful than defensive copying.
The serialization proxy pattern allows the deserialized instance to have a different class from the originally serialized instance.
You might not think that this would be useful in practice, but it is.
If the underlying enum type has sixty-four or fewer elements, the static factories return a RegularEnumSet; otherwise, they return a JumboEnumSet.
Now consider what happens if you serialize an enum set whose enum type has sixty elements, then add five more elements to the enum type, and then deserialize the enum set.
It was a RegularEnumSet instance when it was serialized, but it had better be a JumboEnumSet instance once it is deserialized.
In fact that’s exactly what happens, because EnumSet uses the serialization proxy pattern.
It is not compatible with classes that are extendable by their clients (Item 17)
Finally, the added power and safety of the serialization proxy pattern are not free.
On my machine, it is 14 percent more expensive to serialize and deserialize Period instances with serialization proxies than it is with defensive copying.
In summary, consider the serialization proxy pattern whenever you find yourself having to write a readObject or writeObject method on a class that is not extendable by its clients.
This pattern is perhaps the easiest way to robustly serialize objects with nontrivial invariants.
Enforce the singleton property with a private constructor or an enum type.
Use checked exceptions for recoverable conditions and runtime exceptions for programming errors.
