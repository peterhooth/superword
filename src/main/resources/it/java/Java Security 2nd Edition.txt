Preface When I first mentioned to a colleague of mine that I was writing a book on JavaTM security, he immediately starting asking me questions about firewalls and Internet DMZs.
Another colleague overheard us and started asking about electronic commerce, which piqued the interest of a third colleague who wanted to hear all about virtual private networks.
All this was interesting, but what I really wanted to talk about was how a Java applet could be allowed to read a file.
Such is the danger of anything with the word "security" in its title: security is a broad topic, and everyone has his or her own notion of what security means.
Complicating this issue is the fact that Java security and network security (including Internet security) are complementary and sometimes overlapping topics: you can send encrypted data over the network with Java, or you can set up a virtual private network that encrypts all your network traffic and remove the need for encryption within your Java programs.
From a programming perspective, we assume that developers who read this book have a good knowledge of how to program in Java, and in particular how to write Java applications.
When we discuss advanced security features and cryptographic algorithms, we do so assuming that the programmer is primarily interested in using the API to perform certain tasks.
Hence, we explain at a rudimentary level what a digital signature is and how it is created and used, but we do not explain the cryptographic theory behind a digital signature or prove that a.
For developers who are sufficiently versed in these matters, we also show how the APIs may be extended to support new types of cryptographic algorithms, but again we leave the mathematics and rigorous definitions of cryptography for another book.
We also discuss three Java extensions in this book: version 1.2.1 of the Java Cryptography Extension, version Service.
Code examples used in this book are available from the O'Reilly web site located at http://www.oreilly.com/catalog/javasec2/
When a new method or class is introduced, its definition will appear beginning with italicized text like this:
There are some examples of commands scattered through the book, especially in sections and appendices that deal with administration.
By convention, most examples are shown as they would be executed on a Unix system, e.g.:
When an argument requires a URL, we always specify the protocol to distinguish it from a filename, even though tools will often accept the string without a protocol.
The code examples in this book (and in the online samples) are organized by chapter.
When you unpack the online code, you'll end up with a single directory (javasec), from which the remaining directories and source files descend.
The first is to remain in the directory where you unpacked the sources, not set your classpath, and reference everything by full package name.
Hence, to compile and run the Test class from Chapter 3, you'd execute these commands:
Alternately, you can work in the directory containing the source and set your classpath as follows:
When required for space, commands may be continued on multiple lines, in which case a backslash character is used:
Commands that appear like this should be typed on one line or typed on multiple lines using whatever escape character is appropriate for your system (e.g., the backslash for a Unix system)
Chapter 1 This chapter gives an overview of the security model (the Java sandbox) used in Java applications and sets the stage for the rest of the book.
Chapter 2 This chapter discusses the parameters of the default sandbox and how the sandbox may be changed administratively.
It provides instructions for end users and administrators on how to set up Java security policies (including the use of policytool) and introduces the concepts by which these policies are implemented.
Chapter 3 This chapter discusses the memory protections built into the Java language, how those protections provide a measure of security, and how they are enforced by the bytecode verifier.
Chapter 6 This chapter discusses the class loader, which is the class that reads in Java class files and turns them into classes.
From a security perspective, the class loader is important in determining where classes originated and whether or not they were digitally signed (and if so, by whom), so the topic of class loaders appears throughout this book.
Chapter 7 This chapter provides an overview to the cryptographic algorithms of the Java security package.
It provides a background for the remaining chapters in the book.
Chapter 8 This chapter discusses the architecture of the Java security package and how that architecture may be used to extend or supplant the default cryptographic algorithms that come with the SDK.
Chapter 9 This chapter discusses the APIs available to model cryptographic keys and certificates.
Chapter 10 This chapter discusses how keys can be managed within a Java program: how and where they may be stored and how they can be retrieved and validated.
Chapter 11 This chapter discusses message digests: how to create them, how to use them, and how to implement them.
Chapter 12 This chapter discusses how to create, use, and implement digital signatures.
Chapter 13 This chapter discusses the encryption available within Java Cryptography Extension (JCE), which allows developers to encrypt and decrypt arbitrary data.
Chapter 14 This chapter discusses how the Java Secure Sockets Extension (JSSE) provides SSL encryption, which can be used to encrypt data over TCP sockets.
It also provides an implementation of the HTTPS Internet protocol.
Chapter 15 This chapter discusses how the Java Authentication and Authorization Service (JAAS) enables applications to authenticate users and grant them particular permissions based on their login ID or other credentials.
Appendix A This appendix provides an annotated listing of the java.security file, which is the standard configuration file for the Java security architecture.
Appendix C Key management in Java 1.1 was radically different than the systems we explored in the main text.
Appendix E In the text, we discuss how to implement standard security providers.
Appendix F This appendix is a simple reference guide to the classes discussed in this book.
What's New in This Edition The second edition of this book provides new chapters on JSSE and JAAS, which have only recently been released.
It provides updated information on JCE version 1.2.1, including modified code examples.
Please let us know about any errors you find, as well as your suggestions for future editions, by writing to:
We have a web page for this book, where we list errata, examples, or any additional information.
To comment or ask technical questions about this book, send email to:
For more information about our books, conferences, software, Resource Centers, and the O'Reilly Network, see our web site at:
Acknowledgments I am grateful to the many people who have helped me with this book along the way; this book is as much a reflection of their support as anything else.
I offer my heartfelt thanks to Mike Loukides and Deb Cameron for stewarding me through the editorial process.
Finally, I must offer my thanks to James for all his patience and support and for putting up with my continual state of distraction during phases of this process.
Feedback for the Author I welcome any comments on the text you might have; despite the contributions of the people I've listed, any errors or omissions in the text are my responsibility.
Just as different developers came to Java with different expectations, so too did they bring different expectations as to what was meant by the ubiquitous phrase "Java is secure." Security means different things to different people, and many developers who had certain expectations about the word "security" were surprised to find that their expectations were not necessarily shared by the designers of Java.
The term "security" is vague unless it is discussed in some context; different expectations of the term "security" might lead us to expect that Java programs would be:
Safe from malevolent programs Programs should not be allowed to harm a user's computing environment, such as Trojan horses and harmful programs that replicate, like computer viruses.
In fact, while all of these features could be part of a secure system, only the first two were within the province of Java's 1.0 default security model.
Still others of these items will be added in the future.
But the basic premise remains that Java security was originally and fundamentally designed to protect the information on a computer from being accessed or modified (including a modification that would introduce a virus) while still allowing the Java program to run on that computer.
When we refer to a specific release, we'll use its number; otherwise, we'll say Java 2 to refer to either platform.
Each of these contributes certain technologies to the Java security story.
Information about the extensions is presented thoughout the book as it makes sense.
The JSSE API defines a set of classes that are used to perform SSL operations, and these are discussed in a separate chapter.
The JSSE API also defines a set of classes that are used for key management; these are discussed along with the classes in the core API that handle key management.
So even though these three packages are standard extensions, we recommend that you install them now along with the SDK so that you can become familiar with their features when they arise.
In version 1.4, all these extensions are scheduled to be included in the core SDK, which is another reason why it helps to think of them as an integrated unit.
In the next few pages, we'll discuss how to obtain and install the platform and extensions.
Configuring the extensions may require some steps that you don't understand right now because they have various security options that apply to them.
However, we recommend that you just follow the instructions for now and install the extensions.
The extensions use Java's standard security framework, and as we discuss each aspect of the framework, we detail how the extensions relate to that aspect.
Thus, while the core features of each extension is discussed in its own chapter, information about the extensions appears throughout the book.
The core Java 2 platform supplies the basic facilities of Java security:
A configurable security policy that lets you prevent Java programs from reading your files, making network connections to other hosts, accessing your printer without permission, and so on.
This policy is based on Java's access controller, which in turn depends upon Java's class loaders, security manager, and language protections.
The ability to generate message digests if you want a simple (but not secure) way to determine if data your program reads has been altered.
The ability to generate digital signatures if you want to detect if data your program reads has been altered (or if you want to send data and enable the recipient of that data to detect if the data was altered in transit)
A key management system to manage the keys necessary for digital signatures..
The Java 2 platform contains two flavors: the Software Development Kit (SDK, also known historically as the JDK) and the Java Runtime Environment (JRE)
Administration of the security model applies to both the JRE and SDK, but to use the security APIs that we discuss, you'll need the SDK (which includes the JRE)
When you work with the extensions that we use in this book, you have the option of treating them as installed or bundled extensions.
Installed extensions are much easier to work with: they require no special configuration once they are installed.
Depending on your setup, this may require special operating system privileges.
Version 1.2.1 is an important version because it takes advantage of a change in the policy of the United States regarding export controls of cryptographic engines.
Prior to early 2000, the United States government considered cryptographic engines to be a munition and severely restricted the export of such technology.
As a result, although it performs strong encryption, JCE 1.2.1 can be exported from the United States.
Like most extensions, you can install JCE as a bundled or unbundled extension.
Note that this is a URL; you use forward slashes no matter what your platform.
In every program that you run, you must insert the following line:
More details about how this works can be found in later chapters.
If you need to communicate with an SSL server or SSL client, you can use the APIs in this extension.
If you are writing both a client and server and want to do encryption, you can use this extension or you can use the cipher facilities of JCE.
Version 1.0.2 takes advantage of the relaxed export restrictions of the U.S.
Unlike JCE, however, there are still two different versions of JSSE: one for domestic use (use within the United States and Canada) and one for global use.
The difference between these two versions is that the domestic version allows you to substitute new implementations of the SSL algorithms.
Such substitution is still prohibited by export rules, so the global version does not allow it.
However, both versions provide exactly the same API and the same key strength for their encryption.
This line should immediately follow the line you inserted for JCE.
In every program that you run, you must insert the following line:
All of the core facilities of Java's security design are intended to protect end users from the influences of developers: end users give permissions to developers to access resources on the end user's machine.
JAAS, on the other hand, allows developers to grant (or deny) access to their programs based on the authentication credentials provided by the user.
The jar file should either be installed into $JREHOME/lib/ext, or the user must add it to her classpath.
On Microsoft Windows systems, these libraries are named nt.dll, nt.lib, and nt.exp and they must be installed into $JREHOME\bin.
No modification to the java.security file is required for JAAS.
In France, for example, it is illegal to import many encryption packages without a license.
Other countries have regulations for cryptography, but in most cases they are less onerous than those of the United States.
However, it is always wise to check your local policies to be sure (see Appendix B, for resources to find more information about these limitations)
You may not export either JCE or JSSE (and, hence, any programs that use them) to the following countries: Afghanistan, Cuba, Iran, Iraq, Libya, North Korea, Serbia/Montenegro (Yugoslavia), Sudan, Syria and parties listed on the Denied and Restricted Parties List (available at http://bxa.fedworld.gov/prohib.html)
Additionally, it is Sun company policy not to ship products to Burma.
The whole question of importing and exporting encryption technology occurs because it is often classified as a munition.
While this position is sometimes questioned, it comes from a long tradition in computer science.
During WWII, the Allies waged a successful and pivotal campaign in the Atlantic against the Axis navy.
The success of this campaign was greatly due to the work of Alan Turing, who with his colleagues broke the German encryption algorithm known as Enigma.
Turing was also one of the founding fathers of modern computer science, much of which was based on the work he developed in service to his country during the war.
Ironically, the reward that Turing reaped for his efforts was that some years after the war, he was arrested and forced to undergo harmful chemical treatments because he was gay.
There's an odd parallel here: many of the harsh restrictions that are sometimes placed on encryption technology make no more sense in a world with a global Internet than did England's persecution of Alan Turing in the 1950s.
Perhaps the relaxation of export restrictions is a good sign in general.
This security model centers around the idea of a sandbox.
The idea is when you allow a program to be hosted on your computer, you want to provide an environment where the program can play (i.e., run), but you want to confine the program's play area in certain bounds.
You may decide to give the program certain toys to play with (i.e., you may decide to let it have access to certain system resources), but in general, make sure that the program is confined to its sandbox.
This analogy works better when you consider it from the view of a close relative rather than from the view of a parent.
If you're a parent, you probably consider the purpose of a sandbox to be to provide a safe environment for your child to play in.
When my niece Rachel visits me, however, I consider the purpose of a sandbox not (only) to be to protect her, but also to protect my grandmother's china from her.
I love my niece, but I can't give her leave to run through my house; I enjoy running the latest cool applet on the Internet, but I can't give it leave to run through my filesystem.
Internally, it has access to its local memory (the computer's RAM)..
Externally, it has access to its filesystem and to other machines on the local network..
For running applets, it also has access to a web server, which may be on its local (private) net or may be on the Internet.
Data flows through this entire model, from the user's machine through the network and (possibly) to disk.
A sandbox in which the program has access to the CPU and its own memory as well as access to the web server from which it was loaded.
This is often thought of as the default state for the sandbox.
An open sandbox, in which the program has access to whatever resources the host machine normally has access to.
Any program, including an applet, can change the behavior of the sandbox under certain circumstances.
The default sandbox, as we'll see in Chapter 2, is very flexible; it allows the user who runs the program to determine exactly how the sandbox will operate.
This moves the definition of the security policy to the end user or system administrator of the machine running the program.
The bytecode verifier The bytecode verifier ensures that Java class files follow the rules of the Java language.
In terms of resources, the bytecode verifier helps enforce memory protections for all Java programs.
As the figure implies, not all classes are subject to bytecode verification.
The class loader One or more class loaders load all Java classes.
Programatically, the class loader can set permissions for each class it loads.
The access controller The access controller allows (or prevents) most access from the core API to the operating system, based upon policies set by the end user or system administrator.
The security manager The security manager is the primary interface between the core API and the operating system; it has the ultimate responsibility for allowing or preventing access to all system resources.
However, it exists mostly for historical reasons; it defers its actions to the access controller.
The security package The security package (that is, classes in the java.security package as well as those in the security extensions) allows you to add security features to your own application as well as providing the basis by which Java classes may be signed.
Although it is only a small box in this diagram, the security package is a complex API and discussion of it is broken into several chapters of this book.
The key database The key database is a set of keys used by the security infrastructure to create or verify digital signatures.
In the Java architecture, it is part of the security package, though it may be manifested as an external file or database.
The last two items in this list have broad applicability beyond expanding the Java sandbox.
With respect to the sandbox, digital signatures play an important role because they provide authentication of who actually provided the Java class.
As we'll see, this provides the ability for end users and system administrators to grant very specific privileges to individual classes or signers.
But a digital signature might be used for other applications.
Let's say that you're deploying a payroll application throughout a large corporation.
When an employee sends a request to view his payroll information, you really want to make sure that the request came from that employee rather than from someone else in the corporation.
Often, this type of application is secured by a simple password, but a more secure system could require a digitally signed request before it sent out the payroll information.
This list is also a rough outline of the path we'll take through this book.
We'll start by looking at the default sandbox and how it can be administered.
Following that, we'll look at the details of everything that makes up that sandbox, from the bytecode verifier through the access controller.
Then we'll move into the security APIs that allow you to add digital signatures and encryption to your own applications.
The Java security packages include debugging code that you can enable via a system property.
Trace all calls to the checkPermission( ) method of the access controller.
This allows you to see which permissions your code is requesting, which calls are succeeding, and which ones are failing.
As you progress through the samples in the book, you can turn various options on in order to see more information about what's going on.
The information in this chapter is targeted to end users and system administrators: those are the people who are ultimately responsible for defining the security policies that their programs use.
Except in special circumstances, it is not possible to change security policies programmatically: in the default sandbox, there is no API that a developer can use that allows her to change a security policy.
If you want your program to read a local file, then you must tell the user who will run that program to modify the security policy of his machine before he runs your program.
However, developers do need to understand the concepts (and especially the terms) that we define in this chapter.
In the next few chapters, we'll discuss the programmatic details of how the sandbox is implemented; this will give you a better understanding of how Java security works and allow you to develop your own programs that implement a different security policy.
But we'll start with the default sandbox, an administratable, flexible model used by most Java programs.
From an administrative point of view, the sandbox is composed of five elements:
Permissions A permission is a specific action that code is allowed to perform.
Permissions are composed of three elements: the type of the permission, its name, and its actions.
The type of the permission is required; it is the name of a particular Java class that implements the permission.
Although no programming is involved in administering the default sandbox, administrators must know the Java class name of various permissions in order to allow code to perform those operations.
Otherwise, the name is based on the type of the permission; for example, the name of a file permission is a file or directory name.
The names of permissions are often specified as wildcards, such as all files in a directory or all hosts on the local network.
The actions of a permission also vary based on the type of the permission; many permissions have no action at all.
The action specifies what may be done to the target; a file permission may specify that a particular file can be read, written, deleted, or some combination of those actions.
The first carries only a type; the second carries a type and a name; the third carries a type, a name, and a set of actions:
If code is signed, information about the signer is included in the code source.
However, it's important to note that the URL and signer information in a code source are both optional.
Classes can be assigned permissions based only on the URL from which the class was loaded, based only upon who signed the class, or a combination of both.
Hence, it is not required that code be signed in order for it to carry special permissions.
The URL within a code source is called a codebase.
Protection domains A protection domain is an association of permissions with a particular code source.
Policy files Policy files are the administrative element that controls the sandbox.
A policy file contains one or more entries that define a protection domain; less formally, we can say that an entry in a policy file grants specific permissions to code that is loaded from a particular location and/or signed by a particular entity.
Keystores Code signing is one way in which code can be granted more latitude.
The rationale behind code signing is discussed in Chapter 7, but if you are assured that code you are running came from an organization that you trust, you may feel comfortable allowing that code to read the files on your disk, send jobs to the printer, or whatever.
Signed code depends on public key certificates, and there is a lot of administration that takes place when you use certificates.
The certificates themselves are held in a location (usually a file) called the keystore.
If you are a developer, the keystore is consulted to find the certificate used to sign your code; if you are an end user or system administrator, the keystore is consulted when you run signed code to see who actually signed the code.
In the next few sections, we'll look at these elements in more depth.
Every Java class carries a set of permissions that defines the activities that the class is allowed to perform.
The parameters of the sandbox are wholly defined by these permissions.
When a Java program attempts to perform a sensitive operation, the permissions for all active classes are consulted: if every class carries the permission.
Otherwise, an exception is thrown in the code, and the operation fails.
In Chapter 5, we'll explain in detail what we mean when we say that the permissions of "active" classes are used to determine if an operation succeeds.
In general, though, it matters which code initiates an operation.
An applet cannot initiate a print job unless it has been explicitly granted permission to do so.
However, users can print applets by initiating the print job through the browser.
Even though the applet code is active, the browser code is still granted permission to execute the print operation.
Classes that make up the core Java API are always given permission to perform any action.
All other classes, including those on the classpath, must explicitly be given permission to perform sensitive operations.
For the most part, these permissions are listed in various policy files, along with the code source to which they apply.
End users and system administrators define the parameters of the sandbox by administering these policy files.
The permissions within the virtual machine are based on an extensible system of Java classes.
Hence, any Java API or application can define its own permissions and ensure that the user has granted those permissions to the API before it can run.
Classes that want to participate in a Jini community must be granted this permission in order to execute the code that participates in Jini's discovery protocol.
In general, then, you may need to become familiar with arbitrary permission types in order to use certain APIs.
Here are the standard permissions used by the core Java API.
You can specify multiple actions for a particular file by separating the actions with commas.
Remember that file permissions can be overridden by platform permissions: simply because you specify that the Java program has permission to read the /etc/shadow file (a privileged Unix file), a Java application will be unable to do so unless it is run by the Unix super user.
Code is always able to read files from the directory hierarchy from which it was loaded; this particular permission cannot be changed administratively, although it can be changed programatically.
The file separator expansion we have mentioned is a specific example of a general rule: names in permissions may contain any defined environment variable.
If they are used, they will be treated as literal strings and fail.
In particular, the hostname may be given as a hostname (possibly DNS qualified) or an IP address.
These map into the normal socket usage: accept is used to see if the program can accept an incoming connection from a particular host; listen is used to see if the program can accept any incoming socket connections; connect is used to see if the program can make a connection to a particular host; and resolve is used to see if the IP address for a particular hostname can be obtained from the machine's name service.
Code is always able to make a socket connection to (and accept a connection from) the host from which it was loaded, even if that specific permission is not listed in a policy file.
That particular permission cannot be changed by an end user or administrator (though it can be changed by a developer)
By default, that is set to classes within the sun package.
If you wanted additionally to prevent code from accessing classes in the sdo package, you would edit the java.security file so that it defined a property like this:
Then code would be able to access classes in the sdo.foo package but not other classes in any other sdo package.
Both the define and access permissions also require cooperation of the class loader; class loaders determine whether or not to enforce those permissions.
Note, however, that you cannot define any class in the java package, regardless of any permission that you have set.
The stopThread permission is listed in the default global policy file so that any code can stop a thread.
This is for backward compatibility and may change in future releases (the stop( ) method, of course, has been deprecated)
The modifyThread and modifyThreadGroup permissions are used only if the thread or thread group the program is attempting to modify is the system thread group.
Programs generally create and manipulate threads in the main thread group, a subgroup of the system thread group, so these permissions rarely come into play.
You either have permission to perform a runtime operation, or you do not.
There are six names supported by this class, as listed here:
All possible names are listed in here; as we explore the security API throughout the rest of the book, we'll mention when the names apply.
Many of these names are not used in the Java 2 platform because they refer to deprecated classes.
The latter permission allows the ObjectInputStream and ObjectOutputStream classes to be subclassed, which would potentially override the readObject( ) and writeObject( ) methods.
If granted, this permission allows reflection to examine the private variables of arbitrary classes.
Java code can be signed, which entails obtaining digital certificates and running the jarsigner (or equivalent) tool.
You can grant permissions to code that is signed by a particular entity.
If you choose to handle signed code, you must establish a keystore to hold the public keys of the signing entity.
Before you run the signed code, you must obtain the public key certificate of the signing entity and install that certificate into your keystore.
Some browsers (e.g., Netscape 6) allow you to accept the public key certificate when you first run the signed program, but usually you must install the public key certificate before.
Administration of the keystore is handled by the keytool utility (see Chapter 10)
By default, the keystore is held in a file called .keystore in the user's home directory.
When you install a public key certificate into the keystore, you give that certificate an alias that is used to look up the certificate in the future.
For example, my public key certificate lists my full name and other identifying information, but you may enter it into your keystore with an alias of sdo.
This alias is the information that you list in a policy file.
The signer field must match the alias listed in the keystore, as we've just described.
Only the classes in the jar file belong to the codebase.
Only class files in the given directory belong to the codebase.
Jar files in the given directory do not belong to the codebase.
Both jar files and class files in the given directory belong to the codebase.
However, jar and class files in subdirectories of the URL do not belong to the codebase.
All jar and class files in the given directory and its subdirectories belong to the codebase.
Note this directory syntax is not affected by package names.
In order to administer the Java sandbox, you list the various permissions we've discussed in a Java policy file.
Java virtual machines can use any number of policy files, but there are two that are used by default.
We consider this to be a global policy file because it allows an environment where the JRE is mounted from a common server by several machines; each of these machines will share the definitions in this file.
You can administer them with policytool, or you can edit them by hand.
Hand editing is discouraged (in 1.3, policytool writes a warning at the top of the file not to edit it by hand), but real programmers still edit them by hand.
Policy files are also used with JAAS, in which case their syntax changes slightly and you must edit them by hand (at least until 1.4, when JAAS becomes integrated with the SDK)
So first, we'll see how they look, and then we'll look at how they are created with policytool.
Note how the policy file combines all the elements of the sandbox: the code sources (the combination of signedBy and codeBase elements) are associated with various permissions to create protection domains; the entire file is subject to the given keystore.
The first line of this example tells the virtual machine to consult the keystore in the file $HOME/.keystore when it needs to check the certificates of entities that have signed code.
The next four blocks of text define protection domains: code that is loaded from O'Reilly's web site has permission to read files in /tmp and to start a print job; code that is signed by sdo and loaded from Sun's web site has permission to do anything it wants to; code that is signed by jra is able to operate on any nonprivileged socket; and all code is allowed to read the java.vendor system property.
In each of these blocks, the syntax is the same: the word grant is followed by a code source and then a set of permissions enclosed by braces.
The code source is composed of a codebase and a signer, either of which may be blank.
In most cases, code that you run is loaded from only a single location: if you run the applet contained on the java.sun.com home page, you load all the code from java.sun.com.
So only the permissions in a protection domain with that code source are in force while you run that code.
In order for the applet to be able to talk to the stock quote server, both codebases must contain the appropriate socket permissions.[1]
If you leave out the codebase or the signer from a code source in this file, then that entry is considered a wildcard.
In the example above, code that is signed by jra can open sockets regardless of where the code was loaded from; if code signed by jra is loaded from the O'Reilly web site, then that code can open sockets, read files in /tmp, and initiate print jobs.
If the signer is not present, then it does not matter whether or not the code is signed: both signed code and unsigned code loaded from the O'Reilly web site can read files in /tmp or initiate print jobs.
Similarly, if both the codebase and signer are omitted, then the permissions listed apply to code loaded from any location, whether or not it is signed.
In sum, the permissions granted to a particular code source are taken as the union of all permissions between all policy files used by the virtual machine for all relevant codebases and/or signers.
The permissions given to an application are determined by the intersection of all permissions in all active code sources.
Note that the keystore entry for this file is .keystore.
You can change that value through an option under the Edit menu.
You can add new codebases to this file by selecting the Add Policy Entry button; when you add a policy entry, you are allowed to specify a URL and a signer (both of which are optional)
The entry for the signer should be an alias in the keystore; if you enter a signer who is not in the keystore, you'll get a warning, but the operation will continue.
You may delete codebases by selecting one and pressing the Remove Policy Entry button.
Selecting a codebase and pressing the Edit Policy Entry button allows you to edit the specific set of permissions for a codebase.
The window where you add permissions contains three pulldown menus in which you can select the permission type, name, and action(s)
The list of permission types in the pulldown is limited to those defined.
Virtually all of the permissions granted to code comes from policy files.
However, advanced applications are allowed to grant additional permissions to code that they load, and standard Java class loaders grant some additional permissions to every class that they load.
Classes that are loaded from the filesystem are always granted permission to read files in the directory hierarchy from which they were loaded.
Classes that are loaded via HTTP are always granted permission to establish a connection back to the host from which they were loaded; they are also granted permission to accept a connection from that host.
And now, putting this all together, let's examine the default sandbox of various Java environments:
Java applications For applications invoked via the Java command line, the sandbox is initially disabled.
Once enabled, the security manager will use the two default policy files to determine the parameters of the sandbox.
You can specify a full URL (e.g., with an http: or file: protocol) or simply list a filename.
Putting this all together, here's how we would run the class PayrollApp in the default sandbox with additional permissions loaded from the file java.policy in the local directory:
These browsers do allow code to be signed, in which case the user can optionally grant the code permission to perform many operations.
In addition, they allow developers to ask for particular operations to be performed using proprietary APIs.
One way or another, the three common Java environments will use the same policy files to determine the parameters of the sandbox.
All other code is allowed to call Thread.stop( ), to listen on an unprivileged port, and to read a limited set of system properties.
And that's it: no file access, no other socket access, and so on (other than the file and socket access granted to all files that we mentioned earlier)
Even the ability to listen on an unprivileged port is of dubious value: in order to complete a socket connection, the program is required to accept a connection from a particular IP address.
The accept permission is not granted in this file; it must be enabled elsewhere in order for a program to open a server socket.
Many parameters of the default sandbox are controlled by entries in the java.security file.
That file has several entries that we'll examine throughout this book; an annotated version of it appears in Appendix A.
In terms of the default sandbox, here are the important entries:
If you would prefer a different set of policy files to be used by default, you can edit the java.security file and change the URLs that are used.
As we've seen, users can specify any number of policy files on the command line as well.
A site that has that value set to false, removes the user's .java.policy entry from this file, and makes the java.security file uneditable by end users has established a sandbox that cannot be modified by end users.
We've shown several examples of how properties can be used in policy files in order to make them more portable.
If you want to disable substitution of properties, set the expandProperties property to false.
In 1.2, there is no prohibition against defining classes in the java package.
Appendix D, shows how you can build a 1.1 application to run other Java applications with a security policy that you've written yourself.
In this chapter, we examined the bounds and adaptability of the Java sandbox.
The default sandbox is set up to be administered through a series of policy files, which contain sets of explicit permissions associated with code; this association depends on where the code was loaded from and/or who signed the code.
Java Language Security The first components of the Java sandbox that we will examine are those built into the Java language itself.
These components primarily protect memory resources on the user's machine, although they have some benefit to the Java API as well.
Hence, they are primarily concerned with guaranteeing the integrity of the memory of the machine that is hosting a program: in a nutshell, the security features within the Java language want to ensure that a program will be unable to discern or modify sensitive information that may reside in the memory of a user's machine.
In terms of applets, these protections also mean that applets will be unable to determine information about each other; each applet is given, in essence, its own memory space in which to operate.
In this chapter, we'll look at the features of the Java language that provide this type of security.
We'll also look at how these features are enforced, including a look at Java's bytecode verifier.
With a few exceptions, the information in this chapter is largely informational; because the features we are going to discuss are immutable within the Java language, there are fewer programming considerations than we'll find in later chapters.
However, the information presented here is crucial in understanding the entire Java security story; it is very helpful in ensuring that your Java environment is secure and in assessing the security risks that Java deployment might pose.
The security of the Java environment is dependent on the security of each of its pieces, and the Java language forms the first fundamental piece of that security.
Default (or package) The entity can be accessed by code that is contained within the class that defines the entity, or by a class that is contained in the same package as the class that defines the entity.
The notion of assigning data entities an access level is certainly not exclusive to Java; it's a hallmark of many.
In a large project with multiple programmers, there's a strong argument that such an.
This is only one example of why the Java platform must provide memory integrity: that is, it must ensure that entities in memory are accessed only when they are allowed to be and that these entities cannot be somehow corrupted.
In Java, you cannot be allowed to treat a private entity as anything but private: the intentions of the programmer must always be respected.
Object serialization involves an exception to this rule; we'll give more details about that a little bit later.
This is easy to ensure, as Java does not have the notion of a pointer.
For example, casting between an int and an Object is strictly illegal in Java.
Entities that are declared as final must not be changed.
Final variables in Java are considered constants; they are immutable once they are initialized.
Consider the havoc that could ensue if the final modifier were not respected:
A public final variable could be changed, drastically altering the behavior of a program.
If a rogue applet swapped the values of the variables EAST and WEST in the GridBagConstraints class, for example, any new applets would be laid out incorrectly (and probably incomprehensibly)
That's a rather benign example of what could potentially be a dramatic security flaw.
A subclass could override a final method, altering the behavior of a class.
One of the features of the Java API is that threads are not allowed to raise their priority above a certain maximum priority (typically, the priority of the thread group to which the thread belongs)
This feature is enforced by the setPriority( ) method of the Thread class, which is a final method; allowing that method to be overridden would defeat the security mechanisms.
This feature is used for virtually all of Java's security checks: performing an operation requires calling a final method in a Java class; only that final method can trap into the operating system to execute the operation.
That final method is responsible for making sure the operation does not proceed if it would violate the security policy in place.
If a program were able to read the value of an uninitialized variable, the effect would be the same as if it were able to read random memory locations.
A Java class wishing to exploit this defect might then declare a huge uninitialized section of variables in an attempt to snoop the memory contents of the user's machine.
To prevent this type of attack, all local variables in Java must be initialized before they are used, and all instance variables in Java are automatically initialized to a default value.
Like the access modifiers that started this discussion, bounds checking is generally thought of in terms other than security: the prime benefit to bounds checking is that it leads to fewer bugs and more robust programs.
But it has security benefits as well: if an array of integers happens to reside in memory next to a string (which, in memory, is an array of characters), writing past the end of the array of integers would change the value of the string.
The effect of this is generally a bug, but it could be exploited as a security hole as well: if the string held the destination account number for an electronic funds transfer, we could change the destination account number by willfully writing past the end of the array of integers.[2]
This type of attack is not as farfetched as it might seem; an early version of.
Netscape Navigator suffered from just this type of security hole.
When long URLs were typed into the Goto field, the Netscape C code that read the string overwrote the bounds of the array where the characters were to be stored and clobbered a key location in memory, which allowed a security breach.
Hence, Java does not allow arbitrary casting between objects; an object can only be cast to one of its superclasses or its subclasses (if, in the latter case, the object actually is an instance of that subclass)
Note that the Java virtual machine is much stricter about this rule than the Java compiler is.
In the example above, the compiler would complain about an illegal cast.
We could satisfy the compiler by changing the code as follows:
Only the virtual machine will know if the returned object actually is of type CreditCard or not.
In this case, then, the virtual machine is responsible for throwing a ClassCastException when the snoop variable is assigned to thwart the attack.
These are the techniques by which the Java language ensures that memory locations are read and written only when such access should normally be allowed.
This restriction protects the user's machine from the outside: if I download an applet onto my machine, I don't want that applet accessing the private variables of my CreditCard class.
However, if that applet has a private variable within it, nothing prevents me (depending on my operating system) from using a program outside of the browser to scan the memory on my system and figure out somehow what value that particular variable has.
Similarly, nothing prevents me from having another program outside the browser change the value of a particular variable that is held in memory on my machine.
If you're an applet developer and are worried about this type of problem, you're pretty much on your own to come up with a solution to it.
This might be particularly troublesome if you had, say, a variable somewhere in your applet that held a Boolean value indicating whether or not the user was licensed for a particular operation; a very clever user can go outside the browser and manipulate the machine's memory so that the integrity of your licensing scheme is violated.
This problem is not new to Java, but it's not solved by Java either.
There is one general exception to the rules about public, private, and protected access in Java.
Object serialization is a feature of Java that allows an object to be written as a series of bytes; when those bytes are read someplace else, a new object is created that has the same state as the original object.
Object serialization has two main purposes: it's used extensively in the RMI API to allow clients and servers to exchange objects, and it's used whenever you need to save a particular object to disk and want to recreate the object at some later point in time.
The murky issue here is just what constitutes an object's state.
In the case of our CreditCard object, the account number is pretty basic to creating that object, but it's a variable that needs to be private for the reasons we've been discussing.
In order for object serialization to work, it must have access to those private variables so it can correctly save and restore the object's state.
That's why the object serialization API can access and save all private variables of an object (as well as its default, protected, and public variables)
Similarly, the object serialization API is able to store those values back into the private data members when the object is actually reconstituted.
Depending on your perspective, this is a good thing or a bad thing.
From a security perspective, it can be a bad thing: if the CreditCard object is saved to disk, something else can come along and read all that information from the disk file.
Worse yet, the file could be edited in such a way that the object will be recreated in a completely different state than it originally had, with potentially damaging results.
In theory, this is the same problem we just discussed about influences outside the browser being able to read and write the private data of objects that are held in memory (which may help to explain why object serialization works this way by default)
In practice, however, it's much easier to change the data in a binary file than to figure out how to access and change the value of an object in memory.
Hence, object serialization has two additional mechanisms associated with it that make it more secure.
The second of these mechanisms is that object serialization respects the transient keyword associated with a variable: if our account number in the CreditCard class were declared as private transient, then object serialization would not be allowed to read or write that particular variable.
This lets us design classes that can be stored and reconstituted without showing their private data to the world.
Of course, a CreditCard object without an account number is worthless; what we really need is something that can save and reconstitute the transient data in such a way that the data can't be compromised.
This is achieved by having our class implement the writeObject( ) and readObject( ) methods.
Similarly, the readObject( ) method uses the defaultReadObject( ) method to read the data and then must restore the corresponding transient data.
Using either of these techniques, you have the ability to protect any sensitive data contained in your objects, even if you choose to share those objects over the network or save those objects to some sort of persistent storage.
The list of rules we outlined above are fine in theory, but they must be enforced somehow.
We've always been taught that overwriting the end of an array in C code is a bad thing, but I somehow still manage to do it accidentally all the time.
There are also those who willfully attempt to overwrite the ends of arrays in an attempt to breach the security of a system.
Without mechanisms to enforce these memory rules, they become simply guidelines and provide no sort of security at all.
This necessary enforcement happens at three different times in the development and deployment of a Java program: at compile time, at link time (that is, when a class is loaded into the virtual machine), and at runtime.
Not all rules can be checked at each of these points, but certain checks are necessary at each point in order to ensure the memory security that we're after.
As we'll see, enforcement of these rules (which is really the construction of this part of the Java sandbox) varies depending on the origin of the class in question.
The Java compiler is the first thing that is tasked with the job of enforcing Java's language rules.
In particular, the compiler is responsible for enforcing all of the rules we outlined above except for the last two: the compiler cannot enforce array bound checking nor can it enforce all cases of illegal object casts.
But the validity of a cast between an object of type X to type Y where Y is a subclass of X cannot be known at compile time, so the compiler must let such a construct pass.
Okay, the compiler has produced a Java program for us, and we're about to run the Java bytecode of that program.
But if the program came from an unknown source, how do we know that the bytecodes we've received are actually legal?
Throughout this section, we're discussing the bytecode verifier as if it were tied to the Java language.
This is somewhat imprecise: the bytecode verifier is actually independent of the original source language of the program.
If we had a C++ compiler that generated Java bytecodes from C++ source, the bytecode verifier would still be able to verify (or not) the bytecodes.
However, the verification of the bytecodes would still depend upon the semantics of the Java language, and not the semantics of C++; just because the bytecodes in question originated from C++ code is no reason that they should suddenly be allowed to cast an arbitrary memory location into an object.
For this reason, I prefer to think of the bytecodes in terms of the Java language itself.
There are tools to produce Java bytecodes from other languages (like Scheme), but in general, producing Java bytecodes from another language severely limits the constructs that can be written in that other language.
If we run this code, we'll create a CreditCard object and print out its account number.
Now say that we realize the account number should really have been private, so we go back and change the definition of acctNo to be private and recompile only the CreditCard class.
We then have two class files and the Test class file contains Java code that illegally accesses the private instance variable acctNo of the CreditCard class.
The above example shows an innocent mistake, but a malicious programmer could use just this technique to produce illegal Java bytecodes.
In order to modify the contents of a string, for example, all we need to do is:
Compile this modified class, and replace the class files in the SDK.
This entails unpacking rt.jar, copying in the new classes, and repacking rt.jar.
Compile some new code against this modified version of the String class.
Now any time you want to modify a string in place, simply call this modifyString( ) method with the string you want to corrupt (src) and the new string you want it to have (dst)
The full definition of the class file format may be found in the Java virtual machine specification; the bytecode verifier is responsible for making sure that the class file has the right length, the correct magic numbers in the correct places, and so on.
One stack holds a series of method frames, where each method frame holds the local variables and other storage for a particular method invocation.
Hence, the bytecode verifier delays all tests for field and method access until the code is actually executed.
The process by which this happens is implementation independent; one technique that is often used is to ensure during verification that all accesses test the validity of the field access.
If the access is valid, the standard bytecodes are then replaced during execution with a special bytecode indicating that the test has been performed and access to the field in question no longer needs to be tested.
Like the compiler, the bytecode verifier cannot completely guarantee that the bytecodes follow all of the rules we outlined earlier in this chapter: it can only ensure that the first four of them are followed.
The virtual machine must still take responsibility for ultimately determining that the Java bytecodes provide the security we expect them to.
The remaining security protections of the Java language must be enforced at runtime by the virtual machine.
Array bounds checking In theory, the bytecode verifier can detect certain cases of array bounds checking, but in general, this check must take place at runtime.
Since nItems and a are parameters, the bytecode verifier has no way of determining whether this code is legal.
Object casting The verifier can and will detect the legality of certain types of casts, specifically whenever unrelated classes are cast to each other.
The virtual machine must monitor when a superclass is cast into a subclass and test that cast's validity; failure to execute a legal cast results in a ClassCastException.
This holds for casts involving interfaces as well since objects that are defined as an interface type (rather than a class type) are considered by the verifier to be of type Object.
One thing which has changed is bytecode verification: in 1.1, the virtual machine did not perform bytecode verification of classes on the classpath.
This is really a reflection of class loading policies: starting with the Java 2 platform, classes on the classpath are loaded by a traditional class loader, which subjects them to verification.
Nonetheless, in 1.1 only classes loaded by a browser are subject to bytecode verification.
Browsers always ensure that the code imported to run an applet is verified, and Java applications are typically not verified.
Of course, this may or may not be the perfect solution:
If a remote site can talk an end user into installing a local class in the browser's classpath, the local class will not be verified and may violate the rules we've discussed here.
In Java 2, this is much harder since the class must be added to the jar file containing the core API classes.
You may implicitly rely upon the verifier to help you keep files in sync so that when one is changed, other files are verified against it.
It's important to keep in mind that the purpose of these security constraints is to protect the user's machine from a malicious piece of code and not to protect a piece of code from a malicious user.
Java does not (and could not) prevent a user from acting on memory from outside the browser, with possibly harmful results.
The Security Manager In the next three chapters, we're going to discuss how the sandbox of a Java application is implemented.
The access controller, which provides the basis of the default implementation of the security manager..
The class loader, which encapsulates information about security policies and classes..
From the perspective of the Java API, there is a security manager that actually is in control of the security policy of an application.
The purpose of the security manager is to determine whether particular operations should be permitted or denied.
In truth, the purpose of the access controller is really the same: it decides whether access to a critical system resource should be permitted or denied.
Hence, the access controller can do everything the security manager can do.
On one level, the Java security manager is simple to understand, and it's often summarized by saying that it prevents Java applets from accessing your local disk or local network.
The real story is more complicated than that, however, with the result that Java's security manager is often misunderstood.
The programmer makes a request of the Java API to perform an operation.1
The Java API asks the security manager if such an operation is allowable.2
If the security manager does not want to permit the operation, it throws an exception back to the Java API, which in turn throws it back to the user.
Otherwise, the Java API completes the operation and returns normally.4
The FileReader object will in turn create a FileInputStream object, and constructing the input stream is the first step of the algorithm.
When the input stream is constructed, the Java API performs code similar to this:
This is step two of our algorithm and is the essence of the idea behind the security manager: when the Java API wants to perform an operation, it first checks with the security manager and then calls a private method (the open( ) method in this case) that actually performs the operation.
Meanwhile, the security manager code is responsible for deciding whether or not the file in question should be allowed to be read and, if not, for throwing a security exception:
Several methods in the SecurityManager class are similar to the checkRead( ) method.
It is up to the Java API to call those methods at the appropriate time.
You may want to call those methods from your own Java code (using the technique shown in the previous example), but that's never required.
Since the Java API provides the interface to the virtual operating system for the Java program, it's possible to isolate all the necessary security checks within the Java API itself.
Since a violation of the rules of the security manager manifests itself as a security exception, it's possible to hide the attempted operation from the user running the program by catching that exception.
To portray this feature in a positive light, it allows the developer to provide a more intelligent program that might be delivered to an end user in different ways.
If the program is delivered as an application, the author may want to save some state from the program in a file on the user's disk; if the program is delivered as an applet, the author will need to save that state by sending it to the web server.
Now the Java program has an appropriate output stream to save its data.
There are two methods in the System class that are used to work with the security manager itself:
These methods operate with the understanding that there is a single security manager in the virtual machine; the only operations that are possible on the security manager are setting it (that is, creating an instance of the security manager class and telling the virtual machine that the newly created object should be the security manager) and getting it (that is, asking the virtual machine to return the object that is the security manager so that a method might be invoked upon it)
Now that we have an understanding of how the security manager works, we'll look into what protection the security manager actually provides.
We'll discuss the public methods of the security manager that perform security checks and when those methods are called, along with the rationale behind each of the methods.
Since these methods are all public, they can be called anywhere, including in your own code, although as we've mentioned, that's a rare thing.
The real point of this section is so that you can know which methods of the core Java API are affected by the security manager and to give you some background on why these choices were made.
When we discuss the methods below, we speak of them in terms of trusted and untrusted classes.
A trusted class is a class of the core Java API or a class that has been granted explicit permission to perform the operation in question.
In fact, the basic implementation of each method of the security manager is to test to ensure that each active protection domain has permission to perform the desired operation.
These are the methods the security manager uses to track file access:
Check whether the program is allowed to read the given file.
The first of these methods succeeds if the current protection domain has been granted the runtime permission with the name readFileDescriptor.
The other methods succeed if the current protection domain has a file permission with a name that matches the given file and an action of read.
Check whether the program is allowed to write the given file.
The first of these methods succeeds if the current protection domain has been granted the runtime permission with the name.
The second succeeds if the current protection domain has a file permission with a name that matches the given file and an action of write.
This table lists only those classes that directly call the security manager method in question.
There may be many routes through the Java API that lead to one of these checks; for example, when a FileReader object is constructed, it will construct a FileInputStream object, which will result in a call to checkRead( )
Method Called By Rationale checkRead(  ) File.canRead(  ) Test if the current thread can read the file.
FileInputStream(  ) RandomAccessFile(  ) Constructing a file object requires that you read the file.
Determining whether a file object is an actual file or a directory requires that you read the file.
File.length(  ) Determining the length requires that you read the file's attributes.
File.list(  ) Determining the files in a directory requires that you read the directory.
To construct a file object, you must be able to write the file.
File.mkdir(  ) To create a directory, you must be able to write to thefilesystem.
File.renameTo(  ) To rename a file, you must be able to write to the directory containing the file.
If you carefully considered the list of methods in the table above, you were probably surprised not to see an obvious method to check: the actual read( ) or write( ) methods of any of the File classes.
The assumption here is that a trusted class is responsible for determining the security policy associated with any particular File object; if the trusted class decides that it is okay for an untrusted class to perform I/O on a particular File*Stream object, then it is free to deliver that object to the untrusted class, and the untrusted class is free to read or write to that object.
This implementation also allows for much greater efficiency: if the program had to check with the security manager every time it called the read( ) or write( ) methods, I/O performance would drastically suffer.
Now consider what happens if an applet downloaded onto a machine on the local network can connect to other machines on the local network.
Network sockets can be logically divided into two classes: client sockets and server sockets.
A client socket is responsible for initiating a conversation with an existing server socket; server sockets sit idle waiting for these requests to come from client sockets.
Untrusted classes are by default restricted from creating server sockets.[2]
Technically, untrusted classes by default can create a server socket, since the default policy.
Once created, however, the server socket must accept a connection on the socket, and that action is by default denied.
The security manager uses the following methods to check network access:
Check if the program can open a client socket to the given port on the given host.
This succeeds if the current protection domain has a socket permission with a name that matches the host and port and an action of connect.
Test if the untrusted class can see any hosts on the local network.
Test if the untrusted class can operate on a multicast socket.
Test if the untrusted class can accept a server connection.
Test if the untrusted class can alter the manner in which all sockets are created.
On the other hand, there's a good chance the outside web server already has that.
If our request passed through a firewall or proxy server, there's a chance that some of this information was prevented from passing to the outside web server, but that's not necessarily the case either.
This method is also used to determine whether the Java program will automatically follow redirect messages when opening a URL.
When a Java program opens a URL, the server to which it is connected may send back a redirect response (an HTTP response code of 3xx)
Often, browsers follow these redirects transparently to the user; in Java, the programmer has the ability to determine if the redirection should automatically be followed or not.
An untrusted class is not able to change whether redirection is on or off.
The HttpURLConnection class that uses this method is abstract, so the actual behavior of this class may be overridden in a particular implementation.
Class loaders are protected since they provide information to the security manager.
See if the current thread has been granted a particular permission.
Hence, an untrusted class is typically not allowed to create a class loader.
This method is only called by the constructor of the ClassLoader class: if you can create a class loader (or if you obtain a reference to a previously created class loader), you can use it.
To succeed, the current protection domain must have a runtime permission with the name createClassLoader.
The separate process would not need to be written in Java, of course, so there.
Check to see if the current thread has the given permission.
It is also used directly by the Java API when it.
This method succeeds if the current protection domain has been granted the given permission.
Untrusted classes may only manipulate threads that they have created.
Untrusted classes can only affect thread groups that they have created.
Stopping a thread could corrupt state of the virtual machine.
Unlike the other public methods of the security manager, the getThreadGroup( ) method is not responsible for deciding whether access to a particular resource should be granted or not, and it does not throw a security exception under any circumstances.
The point of this method is to determine the default thread group that a particular thread should belong to.
When a thread is constructed and does not ask to be placed into a particular thread group, the getThreadGroup( ) method of the security manager is used to find a thread group to which the thread should be assigned.
By default, this is the thread group of the calling thread.
The getThreadGroup( ) method can be used to create a hierarchy of thread groups.
One popular use of this method is to segregate applets loaded from different sites into their own thread group; in a server, it could be used to segregate the threads assigned to different clients into different thread groups.
Doing so requires some cooperation with the class loader since it forms a natural boundary between different applets or different clients.
However, a full hierarchy of thread groups does not mesh well with Java's default thread permission model, so we won't discuss that option in the main text.
In Appendix D, we discuss the implementation of a different security manager that uses this notion of a thread group hierarchy.
The Thread class also calls the checkPermission( ) method of the security manager whenever the stop( ) method is called since stopping a thread is an inherently dangerous operation (which has led the stop( ) method to become deprecated)
For backward compatibility, this permission is normally granted even to untrusted classes, but an end user may change her environment so that the security manager throws an exception whenever the stop( ) method is called.
Can't change the locale unless the user.language property can be read.
Can't get a font unless its property can be read.
Windows created by untrusted classes should have an indentifying banner.
In order to succeed, the current protection domain must have an AWT permission with the name queuePrintJob.
The Java virtual machine has a set of global (system) properties that contains information about the user and the user's machine: login name, home directory, etc.
Untrusted classes are generally denied access to some of this information in an attempt to limit the amount of spying that an applet can do.
As usual, these methods only prevent access to the system properties; an untrusted class is free to set up its own properties and to share those properties with other classes if it desires.
To succeed, the current protection domain must carry a property permission.
If a key is specified, then the name of the property permission must include the given key and have an action of read.
Otherwise, the name of the property permission must be "*" and the action must be read and write.
Note that unlike other methods in the security manager, this method has three outcomes: if it returns true, the window will be created normally; if it returns false, the window will be created with the identifying banner.
Theoretically, this method could also throw a security exception (just like all the other methods of the security manager class) to indicate that the window should not be created at all; no popular implementations do that.
Untrusted classes can only inspect public information about other classes.
Check if the untrusted class can access classes in a particular package.
Check if the untrusted class can load classes in a particular package.
In Chapter 3, we examined the importance of the access modifiers to the integrity of Java's security model.
Java's reflection API allows programs to inspect classes to determine the class's methods, variables, and constructors.
The ability to access these entities can impact the memory integrity that Java provides.
The reflection API is powerful enough that, by inspection, a program can determine the private instance variables and methods of a class (although it cannot actually access those variables or call those methods)
All classes are allowed to inspect any other class and find out about its public variables and methods.
All classes loaded by the same class loader are allowed to inspect all of each other's variables and methods.
This allows the security manager to prevent an untrusted class from loading a class from the network and placing it into, for example, the java.lang package.
That's all the methods of the security manager class that are used by the Java API to perform checks on certain operations.
There are other public and protected methods of the SecurityManager class that we have not examined in this chapter; those methods are generally only used when you implement your own security manager without using the access controller, so we will defer their discussion to Appendix D.
In the next chapter, we'll discuss how the security manager is usually implemented.
In addition, in Appendix D, we'll show how a security manager could be implemented in order to specify a policy for applications run in 1.1
The default notion of what constitutes a trusted class has changed significantly between releases of Java:
In Java 1.0, a class that is loaded from the classpath is considered trusted and a class that is loaded from a class loader is considered untrusted.
In Java 2, only classes in the core API are considered trusted.
Other classes must be given explicit permission to perform the operations we've discussed.
Attempting to call this method after a security manger has already been installed will result in a SecurityException.
In 1.0, untrusted classes were typically not allowed to create a server socket at all, which meant that the checkListen( ) and checkAccept( ) methods always threw a security exception when an.
Note too that the receive( ) method of the DatagramSocket class in Java 2 now calls the checkAccept( ) rather than the checkConnect( ) method.
In 1.1, attempts to redirect the standard input, output, and error streams call the checkExec() method rather than the checkPermission( ) method.
In fact, the checkPermission( ) method does not exist at all in 1.1 and earlier releases.
In 1.1, by default each applet is given an individual thread group, and the threads within that group can manipulate other threads within that group without respect to any additional hierarchy.
The getThreadGroup( ) method is only present in Java 1.1 and subsequent releases.
In Java 1.0 (and browsers built on that release), thread security was generally nonexistent: any thread could manipulate the state of any other thread, and applets weren't able to create their own thread groups.
We examined in this chapter all the times when the security manager is asked to make a decision regarding access; such decisions range from the expected file and network access to more esoteric decisions, such as whether a frame needs a warning banner or what thread group a particular thread should belong to.
This gave us a basic understanding of how the security manager is used to enforce a specific policy and the issues involved when defining such a policy.
This knowledge will be used as a basis in the next few chapters when.
The Access Controller In the last chapter, we looked at the security manager, which provides the security policy interface used by the core Java API.
The implementation of most security managers, however, is based entirely upon the access controller.
In this chapter, we're going to look at the access controller and its related classes.
Along the way, we'll cover a number of important topics:
How to implement and use your own permission classes to extend the mechanism of the Java sandbox to your own applications.
How to implement a different security policy so that permissions can be set in new ways (e.g., by reading them from a central server rather than from a collection of files)
How the core Java API is able to perform certain operations that other classes cannot..
How to create objects that can only be accessed if you have the appropriate permission..
The access controller is built upon the four concepts we examined in Chapter 2 :
Code sources An encapsulation of the location from which certain Java classes were obtained.
Permissions An encapsulation of a request to perform a particular operation.
Policies An encapsulation of all the specific permissions that should be granted to specific code sources.
Protection domains An encapsulation of a particular code source and the permissions granted to that code source.
We'll start by examining how these concepts map to the Java API.
A code source is a simple object that reflects the URL from which a class was loaded and the keys (if any) that were used to sign that class.
Class loaders are responsible for creating and manipulating code source objects, as we'll see in the next chapter.
Two code source objects are considered equal if they were loaded from the same URL (that is, the equals( ) method for the URL of the objects returns true) and the array of certificates is equal (that is, a comparison of each certificate in the array of certificates will return true)
In Chapter 6, we'll show how to construct and use class loaders; later in this chapter, we'll see how they fit into the design of the access controller.
For example, if we construct a permission object that represents access to a file, possession of that object does not mean we have permission to access the file.
Rather, possession of the object allows us to ask if we have permission to access the file.
In the case of file permissions, the name is obviously the file.
This is only a concern to programmers when dealing with your own permission classes; as a developer you rarely need to create.
On the other hand, this naming convention is of concern to end users and administrators, who must know the name of the permission they want to grant to the programs they are going to run.
The presence of actions is dependent upon the semantics of the specific type of permission.
A file permission object has a list of actions that could include read, write, and delete; an XYZ payroll permission object could have a list of actions that includes view and update.
On the other hand, a window permission does not have an action: you either have permission to create the window or you don't.
The terms used to specify a list of actions are also arbitrary and handled by convention.
They allow the Java API to negotiate access to several resources (files, sockets, and so on)
Those permissions are defined by convention within the Java API, and their naming conventions are wholly within the domain of the Java API itself.
Hence, you can create an object that represents permission to read a particular file, but you cannot create an object that represents permission to copy a particular file since the copy action is not known within the file permission class.
On the other hand, you can create arbitrary permissions for use within your own programs and completely define both the names of those permissions as well as the actions (if any) that should apply.
If you are writing a payroll program, for example, you could create your own permission class that uses the convention that the name of the permission is the employee upon whose payroll information you want to act; you could use the convention that the permissible actions on the payroll permission are view and update.
Then you can use that permission in conjunction with the access controller to allow employees to view their own payroll data and to allow managers to change the payroll data for their employees.
From a developer perspective, this latter role is the more interesting, and we'll use it when we examine the permission class itself.
Permission is an abstract class that contains these public methods:
Say that you are implementing a program to administer payroll information.
You'll want to create permissions to allow users to view their payroll history.
You'll also want to allow the HR department to update the pay rate for employees.
We'll need to implement a permission class to encapsulate all of that:
Finally, the implies( ) method is responsible for determining how wildcard and other implied permissions are handled.
If the name passed to construct our object is an asterisk, then we match any other name; hence, an object to represent the permissions of the HR department might be constructed as:
When the implies( ) method is called on this wildcard object, the name will always match, and because the action mask has the complete list of actions, the mask comparison will always yield the mask that we're testing against.
If the implies( ) method is called with a different object, however, it will only return true if the names are equal and the object's mask is a subset of the target mask.
The wildcard matching of this class does not match partial names: xyz.read* wouldn't match any of the permissions we just listed.
Further, the wildcard must be in the rightmost position: *.readDatabase wouldn't match any basic permission.
The BasicPermission class is abstract, although it does not contain any abstract methods, and it completely implements all the abstract methods of the Permission class.
Hence, a concrete implementation of the BasicPermission need only contain a constructor to call the correct constructor of the superclass (since there is no default constructor in the BasicPermission class)
The access controller depends upon the ability to aggregate permissions so that it can easily call the implies( ) method on all of them.
For example, a particular user might be given permission to read.
Every permission class is required to implement a permission collection, then, which is a mechanism where objects of the same permission class may be grouped together and operated upon as a single unit.
There are three basic operations that you can perform on a permission collection:
The definition of this class seems to imply that permission collections can contain any set of arbitrary permissions (and some versions of the Java documentation state that explicitly)
Forget that idea; introducing that notion into permission collections vastly complicates matters, and the issue of a heterogeneous collection of permission objects is better handled elsewhere (we'll see how a little bit later)
As far as we're concerned, the purpose of a permission collection is to aggregate only permission objects of a particular type.
Permission collections are typically implemented as inner classes, or at least as classes that are private to the package in which they are defined.
There is, for example, a corresponding permission collection class for the FilePermission class, one for the SocketPermission class, and so on.
None of these collections is available as a public class that we can use in our own program.
This is called when the same name is added twice to the // permissions; we merge the action lists and only store the.
When you extend the Permission class, but do not do wildcard pattern matching.
Hidden internally within the Java API is a PermissionsHash class, which is the default permission collection class for permission objects.
The PermissionsHash class stores the aggregated permissions in a hashtable, so the implementations of its add( ) and elements( ) methods are straightforward.
The implementation of its implies( ) method is based on looking up the name of the permission parameter in the hashtable collection: if an entry is found, then the implies( ) method is called on that entry.
When you extend the BasicPermission class and do not provide support for actions.
This idea simplifies the implies( ) method that we showed previously.
But to be truly useful, a permission collection needs to be heterogeneous so that it can represent all the permissions a program should have.
A permission collection really needs to be able to contain file permissions, socket permissions, and other types of permissions.
This class contains a concrete implementation of a permission collection that organizes the aggregated permissions in terms of their individual, homogenous permission collections.
You can think of a permissions object as containing an aggregation of permission collections, each of which contains an aggregation of individual permissions.
The file permission is then stored within this file permission collection.
When another file permission is added to the permissions object, the permissions object will place that file permission into the already existing file permission collection object.
When a payroll permission object is added to the permissions object, a new payroll permission collection will be obtained, the payroll permission added to it, and the collection added to the permissions object.
This process will continue, and the permissions object will build up a set of permission collections.
When the implies( ) method of the permissions object is called, it will search its set of permission collections for a collection that can hold the given permission.
It can then call the implies( ) method on that (homogenous) collection to obtain the correct answer.
The Permissions class thus supports any arbitrary grouping of permissions.
There is no need to develop your own permission collection to handle heterogeneous groups.
The third building block for the access controller is the facility to specify which permissions should apply to which code sources.
In programmatic terms, writing a policy class involves implementing these methods.
Unfortunately, the PolicyFile class is in the sun package; it is not accessible to us as programmers.
Hence, while it's possible to write your own Policy class, it is a fairly involved process.
You might want to write your own Policy class if you want to define a set of permissions through some other mechanism than a URL (e.g., loading the permissions via a policy server database)
That implementation is fairly straightforward: you need only provide a mechanism to map code sources to a set of permissions.
Then, for each code source, construct each of the individual permission objects and aggregate them into a permissions object to be returned by the getPermissions( ) method.
Hence, a simple implementation of a policy class might looks like this:
This class implements a simple policy: if the class in question was loaded from the filesystem, then all operations are allowed.
Note that this implementation requires us to define a permission collection to return from the getPermissions( ) method.
That's typically where all the work goes; in our case, we have either a simple collection with an all permission element or one with no elements.
The implies( ) method in this case doesn't rely upon those elements, though it typically would.
Only a single instance of the policy class can be installed in the virtual machine at any time.
However, the actual instance of the policy class can be replaced.
There is a programmatic and an administrative way to install a policy class.
As it turns out, both ways have their problems, though the administrative way is preferable.
Getting and setting the policy object requires going through the checkProperty( ) method of the security manager.
By default, this succeeds only if you already have been granted a security permission with the name of getPolicy or setPolicy (as appropriate)
When the new policy is installed, it will only affect code sources that have not yet been established.
To use this technique, you must install a policy file and then load classes through a new class loader; only those classes will be subject to the policy file that you've just installed.
You may also specify administratively which policy class to use by changing the policy.provider entry in the java.security file.
But the MyPolicy class must reside in the boot classpath of the virtual machine.
That means that in order to use this technique, you must either add MyPolicy.class to the rt.jar file, or you must run the virtual machine with the appropriate argument to specify the boot classpath.
This argument is nonstandard and is subject to change, but in 1.3 to load the MyPolicy class from /files/policy you'd use this command fragment:
Nonetheless, installing the policy file through the java.security file is far easier on developers since it will apply to all classes, regardless of their class loader.
When associated with a class, a protection domain means that the given class was loaded from the site specified in the code source, was signed by the public keys specified in the code source, and should have permission to perform the set of operations represented in the permission collection object.
Each class in the virtual machine may belong to one and only one protection domain, which is set by the class loader when the class is defined.
However, not all class loaders have a specific protection domain associated with them: the class loader that loads the core Java API does not specify a protection domain.
We can think of these core classes as belonging to the system protection domain.
Although protection domain objects are important to the access controller, for most developers they are simply opaque objects.
This method is used by the security manager to implement each of its methods.
We can use this method to determine whether or not a specified operation should be permitted:
The run( ) method is always the bottom method on a stack since stacks apply on a.
The reason we need to know the stack trace of the current thread is to examine the protection domains that are on the stack.
In Chapter 2, we referred to the classes on the stack as the active classes; the access controller looks at only those classes and domains that are on the stack.
In this example, only the AccessTest class has been loaded by a class loader: the AppletPanel class and the Thread class were loaded from the core API with the primordial class loader.
Hence, only the AccessTest class has a nonsystem protection domain (associated with the URL from which we loaded it, http://piccolo/ in this case)
The permissions in effect for any particular operation are the intersection of all permissions of each protection domain on the stack when the checkPermission( ) method is called.
When the checkPermission( ) method is called, it checks the permissions associated with the protection domain for each method on the stack.
It does this starting at the top of the stack and proceeding through each class.
For most implementations of Java browsers, and many Java applications, there will only be a single nonsystem protection domain on the stack: all the classes for the applet will have come from a single CODEBASE (and hence a single protection domain)
But the checkPermission( ) method is more general than that, and if you use a class loader that performs delegation, there will be multiple protection domains on the stack.
This is a common occurrence if you're using a Java extension or your own custom class loader.
In this example, the access controller first checks the protection domain for the Network class to see if a class loaded from http://network.xyz.com/ is allowed to connect to the socket.
If that succeeds, it then checks the protection domain of the PayrollApp class to see if a class loaded from http://hr.xyz.com/ is allowed to connect to the socket.
Only if both code sources are granted permission in the policy file (either individually or via an entry that does not specify a code base at all) does the checkPermission( ) method succeed.
Whether or not this is the appropriate behavior depends upon your intent.
Let's say that the policy file for the payroll application specifies that classes with a code base of http://network.xyz.com/ are allowed to create sockets but that no other protection domains (other than the system protection domain, of course) are granted that permission.
That leads to the situation where a class from the network services department might not be able to open a socket (even though it has that permission in the file): if there is any class in the HR protection domain on the stack, the operation will fail.
All classes on the stack must have permission for an operation to succeed.
Often, however, you want a class to be temporarily given the ability to perform an action on behalf of a class that might not normally have that ability.
In this case, we might want to establish a policy where the classes from the HR department cannot create a socket directly but where they can call classes from the network services department that can create a socket.[3] In this case, you want to tell the access controller to grant (temporarily) the permissions of the network services department to any methods that it might call within the current thread.
Consider this in terms of writing a file: an applet might not be able to write a file, but it can.
That facility is possible with these methods of the access controller class:
Execute the run( ) method on any given object, temporarily granting its permission to any protection domains below it on the stack.
Note the unfortunate overloading between this method and the run( ) method of the Thread class and Runnable interface, which return void; a class cannot implement both the Runnable and PrivilegedAction interfaces.
Let's see how all of this might work with our network monitor example:
Second, the exception handling is somewhat new: we must list the exceptions that the socket constructor can throw in the run( ) method of our embedded class.
There's an important (but subtle) distinction to be made here: the doPrivileged( ) method does not establish a global permission based on the protection domain of the class that called it.
Rather, it specifies a stopping point as the access controller searches the list of protection domains on the stack.
In the previous example, we assumed that http://network.xyz.com/ had permission to open the socket.
When the access controller searched the protection domains on the stack, it first reached the protection domain associated with http://network.xyz.com/
Since that domain had been marked as the privileged domain, the access controller returned at that point: it never got to the point on the stack where it would have checked (and rejected) the protection domain associated with http://hr.xyz.com/
Now consider what would happen if the permissions given to these protection domains were reversed; that is, if the http://network.xyz.com/ protection domain is not given permission to open the socket, but the http://hr.xyz.com/ protection domain is.
When we need to write a PayrollApp class, we might assume that the class has permission to open the socket and write it like this:
So protection domain can grant privileges to code that has called it, but it cannot grant privileges to code that it calls.
This rule permits key operations of the Java virtual machine; if, for example, your nonprivileged class calls the Java API to play an audio clip, the Java API will grant permission to the calling code to write data to.
When you write your own applications, however, it's important to realize that the permission granting goes only one way.
The access controller works by examining the protection domains of every class on the stack.
Sometimes, however, you want the access controller to examine the protection domains of a different set of classes.
Instances of this class are returned by the getContext( ) method of the AccessController class.
That method takes a snapshot of the protection domains that are on the stack when it is called and stores those domains into the returned access context object.
You can then use that context object in a later call to the access controller; the access controller will use that set of protection domains in its operation rather than the set of domains that are on the stack.
Usage of this class in application code is very limited.
It is often used within a class loader because the permissions that a class loader should use to determine whether a new class can be loaded should be determined by the protection domains of the stack that created the class loader rather than any subsequent users of that class loader.
This class allows you to embed another object within it in such a way that all access to the object will first have to go through a guard (which, typically, is the access controller)
Although you can write your own guards, the Permission class already implements the guard interface.
Hence, in order to get access to the object, the necessary policy file must be created with the following permission granted to the codebase from which the GuardTest class is loaded:
A more permissive name and set of actions may be given as well.
None of the classes that we've discussed in this chapter are available in Java 1.1; in order to implement something similar, you would need to supply the logic we have discussed within a custom security manager.
In this chapter, we've looked at Java's access control mechanism.
The access controller is the most powerful security feature of the Java platform: it protects most of the vital resources on a user's machine, and it allows users (or system administrators) to customize the security policy of a particular application simply by modifying entries in java.policy and other similar files.
In the next chapter, we'll look how the class loader completes the implementation of a security policy by associated code sources and protection domains with specific classes.
Java Class Loaders In this chapter, we're going to look at the third major component that determines the security policy of a Java program: the Java class loader.
Class loaders are the mechanism by which files (or other sources) containing Java bytecodes are read into the Java virtual machine and converted into class definitions.
There are three areas in which the class loader operates with the security model.
First, the class loader cooperates with the virtual machine to define namespaces, which protect the integrity of the security features built into the Java language.
Second, the class loader calls the security manager when appropriate, ensuring that code has the appropriate permissions in order to access or define classes.
And third, the class loader sets up the mapping of permissions to class objects (the protection domain of each class) so that the access controller knows which classes have which permissions.
The last of these areas is the one which is of most use to developers: if you want to establish a different security policy in your application, it's easier to do it by writing a custom class loader and establishing the permissions of classes within that class loader than by writing a new implementation of the Policy class.
We'll also look into the class loader classes that come with Java and how to write your own class loader.
As with the other elements of the Java sandbox, the ability to create and use a class loader is limited.
If the default security model is in place, then you must explicitly grant code permission to create a class loader.
Class loaders are used by the Java virtual machine to enforce certain rules about the namespaces used by Java classes.
On the other hand, a class does not need to belong to a package, in which case its full name is just the name of the class.
It's often said that these classes are in the default package, but that's slightly misleading: as it turns out, there is a different default package for each class loader in use by the virtual machine.
In order for this scheme to work, the Car class from www.ora.com must be loaded using a different class loader than that which loaded the Car class from www.sun.com.
That way, when the virtual machine asks the class loader r2 for the definition of the Car class, it will get back (correctly) the definition from ora.com.
The class loader does not need to be a different class; as this example implies, it must merely be a different instance of the class.
Hence, applets that have a different codebase (even if they originate on the same host) are always loaded by different instances of the browser's class loader.
Applets on the same page with the same codebase, however, may use the same class loader so that they may share class files (as well as sharing other information)
Some browsers also allow applets on different pages to be loaded by the same class loader as long as those applets have the same codebase, which is generally a more efficient and useful implementation.
Note too that with a badly written class loader, the hackers at EvilSite.org have the potential to supply new classes to override the core classes of the Java API.
In practice, this is not a problem because the class loader is written to find and return the core class first.
Without enforcement of the namespace separation that we've just outlined, there is no way to ensure that the hackers at EvilSite.org have not forged a class into the com.sun package.
The only way to prevent such forgeries would be to require that every class be a signed class which authenticated that it did in fact come from sun.com (or wherever its package name indicates that it should have come from)
Authenticated classes certainly have their place in Java's security model, but it would be unmanageable to require that every site sign and authenticate every class on its site.
We'll show some examples of how to create and use class loaders a bit later in this chapter.
First, let's examine from a logical perspective how class loaders work.
At the root of this tree is the system class loader.
This class loader is also called the primordial class loader or the null class loader.
It is used only to load classes from the core Java API.
In any case, a class loader is asked to load the class.
In the first case, the class loader is the object on which the loadClass( ) method is invoked.
In the case of the forName( ) method, the class loader is either passed to that method, or it is the class loader that loaded the class that is calling the forName( ) method.
The implicit case is similar: the class loader that was used to load the referencing class is also used to load the.
Class loaders are responsible for asking their parent to load a class; only if that operation fails will the class loader attempt to define the class itself.
Take the case of the class com.sun.Car that was loaded by the URL class loader that knows about www.sun.com.
It will ask its parent (the URL class loader for the classpath) to provide that class.
Its parent will in turn ask the system class loader to provide that class.
The net effect of this is that system classes will always be loaded from the system class loader, classes on the class path will always be loaded by the class loader that knows about the classpath, and in general, a class will be loaded by the oldest class loader in the ancestor hierarchy that knows where to find a class.
When you create a class loader, you can insert it anywhere into the hierarchy of class loaders (except at the root)
Typically, when a class loader is created, its parent is the class loader of the class that is instantiating the new class loader.
Now we'll look at how to implement a class loader.
The class loader we implement will be able to extend the normal permissions that are granted via policy files, and it will enforce certain optional security features of the class loader.
The secure class loader provides additional functionality in dealing with code sources and protection domains.
You should always use this class as the basis of any class loader you work with; in fact, the ClassLoader class would be private were it not for historical reasons.
If you're loading classes through the filesystem or from an HTTP server, then the URLClassLoader provides a complete definition of a class loader.
In addition, you can override some of its methods if you want to modify the security policy of classes that it defines.
The ClassLoader class and its subclasses have three key methods that you work with when creating your own class loader.
The loadClass( ) method is the only public entry into the class loader:
This is the simplest way to use a class loader directly: it requires that the class loader be instantiated and then be used via the loadClass( ) method.
Once the Class object has been constructed, there are three ways in which a method in the class can be executed:
This is the technique the Java virtual machine uses to execute the main( ) method of a Java application once the initial class has been loaded, but this is not generally a technique used by Java applications.
The reflection API can be used to call a static method on the class or to construct instances of the object and execute methods on that object.
The reflection API allows more flexibility than the second choice since it allows arguments to be passed to the constructor of the object.
In addition, every time that a class needs the definition of any other class, it calls the loadClass( ) method of its class loader.
The correct implementation of the loadClass( ) method is crucial to the security of the virtual machine.
For instance, one operation this method performs is to call the parent class loader to see if it has already defined a particular class; this allows all the core Java classes to be loaded by the primordial class loader.
If that operation is not performed correctly, security could suffer.
As a developer you should be careful when you override this method; as an administrator, this is one of the reasons to prevent untrusted code from creating a class loader.
The loadClass( ) method performs a lot of setup and bookkeeping related to defining a class, but from a developer perspective, the bulk of the work in creating a Class class object is performed by the findClass( ) method:
The findClass( ) method uses whatever mechanism it deems appropriate to load the class (e.g., by reading a class file from the file system or from an HTTP server)
It is then responsible for creating the protection domain associated with the class and using the next method to create the Class class object.
These methods all take an array of Java bytecodes and some information that specifies the permissions associated with the class represented by those bytecodes.
Create a class based on the bytecodes in the given array.
The protection domain associated with the class varies based on which form is used:
The third method in this list is available only within the SecureClassLoader class and its subclasses (including the URLClassLoader class)
When you use that method, the class loader will ask what permissions are associated with a particular code source by calling this method:
The default implementation of this method calls the getPermissions( ) method of the Policy class.
Note that this gives you two effective ways in which to override the policy set up by policy files: by supplying your own Policy class or by supplying your own secure class loader that overrides this method.
When you implement a class loader, you override some or all of the methods we've just listed.
In sum, the class loader must perform the following steps:
The security manager is consulted to see if this program is allowed to access the class in question.
This step is optional; it should be implemented at the beginning of the loadClass( ) method.
If the class loader has already loaded this class, it finds the previously defined class object and returns that object.
Otherwise, the class loader consults its parent to see if the parent knows how to load the class.
This is a recursive operation, so the system class loader will always be asked first to load a class.
This prevents programs from providing alternate definitions of classes in the core API (but a clever class loader can defeat that protection)
The security manager is consulted to see if this program is allowed to create the class in question.
This step is optional; if implemented, it should appear at the.
This can come from the default security model (i.e., from the policy files), and it can be augmented (or even replaced) by the class loader.
Alternately, you can create a code source object and defer definition of the protection domain.
Within the findClass( ) method, a Class object is constructed from the bytecodes by calling the defineClass( ) method.
If you used a code source in step 6, the getPermissions( ) method will be called to find the permissions associated with the code source.
The defineClass( ) method also ensures that the bytecodes are run through the bytecode verifier.
In the next two sections, we'll see how this plays out in each of the class loader types.
Note that we do not show how to subclass the ClassLoader class directly: all class loaders should subclass the SecureClassLoader class or its subclasses instead.
If you want to use a custom class loader, the easiest route is to use the URL class loader.
This limits the number of methods that you have to override.
To construct an instance of this class, use one of the following constructors:
Construct a class loader based on the given array of URLs.
This class loader attempts to find a class by searching each URL in the order in which it appears in the array.
The parent of this class loader will be the class loader passed to the constructor or, if one is not provided, the class loader of the class that is creating the URLClassLoader object.
An instance of the URLClassLoader class may also be obtained via one of these methods:
Only class loaders obtained this way will perform that optional step (unless you write your own class loader to perform that step)
So a URL class loader that you construct directly will not implement step 1 in the list above, while one obtained from the newInstance( ) method will.
When we use this class loader to load the class com.sdo.Car, the class loader first attempts to load it via http://piccolo.East/~sdo/com/sdo/Car.class; if that fails, it looks for the class in the LocalClasses.jar file.
To implement a URL class loader, we follow the steps listed before.
If you need to modify other behavior of the URL class loader, then you cannot use the newInstance( ) method.
The loadClass( ) method of the ClassLoader class performs this operation for you, which is why we've called the super.loadClass( ) method.
The loadClass( ) method of the ClassLoader class performs this operation.
The URL class loader performs this operation for you by consulting the URLs that were passed to its constructor.
If you need to adjust the way in which the class bytes are read, you should use the SecureClassLoader class instead.
The URL class loader will create a code source for each class based on the URL from which the class was loaded and the signers (if any) of the class.
The permissions associated with this code source will be obtained by using the getPermissions( ) method of the Policy class, which by default will return the permissions read in from the active policy files.
In addition, the URL class loader will add additional permissions to that set:
If you want to associate different permissions with the class, then you should override the getPermissions( ) method.
For example, if we wanted the above rules to apply and also allow the class to exit the virtual machine, we'd use this code:
The URL class loader will use whatever permissions are returned from this getPermissions( ) method to define the protection domain that will be associated with the class.
These steps are handled internally by the URL class loader.
If you need to load bytes from a source that is not a URL (or from a URL for which you don't have a protocol handler, like FTP), then you'll need to extend the SecureClassLoader class.
A subclass is required because the constructors of this class are protected, and in any case you need to override the findClass( )
The parent argument will become the parent of this class loader; if none is provided, then the class loader that calls the constructor will be the parent class loader.
To implement step 5, you must override the findClass( ) method like this:
The syntax of this method is complicated by the fact that we need to load the class bytes in a privileged block.
Depending on your circumstances, that isn't strictly necessary, but it's by far the most common case for class loaders.
Say that your class loader loads class A from the database; that class is given minimal permissions.
When that class references class B, the class loader will be asked to load class B and class A will be on the stack.
When it's time to load the new class bytes, we need to load them with the permissions of the class loader rather than the entire stack, which is why we use a privileged block.
Notwithstanding, the try block has three operations: it loads the class bytes, it defines a code source for that class, and it calls the defineClass( ) method to create the class.
The first two of the operations are encapsulated in the readClassBytes( ) and getCodeSource( ) methods; these are methods that.
Loading the class bytes is an operation left to the reader.
The reason for providing your own class loader is that you want to read the class bytes in some special way; otherwise, you'd use the URLClassLoader class.
The code source is another matter: we must determine a URL and a set of certificates that should be associated with the class.
In a signed jar file, the certificates are read from the jar file and the URL is the location of the jar file.
In Chapter 12, we'll show how to get the certificates from a standard jar file and construct the appropriate code source.
If your class definition isn't coming from a URL, then you must be a little creative.
You could also use the methods we examine in Chapter 10, and load one or more certificates from the keystore; you would then use both items to construct the code source.
The defineClass( ) method will call back to the getPermissions( ) method in order to complete the definition of the protection domain for this class.
And that's why the URL used to construct the code source can be arbitrary: when you write the getPermissions( ) method, just make sure that you understand what the URL actually is.
In default usage, the URL would be used to find entries in the policy files, but since you're defining your own permissions anyway, the contents of the URL don't matter.
What matters is that you follow a consistent convention between the definition of your getCodeSource( ) and findClass( ) methods.
Hence, possible implementations of the getPermissions( ) and getCodeSource( ) methods are as follows:
If you're reading the class bytes from, say, a database, it would be more useful if you could pass an arbitrary string to construct the code source.
That doesn't work directly since the code source requires a URL but the file part of the URL can be any arbitrary string.
Note that the getPermissions( ) method of the SecureClassLoader class does not add the additional permissions that the same method of the URLClassLoader class adds.
Classes loaded by the primordial class loader do not have an associated protection domain (alternately, we may say that they are associated with the system protection domain), which is why they have permission to perform any operation.
There are a few details about class loaders that we haven't yet covered.
These details are not directly related to the security aspects of the class loader, which is why we've saved them until now.
If you're interested in the complete details of the class loader, we'll fill in the last few topics here.
This model permits a class loader to be instantiated with this constructor:
This class loader delegates all operations to the parent first: if the parent is able to fulfill the operation, this class loader takes no action.
For example, when the class loader is asked to load a class via the loadClass( ) method, it first calls the loadClass( ) method of the parent.
If that succeeds, the class returned by the delegate will ultimately be returned by this class.
If that fails, the class loader then uses its original logic to complete its task, something like this:
You may retrieve the delegate associated with a class loader with the following method.
The class loader that exists at the root of the class loader hierarchy is retrieved via this method:
Return the system class loader (the class loader that was used to load the base application classes)
If a security manager is in place, you must have the getClassLoader runtime permission to use this method.
A class loader can load not only classes, but any arbitrary resource: an audio file, an image file, or anything else.
Instead of calling the loadClass( ) method, a resource is obtained by invoking one of these methods:
Find the named resource and return either a URL reference to it or an input stream from which it can be read.
Implementations of class loaders should look for resources according to their internal rules, which are typically (but need not be) the same rules as are used to find classes.
The getResource( ) method calls the getSystemResource( ) method; if it does not find a system resource, it returns the object retrieved by a call to the findResource( ) method (which by default will be null)
Find the named resource and return either a URL reference to it or an input stream from which it can be read.
By default, these methods look for the resource on the classpath and return that resource (if found)
In the first method, an enumeration of the local resources of all delegated class loaders (including the present class loader) is returned; in the second method, only the local resources of the present class loader are returned.
Loading classes with native methods creates a call to this method of the ClassLoader class:
Note that if the user can write to the hardwired directory where the library lives, this advantage no longer exists: the user can simply overwrite the existing library instead of changing an environment variable to point to another library; the end result is the same.
In 1.2 and earlier releases, that restriction is not present (unless you code it into your own class loader)
To begin, there are no code source or protection domain objects in 1.1, and classes do not carry associated permissions with them.
Security in 1.1 is solely up to the security manager, and the class loader simply loads classes.
That means that the loadClass( ) method in 1.1 is very different.
In particular, there is only one defineClass( ) method that it can call (the one without a protection domain argument), and it does not call the findClass( ) method.
In order to write a class loader in 1.1, you must override the loadClass( ) method and perform all your work in that method.
In 1.1, the primordial class loader is used to load all classes on the classpath in addition to the classes in the core API.
In 1.1, a custom class loader can make a special method call to load classes from the classpath, but there is no general hierarchy of class loaders.
In 1.1, the default behavior of the methods that retrieve resources is to return null.
The RMI class loader does not exist in Java 1.0
A digital signature, for example, can authenticate a Java class so that the security policy can allow that class greater latitude in the operations it can perform, but a digital signature is a useful thing in its own right.
An HR department may want to use a digital signature to verify requests to change payroll data, an online subscription service might require a digital signature to process a change order, and so on.
Thus, while we'll examine the classes of the Java security package from the perspective of what we'll be able to do with a signed class, the techniques we'll show will have broader applicability.
If you already have an understanding of the basics of digital signatures, encryption, and the need for authentication, you can skip this chapter, which provides mainly background information.
The identity of the site from which the class was loaded can be verified ( author authentication)..
The class was not modified in transit over the network (data authentication)..
There's a small irony here because many computer viruses are spread through commercial software.
That's one reason why the fact that a class has been authenticated does not necessarily mean it should be able to.
First we must prove that the author of the data is who we expect it to be.
Hence, although the URL in your browser says www.xyz.com, you've been fooled: you're actually receiving whatever data the impersonator of XYZ Corporation wants to send to you.
The second problem introduced by the fact that our transmissions to www.xyz.com must pass through several hosts is the possibility of snooping.
In this scenario, assume that site2 on the network is under control of a hacker.
When you send data through a public network, you can use a digital fingerprint of that data to ensure that the data was not modified while it was in transit over the network.
This fingerprint is sufficient to prevent a snooper from substituting new data (e.g., a new Java class file) for the original data in your transmission.
However, this authentication does not prevent a snooper from reading the data in your transmission; authenticated data is not encrypted data.
Data authentication prevents writing of data but not reading of data.
This can be a very important difference in countries that place import or export controls on encryption.
Those restrictions do not apply to digital signatures, so the Java code that implements digital signatures is freely available.
Hence, it is easier to deploy an application that requires digital signatures than one that requires encryption.
Without some cryptographic mechanism in place, the hacker at site2 has the option of modifying the classes that are sent from www.xyz.com.
Hence, the classes that are sent need to have a digital fingerprint associated with them.
As it turns out, the digital fingerprint is required to sign the class as well.
When Java was first released and touted as being "secure," it surprised many people to discover that the types of attacks we've just discussed were still possible.
As we've said, security means many things to many people, but a reasonable argument could be made that the scenarios we've just outlined should not be possible in a secure environment.
The reasons Java did not solve these problems in its first release are varied, but they essentially boil down to one practical reason and one philosophical reason.
Provide no security at all, and allow applets full use of the resources of the user's computer.
By now, we know all the possible problems with that route.
It would be better still to solve this problem at the network level itself.
There are many products from various vendors that allow you to authenticate (and encrypt) all data between your site and a remote site on the network.
Using such a product is really the ideal from a design point of view; in that way, all data is protected, no matter what the source of the traffic.
Either of these solutions makes authentication and fingerprinting of Java classes redundant (and may offer the benefit that the data is actually encrypted when it passes through the network)
Unfortunately, these solutions lead us back to practical considerations: if it's hard for Java environments to share digital keys and to manage cryptographic technology, it's harder still to depend on the network software to manage this process.
So while it might be ideal for this problem to be solved for the network as a whole, it's impractical to expect such a solution.
Hence, the Java security package offers a reasonable compromise: it allows you to deploy and use trusted (i.e., authenticated) classes, but their use is not mandated in case you prefer to employ a broader solution to this problem.
In the preceding discussion, we assumed that you want to load classes from www.xyz.com and that you want those classes to be trusted so that they might have some special permission when they execute on your machine.
For example, the spellchecking class might need to open up a local dictionary file to learn how to spellcheck names and other data you customized for the spell checker.
But that's all the information that you know about these classes.
In particular, just because the classes were authenticated does not mean that I didn't put a virus into them that's going to erase all the files on your hard disk.
And just because you know that a particular Java applet came from me does not mean that you can necessarily track me down when something goes wrong.
And if the virus affected your logs, the finger of suspicion might point to the incorrect site.
The moral of the story is that authentication does not magically solve any problem; it is merely a tool that can be used in the pursuit of solutions.
In the next few chapters of this book, we're going to see how Java provides an interface to the algorithms required to perform the sort of authentications we've just talked about.
We'll also explore the architecture Java provides for general implementation of these algorithms, including ones (such as encryption) that are not strictly required for authentication.
If you're not familiar with the various cryptographic algorithms we've been alluding to so far in this chapter, the next section should sort that all out for you.
In the Java security package, there are two standard cryptographic engines: a message digest engine and a digital signature engine.
In addition, for some users, an optional engine is available to perform encryption.
Finally, because keys are central to the use of most of these engines, there is a wide set of classes that operate on keys, including engines that can be used to generate certain types of keys.
The term "engine" is also used within the security package to refer to other classes that support these operations.
When an algorithm requires a secret key, both parties using the algorithm will use the same key.
Both parties must agree to keep the key secret, lest the security of the cryptography between the parties be compromised.
The other problem with this approach is coming up with a method for sharing the keys.
It's crucial that the key be kept secret, since anyone with the key can decrypt the data to be shared.
Hence, you can't simply send the key over the network without somehow encrypting the key itself; doing so would be tantamount to sending the data itself unencrypted.
There are engines that perform secure secret key exchange, however; these key exchanges are the basis of many operations, including SSL.
Public and private keys can provide asymmetric operation to cryptographic engines.
The public key can be used by one party participating in the algorithm, and the private key can be used by the other party.
Public key encryption is not without its key management problems as well, however.
When you receive a digitally signed document, you need the public key of the signer of the document.
The mechanism to obtain that key is very fluid; there are a number of proposals for centralized key warehouses that would hold public keys and for methods to access those keys, but the infrastructure to make this all a reality is not really in place.
Hence, users of public keys have adopted a variety of techniques for obtaining the public keys.
The second engines that we'll examine deal with message digests.
A message digest is the digital fingerprint we alluded to earlier.
Conceptually, a message digest is a small sequence of bytes that is produced when a given set of data is passed through the message digest engine.
Unlike other cryptographic engines, a message digest engine does not always require a key to operate; some do, and some do not.
A message digest engine takes a single stream of data as its input and produces a single output.
We call the output a message digest (or simply a digest, or a hash), and we say that the digest represents the input data.
Data that is fed into a message digest engine is always treated as an ordered set of bytes.
If even one byte of the data is altered or absent (or presented out of order), the digest will be different.
Don't be confused by the fact that we're dealing in bytes here when the characters in a Java.
The primary engine in the security package (at least as far as authentication goes) is the digital signature engine.
Like a real signature, a digital signature is presumed to provide a unique identification of an entity (that is, an individual or an organization)
Like a real signature, a digital signature can be forged, although it's much harder to forge a digital signature than a real signature.[2] Forging a digital signature requires access to the private key of the entity whose signature is being forged; this is yet another reason why it is important to keep your private keys private.
Like a real signature, a digital signature can be "smudged" so that it is no longer recognizable.
And because they're based on key certificates, digital signatures have other properties, such as the fact that they can expire.
On the other hand, a forged digital signature is undetectable, unlike a forged real signature.
A message digest is calculated that represents the input data.1
Verifying a digital signature requires the same path; the message digest of the original data must be calculated.
The signed digest is decrypted with the public key and if the decrypted digest matches the calculated digest, the signature is valid.
Strictly speaking, the operations performed on the digests are not necessarily encryption and decryption; most digital signature algorithms cannot be used for encryption of arbitrary data.
So the data that accompanies the digital signature cannot be sensitive data; the digital signature only verifies that the message came from a particular entity and that the message was not altered in transit, but it does not actually protect that message from being read by anyone with access to it.
If the data is altered, it will not produce the same message digest, which in turn will not produce the same digital signature.
It is, however, possible to replace one message that was signed by a private key with another message that was signed by that same private key.
The security package, like many Java APIs, is actually a fairly abstract interface that several implementations may be plugged into.
Hence, another feature of the security package is its infrastructure to support these differing implementations.
In the next chapter, we'll explore the structure of the security package and how it supports these differing implementations; we'll then proceed into how to use the engines of the security package.
In this context, "engine" is just another word for operation; there are certain operations the security provider knows about, and in Java, these operations are known as engines.
An algorithm defines how a particular operation should be executed.
An algorithm can be thought of as an implementation of an engine, but that can lead to confusion because there may be several implementations of an algorithm.
As a simple example, the Java security package knows about message digests.
A message digest is an engine: it is an operation a programmer can perform.
The idea behind a message digest is independent of how any particular message digest may be calculated.
All message digests share certain features, and the class that abstracts these common features into a single interface is termed an engine.
Engines are generally abstract and are always independent of any particular algorithm.
A message digest may be implemented by a particular algorithm, such as MD5 or SHA.
An algorithm is generally provided as a concrete class that extends an abstract engine class, completing the definition of the class.
However, there may be many classes that provide a particular algorithm; you may have an SHA class that came with your Java platform and you may also have obtained an SHA class from a third party.
Both classes should provide the same results, but their internal implementations may be vastly different.
Security providers are the glue that manages the mapping between the engines used by the rest of the security package (such as a message digest), the specific algorithms that are valid for those engines (such as an SHA digest), and the specific implementations of that algorithm/engine pair that might be available to any particular Java virtual machine.
The goal of the security provider interface is to allow an easy mechanism where the specific algorithms and their implementations can be easily changed or substituted.
The security provider allows us to change the implementation of the SHA digest algorithm that is in use and to introduce a new algorithm to generate a digest.
Hence, a typical programmer only uses the engine classes to perform particular operations.
You don't need to worry about the classes that actually perform the computation.
The engine classes provide the primary interface to the security package.
An administrator, meanwhile, needs to know only the name of the provider class so that she can ensure that the correct provider class is used.
Engine classes These classes come with the Java virtual machine as part of the core API.
The Provider class Each set of algorithm classes from a particular vendor is managed by an instance of the class Provider.
A provider knows how to map particular algorithms to the actual class that implements the operation.
The Security class The Security class maintains a list of the provider classes and consults each in turn to see which operations it supports.
In later chapters, we'll look at the individual algorithms and engines of this architecture; for now, we'll discuss the Provider and Security classes.
These two classes together make up the idea of a security provider.
So a typical program that wants to use the security package does not interact directly with the security provider.
Instead, the security provider is transparently useful to the programmer and to the end user.
An end user, a system administrator, or a developer can configure the security provider; this is a result of the security provider being based on a set of provider classes.
While there is a default provider class, the end user or system administrator can replace the default provider with another class.
In addition, a user or programmer can augment the default provider class by adding additional provider classes.
When the security package needs to perform an operation, it constructs a string representing that operation and asks the Security class for an object that can perform the operation with the given algorithm.
When the Java virtual machine begins execution, it is responsible for consulting the user's properties in order to determine which security providers should be in place.
In Sun's release of 1.3, that file contains these lines (among others):
Hence, to use these providers you add these lines to the java.security file (as we did in Chapter 1):
The order of these properties is significant; when the Security class is asked to provide a particular engine and algorithm, it searches the listed providers in order to find the first one that can supply the desired operation.
All engine classes use the security class to supply objects.
When the message digest engine is asked to provide an object capable of generating SHA message digests, the engine will ask the Security class which provider to use.
If the first provider in the list can perform SHA message digests, that provider will be used.
Otherwise, the second provider is checked, and so on, until there are no providers left (and an exception is thrown) or until a provider that implements the desired operation is found.
Note that the classes that are listed in this manner must be installed into the system classpath.
The security infrastructure will use only the system class loader to locate these classes, which is why they are usually installed as an extension in $JREHOME/lib/ext.
If you write your own security provider (as we do in the next section), that provider must either be installed programatically or the classes that encompass the provider must be installed as an extension.
For end users and administrators, that's all there is to adding new security providers.
For developers, there is also a programmatic way in which a security provider may be added; we'll explore that when we discuss the interface of the Security class.
But as we mentioned earlier, the programmatic interface provided by the two classes we're about to discuss is not often needed; you'd need it only if you wanted to supply your own security provider or if you wanted to inspect or set programmatically the list of existing providers.
Otherwise, the classes are interesting only because they are used by the engine classes we'll begin to examine in the next chapter.
In the core Java API, the Provider class is abstract and there are no classes in the core Java API that extend the Provider class.
However, since this class is in the sun package, there's no guarantee that it will be available with every implementation of the Java virtual machine; other.
The concepts of the security package will work according to the specification as long as the Java implementation provides an appropriate provider class and appropriate classes to perform the operations a Java program will expect.
The exact set of classes a particular program may expect will depend, of course, on the program.
In the next section, we'll discuss how different implementations of the Provider class may be loaded and used during the execution of the virtual machine.
The Provider class is seldom used directly by a programmer.
This class does contain a number of useful miscellaneous methods we'll review here; these methods are generally informational and would be used accordingly:
As an extension of the Properties class, the Provider class also shares its public interface.
These methods are overridden so that the Provider class can ensure that the program has sufficient permissions to perform the operation.
Although the Provider class is abstract, none of its methods are abstract.
This means that implementing a provider is, at first blush, simple: all you need do is subclass the Provider class and provide an appropriate constructor.
The subclass must provide a constructor since there is no default constructor within the Provider class.
Note we used a default constructor in this class rather than providing a constructor similar to the one found in the Provider class itself.
The reason for this has to do with the way providers are constructed, which we discuss at the end of this section.
When you write a provider, it must provide a constructor with no arguments.
In order to make the associations from this table, then, our XYZProvider class needs to look like this:
The only properties a provider is required to put into its property list are the properties that match the engine name and algorithm pair with the class that implements that operation.
In this example, that's handled with the first four calls to the put( ) method (but remember too that the provider can implement as few or as many operations as it wants to; it needn't implement more than a single engine with one algorithm, or it can implement dozens of engine/algorithm pairs)
Note that the class name is the fully qualified package name of the class.
A provider can set any other arbitrary properties that it wants as well.
However, as Java has become more widely used, this is now the exception.
There's one more nonpublic method of the Provider class that is used by the security API:
In this section, we'll look into how the Java VM locates the security provider(s) we want to use.
This class is final, and all its methods are static (except for its constructor, which is private)
Like the System and Math classes, then, the Security class can never be created or subclassed; it exists simply to provide a placeholder for methods that deal with the java.security package.
Earlier, we explained how to add entries to the java.security file to add new providers to the security architecture.
The same feat can be accomplished programmatically via these methods of the Security class:
Add a new provider into the internal array of providers.
The provider is added at the specified position; other providers have their index changed if necessary to make room for this provider.
The notion that these classes are kept in an indexed array is important; when the Security class is asked to provide a particular algorithm for an operation, the array is searched sequentially for a provider that can supply the requested algorithm for the requested operation.
Now when our Java program needs to generate a key pair, the security provider is consulted as to which classes will implement the key pair generation we want.
If we need to generate a DSA key, the security provider returns to us a class associated with the Sun provider class since the Sun provider, at position 1, is the first class that says that it can perform DSA key generation.
Similarly, when we request a Foo key pair, a class associated with the JRA provider is returned to us, regardless of what index it occurs at, since that is the only provider class that knows how to perform Foo key generation.
There are a number of other methods in the Security class that provide basic information about the configuration of the security provider:
The java.security file has a number of other properties within it; these other properties may also be retrieved via this method.
Here's a simple example, then, of how to see a list of all the security providers in a particular virtual machine:
If we run this program with the 1.3 default security providers, we get the following output (although we've removed some lines for clarity):
This gives the security manager the opportunity to intervene before an untrusted class affects the security policy of the virtual machine.
In the case of the methods in the Security class, the call that is made looks like this:
In the next few chapters, we'll discuss the engine classes that are part of the core Java API and the security extensions.
All engine classes share a similar architecture that we'll discuss here.
Most programmers are only interested in using the engine classes to perform their desired operation; each engine class has a public interface that defines the operations the engine can perform.
None of this is unusual: it is the basis of programming in Java.
However, this difference in class hierarchies has no practical effect on developers.
Hence, if you want to implement a security provider, you extend the SPI of each engine that you want to provide.
This allows a developer to request a particular engine and receive the correct class according to the following algorithm:
The programmer requests an instance of a particular engine that implements a particular algorithm.
Engine classes never have public constructors; instead, every engine has a getInstance( ) method that takes the name of the desired algorithm as an argument and returns an instance of the appropriate class.
The Security class is asked to consult its list of providers and provide the appropriate instance.
An instance of the retrieved class is created and returned to the getInstance( ) method (which in turn returns it to the developer)
We'll show examples of this in later chapters for particular engines.
In 1.1, there are only engines to perform key pair generation, message digests, and digital signatures.
In 1.1, the Provider class does not override the clear( ) , put( ), and remove( ) methods.
In the Security class, certain methods still call the security manager to see if their operation should continue, but the string passed to the security manager is always simply the string "java." In addition, the getProviders( ) , getProvider( ), and getProperty( ) methods also perform this check in 1.1
In this chapter, we've explored the architecture that forms the basis of the Java security API.
This architecture is based on the Security and Provider classes, which together form a set of mappings that allow the security API to determine dynamically the set of classes it should use to implement certain operations.
We also cover the implementation of certificates in this chapter.
Certificates are used to authenticate public keys; when public keys are transmitted electronically, they are often embedded within certificates.
The core Java API comes with the necessary classes to handle public and private keys and their certificates.
The classes necessary to handle secret keys come only with JCE.
With no input (or, possibly, input to initialize it to a certain state), the generator can produce one or more keys.
Symmetric keys are generated by the KeyGenerator class while asymmetric key pairs are generated by the KeyPairGenerator class.
The KeyFactory class translates between key objects and their external representations, which may be either a byte array or a key specification.
The ability to create new keys from scratch using the key pair generator or the key generator..
The ability to export a key, either as a parameter specification or as a set of bytes, and the corresponding ability to import that data in order to create a key.
We'll show their complete interface (which you might be curious about and which is absolutely needed if you're writing your own security provider), but we'll try not to lose sight of the two goals of this chapter.
Let's start with the various classes that support the notion of keys within Java.
As we discussed in Chapter 8, there might be several algorithms available for generating (and understanding) keys, depending on the particular security providers that are installed in the virtual machine.
Hence, the first thing a key needs to be able to tell us is what algorithm generated it:
The encoded data of the key itself is produced by this method:
Those are the only methods that a key is guaranteed to implement (other than methods of the Object class, of course; most implementations of keys override many of those methods)
In particular, you'll note that there is nothing in the key interface that says anything about decoding a key.
These keys come in pairs; hence the core Java API contains these two additional interfaces:
These interfaces contain no additional methods; they are used simply for type convenience.
A class that implements the PublicKey interface identifies itself as a public key, but it contains no public methods different from any other key.
First, it allows the programmer to determine if the key is a DSA key by checking its type.
The second purpose is to allow the programmer to access the DSA parameters using this method in the DSAKey interface:
These methods and interfaces allow us to do specific key manipulation like this:
In particular, if you're writing a security provider that provides an implementation of DSA keys, you should ensure that you implement all of these interfaces correctly.
Unlike their DSA counterparts, RSA keys do not share a common type.
These interfaces define keys suitable for use in RSA algorithms.
These interfaces allow you to retrieve the parameters used to create the RSA key.
In particular, the RSA public key interface has methods to return its modulus and public exponent while the private key has methods to return its modulus and private exponent.
The RSAPrivateKeyCrt interface defines additional methods to return its prime values (known as P and Q) and their exponents.
Model a data object that contains a public key and a private key.
The KeyPair class is a very simple data structure class containing two pieces of information: a public key and a private key.
When we need to generate our own keys (which we'll do next), we'll need to generate both the public and private key at once.
If you're not interested in generating your own keys, this class may be ignored.
A key pair object is instantiated through a single constructor:
Secret keys have no specific identifying information; this interface is empty and is used only for type identification.
Unlike asymmetric keys, however, these different key types do not have their own interfaces.
Java's security API provides two standard engines to generate keys: one to generate a pair of asymmetric keys and one to generate a secret key.
Like all engine classes, the KeyPairGenerator is an abstract class for which there is no implementation in the core API.
However, it is possible to retrieve instances of the KeyPairGenerator class via these methods:
Find the implementation of the engine that generates key pairs with the named algorithm.
Once we have the key pair generator, we can invoke any of the following methods on it:
Initialize the key pair generator to generate keys of the given strength.
The idea of strength is common among key pair generator algorithms; typically it means the number of bits that are used as input to the engine to calculate the key pair, but the actual meaning may vary between algorithms.
Key pairs require a random number generator to assist them.
You may specify a particular random number generator if desired; otherwise, a default random number generator (an instance of the SecureRandom class) is used.
Initialize the key pair generator using the given parameter specification (which we'll discuss a little later)
By default, the first method simply calls the second method with a default instance of the.
Generate a key pair using the initialization parameters previously specified.
A KeyPairGenerator object can repeatedly generate key pairs by calling one of these methods; each new call generates a new key pair.
The genKeyPair( ) method simply calls the generateKeyPair( ) method.
Using these methods, generating a pair of keys is very straightforward:
We'll show what to do with these keys in the next chapter when we discuss the topic of key management.
The P, Q, and G parameters are set from the values passed in params.
We must also define a class to represent keys we're implementing.[1] We can do that with this class:
This is true even if you're implementing an algorithm already implemented by the Sun.
The classes the Sun security provider uses to represent keys are not in the java package, so they are unavailable to us.
So even if you're implementing DSA keys, you must still define classes that implement all the DSA interfaces we looked at earlier.
The only data value our key class cares about is the value to be used as the index; for simplicity, we've made it a simple instance variable accessible only by classes in our package.
Because this example is simple, we can use the same class as the interface for the public and the private key; normally, of course, public and private keys are not symmetric like this.
With this in place, we're ready to define our key pair generation class:
Now obtaining a new key pair for the XYZ algorithm is as simple as substituting the string "XYZ" for the algorithm name when we request the key pair, as is shown in the main( ) method.
This class is very similar to the KeyPairGenerator class except that it generates instances of secret keys instead of pairs of public and private keys:
As such, it has all the hallmarks of a cryptographic engine.
It has a complementary SPI and a set of public methods that are used to operate upon it, and its implementation must be registered with the security provider.
Like other engine classes, the KeyGenerator class doesn't have any public constructors.
An instance of a KeyGenerator is obtained by calling one of these methods:
Return an object capable of generating secret keys that correspond to the given algorithm.
These methods use the standard rules of searching the list of security providers in order to find an object that implements the desired algorithm.
The first three algorithms are used in data encryption; the last two are used to calculate a message authentication code (MAC)
Once an object has been obtained with these methods, the generator must be initialized by calling one of these methods:
A key generator does not have to be initialized explicitly, in which case it is initialized internally with a default instance of the SecureRandom class.
However, it is up to the implementor of the engine class to make sure that this happens correctly; it is better to be sure your code will work by always initializing your key generator.
A secret key can be generated by calling this method:
There are two additional methods in this class, both of which are informational:
In the next section, we'll show the very simple code needed to use this class to generate a secret key.
There are three protected methods of this class that we must implement if we want to provide an SPI for a key generator:
This method should use the installed random number generator and (if applicable) the installed algorithm parameter specification to generate the secret key.
If the engine has not been initialized, it is expected that this method will initialize the engine with a default instance of the SecureRandom class.
Initialize the key generation engine with the given random number generator and, if applicable, algorithm parameter specification.
Ours will hold the single integer used in XOR encryption:
Now we can define the key generator that creates these keys:
Keys, of course, are usually longer than a single integer.
However, unlike a public key/private key pair, there is not necessarily a mathematical requirement for generating a symmetric key.
Such a requirement depends on the encryption algorithm the key will be used for, and some symmetric encryption algorithms require a key that is just an arbitrary sequence of bytes.
Remember that the key generator engine is a JCE engine.
Because of this, we must verify it with our security provider, which is why the constructor invokes the verifyForJCE( ) method of our provider.
The KeyFactory class is an engine class, which provides the typical method of instantiating itself:
Create a key factory capable of importing and exporting keys that were generated with the given algorithm.
The class that implements the key factory comes from the named provider or is located according to the standard rules for provider engines.
These methods are used to import a key: they create the key based on the imported data that is held in the key specification object.
We'll defer examples of these methods until we discuss the KeySpec class later.
The KeyFactorySpi class contains the following methods; since each of these methods is abstract, our class must provide an implementation of all of them:
Depending on the key specification, this means either decoding the data of the key or regenerating the key based on specific parameters to the key algorithm.
Depending on the key class specification, this means either encoding the data (e.g., by calling the getEncoded( ) method) or saving the parameters that were used to generate the key.
This is typically performed by translating the key to its specification and back.
Although we show how to use a key factory later, we won't show how to implement one; the amount of code involved is large and relatively uninteresting.
However, the online examples do contain a sample key factory implementation if you're interested in seeing one.
The second engine that we'll look at is the SecretKeyFactory class.
Like the KeyFactory class, this class can convert from algorithmic or encoded key specifications to actual key objects and can translate key objects from one implementation to another.
Unlike the KeyFactory class, which can only operate on public and private keys, the SecretKeyFactory class can operate only on secret keys:
The interface to the SecretKeyFactory class is exactly the same at a conceptual level as the interface to the KeyFactory.
At a programming level, this means that while most of the methods between the two classes have the same name and perform the same operation, they may require slightly different parameters: a secret key, rather than a public or private key.
In addition, instead of methods to generate public or private keys, the SecretKeyFactory class contains this method:
Because it is a JCE engine, the constructor of the secret key factory engine must invoke the verifyForJCE( ) method of our sample provider (or execute similar code)
Earlier we mentioned that the Key class must provide a getEncoded( ) method for the key that outputs a series of bytes in a format specific to the type of key; this format is generally part of the specification for the key algorithm.
An encoded key specification can be operated on via these methods:
In addition to their encoded format, keys are typically able to be specified by providing the parameters to the algorithm that produced the key.
Implementations of this interface have specific methods that are used to retrieve or set the parameters within the object.
As we mentioned at the beginning of this section, the prime reason for key factories is that they give us the ability to import and export keys.
Exporting a key specification is typically done by transmitting the individual data elements of the key specification (those individual elements vary by the type of key)
Importing a key specification typically involves constructing the specification with the transmitted elements as parameters to the constructor.
First, one argument to the getKeySpec( ) method is a class object, requiring us to construct the class object using the forName( ) method (a somewhat unusual usage)
Then, once we have the key specification itself, we have to figure out how to transmit the specification.
But for reasons that we'll discuss later, it's better not to serialize key classes that are to be imported into another Java virtual machine anyway.
Note that the SecretKeySpec class is an exception to this last step: that class implements the SecretKey interface already.
Once you've instantiated a SecretKeySpec object, you've created a secret key.
When you are given a public and private key, you often need to provide other people with your public key.
If you sign a digital document (using your private key), the recipient of that document will need your public key in order to verify your digital signature.
In practice, the key may not belong to Fred at all; certificate authorities have different levels at which they assess the identity of the entity named in the certificate.
Some of these levels are very stringent and require the CA to do an extensive verification that Fred is who he says he is.
Other levels are not stringent at all, and if Fred can produce a few dollars and a credit card, he is assumed to be Fred.
Hence, one of the steps in the process of deciding whether or not to trust the entity named in the certificate includes the level at which the certificate authority generated the certificate.
Each certificate authority varies in its approach to validating identities, and each publishes its approach to help you understand the potential risks involved in accepting such a certificate.
The name of the entity for whom the certificate has been issued.
This entity is referred to as the subject of the certificate.
A digital signature that verifies the information in the certificate.
The certificate is signed by the issuer of the certificate.
Another implication of this profusion of certificate authorities is that certificates are often supplied as a chain.
Let's say that you have the certificate of the U.S.
Post Office certificate authority, and I want to send you my certificate that has been generated by the Acme Certificate company.
This class is the preferred class for all interactions with certificates and is used by the utilities provided with the Java 2 platform.
One problem where this manifests itself is with import statements.
When dealing with certificates, you'll either need to refer to them by their fully qualified name or only import those classes in the security package that you explicitly need.
Except for some examples in Appendix C, we will not show usage of the Certificate interface.
There are many formats that a certificate can take (depending on the cryptographic algorithms used to produce the certificate)
There are three essential operations that you can perform upon a certificate:
In order to verify a certificate, you must have the public key of the certificate authority that issued it; a valid certificate is one in which the signature of the certificate authority is valid.
A valid certificate does not imply anything about the trustworthiness of the certificate authority or the subject to which the certificate belongs; it merely means that the signature in the certificate is valid for the supplied public key.
These are the basic operations that are valid for any certificate.
Notice that while we can encode a certificate into a byte array in order to transmit the certificate, there is nothing in the basic API that allows us to create a certificate from such a byte array.
In fact, there's no practical way to instantiate a certificate object at all; the Certificate class is usually used as a base class from which individual certificate types are derived.
That class is an engine class, and it has the following interface:
Return a certificate factory that may be used to import certificates of the specified type (optionally implemented by the given provider)
The default Sun security provider has one certificate factory that works with certificates of type X509
This is one reason why it's hard to provide a certificate authority based solely on the standard Java API.
In the next section, we'll see an example of reading a certificate through this interface.
As we mentioned, there are many certificate formats that could be used by a key management system; one of the most common is the X509 format.
This format is an ANSI standard for certificates, and while there are PGP and other certificate formats in the world, the X509 format is dominant.
This is the only format of certificate for which Java provides a standard API; if you want to support another certificate format, you must implement your own subclass of Certificate.
An X509 certificate has a number of properties that aren't shared by its base class:
A start and end date: An X509 certificate is valid only for a certain period of time, as specified by these dates.
A serial number: Each certificate that is issued by a certificate authority must have a unique serial number.
The serial number is only unique for a particular authority so that the combination of serial number and certificate authority guarantee a unique certificate.
See What's in a Name? in Chapter 10 for an explanation of distinguished names.
The distinguished name of the subject represented by the certificate..
These properties can be retrieved with the following set of methods:
Check that the specified date (or today if no date is specified) is within the start and end dates for which the certificate is valid.
Return the version of the X509 specification that this certificate was created with.
From a programmatic view, these are the most useful of the attributes of a certificate.
If your X509 certificate is contained in the file sdo.cer, you could import and print out information about the certificate as follows:
There are a number of other methods of the X509Certificate class.
For the purposes of this book, these methods are not generally useful; they enable you to perform more introspection on the certificate itself.
We'll list these methods here simply as a matter of record.
The TBS certificate is used as the input data to the signature algorithm when the certificate is signed or verified.
While the notion of revoked certificates in not necessarily specific to an X509 certificate, the Java implementation is.
Instances of the X509CRLEntry class are obtained by the getInstance( ) method of the CertificateFactory.
Once the class has been instantiated, you may operate upon it with these methods.
As you can see, there is a strong synergy between the methods that are used to operate upon an X509 certificate and those used to operate upon a CRL:
Verify that the signature that accompanied the CRL is valid.
The public key should be the public key of the certificate authority that issued the CRL.
When all is said and done, the point of the CRL class (and the revoked certificate class) is to provide you with the tools necessary to see if a particular certificate has been invalidated.
Your application should perform this checking; you might choose to implement it as follows:
We've glossed over two details in this method: how we obtain the public key of the authority that issued the certificate and how we get the CRL associated with that authority.
Obtaining the CRL is slightly more problematic since you must have access to a source for the CRL data.
Once you have that data, however, it's trivial to create the CRL via the generateCRL( ) method.
Whether or not the Sun security provider has been installed in the destination virtual machine is irrelevant.
The process of deserializing the object uses that class if it is available, and deserialization fails if that class is not available.
Hence, while they are serializable objects, keys and certificates should only be transmitted as encoded data.
For keys, you also have the option of transmitting the data contained in the key specification as we did earlier; the key specification classes are not serializable themselves, so you still have to rely on transmitting only the data that those objects contain.
Keys are a basic feature of any cryptographic system; they provide one of the inputs required to produce a digital signature (as well as other potential cryptographic operations)
In this chapter, we looked at the basic classes that implement the notion of a key within the Java security package.
Key Management In this chapter, we're going to discuss key management and the facilities in Java that enable key management.
The problem of key management turns out to be a hard one to solve: there is no universally accepted approach to key management, and although many features in Java (and on the Internet) are available to assist with key management, all key management techniques remain very much works in progress.
Keys are important because they allow us to perform a number of cryptographic operations, from digital signatures to encrypted data streams.
We'll discuss the details of these algorithms in the next few chapters.
For now, it's enough to know that you must provide some sort of key or certificate for many of these algorithms: sometimes you need a private key, sometimes you need a secret key, and sometimes you need a public key contained within a certificate.
The purpose of a key management system is to store such keys and allow you to retrieve them programatically (or through certain tools)
A key management system may encompass other operations (it may, for example, provide information about the degree to which a particular individual should be trusted), but it exists primarily to serve up keys and certificates.
There are a number of terms that are important in our discussion of Java's key management facilities:
However, there is great flexibility about where this file is located: the key management tools allow you to specify the location of the file, and the key management API allows you to use any arbitrary input stream.
In fact, at the end of this chapter we'll discuss how the set of keys may be held in a persistent store like a centralized database.
This is a long string; for example, my DN is:
DNs are used by certificate authorities to refer to the entities to whom they supply a certificate.
Hence, unlike an alias, the DN for a particular key is the same no matter what keystore it is located in: if I send you my public key, it will have the DN encoded in the public key's certificate.
However, nothing prevents me from having two public keys with different DNs (I might have one for personal use that omits references to my place of employment)
And there is no guarantee that two unrelated individuals will not share the same DN (in fact, you can count on this type of namespace collision to occur)
The common name (CN) within a DN is usually the domain name of the organization to which the certificate belongs.
In fact, SSL uses this convention to verify the identity of the server to which it connects.
X509 certificates (and many other ANSI standards) make use of the idea of a distinguished name (usually referred to as a DN)
Common name (CN) The (full) common name of the individual.
Organizational unit (OU) The unit the individual is associated with.
The DN specification allows other fields as well, although these are the only fields used internally in Java.
The organization that is associated with an individual is typically the company the individual works for, but it can be any other organization (and of course, you may not be associated with an organization under a variety of circumstances)
The idea behind a DN is that it limits name duplication to some extent.
There are other people named Scott Oaks in the world, but only one who has a DN of:
On the other hand, this is not absolute; there are many nonunique DNs.
The first type of entry is called a key entry.
A key entry may hold either an asymmetric key pair (private key and public key certificate) or a single secret key.
If the entry holds a key pair, it may store a chain of certificates: the first certificate always contains the public key of the entity.
Other certificates may be present that establish a chain to the root certificate of the CA that issued the entity's certificate.
JKS, JCEKS, and PKCS12 The keystore is an engine within the Java API, and Sun's various security providers supply three different algorithms of the keystore.
The default algorithm is JKS and is supplied by the security manager within the core API.
It is capable of reading and storing key entries and certificate entries; however, the key entries can store only private keys.
If you want to use the keystore for secret keys, you must use the JCEKS implementation, which is supplied by the security provider that comes with JCE.
The JCEKS keystore can hold either private or secret keys for each key entry.
The private keys held by JKS or JCEKS are encrypted.
The encryption used by JKS is weaker than that used by JCEKS; it was designed to pass the old export restrictions of the U.S.
For these two reasons, JCEKS is a preferable keystore; for compatibility reasons the default keystore remains JKS.
Both the Java key management API and keytool allow you to specify the algorithm name when operating on a keystore, so you can use either algorithm at any time.
If your enterprise has its own certificate authority, or if you obtain the root certificate from another.
Note that these CAs are the all from the same company.
Part of the difference between them is historical ( Verisign and Thawte used to be different companies), but the more significant difference between them is the degree to which they verify the subject to whom the certificate is issued.
You can get a certificate from the Thawte Personal Freemail CA for free and with relatively little information.
If you want a certificate from the Verisign Server CA, you must provide a great deal of information (which Verisign will go to great lengths to verify), and you must pay for the certificate.
As we mentioned in the last chapter, the level at which a particular CA issues a certificate is very important in deciding whether or not you should trust the holder of the certificate.
At an administrative level, keys are managed by keytool, a utility supplied with the JRE.
This tool allows you to create new keys, import digital certificates, export existing keys, and generally interact with the key management system.
There is no default for this value, and if you do not specify it on the command line, you will be prompted to enter it when it is needed.
Letting keytool prompt you is generally easier since the tool will prompt for the name one field at a time.
Access to any element in the keystore requires this global password.
If this password is not provided on the command line, you will be prompted for it.
This is more secure than typing it on a command line or in a script where others might see it.
This is usually not (and should not be) the same as the global password.
There should be a different password for each private key that is specific to that entry.
This allows the keystore to be shared among many users.
If the password is not provided on the command line, you will be prompted for it, which is the more secure way to enter this password.
This defaults to the keystore type in the java.security file, which defaults to JKS, the keystore type provided by the Sun security provider.
Now we'll look at the various commands that are available within keytool, and along the way we'll build up a keystore that we'll use in examples in later chapters.
The default for this option is DSA; you must use an algorithm name that is supported by a security provider that you have installed.
The default value for this option is 1024; you must use a key size that is supported by the key algorithm you want to use.
Here's how you use this command to create a key entry:
Hence, if you see quotes in the generated DN, reenter the information so that it is not quoted.
While it is possible for a keystore to hold a key entry that stores a secret key, keytool itself does not support creating such entries.
If we want someone to accept the key we just generated, we need to obtain a certificate from a known CA.
As we've mentioned, CAs will take different steps to verify the identity of the person or organization to whom they issue a certificate.
The certificate they issue will be verified by a different root certificate as a result: if you want a simple, free certificate with little verification of your identity, you can get a Thawte Personal Certificate.
If you want something with more assurance as to your identity, you can pay for an SSL or developer's certificate from Thawte.
That process takes longer since Thawte will do an extensive check to make sure that you are who you represent yourself to be.
So the issue here is to whom you will present your certificate and what level of verification they will accept.
For our testing purposes, the Thawte Personal Certificate will do just fine; if you're presenting a certificate to a developer's association, they may require a Verisign Class 3 certificate, and so on.
Of course, the converse of this relationship should also hold: when someone presents you with a certificate, you should check who issued it and what type it is in order to determine how careful the CA was in supplying the certificate.
In order to obtain a certificate from a CA, you must first generate a certificate signing request (CSR)
The CSR contains the distinguished name and public key for a particular alias and is signed using the private key of the alias; the CA can then verify that signature and issue a certificate verifying the public key.
The default algorithm will be based on the type of key held by the alias.
If you used the same password for the keystore and the key itself, you are only prompted once for the password.
Once you have the CSR in a file, you must send it to the CA of your choice.
Different CAs have different procedures for doing this, but all of them will send you back a certificate they have signed that verifies the public key you have sent to them.
For simple testing, the quickest way to proceed is to register for a personal certificate at http://www.thawte.com/
However, if you do this you must generate the initial keypair with a special value in the CN field; Thawte will tell you what that value is when you follow the links to request the certificate.
No matter which CA you use, you'll eventually be sent back the certificate, which will be in RFC 1421 format.
When the response from the CA comes, we must save it to a file from which we can import it.
In order to import the certificate, we must already have the root certificate in our list of trusted certificate authorities, or we must be prepared to accept the root certificate that keytool presents to us.
This command either creates a new certificate entry or imports a certificate for an existing key entry.
When this option is present, the certificate is always installed.
Otherwise, if the root certificate in the chain is not from a trusted certificate authority, the user will be prompted whether or not to install the certificate chain.
Without this option, no CAs are considered trusted, and the user will always be asked whether or not to accept the certificate (unless, of course, the noprompt option is in effect)
If we saved the response from the CA in the file sdo.cer, here's how we'd import it into our keystore:
Assuming that the certificate is valid, this imports the new certificate into the keystore.
The certificate is invalid if the public key for sdo does not match the previously defined public key in the database or if the certificate signature is invalid (which would be the case if data in the certificate had been modified in transit)
As a result of this command, the state of the sdo entry has significantly changed:
When we created the key entry, the sdo entry had a single certificate; that certificate was issued by sdo.
Certificate entries in a keystore are always created by importing an existing certificate.
The certificate may be the root certificate of a known CA (or the internal CA for your enterprise), or it may be a certificate that.
For example, if I'm going to send you a digitally signed message, you must have my certificate (issued by a CA) within your keystore.
Certificate entries are created with the same import command that we just looked at.
Let's say that I send you my certificate, and you've saved it to the file fromsdo.cer.
Note that in this example, we haven't used the cacerts file to verify the certificate automatically (and since the given CA doesn't exist in the cacerts file, that would fail anyway)
This causes keytool to print out the certificate information; you should examine and verify its fingerprint before deciding whether or not to trust the certificate.
There is no way to modify a certificate entry in the keystore.
You may delete an existing entry and add a new one if required.
There is one command that can modify the data within a key entry:
The cloned entry will have the same private key and certificate chain as the original entry.
If this is not specified, you will be prompted for it.
If this is not specified, you will be prompted for it.
Again, it is more secure to respond to a prompt (because the password is masked) than it is to supply it in plain text at the command line.
To change the password associated with a particular key entry, use this command:
If this option is not supplied, you will be prompted for the new password.
Changing the password is one way to migrate entries from a JKS to a JCEKS keystore since you can specify a.
There is a single command to delete either a key entry or a certificate entry:
If a certificate entry for a certificate authority is deleted, there is no effect upon key entries that have been validated by the authority.
If you want to examine one or more entries in the keystore, you may use the following commands:
If an alias option is given to this command, only that alias will be listed; otherwise, all entries in the keystore are listed.
You do not need to know the password for the keystore to use this command.
If the target alias is a certificate entry, that certificate is exported.
Otherwise, the first certificate in the target key entry's certificate chain will be exported.
If you need to send your certificate to another entity, you send it the file created by this command.
The input to this command must be a certificate in RFC 1421 format; this command will display that certificate in readable form so that you may verify its fingerprint.
Unlike all other commands, this command does not use the keystore itself, and it requires no keystore passwords to operate.
The first allows you to change the global password of the keystore:
If you do not specify this value, you will be prompted for it, which is more secure.
Finally, you can get a summary of all commands with this command:
The exact details of this vary by Netscape release, but under the Tools menu, select Security Info (in Netscape 6, it's called Personal Security Manager)
You can export it to any file; the normal extension to use for the file is .p12
If you exported the certificate to a file called sdocer.p12, this command will list the certificate:
If you use the export command to export the certificate, you may import it into a JKS or JCEKS keystore.
Besides integrating it into a single source, this allows you to make modifications to the entry, such as changing its password and alias.
The keytool gives us the ability to create keys, obtain certificates, and so on.
Now we'll turn our attention to using the key management facilities programatically: if you need to create a digital signature, you'll use the key management API to locate the correct key.
Similarly, you may choose to store secret keys for data encryption in the keystore.
The key management API allows us to read and write keystores and their entries.
In addition, the implementation of keytool has certain limitations: it cannot create entries that store secret keys, and it is difficult to share the keys in a keytool database among a widely dispersed group of people (like all the employees of XYZ Corporation)
We can, however, use the key management API to create a key management system that has whatever features we require.
That framework is the ultimate goal of the following sections.
There is a single method that implementors of the Principal interface must implement:
The only idea that the Principal interface abstracts is that principals have a name.
The Java documentation states that a principal is anything that can have an identity, but don't be confused by that statement; the word "identity" is being overloaded in this context.
There is an Identity class that implements the Principal interface, but there are classes implementing the Principal interface that are unrelated to the Identity class.
In addition, although it is not officially deprecated, the Identity class is obsolete; it was used primarily in Java 1.1
Instances of the KeyStore class are predictably obtained via this method:
Return an instance of the KeyStore class that implements the given algorithm, supplied by the given provider, if applicable.
If you do not want to hardwire the name of the keystore algorithm into your application, you may use this method to return the string that should be passed to the getInstance( ) method:
When the keystore object is created, it is initially empty.
Although the getInstance( ) method has constructed the object, it is not expected that the object's constructor will read in a keystore from any particular location.
The interaction between the keystore object and the keytool database comes via these two methods:
It's somewhat misleading to call this parameter a password, although that's what the javadoc calls it, and that's the term used by keytool.
If you pass null for the password, you'll always be able to read the keystore.
Remember that a different password is used to decrypt the private keys in the keystore, so this isn't a security hole: if you don't have the password, you will be able to read only public certificates.
If you use an incorrect password, an I/O exception is thrown.
You cannot require a password for the load( ) method to succeed since the Sun implementation of the Policy class calls this method without a password when it constructs the information needed for the access controller.
You may, of course, provide your own implementation of the Policy class that requires a password.
The password is typically included in a digest calculation of the keystore; this digest is then written to the output stream as well (but again, your own implementation of this class could use the password differently)
Indicate whether the given alias represents a key entry or a certificate entry.
Retrieving a private key typically requires a password; this may or may not be the same password that was used to read the entire keystore.
This allows private keys to be stored encrypted so they cannot be read without the appropriate password.
Assign the given private or secret key and certificate chain to the key entry represented by the given alias, creating a new key entry if necessary.
Any previous private key and certificate chain (or secret key) for this entry are lost; if the previous entry was a certificate entry, it now becomes a key entry.
If the key is a secret key, the certificate chain should be null.
Note that there is no method that returns an entire entry; you must use the specific methods (such as the getKey( ) method) to obtain the individual pieces of information you need.
These are the basic methods by which we can manage a keystore.
We'll see examples of many of these methods throughout the rest of this book; for now, let's look at a simple example that handles basic operations on a keystore:
We'll use this class in the rest of the book to manage the default keystore.
It's main( ) method (for testing) expects two arguments: the name of the entity in the keystore for which information is desired and the password that was used to encrypt the private key.
Since access to the private key of the signer is protected by a password, the signer and the end user are able to share a single database without concern that the end user may obtain access to the signer's private key (assuming that she keeps her password secret, of course)
In the case of a corporate network, this flexibility is important since an enterprise may want to maintain a single database that contains the private keys of all of its employees as well as the certificates of all known external entities.
Hence, for many applications, you'll want to provide your own implementation of the KeyStore class.
We'll show a very simple example here as a starting point for your own implementations.
For the payroll application being deployed by XYZ Corporation, a database containing each employee in the corporation is necessary.
The HR department could set up its own keystore for this purpose, but a similar keystore will be needed by the finance department to implement its 401K application; a better solution is to have a single keystore that is shared by all departments of XYZ Corporation.
Without getting bogged down in the details of the network and database programming required for this architecture, let's look at how the KeyStore class itself would be designed.
Many of the methods of our new class are simple passthroughs to the remote server.
If the handle to the remote server is held in the instance variable rks, a typical method looks like this:
The methods that could be implemented in this manner are:
Note that we did not include the engineLoad( ) method in the above list.
The engineLoad( ) method is useful to us because it allows the application to require a password from the user before a connection to the remote server can be made.
Typically, the engineLoad( ) method is called with the input stream from which to read the keystore.
In this case, the engineLoad( ) method is expected to be called with a null input stream and sets up the connection to the remote server itself:
On the server side, implementation of the required methods is simply a matter of making appropriate database calls:
There are unlimited possibilities in the implementation of a keystore.
One technique might be to create a floppy for each employee that contains only that employee's entry and to write a keystore class that looks for key entries from the file on the floppy and for certificate entries from a global file somewhere.[1] This type of implementation is very simple.
The new keystore can contain two instances of the Sun KeyStore class that have read in both files, and it can use object delegation to implement all of its methods.
The Policy class uses the keystore in a predictable manner.
It will open the file $HOME/.keystore and pass that input stream to the load( ) method of the keystore class; if you're not using that file, you may simply ignore that input stream.
The key management techniques that we've discussed so far are ideally suited to managing asymmetric keys.
In fact, although we've mentioned that the keystore can hold secret keys, there are some problems with doing so.
When we discussed public and private key pairs, we talked about the bootstrapping issue involved with key distribution: the problem of obtaining the public key of a trusted certificate authority.
In the case of key pairs, keeping the private key secret is of paramount importance.
Anyone with access to the private key will be able to sign documents as the owner of the private key; he will also be able to decrypt data that is intended for the owner of the private key.
Keeping the private key secret is made easier because both parties involved in the cryptographic transfer do not need to use it.
With symmetric keys, however, the bootstrapping issue is even harder to solve because both parties need access to the same key.
The question then becomes how this key can be transmitted securely between the two parties in such a way that only those parties have access to the key.
One technique to do this is to use traditional (i.e., nonelectronic) means to distribute the key.
The key could be put onto a floppy disk, for example, then mailed or otherwise distributed to the parties involved in the encryption.
Or the key could be distributed in paper format, requiring the recipient of the key to type in the long string of hex digits.
Another technique is to use public key/private key encryption to encrypt the symmetric key and then send the encrypted key over the network.
This allows the key to be sent electronically and used to set up the desired engine.
This is a particularly attractive option for things like encryption because symmetric encryption is usually much faster than public key encryption.
You can use the slower encryption for the secret key, then use the faster encryption for the rest of your data.
The final option is to use a key agreement algorithm.
Key agreement algorithms exchange some public information between two parties so they each can calculate a shared secret key.
However, they do not exchange enough information that eavesdroppers on the conversation can calculate the same shared key.
If you use traditional means to distribute a secret key, you have the problem of getting that key into your program.
Your program can of course read the key directly from a file, but if many programs are going to share the secret key, you'd like to put that key into the keystore.
Unfortunately, keytool does not understand the idea of secret keys.
If a keystore contains a secret key, then keytool will be able to list it, but there's no way to use keytool to introduce a secret key into the keystore.
Notice that in order for keytool to operate on secret keys, the keystore format must be JCEKS.
You may specify that as the default format (as we showed earlier) in the java.security file, or you may specify that algorithm whenever you obtain the keystore.
To add a secret key entry into a keystore you have to use something like this program:
The other option for distributing secret keys is to use a key agreement algorithm, which is available only with the JCE security provider.
As an engine class, this class has no constructors, but it has the usual method to retrieve instances of the class:
Return an instance of the KeyAgreement class that implements the given algorithm, loaded either from the standard set of providers or from the named provider.
The interface to this class is very simple (much simpler than its use would indicate, as our example will show):
This method will also perform the first phase of the key agreement protocol.
The number of phases, along with the types of keys they require, vary drastically from key exchange algorithm to algorithm.
Your security provider must document the types of keys required for each phase.
In addition, you must specify which is the final phase of the protocol.
Generate the bytes that represent the secret key; these bytes can then be used to create a SecretKey object.
The type of that object will vary depending upon the algorithm implemented by this key agreement.
The bytes are either returned from this argument or placed into the given array (starting at the given offset)
After this method has been called, the engine is reset and may be used to generate more secret keys (starting with a new call to the init( ) method)
Bob uses the algorithm specification to generate his own public and private keys; he sends the public key to Alice.
Alice uses her private key and Bob's public key to create a secret key.
In the KeyAgreement class, this requires two phases: one that uses her private key and one that uses her public key.
This secret key can then be used for a variety of operations: it can be used directly for creating MACs, or it can be converted into a DES key for use in a cipher.
Note that this example uses the Cipher class; see Chapter 13 for more details about that class.
Otherwise, despite its length, this example merely uses a lot of the techniques we've been talking about in the past two chapters.
Keys are generated, they are transmitted in neutral (encoded) format, they are reformed by their recipient, and both sides can continue.
Remember that this is a JCE engine class, so you must perform the appropriate steps in the constructor of your engine to verify the JCE installation.
If you must implement a key management system under Java 1.1, you'll need to use the IdentityScope class.
Java 1.1 comes with a key management system that is based upon the javakey utility.
This allows anyone with access to the javakey database to determine all the keys that were stored in the file.
Since access is required to obtain your own private key to generate your own digital.
This problem was a limitation of the javakey utility itself.
It's possible to use the 1.1 classes to write a key database in such a way that your private key is held separately from a group of public keys (see Appendix C)
The default for this is identitydb.obj in the user's home directory.
With this command, each trusted entry in the identity database will be created as a key entry in the keystore.
All other entries in the identity database will be ignored.
For all the time we've spent on them, keys are not interesting by themselves.
They are interesting for what they allow us to do, which among other things includes the ability to operate on a digital signature.
In the next chapters, we'll look at message digests and digital signatures, their relationship to keys, and the operations that all this enables us to perform.
Message Digests In this chapter, we're going to look at the API that implements the ability to create and verify message digests.
The ability to create a message digest is one of the standard engines provided by the Sun default security provider, and there are engines that manipulate digests in the Java Cryptography Extension as well.
You can therefore reasonably expect every Java implementation to create message digests.
We'll examine how developers can use the message digest in this chapter and also explore how a security provider can implement her own message digest algorithm.
Like all engine classes, instances of the message digest are obtained through one of these methods:
Return an instance of the message digest class that implements the given algorithm, optionally using the given provider.
Once a message digest object has been obtained, the developer can operate on that object with these methods:
The first of these methods adds a single byte to the data, the second adds the entire array of bytes, and the third adds only the specified subset of the array of data.
These methods may be called in any order and any number of times to add the desired data to the digest.
Consecutive calls to these methods append data to the internal accumulation of data over which the digest will be calculated.
Once a digest has been calculated, the internal state of the algorithm is reset so that the object may be reused at this point to create a new message digest.
Let's see an example of how all of this works.
As a simple case, let's say that we want to save a simple string to a file, but we're worried that the file might be corrupted when we read the string back in.
Hence, in addition to saving the string, we must save a message digest.
We do this by saving the serialized string object followed by the serialized array of bytes that constitute the message digest.
In order to save the pieces of data, we use this code:
Similarly, to retrieve this data we need only read the object back in and verify the message digest.
In order to verify the message digest, we must recompute the digest over the data we received and test to make sure the digest is equivalent to the original digest:
As we stated in Chapter 7, the message digest by itself does not give us a very high level of security.
We can tell whether somehow the output file in this example has been corrupted because the text that we read in won't produce the same message digest that was saved with the file.
But there's nothing to prevent someone from changing both the text and the digest stored in the file in such a way that the new digest reflects the altered text.
A secure message digest is called a Message Authentication Code (MAC)
A MAC has the property that it cannot be created solely from the input data; it requires a secret key that is shared by the sender and receiver.
Hence, an intermediate party cannot change both the data and the MAC without the receiver detecting that the data has been corrupted.
There are various ways in which a message digest can be made into a MAC, but the core Java security API does not provide any standard techniques for doing so.
However, JCE does provide a class to produce a MAC, and there are simple ways to calculate a MAC on your own.
The interface to the Mac class is only slightly different than that of the MessageDigest class.
There are still various update methods that are used to send data through the algorithm, but the digest( ) method is replaced with the doFinal( ) method:
The MAC is either returned directly or (in the last case) stored in the given array.
The last two methods allow you to specify the last data to include in the MAC.
In order to calculate the size of the output array for the third method, use the getMacLength( ) method.
In addition, before calling the update( ) or doFinal( ) methods, a MAC must be initialized by calling this method:
The remainder of the methods of the Mac class mimic those in the MessageDigest class.
Mac objects can be reused any number of times; they are reset after each call to the doFinal( ) method.
They may be reused with a different key by calling the init( ) method with the new key.
This modification of our last example saves a MAC instead of a simple digest:
Using standard key management techniques, we look up a secret key in the default keystore and use that key to initialize the Mac object.
Otherwise, the code is very similar to what we've seen before.
Note that you must have a secret key in your keystore to run this example; use the StoreKey example from Chapter 10 to create such a key.
A second way to create a MAC is to calculate one directly.
This requires that both the sender and receiver of the data have a shared passphrase that they have kept secret, though that's often easier than sharing a secret key.
Calculate the message digest of the secret passphrase concatenated with the data:
We can substitute this code in our original Send example, writing out the data string and the MAC to the file.
Note that we can use the same message digest object to calculate both digests since the object is reset after a call to the digest( ) method.
Also note that the first digest we calculate is not saved to the file: we save only the data and the MAC.
Of course, we must make similar changes to the Receive example; if the MACs are equal, the data was not modified in transit.
The interface to the message digest class requires that you supply the data for the digest as a series of single bytes or byte arrays.
As we mentioned earlier, this is not always the most convenient way to process data, which may be coming from a file or other input stream.
These classes implement the standard input and output filter stream semantics of Java streams so that data can be written to a digest stream that will calculate the digest as the data itself is written (or the reverse operation for reading data)
Unfortunately, because the Mac class does not extend the MessageDigest class, these streams work only with standard message digests.
This class allows us to write data to a particular output stream and calculate the message digest of that data transparently as the data passes through the stream:
In addition to the standard methods available to all output streams, a message digest output stream provides the following interface:
Write the given byte or array of bytes to the underlying output stream, and also update the internal message digest with the given data (if the digest stream is marked as on)
These methods may throw an IOException from the underlying stream.
Note that this last method does not affect the underlying output stream at all; data is still sent to the underlying stream even if the digest output stream is marked as off.
The on/off state only affects whether the update( ) method of the message digest will be called as the data is written.
We can use this class to simplify the example we used earlier:
The digest input stream has essentially the same interface as the digest output stream (with writing replaced by reading)
The interface provided by the digest input stream is symmetric to the digest output stream:
Read one or more bytes from the underlying output stream, and also update the internal message digest with the given data (if the digest stream is marked as on)
These methods may throw an IOException from the underlying stream.
Here's how we can use this class to read the file we created with the digest output stream:
Once again, constructing the input stream is a matter of providing a message digest.
In this example, we've again turned off the digest input stream after reading the string object in the file.
Turning off the stream is strictly required in this case.
We want to make sure that the digest we calculate is computed only over the string object and not the stored byte array (that is, the stored message digest)
If you want to write your own security provider, you have the option of creating your own message digest engine.
Typically, you'd do this because you want to ensure that a particular algorithm like SHA is available regardless of who the default security provider is; if you have a mathematics background, it's conceivable that you might want to implement your own algorithm.
In order to implement a message digest algorithm, you must provide a concrete subclass of the MessageDigestSpi class.
That means providing a body for each of the following methods:
Add the given bytes to the data over which the digest will be calculated.
Note that there is no method in this list that accepts simply an array of bytes; the update(byte[] b) method in the base class simply uses an offset of and a length equal to the entire array.
Note that there is no corresponding method that accepts an array of bytes as an argument; the digest( ) method in the base class simply calls the engineUpdate( ) method if needed before calling the engineDigest( ) method.
The default implementation of this method simply calls the engineDigest( ) method and then copies the result into buf.
The buffer passed to this method always has sufficient length to hold the digest since if the buffer had been too short the digest( ) method itself would have thrown an exception.
Unlike most of the protected methods in this class, this method is not abstract; it does not need to be overridden.
If is returned by this method, the getDigestLength( ) method attempts to create a clone of the digest object, calculate its digest, and return the length of the calculated digest.
If a digest implementation does not override this method and does not implement the Cloneable interface, the getDigestLength( ) method will not operate correctly.
Each of these methods corresponds to a public method of the MessageDigest class, with the name of the public method preceded by the word "engine"
The public methods that do not have a corresponding method.
The implementation of this class is simple, which isn't surprising given the fact that the algorithm itself is too simple to be considered an effective digest algorithm.
The name of the class (XYZMessageDigest) and the name of the algorithm that it implements (XYZ) must match one of the strings in the provider package for this class to be found.
Hence, in our provider class in Chapter 8, we included this property:
It must call the superclass constructor passing the name of the message digest algorithm it implements.
The engineDigest( ) method converts the hash instance variable into a byte array and returns that to the programmer.
Note that the engineDigest( ) method is responsible for resetting the internal state of the algorithm.
In addition, the engineDigest( ) method is responsible for padding the data so that it is a multiple of four bytes (the size of a Java integer)
This type of data padding is a common feature of message digest calculation.
The engineReset( ) method initializes the algorithm to its initial state..
Once we have an implementation of a message digest, we must install it into the security provider architecture.
If we use the XYZProvider class from Chapter 8, we can change our Send class above to use our new digest algorithm:
Similar changes to the Receive class will allow us to accept the message that we've saved to the file test.xyz.
The method names within that class follow the method names of the Mac class: there is an engineDoFinal( ) method instead of an engineDigest( ) method, and so on.
The key to the implementation of the engineDoFinal( ) method is that it should use the key it received in the engineInit( ) method to calculate a secure message digest (perhaps using the technique we outlined above when we used a simple passphrase)
Remember that the Mac class is a JCE engine, so the constructor of your MAC implementation must verify the JCE installation.
In Java 1.1, there is no MessageDigestSpi class, and the MessageDigest class simply extends Object.
If you want to implement your own message digest in 1.1, then you extend the MessageDigest class directly.
The getDigestLength( ) method does not exist in 1.1 nor does the digest( ) method with a signature that accepts an array, offset, and length.
The facility to calculate a message digest is straightforward and easy to use; the facility to write our own message digest class is equally straightforward.
The message digest by itself gives us some comfort about the state of the data it represents, but it does not give us a completely secure system.
If we have a shared passphrase or secret key, we can construct a secure message digest (that is, a Message Authentication Code)
A secure message digest is very similar to a digital signature, which we'll explore in the next chapter.
Digital Signatures In this chapter, we explore the mechanisms of the digital signature.
The use and verification of digital signatures is another standard engine that is included in the security provider architecture.
Like the other engines we've examined, the classes that implement this engine have both a public interface and an SPI for implementors of the engine.
We'll start by looking at the interface of the digital signature engine and see how you can create digitally signed objects that you can send between programs.
We'll continue by looking into the details of digitally signed classes, including the jarsigner tool that creates those classes and how you can deal with those classes programatically.
We'll conclude by looking at the details of the engine algorithm and how you can implement your own digital signature algorithms.
When you handle digital signatures programatically, you perform two operations on them.
You create them by taking a piece of data, creating a message digest of the data, and signing the message digest with a private key.
The digitally signed data is then transmitted to someone else, who must verify the digital signature by creating a message digest of the data and verifying the signed digest using a public key.
The Sun security providers include implementations of this class that generate signatures based on the DSA and RSA algorithms.
As with all engine classes, instances of the Signature class are obtained by calling one of these methods:
Generate a signature object that implements the given algorithm, optionally using the named provider.
If the algorithm string is "DSA", the string "SHA/DSA" is substituted for it.
Hence, implementors of this class that provide support for DSA signing must register themselves appropriately (that is, with the message digest algorithm name) in the security provider.
Once a signature object is obtained, the following methods can be invoked on it:
Add the given data to the accumulated data the object will eventually sign or verify.
If the object has not been initialized, a SignatureException is thrown.
Create the digital signature, assuming that the object has been initialized for signing.
If the object has not been properly initialized, a SignatureException is thrown.
Once the signature has been generated, the object is reset so that it may generate another signature based on some new data (however, it is still initialized for signing; a new call to the initSign( ) method is not required)
In the first of these methods, the signature is returned from the method.
Otherwise, the signature is stored into the outbuf array at the given offset, and the length of the signature is returned.
In the first format, the named parameter is set to the given value; in the second format, parameters are set based on the information in the param specification.
In the Sun implementation of the DSA signing algorithm, the only valid param string is KSEED, which requires an array of bytes that will be used to seed the random number generator used to.
It is no accident that this class has many similarities to the MessageDigest class; a digital signature algorithm is typically implemented by performing a cryptographic operation combining a private key and the message digest that represents the data to be signed.
For the developer, this means generating a digital signature is virtually the same as generating a message digest; the only difference is that a key must be presented in order to operate on a signature object.
This difference is important, however, since it fills in the hole we noticed previously: a message digest can be altered along with the data it represents so that the tampering is unnoticeable.
A signed message digest, on the other hand, can't be altered without knowledge of the key that was used to create it.
The use of a public key in the digital signature algorithm makes the digital signature more attractive than a message authentication code in which there must be a shared key between the parties involved in the message exchange.
Let's take our example from Chapter 11, where we saved a message and its digest to a file; we'll modify it now to save the message and the digital signature.
Obtain a signing object via the getInstance( ) method and initialize it.
Since we're creating a signature in this example, we use the initSign( ) method for initialization.
Pass the data to be signed as a series of bytes to the update( ) method of the signing object.
Multiple calls could be made to the update( ) method even though in this example we only need one.
We save the signature bytes and write them to a file with the data so that the data and the signature can be retrieved at a later date.
In our last example, we had to create an object that held both the data in which we are interested and the signature for that data.
It's very important to realize that this constructor makes, in effect, a copy of its parameter; if you create a signed object based on a string buffer and later change the contents of the string buffer, the data in the signed object remains unchanged.
This preserves the integrity of the object encapsulated with its signature.
Here are the methods we can use to operate on a signed object:
Verify the signature within the embedded object with the given key and signature engine.
The signature engine parameter may be obtained by calling the getInstance( ) method of the Signature class.
We'll use this class in examples later in this chapter.
In the previous examples, we specified on the command line the name of the entity that we assumed generated the signature in the file.
This was necessary because the file contained only the actual signature of the entity and the data that was signed; it did not contain any information about who the signer actually is.
That's fine for an example, but it is not always appropriate in a real application.
We could have asked the user for the name of the entity that was supposed to have signed the data, but that course is fraught with potential errors:
The user could have no idea what names are in the keystore of the application.
Especially in a corporate environment, users may not know what data the keystore database might contain.
The user could get the name of the keystore alias wrong.
Say that the application asks the user to enter the name of the signer; the user, knowing that the data came from me, may enter "sdo" as the alias of the identity.
What the user may not remember is that when the keystore was first created, she received a public key from the San Diego Oil company; that public key was entered into the keystore with the alias "sdo." When my identity was added to the keystore, a different alias had to be chosen, so my public key was added with the alias "ScottOaks." But that was a long time ago, now forgotten, and because I use the sdo moniker all over my writings, the user assumes that I am the sdo in the keystore.
And so the wrong alias will be chosen, and the signature verification will fail when it should have succeeded.
For these reasons, it makes more sense to include the public key with the signature and the signed data.
This allows the application to find the identity based on the unique public key in order to determine who the signer of the data is.
We could do that by simply sending the encoded public key with the signature and data.
A better solution, however, would be to send the certificate that verifies the public key.
That way, if the public key is not found in the database, the credentials of the certificate can be presented to the user, and the user can have the opportunity to decide on the fly if the particular entity should be trusted.
Although an embedding of signature, data, and certificate is very common, the SignedObject class does not include the capability to contain a certificate.
So we'll use the SignedObject class in this example, but we'll still need an object that contains the signed object and the certificate.
We'd like to do this by extending the SignedObject class, but since that class is final we're forced to adopt this approach:
We've made the certificate variable in this class transient and have explicitly serialized and deserialized it using its external encoding.
As we discussed in Chapter 9, whenever we have an embedded certificate or key, we should follow a procedure like this to ensure that the receiving party is able to deserialize the class.
When we save the message to the file, we now have to make sure that we save a certificate with it.
Essentially, the only change we have made is to use the new Message class to store the data that we're sending.
Retrieving the data is now more complicated, since we must verify both the signature in the signed object and the identity of the authority that signed the embedded certificate:
The new code for us is primarily in the verifySigner( ) method, where we search the entire keystore for a name that matches the issuer of the certificate that was sent to us.
If we find a match, we use the corresponding public key to verify the certificate we received.
One of the primary applications of digital signatures in Java is to create and verify signed classes.
Signed classes allow the expansion of Java's sandbox in two ways:
The policy file can insist that classes coming from a particular site be signed by a particular entity before the access controller will grant that particular set of permissions.
In the policy file, such an entry contains a signedBy directive:
The security manager can cooperate with the class loader in order to determine whether or not a particular class is signed; the security manager is then free to grant permissions to that class based on its own internal policy.
We talked about these operations throughout this book; in this section, we'll fill in the last details about how the digital signatures are created and verified.
There are three necessary ingredients to expand the Java sandbox with signed classes:
A class loader that knows how to understand the digital signature associated with the class.
The URLClassLoader class knows how to do this, but we'll show an example of how to do that for a custom class loader as well.
A security manager or access controller that grants the desired permissions based on the digital signature.
The access controller will do this for us; we'll show how the security manager might do this directly in Appendix D.
As we discussed in Chapter 10, the keystore that jarsigner uses is subject to the KeyStore class that has been installed into the virtual machine; if you have your own keystore implementation, jarsigner will be able to use it.
Similarly, if you use the standard keystore implementation but hold the keys in a file other than the default .keystore file, jarsignerwill allow you to use that other file as well.
A signed jar file is identical to a standard jar file except that a signed jar file contains two additional entries:
SIGNER.SF A file containing an SHA message digest for each class file in the archive.
The digest is calculated from the three lines in the manifest for the class file.
The base of this name (SIGNER) varies; it is typically based upon the alias of the keystore entry used to sign the archive.
SIGNER.DSA A file containing the digital signature of the .SF file.
The base of this name matches the first part of the .SF file; the extension is the algorithm used to generate the signature.
This file also contains the certificate of the entity that signed the archive.
The algorithm used to generate the signature depends upon the type of the key found in the keystore: if the key is an X509 (DSA) key, a DSA signature will be generated.
If the key is an RSA key, an RSA signature will be generated.
The simplest command to sign a jar file is: piccolo% jarsigner xyz.jar sdo.
This command takes the existing jar file xyz.jar and signs it using the private key of the given alias (sdo)
The signature files in this example will be named SDO.SF and SDO.DSA and will be added to the existing jar file.
A jar file can be signed by any number of entities simply by executing this command multiple times with different aliases.
Each act of signing the jar file creates a new set of .SF and .DSA or .RSA files in the archive.
A number of options can be used in conjunction with this command:
If this value is not provided, you will be prompted for it (which, as always, is the more secure way to enter a password)
If this value is not provided, you will be prompted for it.
This is present for backward compatibility and should not be used since it increases the size of the jar file.
This is present for backward compatibility and should not be used since it requires longer to verify the jar file.
If the jar file can't be verified (because it has been corrupted), an error message with a Java exception will be printed instead.
This option is useful when the jar file has been signed by multiple entities.
Note the legend for each file that is printed by this command.
We know if the file was signed, whether or not.
In the vast majority of cases, the information for each file will be the same: jar files are usually signed all at once by the same person.
However, there's nothing to prevent someone from adding a new class to a signed jar file (in which case the class would appear as unsigned) or for a jar file to contain multiple signers (some of whom may have signed some of the classes, while others may have signed only a few of the classes)
In order to determine whether the certificate was found in the keystore, jarsigner opens the default instance of the KeyStore class and loads it.
Note that no password is required for this operation; we're reading only public information from the keystore.
As we've just seen, a signed jar file has three special elements:
A manifest (MANIFEST.MF ), containing a listing of the files in the archive that have been signed, along with a message digest for each signed file.
A signature file (XXX.SF, where XXX is the name of the entity that signed the archive) that contains signature information.
The data in this file is comprised of message digests of entries in the manifest file.
A block file (XXX.DSA, where XXX is the name of the entity that signed the archive and DSA is the name of the signature algorithm used to create the signature)
The block file contains the actual signature data in a format known as PKCS7
There are many advantages to this format, not the least of which is that the PKCS7 block file (that is, the signature itself) is a standard format for external signatures.
Unfortunately, the necessary classes to create PKCS7 blocks are not part of Java's public API; if you want to be able to write a signed jar file, you'll need to write the classes to create the signature block yourself.
However, we can read a signed jar file using the core API.
In Chapter 6, when we created a code source we always passed null for the array of certificates that had signed the class.
We'll extend that class loader now so that it handles reading the correct certificates from the signed jar file and uses those certificates to create an appropriate code source.
These hold the classes and certificates that we read from // the jar file Hashtable classArrays; Hashtable classIds;
Although it's a long example, most of it simply deals with reading entries from the jar file.
All that we're left to do from a security perspective is obtain the array of signers when we read in each jar entry and then use that array of signers when we construct the code source we use to define the class.
Remember that each file in a jar file may be signed by a different group of identities and that some may not be signed at all.
This is why we must construct a new code source object for each signed class that was in the jar file.
Now that we've seen how to use the Signature class, we'll look at how to implement our own class.
The techniques we'll see here should be very familiar from our other examples of implementing an engine in the security provider architecture.
In particular, since in Java 2 the Signature class extends its own SPI, we can implement a single class that extends the Signature class.
To construct our subclass, we must use the following constructor:
The string passed to the constructor is the name that will be registered with the security provider.
Once we've constructed our engine object, we must implement the following methods in it:
Add the given bytes to the data that is being accumulated for the signature.
These methods are called by the update( ) methods; they typically call the update( ) method of a message digest held in the engine.
If the engine has not been correctly initialized, a SignatureException is thrown.
If there is an error in generating the signature, a SignatureException is thrown.
If there is an error in validating the signature, a SignatureException is thrown.
The state is initially UNINITIALIZED; it is set to SIGN by the initSign( ) method and to VERIFY by the initVerify( ) method.
These variables are not normally used by the subclasses of Signature since the logic to maintain them is already implemented in the Signature class itself.
Like all implementations of engines in the security architecture, this class must have a constructor that takes no arguments, but it must call its superclass with its name.
The constructor also is responsible for creating the instance of the underlying message digest using whatever algorithm this class feels is important.
These engine signing and verification methods are also responsible for setting the internal state of the engine back to an initialization state so that the same object can be used to sign or verify multiple signatures.
But if there were other state information, it would need to be reset in those methods.
There are significant changes to the way in which signed classes are handled between Java 1.1
The digital signatures we've examined in this chapter form a key piece of the Java security architecture since they are the mechanism by which the parameters of the Java security sandbox can be extended: a digital signature gives the user the assurance that particular Java classes were provided by known entities.
The user is then free to adopt a security policy for those classes based on the user's assessment of the trustworthiness of the entity that provided the classes.
Digital signatures have many other uses, of course, and in conjunction with the SignedObject class they allow you to send and verify arbitrary pieces of data.
Modes and padding schemes are present in the Cipher class because that class implements what is known as a block cipher; that is, it expects to operate on data one block (e.g., 8 bytes) at a time.
Padding schemes are required in order to ensure that the length of the data is an integral number of blocks.
There are known ways to attack this encryption, though they require a lot of computing power to do so; despite widespread predictions about the demise of.
DES, it continues to be used in many applications and is generally considered secure.
The examples in this chapter are mostly based on DES encryption.
From a developer's perspective, DESede is equivalent to DES; only the algorithm name passed to the key generator and cipher engines is different.
Although DESede requires multiple keys, these keys are encoded into a single secret key.
Hence, the programming steps required to use DESede are identical to the steps required to use DES.
From a developer's perspective, this algorithm requires some special programming to obtain the key.
Blowfish This algorithm was designed by Bruce Schneier; it is an attractive algorithm because it is not patented, and Mr.
Schneier has placed implementations of the algorithm in the public domain.
It is best used in applications where the key does not change often, though it requires a lot of memory.
This is the only mode that will work for PBEWithMD5AndDES encryption.
Since that size may vary, the padding scheme that is used with it must vary as well.
For CFB8, no padding is required, since data is always fed in an integral number of bytes.
Since that size may vary, the padding scheme that is used with it must vary as well.
For OFB8, no padding is required since data is always fed in an integral number of bytes.
It is popular in a particular system known as Kerberos; if you need to speak to a Kerberos version 4 system, this is the mode to use.
However, this mode has some known methods of attack, and Kerberos version 5 has switched to using CBC mode.
The padding schemes specified by the SunJCE security provider are:
NoPadding When this scheme is specified, no padding of input is done.
In this case, the number of input bytes presented to the encryption cipher must be a multiple of the block size of the cipher; otherwise, when the cipher attempts to encrypt or decrypt the data, it generates an error.
The mode and padding scheme specified for decryption must match the mode and padding scheme specified for encryption, or the decryption will fail.
The Cipher class is normally used to encrypt or decrypt data.
However, it may also be used to wrap and unwrap keys.
We'll discuss encryption and decryption first; information about wrapping and unwrapping keys will follow.
In order to obtain an instance of the Cipher class, we call one of these methods:
Obtain a cipher engine that can perform encryption and decryption by implementing the named algorithm.
The engine is provided by the given security provider, or the list of installed security providers is searched for an appropriate engine.
Once you've obtained a cipher object, you must initialize it.
An object can be initialized for encryption, decryption, or for key wrapping, but in any case, you must provide a key.
If the algorithm is a symmetric cipher, you should provide a secret key; otherwise, you should provide a public key to encrypt data and a private key to decrypt data (in fact, the key must match the algorithm type: a DES cipher must use a DES key, and so on)
The cipher is initialized with the given key or the public key contained within the given certificate.
These calls reset the engine to an initial state, discarding any previous data that may have been fed to the engine.
Hence, a single cipher object can be used to encrypt data and then later to decrypt data.
Many algorithm modes we discussed earlier require an initialization vector to be specified when the cipher is initialized for decrypting.
In these cases, the initialization vector must be passed to the init( ) method within the algorithm parameter specification or algorithm parameters; typically, the IvParameterSpec class is used to do this for DES encryption.
Failure to specify an initialization vector for a mode that requires one will generate incorrect decrypted data.
After an engine has been initialized, it must be fed data.
The first set can be used any number of times:
Encrypt or decrypt the data in the input array (starting at the given offset for the given length, if applicable)
The resulting data is either placed in the given output array (in which case the size of the output data is returned) or returned in a new array.
If the length of the data passed to this method is not an integral number of blocks, any extra data is buffered internally within the cipher engine; the next call to an update( ) or doFinal( ) method processes that buffered data as well as any new data that is just being provided.
The required size of the output buffer can be obtained from the getOutputSize( ) method.
This second set of methods should only be called once:
Encrypt or decrypt the data in the input array as well as any data that has been previously buffered in.
This method behaves exactly the same as the update( ) method, except that this method signals that all data has been fed to the engine.
If the engine is performing padding, the padding scheme will be used to process the pad bytes (i.e., add padding bytes for encryption and remove padding bytes for decryption)
In order to preallocate an output buffer for use in the update( ) and doFinal( ) methods, you must know its size, which is returned from this method:
We've reused the single engine object to perform both the encryption and the decryption.
Since DES is a symmetric encryption algorithm, we generated a single key that is used for both operations.
Within the try block, the second block of code performs the encryption:
We pass the bytes we want to encrypt to the doFinal( ) method.
Of course, we might have had any number of calls to the update( ) method preceding this call, with data in any arbitrary amounts.
Since we've specified a padding scheme, we don't have to worry about the size of the data we pass to the doFinal( ) method.
Finally, we save the initialization vector the system provided to perform the encryption.
Note that this step would not be needed for ECB mode, which doesn't require an initialization vector.
In this case, however, we must provide an initialization vector to initialize the engine in order to get the correct results (again, this would be unnecessary for ECB mode)
Next, we pass the encrypted data to the doFinal( ) method.
Again, we might have had multiple calls to the update( ) method first.
In typical usage, of course, encryption is done in one program and decryption is done in another program.
In the example above, this would entail that the initialization vector and the encrypted data be transmitted to a receiver; this may be done via a socket or a file or any other convenient means.
There is no security risk in transmitting the initialization vector, as it has the same properties as the rest of the encrypted data.
So you could simply write out the byte array to the data sink followed by the data itself; the receiver would read the byte array, use it to construct the IvParameterSpec object, and then decrypt the data.
Data passes through the null cipher unchanged, and no padding or blocking is performed (the getBlockSize( ) method will return 1)
Unlike a traditional cipher engine, instances of the NullCipher class must be constructed directly:
This class can be used to test the logic of your program without actually encrypting or decrypting the data.
The problem with this code is that when the data is decrypted, there is no indication of how many bytes should be discarded as padding.
PKCS5 and other padding schemes solve this problem by encoding that information into the padding itself.
Of course, despite the presence of the salt and iteration, the password chosen in the method should not be easy to guess in the first place: it should contain special characters, not be known quotes from literature, and follow all the other usual rules that apply to selecting a password.
Because this is a common operation, the Cipher class provides methods that wrap (encrypt) and unwrap (decrypt) keys.
These operations could be accomplished by using the update( ) and/or doFinal( ) methods of the Cipher class directly, but the methods we're about to examine operate directly on Key objects rather than on arrays of bytes, so they are more convenient to use.
To wrap keys, you initialize the cipher object using any of the init( ) methods we listed previously; you must specify Cipher.WRAP_MODE as the operation.
Then, instead of using the update( ) and doFinal( ) methods, you use one of these methods:
There is very little intelligence in the Cipher class itself; virtually all of its methods are simply passed through calls to corresponding methods in the SPI.
The one exception to this is the getInstance( ) method, which is responsible for parsing the algorithm string and removing the mode and padding strings if present.
If it finds a mode and padding specification, it calls these methods of the SPI:
Set the padding scheme of the cipher engine according to the specified string.
Remember that the mode and padding strings we looked at earlier are specific to the implementation of the SunJCE security provider.
Hence, while ECB is a common mode specification, it is completely at the discretion of your implementation whether that string should be recognized or not.
If you choose to implement a common mode, it is recommended that you use the standard strings, but you may use any naming convention that you find attractive.
Complicating this matter is the fact that there are no classes in JCE that assist you with implementing any mode or padding scheme.
So if you need to support a mode or padding scheme, you must write the required code from scratch.
The remaining methods of the SPI are all called directly from the corresponding methods of the Cipher class:
If the cipher was in a mode where no initialization vector was required, this method should return null.
This method should take into account any data that is presently being buffered by the cipher as well as any padding that may need to be added if the cipher is performing padding.
The data that is passed to these methods is not necessarily an integral number of blocks.
It is the responsibility of these methods to process as much of the input data as possible and to buffer the remaining data internally.
Like the update( ) method, this method must consume any buffered data before processing the input data.
However, since this is the final set of data to be processed, this method must make sure that the total amount of data has been an integral number of blocks; it should not leave any data in its internal buffers.
Using our typical XOR strategy of encryption, here's a simple implementation of a cipher engine:
The bulk of the work of any cipher engine will be in the engineUpdate( ) method, which is responsible for actually providing the ciphertext or plaintext.
In this case, we've simply XORed the key value with every byte, a process that works both for encryption as well as decryption.
Because the work done by the engineUpdate( ) method is so symmetrical, we don't need to keep track internally of whether we're encrypting or decrypting; for us, the work is always the same.
For some algorithms, you may need to keep track of the state of the cipher by setting an internal variable when the engineInit( ) method is called.
Similarly, because we can operate on individual bytes at a time, we didn't have to worry about padding and buffering internal data.
Such an extension is easy using the code we showed earlier that uses the modulus operator to group the input arrays into blocks.
Then we simply instantiate the engine and create the cipher like this:
Note that "XOR" is the valid algorithm name for this implementation since we do not support any modes or padding schemes.
Note too that we no longer need an initialization vector to create the cipher.
Finally, remember that the Cipher class is a JCE engine, which is why the constructor here calls the verifyForJCE( ) method.
In the Cipher class we just examined, we had to provide the data to be encrypted or decrypted as multiple blocks of data.
This is not necessarily the best interface for programmers: what if we want to send and receive arbitrary streams of data over the network? It would often be inconvenient to get all the data into buffers before it can be encrypted or decrypted.
The solution to this problem is the ability to associate a cipher object with an input or output stream.
When data is written to such an output stream, it is automatically encrypted, and when data is read from such an input stream, it is automatically decrypted.
This allows a developer to use Java's normal semantics of nested filter streams to send and receive encrypted data.
Like all classes that extend the FilterOutputStream class, constructing a cipher output stream requires that an existing output stream has already been created.
This allows us to use the existing output stream from a socket or a file as the destination stream for the encrypted data:
When the flush( ) method is called on a CipherOutputStream (either directly or because the stream is being closed), the padding of the stream comes into play.
If the cipher is automatically padding, the padding bytes are generated in the flush( ) method.
If the cipher is performing padding, it is very important not to call the flush( ) method unless it is immediately followed by a call to the close( ) method.
If the flush( ) method is called in the middle of processing data, padding is added in the middle of the data.
Remember that certain output streams (especially some types of PrintWriter streams) flush automatically; if you're using a padding cipher, don't use one of those output streams.
We can use this class to write some encrypted data to a file like this:
First, we must create the cipher object, which means that we must have a secret key available.
Bypassing the secret key management examples we've used before, we're just going to save the key object to a file that can later be read by whomever needs the key.
Note that we've gone through the usual steps of writing the data produced by the secret key factory so that the recipient of the key need not use the same provider we use.
After we generate the key, we must create the cipher object, initialize it with that key, and then use that cipher object to construct our output stream.
Once the data is sent to the stream, we close the stream, which flushes the cipher object, performs any necessary padding, and completes the encryption.
In this case, we've chosen to use CFB8 mode, so there is no need for padding.
But in general, this last step is important: if we don't explicitly close the PrintWriter stream, when the program exits, data that is buffered in the cipher object itself will not get flushed to the file.
The resulting encrypted file will be unreadable, as it won't have the correct amount of data in its last block.[1]
Closing the output stream is necessary whenever the stream performs buffering, but it is.
All the points we made about the CipherOutputStream class are equally valid for the CipherInputStream class.
You can operate on it with any of the methods in its superclass, although you'll typically want to wrap it in something like a buffered reader, and the cipher object that is associated with the input stream needs to perform automatic padding or use a mode that does not require padding (in fact, it must use the same padding scheme and mode that the output stream that is sending it data used)
The CipherInputStream class does not directly support the notion of a mark.
The markSupported( ) method returns false unless you've wrapped the cipher input stream around another class that supports a mark.
Here's how we could read the data file that we created above:
In this case, we must first read the secret key from the file where it was saved, then create the cipher object initialized with that key.
Then we can create our input stream and read the data from the stream, automatically decrypting it as it goes.
This class is very similar to the SignedObject class we examined in Chapter 12, except that the stored, serialized object is encrypted rather than signed:
These are the only two operations that may be performed upon a sealed object.
Keep in mind that the embedded object in this class is a serialized instance of the original object: the technique the object uses to perform serialization may affect the resulting object that is retrieved from the sealed object.
This class can help us prevent someone from tampering with our serialized object, but the reconstituted object may be lacking transient fields or other information (depending, of course, on the implementation of the object itself)
The init( ) methods to the Cipher class that require a certificate are not available in 1.2
In the next chapter, we'll look at another method of performing encryption: SSL, the secure sockets layer protocol, which automatically encrypts data sent over network sockets.
SSL, as its name implies, is designed to be used over sockets; there is no way within its protocol to separate the encryption from the data transmission.
If you use SSL, you must use TCP sockets to transmit your data; UDP sockets and other transmission modes are not supported.
Despite this, there are three key advantages to using SSL:
There are a number of existing services built on top of SSL (such as HTTPS), and to communicate with or implement such services, you must use SSL.
It is designed for an environment in which there are (relatively) few servers and many, many clients.
Hence, the client in an SSL conversation does not need to go to the trouble of obtaining a certificate.
This allows, for example, an Internet shopper to make purchases without obtaining a certificate.
First, given the complexity of distributing certificates to thousands of clients, it prevents what might otherwise be a major roadblock in consumer acceptance of.
Although there are variations on the way this proceeds (and there may be intermediate messages in the protocol), the basic flow of information goes like this:
The client initiates the connection to the server and tells the server which SSL cipher suites the client supports.
The server responds with the cipher suites that it supports.2
The server sends the client a certificate that verifies its identity.3
The server initiates a key exchange algorithm, based in part on the information contained in the certificate it has just sent, and sends the necessary key exchange information to the client.
The client completes the key exchange algorithm and sends the necessary key exchange information to the server.
Based on the type of key exchange algorithm (which in turn is based on the type of key in the server's certificate), the client selects an appropriate cipher suite and tells the server which suite it wants to use.
The server makes a final decision as to which cipher suite to use.7
If the server desires, it can ask for the client's certificate so that it can be assured of who it is talking to; the client certificate is sent before the client key exchange information (if required)
Once all this information has been established, the client and server can communicate normally over the socket; data that flows over the socket will be encrypted automatically.
Programatically, these steps are transparent: a developer asks for an SSL socket, and when the SSL socket is created, the protocol handshake is complete.
In fact, a truststore has exactly the same format as a keystore; both are administered with keytool, and both are represented programmatically as instances of the KeyStore class.
The difference between a keystore and a truststore is more a matter of function than of programming construct, as we will see.
The server in an SSL conversation must have a private key and a certificate that verifies its identity.
The private key is used by the server as part of the key exchange algorithm, and the certificate is sent to the client to tell the client who the server is.
Remember from our key exchange example in Chapter 10 that the private key is never sent from the server to the client; it is used only as an input to the key exchange algorithm.
In that case, the client must have its own keystore with a private key and certificate.
The truststore is used by the client to verify the certificate that is sent by the server.
If I set up an SSL server, it will use a certificate from my keystore to vouch for my identity.
This certificate is signed by a trusted certificate authority (or, as we've seen, there may be a chain of certificates, the last of which is signed by a recognized CA)
When your SSL client receives my certificate, it must verify that certificate, which means that the trusted CA's certificate must be in your local truststore.
If an SSL server requires client authentication, it must also have a truststore.
In sum, keystores are used to provide credentials, while truststores are used to verify credentials.
Servers use keystores to obtain the certificates they present to the clients; clients use truststores to obtain root certificates in order to verify the servers' certificates.
The keystore and truststore can be (and often are) the same file.
However, it's usually easier to manage keys if they are separate: the truststore can contain the public certificates of trusted CAs and can be shared easily, while the keystore can contain the private key and certificate of the local organization and can be stored in a protected location.
In addition, JSSE is easier to use if the keystore contains a single alias.
When the keystore contains multiple aliases there are ways to specify which one should be used, but that requires more programming.
We'll show that programming later in this chapter, but keep in mind that in general a keystore containing a single alias makes using JSSE simpler.
The default implementation of the key manager does not use a default keystore; it has no notion of $HOME/.keystore.
The password in this case must be the same for both the keystore itself and the private key entry that you want to use.
For the most part SSL uses RSA keys, and those are the type of keys and certificates you need in your keystore and truststore.
This is not an absolute requirement; SSL is actually very flexible about the types of.
In the examples in Chapter 10, we created a keystore with an RSA key.
We'll use that keystore for the examples in this chapter, and we'll export the certificate from that keystore to use as the truststore.
The keystore file contains the private key and a certificate that vouches for our identity; we'll use that as the server's keystore.
The truststore file contains just the certificate; we'll use it as the client's truststore.
Since JSSE is designed to run on Personal Java implementations, for which the java.security package is optional, it cannot rely on classes from that package and must define its own certificate class.
This does not prevent third parties from implementing JSSE independent of the java.security package and providing those implementations with more limited PersonalJava packages.
It does, however, limit the environments in which you can use Sun's JSSE implementation.
However, there are no facilities to convert easily between the two classes; you must get the encoded bytes from the.
Handling JSSE certificates often requires that you parse the distinguished name (DN) held in the certificate.
To make that easier, we'll use this class in our examples:
Given an X500 name, this class can extract any of the six standard fields from it when required.
Because not all X500 names have all the possible fields, we parse the entire string for a field that we're interested in.
The JSSE API defines a set of factory classes that are used to obtain sockets.
These factories are independent of SSL; in fact, they reside in the javax.net package rather than the javax.net.ssl package (although both packages are part of JSSE)
You can use these factories to obtain sockets that use SSL or to obtain plain TCP sockets (instead of directly using the constructors of the Socket and ServerSocket classes)
This adds a nice level of abstraction to network code: the code can switch from plain to SSL sockets simply by changing socket factories.
There are often times when you need to perform special initialization operations on SSL sockets, in which case this abstraction doesn't really help.
But for simple cases, the factory classes are a nice feature.
The default implementations of these classes produce plain sockets; their subclasses will produce SSL sockets (or, potentially, sockets that use other protocols)
Create a server socket that listens on the given port.
If no backlog is specified, a system default value (50) is used.
On machines with multiple network interfaces, the addr parameter may be used to specify that the socket should listen only on the given interface.
If the socket cannot be created, an IOException is thrown.
Create a socket that connects to the given host on the given port.
If the client has multiple network interfaces, the last two methods may be used to select which interface to use on the client; they may.
If no port is specified, an anonymous port is used.
If the socket cannot be created, an IOException is thrown.
We'll show how these factories are used in the next few sections.
In this section, we'll explore how SSL sockets are created and develop a simple server and client that can be used to exchange data over an SSL connection.
As we proceed further in this chapter, we'll modify these simple programs to take advantage of more advanced SSL features.
Even though the export restrictions for JSSE have been relaxed, they still do not permit users in most of the world to substitute their own SSL implementations.
Some additional limited operations can be performed on the SSL server socket, but you generally treat it as you would any other server socket.
To run this example, use the keystore we created earlier and run this command:
This server will run indefinitely, sending out a line of text to each client that connects to it.
You can also test it with the sample SSL clients we develop throughout the rest of this chapter.
The SSLSocketFactory class overrides the getDefault( ) method to provide a factory that produces SSL sockets:
For the most part you can treat it like any other socket, but we will look at some advanced ways of handling the SSL socket a little later.
To run this program, we must supply the host and port that we want to contact.
More importantly, the server will present its certificate to us, and we must have the root certificate of the server's CA in our truststore.
Using the truststore we created earlier, we can run the client with this command:
The first line of output is the string we sent to the server; the second line is the string returned by the server.
At this point, we've developed a very simple server and client that communicate via SSL.
We've relied on the SSL implementation to provide many of the details of this communication for us: the certificates used for verification, the cipher suites used, and so on.
In the next few sections, we'll look at the SSL support classes that allow us to modify these things.
When an SSL socket is connected, it joins an SSL session.
If there are many connections between a client and server they may share an SSL session, but there is no programmatic way to determine which sockets are attached to which sessions.
From our perspective, the SSL session is just an object that allows us to retrieve certain information about a particular SSL connection.
Specifically, the SSL session allows us to perform a necessary (but often ignored) step in the verification of an SSL peer.
In our first example, the server has sent its certificate to the client.
If the client recognized the CA that issued the server's certificate, we allowed communication to proceed.
However, as we've mentioned before, just because someone has a valid certificate does not necessarily mean that they can be trusted.
Just because I present a certificate to you is no assurance that I am authorized to take your credit card information.
So when you make an SSL connection, you should verify that the server certificate contains the information you expect.
Typically, this means that the name within the certificate should be the domain name of the machine to which you're connecting.
If your server requires clients to authenticate themselves, the server should follow this procedure with the client's certificate as well.
We will use the last three methods to modify our original client.
We can use the relevant methods of the SSL session to retrieve information and complete the verification of the server.
We use the session object to retrieve the server's certificate.
If the common name in the server's certificate is not equal to its hostname, we print out a warning message.
It is conceivable that the name we used to construct the socket may not exactly match the name embedded within the certificate, so we should obtain the IP addresses of both and ensure that they are the same.
That's the technique we'll use a little later when we perform HTTP client verification.
Note that this is the same thing a browser does when the name within a site certificate does not match the name within the URL.
If you run this with the test keystore created earlier you'll see the warning message, but if you create another keystore with the common name equal to the hostname of your server, this code will execute without the warning.
The SSLContext class is an engine class; it provides the following methods:
Obtain an SSL context that implements the given protocol, optionally by consulting only the given provider.
Since later versions of the protocol can support earlier versions, the string TLS provides the most generic instance of an SSL context.
Typically, you use an SSL context so you can specify a new key manager or trust manager in the init( ) method.
In our first server, we used the default key manager.
Details on how the server socket selects an algorithm are given later in this chapter, but in essence the server will find the first RSA key or the first DSA key, and so on.
The alias that is chosen is arbitrary, as it depends upon the order in which the aliases are returned via a hashtable enumeration.
If you want to use a different keystore, or if you want to make sure that you use a particular alias, you must interact with the key manager.
In the first case, you can simply initialize the default key manager with an appropriate keystore.
In the second case, you must write your own key manager.
Obtain a key manager factory that implements the given algorithm, optionally by consulting only the given provider.
With the security provider that comes with Sun's implementation of JSSE, the algorithm must be "SunX509"
Here, we create the SSL context and then obtain a key manager factory.
The factory is initialized with the keystore that we load from the first argument on the command line.
The keystore uses the second argument to look up its private keys.
Once the context is initialized, we create the server socket factory from the context and obtain the server socket from that factory.
As before, the server socket is actually an instance of the SSLServerSocket class, and the bulk of the program logic is still provided by the SSLSimpleServer class.
In this case, all we've really done is gone from specifying the keystore via a property to specifying it on the command line.
However, our server still will use an arbitrary alias from the keystore.
So now we'll take this example one step further and develop a key manager that allows us to specify which alias in the keystore to use.
To write our key manager, we must implement the following methods of the X509KeyManager interface:
As the API indicates, key managers may be used by both clients and servers in an SSL conversation.
They are more frequently used by servers, since servers must always authenticate themselves to clients.
This key manager is initialized with a keystore and the particular alias in the keystore that you want to use.
Since we've specified an alias we treat client and server authorization the same way, though you could extend this idea to provide different aliases or otherwise treat the server authentication differently.
Strictly speaking, this isn't true: we could instantiate the SSLKeyManager object.
But that violates the spirit of the Java security framework.
The key manager factory expects a keystore and a password but not an alias, so we've had to specify the alias via a system property.
In general, if you need other initialization fields in your own key manager, this is the way to get them.
This engine class requires a security provider, of course; we'll use the provider from Chapter 8, which contains this mapping:
Finally, here's how we use the key manager within our server:
The only code change here is that we've installed the security provider and used the XYZ algorithm to provide the key manager factory.
However, when we run this version of the server, we must remember to set the xyz.aliasName property to an entry in the keystore that we're loading:
By default that property is not defined, and the algorithm defaults to SunX509
Similarity to the KeyManagerFactory interface extends to the definition of the trust manager itself.
It's a simple enough interface that we won't show a complete example that uses it.
If you need to make a connection through a proxy server, use this method of the SSLSocketFactory class:
If you're using your own protocol, it's up to you to define what data should flow between your program and the proxy server before layering the sockets with this call.
If you're using HTTPS, you must send a connect string and read the headers from the proxy server on the underlying socket before you create the SSL socket.
However, if you're using HTTPS as your protocol, it's far easier to use the HTTPS protocol handler, which handles all these details for you (see Section 14.6 later in this chapter)
As we've mentioned, in most SSL conversations the server presents credentials to the client and the client verifies those credentials; the client is then assured of the server's identity.
The client does not normally present its certificate credentials to the server; in fact, the client is not even required to possess such credentials.
To do this, the server uses the setNeedClientAuth( ) method on its server socket as follows:
Remember that if you put this code into your server, your server will need a valid truststore that contains the root certificate of the client's certificate chain.
Be sure to set the appropriate trustStore property when you run a server with this code.
When an SSL conversation begins, the client and server negotiate between themselves as to which SSL cipher suite they will use.
The suite is chosen based upon the credentials that each side possesses and the suites that each side supports.
For example, a server can't support an RSA cipher suite unless it has an available RSA private key.
The client and server must support at least one common cipher suite in order to communicate; if they both support multiple ciphers, the strongest available suite will be chosen.
When a number appears in the encryption algorithm, it refers to the key strength of the encryption: higher numbers are more secure (though the highest numbers used to be subject to export control, and many other SSL implementations may not support them)
The other suites will not be used unless you enable them explicitly.
To see and modify the suites that an SSL socket is using, use the following methods (which are defined for both the SSLSocket and SSLServerSocket classes):
If you're writing the client, you must supply similar code for the SSLSocket.
When the SSL client and server negotiate which cipher suite to use, they engage in an SSL handshake.
If you want to keep track of the handshake, you can use various handshaking event classes.
This event allows you to retrieve the cipher suite that was negotiated, the certificate chain the peer presented for authentication (if applicable), the SSL session that is in use, and the socket on which the event occurred.
Note that all of this information is available directly from the SSL socket as well.
To use some features of JSSE in an environment in which a security manager has been installed, untrusted code will need the following permissions:
As always, the server (sun.com in this case) will present its certificate to the client, which must verify it using its truststore.
If you connect to your own server, you may need to specify the appropriate trustStore property.
When we wrote our own SSL client socket code, we had to extract the name from the server's certificate and make sure that it represented the host to which we expected to connect.
The HTTPS protocol handler will do that for us automatically, and if the hostnames don't match, an IOException will be thrown when you attempt to get the input or output stream.
In cases such as this you may want to look up the IP address of the name in the certificate and see if it matches your target.
You may also want to ask the user if it's okay to proceed (regardless of whether the names match)
To handle such situations, you can implement a hostname verifier in order to perform extended hostname verification.
Extended hostname verification is used only if the name in the certificate and the hostname in the URL don't match; if the names match, the HTTPS protocol handler does not call the hostname verifier.
Hence, a hostname verifier cannot be used to prevent any arbitrary connection.
These are returned from the openConnection( ) method of the URL class.
There are two methods by which you can install a hostname verifier:
Code that is involved in an SSL conversation can be tricky to debug because many of the details that you'd normally handle yourself (key exchange, certificate verification, and so on) are hidden from you.
When these operations don't work, it can be difficult to figure out what went wrong.
SocketException with the somewhat cryptic detail message of "No SSL Sockets" if you specify an incorrect password for a keystore used by an SSL context or an SSL socket factory.
Exceptions are not always thrown when you might expect, however.
In particular, an SSL socket will become connected at the socket level even if the SSL protocol negotiation fails.
For instance, when an SSL client calls the createSocket( ) method, it will receive a valid socket even if it is unable to verify the identity of the server to which it is connecting (because, for example, the client used the incorrect truststore)
If the client attempts an SSL operation on the socket (such as retrieving the certificate chain in order to verify the server's hostname), an exception will be thrown.
If, however, the client just uses the socket, no exception will occur: the write( ) method will succeed.
In this case, the server can read from the socket, but it will get no data.
Similarly, the server can write data to the client and the client will see that data was written but be unable to read that data.
In our simple test program, this manifests itself with the following output:
Here the client has failed to specify a truststore; it will use the default cacerts truststore.
Since that truststore does not contain the root certificate that our server uses, the server verification fails.
But the client doesn't really know that until it reads data from the server and receives a null string.
This is another reason why it's important to verify the name of the peer to which you are connecting.
In this chapter, we've looked at JSSE and how it provides support for SSL and TLS.
Since it requires only one participant in a conversation to possess a valid certificate, SSL makes it easy to send and receive secure, encrypted data in an environment with relatively few servers and many clients.
From an application perspective, the HTTPS protocol handler that comes with JSSE makes it simple to talk to HTTPS servers using the same code you'd use to talk to a standard HTTP server.
Authentication and Authorization So far, we've examined security mainly from the perspective of how it protects the end user from the outside world.
The default sandbox protects end users from writers of malicious Java programs; digital signatures protect the integrity of end user data while encryption protects the confidentiality of end user data.
But how do we protect the rest of the world from end users? That's the topic of this chapter, which focuses on the Java Authentication and Authorization Service ( JAAS)
Like the default sandbox, permissions granted to particular users by JAAS are administered by a system administrator; the system administrator also sets up the default parameters that JAAS uses.
However, applications must be modified in order to use JAAS; by default, Java applications do not use the JAAS framework.
In this chapter, we'll look into all aspects of JAAS:
Like the engines we looked at earlier, JAAS provides a set of abstract classes, and at runtime each program finds the appropriate provider of the necessary class.
However, the pluggable architecture is not built into the standard security framework, so we will refrain from referring to the major JAAS classes as engines.
The program asks the user to log in, obtaining a user login object.
Programmatically, this is a simple operation, involving the instantiation of a LoginContext object and the invocation of a single method on that object.
What happens when that method is invoked can be quite complex and is determined by a system administrator.
The system administrator is responsible for setting up a file that contains one or more directives indicating what happens when a particular application attempts to log in a user.
These directives take the form of login modules that are called to authenticate the user and a series of options that govern how those classes can be used.
The classes themselves typically interact with the operating system, using system calls to authenticate the user via Solaris' NIS or NIS+, the Windows NT login service, an LDAP server, or whatever other authentication system is available on the platform.
The system administrator also determines the parameters of the authentication.
For example, the user may be required to enter a valid Solaris password.
Alternately, she may be required to enter a valid LDAP password, a valid NT password, or a valid password held in a custom database and either a valid Solaris or NT password.
One or more of these passwords may be deemed optional.
The administrator can set up as few or as many login modules as desired, and any or all of them may be optional or required.
The program executes a method call (the doAs( ) or doAsPrivileged( ) method), passing in the user login object and the code that should be executed on behalf of that user.
Programatically, this method is very similar to the doPrivileged( ) method of the access controller.
Within the context just created, the program executes code that requires a specific permission (e.g., it attempts to count the files in a directory)
Like all such requests, this code results in a call to the security manager (and hence the access controller) to see if the appropriate permission is granted.
As usual, if all the classes on the stack are granted that permission via the standard policy files (or whatever Policy class is in effect), the permission will be granted and the call will succeed.
However, because the call was executed within the context of the doAs( ) method, the JAAS framework comes into play.
For developers, then, there are two steps to using JAAS: they must make a call to authenticate the user and execute particular methods on behalf of that user.
For administrators, there are three steps: they must configure a set of login modules, configure a set of JAAS policy files, and set up the program's environment correctly.
There are three important steps here: first, we construct a LoginContext object; second, we use that object to log in a user; and third, we pass that user as one of the parameters to the doAs( ) method.
Establish a context by which a user can be authenticated.
The details of that authentication are handled by an external configuration file; the name passed to the constructor of this object is referenced from that configuration file.
Certain ways of authenticating users may require callbacks (e.g., to allow the user to type in a password), which we will explore after our simple example.
If you use a constructor that does not require a callback and then configure the program to use an authentication method that does require a callback, a LoginException is thrown.
That exception also is thrown if there is an error in the external configuration files.
The purpose of a login context is to allow retrieval of an authenticated user, which is represented as a subject object.
You can pass a preexisting subject to the login context if you want to add credentials to the subject.
For now, we'll treat subjects as opaque objects; we'll examine them in detail later in this chapter.
Creating the login context does not authenticate the user; that is done via the login( ) method, as our sample code demonstrates.
That method is one of three available to this class:
In essence, each user is represented as an array of Principal objects stored by this class.
There is an array of objects because each user is likely to have several identifying characteristics.
In addition, I may have other identities (such as a database login with a name of scott)
Since a principal contains only a single name, my identity is modeled as a set of these principals.
You can retrieve the entire set of principals from the subject object as well as private and public credentials (i.e., keys and certificates) if they are set by the login system.
Unless you're implementing your own authentication system, you really use the subject object only as an argument to one of the following static methods of the Subject class:
Execute the run( ) method of the given object on behalf of the given subject (possibly with the given access control context)
The doAs( ) method looks remarkably similar to the doPrivileged( ) method of the access controller.
This is not an accident: the doAs( ) method sets up special checking that the access controller uses to perform permission checking.
The details of how that works are coming up next.
The code that we'll execute in our simple example looks like this:
To run our simple example, we must take several administrative steps; in fact, JAAS places a much bigger burden on the administrator than on the developer.
The system administrator must configure a set of login modules that will be executed by the login context, write a set of JAAS policy files for the application, and ensure that the program environment is set up correctly to run the application.
The login context object is quite complex, despite its simple interface.
It is built to support a set of pluggable, stackable login modules.
A login module is the code that actually authenticates a user.
Depending on the module, this may entail either interacting with the user (asking for a login name and password) or using existing information in the user's environment to authenticate the user.
A login module may succeed or fail in its attempt to authenticate a user.
Login modules are called pluggable because they are loaded dynamically.
Instead of calling specific login modules in your code, the login context looks up the login configuration file to see which classes to call.
This allows you to use login modules supplied by third parties.
Login modules are called stackable because you can specify more than one login module in the configuration file.
These modules "stack" within the configuration file; they are called in order, and each one can add one or more principal objects to the current subject (i.e., the current user)
This is how subject objects end up with multiple principals: they may come from a single login module, or they may come from several login modules.
The tag of the CountFiles entry in the first example is matched to the name that is passed to the login context constructor.
Once an entry is found, each of the classes listed is called in order.
The classname is the full classname of the login module you want to use.
The control flag is either required, sufficient, requisite, or optional; we'll discuss the meanings of these later.
We did not list any in our example, but if you wanted to include a parameter to enable debugging, you'd do it like this:
When you stack modules, you can control how they are called via the login control flag.
However, if all modules are optional, the user must pass at least one of them.
This interaction between flags is complicated and is probably best avoided.
In fact, because of the way policy files work, it is impossible to take full advantage of mixing the stacked flags.
The policy flag lists the class that authenticated the user or the principal of the user (e.g., his username)
If you specify one module as sufficient and then a second module as requisite, the entries in the policy file that correspond to the login module listed as requisite will never be granted: the user will never have been logged into that module.
One download contains the Solaris login module and the JNDI login module; the other contains the NT login module and the JNDI login module:
If the user belongs to multiple groups, each group is listed in a separate principal.
This module requires no interaction with the user; all information is obtained from the user's environment.
If the user is logged into a workgroup or standalone configuration, this principal is not available.
If the user belongs to more than one group, each group is listed as a different principal.
This module requires no interaction with the user; all information is obtained from the user's environment.
The JNDI login module The JNDI login module allows you to authenticate a user through JNDI ( JNDI 1.2 is required)
This module requires optional parameters in order to know where the JNDI databases are held; those parameters take this form:
For LDAP, you must know the name of the LDAP server and the name of the entry that stores the user or group information.
The schema must be in the format specified by RFC 2307, which means that the user ID will be retrieved where uid=username.
The password is expected to be in the userPassword field.
Note that regardless of the protocol, the URLs must be contained in quotes and the last option must be followed by a semicolon:
The JNDI login module uses callbacks to obtain the user ID and password (using a technique we'll look at later)
The module can be configured to save each ID and password in its shared state so that subsequent attempts to authenticate the user can use the saved data rather than requesting it from the user again.
You can control how that state is used by setting any of the following optional arguments to true:
If authentication fails, ask the user for a new ID and password and authenticate based on those values.
Once you've written a login configuration file, you must write at least two policy files for the application: a JAAS policy file that grants users particular permissions based on how they were authenticated and a standard Java policy file.
A JAAS policy file is very similar to a standard policy file: the syntax is almost the same, and the permission types are exactly the same.
The only difference is that you must specify the principal type and principal name for each entry.
This difference makes it impossible to use policytool to edit these policy files; you can create them initially with policytool but the final editing must be done by hand.
There is no default location for a JAAS policy file; you can give it any name in any directory you choose.
Later, we'll show how to pass the name of the JAAS policy file to your application.
The entries in this file will apply to all code executed by the doAs( ) method we looked at earlier; this file maps the principals associated with the subject passed to the doAs( ) method with specific permissions.
The codebase and signedBy entries are exactly the same as we've seen all along, and both are optional.
The Principal entry is not optional; you must have one or more of them, and each must specify the principal class type that you want to work with, along with the name of the principal that must be authenticated.
However, either of them may be an asterisk (*), which means that they match all possible principal classes or all possible principal names.
If you use a wildcard, make sure not to enclose it in quotes.
When matching against a policy file entry that contains multiple principals, the authenticated user must match all principals.
More often, you'll see JAAS policy files that list only the principal (such as the last one we looked at), granting a user permissions regardless of where the code was loaded from or whether it was signed.
Code that creates a login context and calls the doAs( ) and doAsPrivileged( ) methods must have (at least) these permissions:
Of course, this code will need other permissions based on what else it does, as well as all the permissions listed in the JAAS policy file.
For simplicity, we generally grant the setup code all permissions.
The code that implements the actual login module must have at least this permission:
However, different login modules will need different permissions based on what they do.
The JNDI login module, for example, needs to be able to open sockets to whatever naming service it is using.
Various providers for the JNDI login module need other permissions; for example, the NIS provider needs all permissions (if they aren't granted, it silently fails)
If the login modules and other extensions are installed as standard extensions this isn't an issue, as they are given all permissions by the default Java policy files.
Now we'll go through the steps required to run the simple code example shown earlier.
If you downloaded the code into a different directory, you'll need to change some of the pathnames in the example.
In case you're typing in the code and configuration files yourself, we'll point out the location where each one needs to go.
In our case, the setup code is the CountFiles class and the action code is the CountFilesAction class.
This type of partitioning will allow us to create separate policy files for the setup code and the action code.
Since we've segregated the code, we must set the classpath when we compile it.
Note that this command compiles both source files since the CountFiles class references the CountFilesAction class; that's why we specified both directories in the classpath.
This entails determining which login module you want to use.
In the sample code online, we provide a configuration file that uses a simple login module (named SimpleLoginModule) that we write later in this chapter.
You can use any other login modules as long as they do not require a callback mechanism to obtain information from the user (our sample program doesn't implement that yet)
The Solaris and NT login modules are good candidates to use since they don't require callbacks; we chose to use the SimpleLoginModule for this example because it works on all platforms, including Microsoft Windows 95/98
The name and location of this file are arbitrary; in subsequent steps we assume that the file is called login.conf and is located in the current directory.
If you're using the simple login module, you'll need to compile it and its associated files:
In the sample code online, policy.jaas is such a file.
If you downloaded the code into a directory other than /files, you need to change the codebase in this file.
The name and location of this file are arbitrary; in subquent steps we assume that the file is called policy.jaas and is located in the current directory.
In the sample code online, policy is such a file.
As with all policy files, its name and location are arbitrary.
This file causes classes loaded from the /files codebase to be given permission to perform any operations.
To run the program, you must specify the following arguments:
For our example, it gives us this command line on Microsoft Windows systems:
If all goes well, the program will run to completion.
The simple example we've just shown is enough to get you started with JAAS, but now we'll delve into some optional topics, including how callbacks are used to get information from the user, how to write your own login module, how to deal with permissions that can't be put into a JAAS policy file, and how to use some advanced administration options.
Login modules such as those for Solaris and NT obtain all their information from the user environment.
Other login modules aren't so lucky: they must somehow prompt the user to enter relevant information (such as an ID and password)
This object is sent to the login modules, and if they need information from the user, they use the handler object to obtain it.
If you think your application might ever need to use a login module that requires callbacks, you should register the appropriate handler in your application.
Implementing a CallbackHandler requires an object that provides this method:
Theoretically, you can implement the Callback interface and create a new type of callback, but such an extension will be proprietary to your application.
We'll focus instead on the seven standard callback classes that you may need to handle in your application:
The JNDI login module requires that you handle the name callback and password callback, which is typical.
For each type of callback, you'll have an if block, substituting the class name where we have the ellipses.
You can set up nice Swing components to prompt for the name, but here's a simple way to read the name from standard input:
As is usual with passwords, the API treats them as arrays of characters rather than strings; this allows you to limit the amount of time that they are held in memory by clearing out the array.
To read the password from the standard input, we'll use this code:
You can use the methods of this class to specify the message and display it to the user as appropriate:
You return an array of which choices were selected through this API:
UNSPECIFIED_OPTION Use the getOptions( ) method to determine what the options are.
If the login module needs to determine which locale the user should be authenticated for, it will provide a language callback object.
If you know your application will use login modules that do not need callbacks, you can specify null as the callback handler (as we did in our first example)
If the login modules will use only a few specific callbacks, you can use a limited callback handler.
This is particularly relevant for server applications with no user to interact with: you can program name and password callback handlers to return a particular name and password, but you cannot hardwire the arbitrary information for other callbacks.
On the other hand, for an interactive application, implementing a callback handler that understands all the possible callbacks gives you the most flexibility.
Say you have a set of IDs and passwords stored in a database somewhere.
You could use a proprietary authentication system, but if you're really ambitious you might want to write a login module to authenticate users based on their Java Cards.
In this section, we'll show you how to write your own login module.
Our rationale (other than pedagogical) for writing a login module is that we want a simple module that will ease testing and can be used on all platforms.
So we're going to write a module that always authenticates a user named "defaultUser." We used this module in our example earlier.
If for some reason the user principal objects cannot be stored, this method should return false.
If this module was configured as optional and it was unable to authenticate the user (i.e., the login( ) method returned false), this method will still be called if other modules authenticated the user.
In that case, this method should not store any information into the subject, and it should clean up any saved state.
It may throw a LoginException if it encounters an error.
We'll say more about that at the end of the chapter.
If // necessary, we could instantiate callback objects // and put them in an array and call the callback handler.
We could also retrieve information from the sharedMap // if we cached a previous login attempt.
Normally, we'd set this from the getName(  ) method of // the name callback, or from the user environment.
Because it always succeeds, this is a good module for testing.
However, we've indicated the logic in all methods that is necessary to handle failure modes as well.
Remember that since login modules can stack, the subject object may have several principals.
This is why we don't add the principal to the subject if it's already there.
This is also why we took care to write a good equals( ) method for the SimplePrincipal class; the default comparison of principal objects is almost never correct, since it compares object references rather than the information contained in the object.
Also remember that even if our module succeeds, other modules may fail and invalidate the entire login process; this is why it's necessary to keep all the state as we proceed.
While they provide essentially the same API, they implement two sets of policies and operate independently: one applies to all code, and one applies only to code run under the doAs( ) method.
This class parses the JAAS policy files and presents the appropriate permissions when asked.
If you need a different JAAS policy, however, you can provide a different implementation of the Policy class, as we'll show in this section.
Except for the subject parameter in the getPermissions( ) method, this is the same API as the core Java Policy class.
This class is constructed with an instance of the policy class; it takes permissions from that class and adds the new file permissions to it.
When it is asked for permissions for a particular subject, it gets the standard permissions for that subject, then iterates through the principal names in that subject and adds a file permission for each of them.
So the user with the principal name sdo will be allowed to read, write, and delete all files in the entire hierarchy of /files/sdo.
Depending on the login modules in place, this will grant additional (probably harmless) permissions.
If you need to avoid this, base the permission on particular principal types.
To use this, you must instantiate it with an instance of the existing Policy class:
This is typically done within the main( ) method of the application, but the policy can be changed at any time.
This works only for policy classes that have a default constructor; it won't work for our UserPolicy class because that class depends on another Policy class, to which it defers most of its work.
However, unlike the core Policy class, this class need not be on the system classpath to be specified in the java.security file.
This is all completely analogous to the core Java policy handling, except that there are no JAAS policy files listed by default in the java.security file.
For that reason, the Subject class and all the principal classes used by JAAS are serializable.
The challenge with this method is that you must set up the login configuration file and JAAS environment on the client.
If you write your own login module, you must distribute it as well.
And you must be careful about environmental issues: if the Subject class is loaded on the server from the Java extensions directory (which is what we usually recommend), your own principal classes must also be loaded from that directory by the server, or object deserialization will fail.
This is a property of how object serialization handles class loading; if you're not serializing the Subject object, it's not a requirement.
The alternate method is to provide authentication on the server.
In that case, you must determine how to obtain callback information from the user.
If all you need are the user ID and password, the client can simply send that information to the server, which can store it in the necessary callback objects.
If you have to handle other callbacks, you must devise your own scheme in order to pass the information between the client and server.
Fortunately, you can usually rely only on a user ID and password.
One technique that can lessen this burden is to rely on groups or roles.
If your application runs on a platform that already supports groups, this is trivial.
This allows those classes to implement their own group or role checking.
Say that you write a principal class called DBPrincipal for database administrators.
You could implement the implies( ) method such that if the name is "DBA," it implies every other DBPrincipal:
Like the rest of the Java security model, it is designed to be very flexible by providing configuration files that determine at runtime how the authentication is performed and which authorizations a particular user should be granted.
This moves much of the burden of these tasks from the developer to the system administrator, and it allows policies to be changed at will.
This appendix provides an annotated listing of that file (including entries that are not present in the default version of the file)
This is the name of the class that will be used as the Policy object.
This class must be on the system classpath (e.g., in rt.jar or the # extensions directory)
This is the name of the class that will be used as the JAAS Policy # object.
You only put this line in this file to change the class # to use.
Note that, unlike the standard Policy object, this class # does not have to be on the system classpath.
There are no default URLs from which to read JAAS policy files.
You may specify them by uncommenting the next property and specifying # a valid URL.
You may specify any number of these files as well.
This is the class used to read the JAAS login configuration file.
If it is not set, a default, internal implementation is used.
It applies both to # standard and JAAS policy files.
This property defines the class that will be used by the default # SSL Server Socket Factory to create SSL server sockets.
Export restrictions prohibit setting this property in the global # version of JSSE; if you set it in that version, it will be ignored.
This property defines the class that will be used by the default # SSL Socket Factory to create SSL sockets.
Export restrictions prohibit setting this property in the global # version of JSSE; if you set it in that version, it will be ignored.
This property defines the algorithm that the default SSL key # manager will use.
This property defines the algorithm that the default SSL trust # manager will use.
Security Resources Books are very useful for learning some things, and hopefully you've gotten some benefit from the one you're holding in your hand.
However, for some types of information, the Internet remains the better choice.
In this appendix, we'll list and discuss various network resources that relate to Java and security.
One reason why this information is better found on the Internet is because it is subject to rapid change.
B.1 Security Bugs Early in my computer science career, I handed in an exam that ended up receiving a lower grade than I had expected.[A] As part of the exam, I was asked to write an algorithm, prove that it was correct, and then provide an implementation of the algorithm.
Such is the potential problem with implementing a security model.
A lot of design and analysis has gone into Java's default security model, and hopefully you'll put your own effort into making your own applications secure.
But no matter how sound the design of a security model, in the end it is the implementation that matters.
In this section, we'll discuss some past bugs in Java's security implementation and list some common resources for finding out about and fixing present bugs.
Few issues in the Java world receive more attention than security bugs; report of a new bug is guaranteed to produce a flurry of activity.
As a result, readers of the trade press often have the idea that Java is riddled with security bugs or that it isn't secure to begin with.
While some important bugs in Java's security implementation have been reported, the impact of these bugs has (at least until now) been minimal.
Bugs that are reported against Java's security model fall into one of five categories:
Reports that are not bugs but that arise from a lack of understanding of Java's security model.
There are two types of very common bugs in this category: applets that perform annoying tasks and applets that seem to break out of the sandbox.
The former category includes applets that take lots of CPU time or otherwise consume many resources.
As we mentioned at the outset of this book, such attacks are annoying but are not security attacks.
The lesson to learn from these reports is this: no computer security model is a substitute for vigilant.
Often, security problems on the Internet are associated with Java without any direct cause.
In particular, bugs related to JavaScriptTM and to ActiveX often fall into this category.
When the first reports of ActiveX security bugs were circulated, there was a lot of discussion about "active content"; the assertion in many quarters was that the security problems that plagued ActiveX were inherent in any active content system.
This assertion attempted to place Java in the same light as ActiveX since both were active content systems.
The reality is that Java and ActiveX have very different security models.
Similarly, bugs in JavaScript are often confused with bugs in Java, in part because of the name.
It is probably well known by this point, but it doesn't hurt to reiterate: JavaScript and Java are completely different technologies produced by separate companies (AOL and Sun, respectively)
The two technologies are complementary in many ways, but they are fundamentally different from a security perspective.
Finally, Java is not immune to security problems that plague the Web in general.
Data that is sent between sites among Java applets and servers can be snooped just like data that is sent via HTTP can be snooped (unless the Java traffic is using SSL or another encryption technique)
A hacker that sets up a site to impersonate XYZ.com will be able to serve Java applets just as she is able to serve HTML.
I know of one corporation where Java is not allowed to be used for any internal project.
This site is not worried about employees doing malicious things to other employees, and they filter out Java class files at their corporate firewall, but developers at this company are still not permitted to use Java for any internal project due to security concerns.
One of the ways to assess the potential impact of Java security bugs is to understand the bugs that have occurred to date and their relative impact.
The fact that these bugs have been fairly minor and quickly fixed is of some comfort.
That is not to say that a future bug won't be more devastating or harder to fix; the point here is really to shed light on the type of bugs that have been found.
Most of the bugs we'll discuss in this section all have another property: attacks based on these bugs were very hard to construct.
In fact, attacks based on these bugs never made it out onto the Internet or other networks; the bugs were all reported by various researchers, and often even the researchers had difficulty in constructing an attack against them.
One bug in this list (the Brown Orifice bug) is an exception to that: it was fairly easy to exploit that particular bug (long since fixed, of course)
There was an additional bug reported in July 1998 regarding the class loader, but this applied only to Netscape's implementation, not to the standard JDK.
Class loader implementation bug In March 1996, a bug was found that allowed an applet to load a class referenced by an absolute pathname.
Verifier implementation bug In March 1996, a bug was discovered that took advantage of an implementation error in the bytecode verifier.
This bug required that the user's machine be running in a DNS domain that it was not registered to and that the attacker's.
Class loader bug In May 1996, a bug in the class loader was discovered that allowed two applets loaded in different class loaders to exploit a way of casting between different classes with the same distinct name.
Verifier implementation bug In March 1997, Sun discovered a bug in the implementation of the verifier.
Exploiting this bug would have required knowledge of the bug itself as well as writing Java bytecodes by hand.
This bug allowed code signed by one entity to be treated as if were signed by a different entity (possibly with more access to the user's machine)
This bug allowed an applet to undermine the typing system of Java.
Compounding this was a bug in Netscape Navigator 4.x (but not other browsers) that allowed these applets to read files; hence the Brown Orifice Exploit turned a user's machine into a web server, serving all the files on the user's machine.
Unauthorized command execution In February 2001, Sun reported a bug that allowed certain untrusted classes to execute arbitrary commands.
This bug applied only to classes that had already been granted permission to execute at least one command; in certain circumstances, these classes were able to execute a command other than the one that had been authorized.
The nature of tracking security bugs makes it impossible to track them through a book such as this; we're sure that the above list is already out of date.
Hence, the better way to track security issues with Java's implementation is to check the following resources on the Web periodically.
This page summarizes their work, including several of the bugs that were listed above.
Work at SIP is funded by many companies, including Sun itself.
The following list is not exclusive: new providers will certainly have been written in the time this book has been published, and the algorithms provided by each entry in the list are subject to change.
In addition to the listed engines, these packages will all provide the necessary key classes and engines to support the algorithms in the package.
The Java Crypto and Security Implementation (JCSI) of DSTC includes a Java 2 security provider that implements the following algorithms:
The JProv provider from ERACOM furnishes a security provider that implements the following:
This package from the Institute for Applied Information Processing and Communications in Austria (IAIK) comes with a security provider that performs the following:
While IAIK must be purchased for commercial use, it is free for noncommercial use.
B.3 Security References Finally, here is a number of white papers and other references that are of general interest:
This page primarily addresses what applets can and cannot do.
For a discussion of implementing cryptographic algorithms in Java with a series of excellent examples, check out this book.
The file used by javakey is called identitydb.obj and is held in the $JAVAHOME directory.
The first step in operating with javakey is to create entries in the javakey database.
You must create entries before assigning them keys or certificates.
When you create an entry, you can specify whether or not you trust the entry; the appletviewer's security manager allows entries that are marked as trusted to access all resources on the machine.
The options to create entities in the javakey database are:
If you want to trust this identity, specify true; otherwise, specify false (the default)
If you want to trust this signer, specify true; otherwise, specify false (the default)
Here's how we create an entry that will eventually hold a private key for signing:
Once entries in the database are created, you can assign keys and certificates to them.
There are two ways to do this: you can generate the credentials, or you can import them.
Generate a public and private key pair for the given signer using the given algorithm.
If the optional files are specified, the encoded public and private keys are saved to those files.
A private key must already have been generated for this signer.
The private and public key of this entity must already have been generated.
This property is optional; if it is not specified, a DSA signature will be used.
If you specify RSA, you must have the appropriate security provider installed.
This property is optional (the certificate is always saved within the javakey database itself, of course)
If you want to generate a certificate, you must generate the public and private keys first.
Here's what the sdo_cert file for this example looks like:
Now that we have a certificate, we must export it.
In general, you can export it and transmit it to someone else who can import it into his javakey database.
This will allow him to run with special permissions code that is signed by you.
In theory, you can send the certificate to a CA in order for them to issue an official certificate.
However, the CA requires the certificate to be embedded within a certificate signing request, and there is no tool to create such a request in 1.1, so you'd have to write the code to do the conversion yourself.
If the entity already has a public key, the public key must match the key held in the certificate.
The credentials that are to be imported must also be encoded in DER format.
Hence, if you get a certificate issued by a CA, you must decode that certificate (again in an ASCII format) into a DER format before you import it into the javakey database.
Hence, these commands are generally used to import files that were previously exported by javakey.
To sign a jar file, you must have an entity in the database that holds a private key and a certificate; that entity is used in conjunction with this command:
The directive file is a properties file that specifies the following properties:
For example, if this property is SDO, the signature and block files will be SDO.SF and SDO.DSA.
This is optional; if you use it, the signature information is added to the input jar file.
C.1.5 Miscellaneous javakey Commands javakey also supports the following miscellaneous commands:
The information string is printed with the detailed information for an entity.
An identity can represent an individual or a corporation (or anything else that can possess a public and a private key)
Key management in 1.1 is only concerned with managing public and private keys; none of these classes understand the notion of a secret key.
An identity object holds only a public key; private keys are held in a different type of object (the signer object, which we'll look at a little later)
Hence, identity objects represent the entities in the world who have sent you their public keys in order for you to verify their identity.
Identities can be aggregated into a collection, which is called an identity scope.
Note that the default implementation of an identity object carries with it no notion of trustworthiness.
You're free to add that feature to your own identity class.
If you want to use an identity object, the following methods are at your disposal:
Test if the given identity is equal to the current object.
Identities are considered equal if they are in the same scope and have the same name.
Otherwise, they are considered equal if the identityEquals( ) method returns true.
By default, identities in different scopes are considered equal by the identityEquals( ) method if they have the same name and the same public key.
An application that wants to work with identities will typically provide its own identity class.
Because all of the methods in the Identity class are fully implemented, our class need only construct itself.
Here are the constructors in the Identity class that we have the option of calling:
This constructor is not designed to be used directly; it is provided for use by object serialization only.
We've chosen in this example only to implement the second of these constructors.
Other than the constructor, we are not required to implement any methods in our class.
If you are implementing an identity within an identity scope, there are methods that you'll need to override in order to get the expected semantics.
Our identity class has one other option available to it, and that is the ability to determine when two identities will compare as equal (via the equals( ) method)
The equals( ) method itself is final, and it will claim that two identities are equal if they exist in the same scope and have the same name.
If either of those tests fails, however, the equals( ) method relies on the following method to check for equality:
The default behavior for this method is to return true if the identities have the same name and the same key.
If your identity class has other information, you may want to override this method to take that other information into account.
In common implementations of the security manager, this string is ignored and trusted classes are typically able to work with identities while untrusted classes are not.
An identity has a public key, which can be used to verify the digital signature of something signed by the identity.
In order to create a digital signature, we need a private key.
The Signer class is fully implemented even though it is declared as abstract; an implementation of the Signer class need not implement any methods.
A signer is used just like an identity, with these additional methods:
Except for these two operations, a signer is identical to an identity.
Signers are trivial to implement, given that none of their methods are abstract.
Hence, it is simply a matter of calling the appropriate constructor:
Note an unfortunate problem here: if you've added additional logic to your identity subclass, your signer subclass cannot use that logic.
Your own signer subclass must extend Java's Signer class, not your own identity subclass.
As with the Identity class, the actual string passed to the security manager is preceded with the name of the class, and the name of the identity is appended to the class along with the name of the identity's scope.
C.3 Identity Scopes The database that an identity is held in is an identity scope.
There can be multiple identity scopes in a Java program, though typically there is only a system identity scope.
By default, the system identity scope for all Java programs is read from a file; this file is the database that javakey operates on.
But the architecture of an identity scope can be more complex than a single scope.
This architecture is not as useful as it might seem since the identity scope class does not give any particular.
If you search the system scope in the figure for sdo's identity, you may or may not find it, depending on how the system identity scope is implemented.
That's because there's no requirement that an identity scope recursively search its enclosed scopes for any information.
And the default identity scope does not do such a recursive search.
The idea of an identity scope, of course, is to hold one or more unique identities.
That means that an identity scope might have a name and a public key, which gives you the ability to model an identity database in very different ways.
Conceivably, you might want an identity scope for an organization that contains all the identities of individuals within that organization.
Rather than having a separate identity for the organization itself, the organization's identity can be subsumed by the identity scope.
Since the organization itself also needs a name and a public key, this type of model might offer some flexibility over the alternative: a model that just has a list of identities, some of which are individuals and one of which is the organization.
However, we'll ignore that possibility for now, and just explore the identity scope class with a view to its simplest use: as a holder of one or more identities.
The IdentityScope class is an abstract class, and there are no classes in the core API that extend the IdentityScope class.
Like other classes in the security package, instances of it may be retrieved by a static method (albeit with a different name than we've been led to expect):
Once you have retrieved the system's default scope (or any other identity scope), you can operate on it with the following methods:
Using the principal's name, return the identity object associated with the corresponding principal.
For example, to list all the identities in the default identity database, we need only find the system identity scope and enumerate it:
That adds an sdo identity to the system identity scope for the current execution of the virtual machine, but unless we can somehow save that scope to the identitydb.obj file, the sdo identity will be lost when we exit the virtual machine.
Unfortunately, there are no public methods to save the identity scope.
The ids variable will hold the identities themselves; we've decided to hold the identities in a hashtable so that we can easily search them based on a key.
That key will be their name, which makes locating identities in this scope by name very easy (but notice that locating them by public key is harder)
The second variable, fname, is the name of the file that will hold the persistent copy of this identity scope.
There are three constructors in the IdentityScope class that are available to us:
This constructor is not designed to be used by programmers; it is provided only so that an identity scope may be subject to object serialization.
In our case, we've chosen only to provide our identity scope with a name.
After calling the appropriate superclass constructor, our class opens up the stored version of the identity database and reads it in.
Like the default javakey implementation, we've chosen the simple expedient of object serialization to a persistent file to provide our storage.
If the file isn't found, we create an empty identity scope.
We've provided a simple save( ) method that serializes the private database out to the same file that we read it in from; this method has a package protection so that it will only be accessible by the code we develop.
The remaining methods in our class are all methods we are required to implement because they are methods that are abstract in our superclass.
Because we're storing identities in a hashtable, their implementations are usually simple:
The size( ) method can simply return the size of the hashtable..
The getIdentity(name) method can simply use the name as the lookup key into the hashtable..
The getIdentity(key) method is the most complex method, although only slightly: it merely needs to enumerate the identities and test each one individually to see if the keys match.
The addIdentity( ) method can search to make sure that the name and public key of the new identity are unique and then simply store the identity into the hashtable with the name as its key.
The removeIdentity( ) method can just tell the hashtable to remove the identity with the appropriate key.
The identities( ) method can just return the hashtable enumeration..
There is one remaining protected method of the IdentityScope class:
We haven't used this method in this example, but it is one that we'll rely on later when we extend this example.
When developers need to operate on identities, they expect to access those identities through the system database.
Now that our class is the system database, we can return identities whether they exist in the user's private key database or in the shared public key database.
When we implemented the abstract methods of our IdentityScope class, we could have made the decision to let the security manager override the ability of an untrusted (or other) class to perform these operations.
Hence, a more secure implementation of the getIdentity( ) method might be:
There should be a central database (identity scope) managed by the system administrators of the XYZ Corporation.
This database will hold the public keys of all identities that are used in the system, along with a security level that is assigned to each identity.
Each user should have a private database that holds the user's private key.
The user's private key will be certified by the XYZ Corporation itself, so this private database will need to have the public key of the XYZ Corporation.
We'll make this scope the system scope so that it can encapsulate the knowledge that there are two scopes in use; to a program, it will appear as only a single scope.
This architecture allows a program to access the user's private key but not anyone else's private key; it also allows the corporation to set security policies for classes that are signed by particular entities.
We must implement three classes for this example: an identity class, a signer class, and a shared identity scope class (which will be based upon the XYZFileScope class that we showed above)
First, let's look at an implementation of the Identity class:
We've chosen in this class to ensure that an identity always belongs to a scope and so we only provided one constructor.
Constructing an identity as part of a scope does not automatically add that identity to the scope.
That logic is required either in the constructor (as we have done), or the design of the class will require that the developer using the class explicitly assigns the identity to the scope later.
Other than the constructor, we're not required to implement any other methods in our identity class.
However, we've chosen to override the setPublicKey( ) and addCertificate( ) methods so that those methods throw an exception when an identity is to be assigned a public key that already exists in the identity scope.
You'll recall that when we first introduced the Identity class, we mentioned that this logic was not present.
Adding that logic is a simple matter of checking to see if the public key in question is already in the identity scope.
Implementing the Signer class that we require follows virtually the same process:
In the architecture we're examining, there are two identity scopes:
This scope will hold one and only one instance of XYZSigner.
This signer represents the user who owns that particular database.
Each of these scopes will be an instance of the XYZFileScope that we showed earlier.
To combine them, we'll create another identity scope that holds a reference to both scopes:
This class is completely tailored to a Solaris machine since we've hardwired the name of the private file to a file on the default floppy drive of a Solaris machine, and we've hardwired the name of the public file to a file that can be automounted on the user's machine.
On other machines, the name of the floppy drive will vary, and a complete implementation of this class would really require the filenames to be properties, which could be set to the appropriate values for the hardware on which the Java virtual machine is running.
The public database probably shouldn't even be a file; it should be held on a remote machine somewhere and accessed via RMI or another technique.
We'll leave those enhancements as an exercise for the reader.
Now that we have the two scopes we're interested in, completing the implementation is a simple matter of:
Setting this identity scope to be the system identity scope.
This allows the developer to use the standard methods we've already seen to extract information from this scope.
Overriding the getIdentity( ) and identities( ) methods so that they operate on both included identity scopes.
Remember that often identity scopes are disjoint; in this case, however, it makes sense for there to be a single interface to the two identity scopes.
Overriding the addIdentity( ) and removeIdentity( ) methods to prevent them from changing the underlying identity databases.
We'll see how to manipulate the individual database in the next section.
The XYZ Corporation is concerned about two sorts of identities: identities from corporations and individuals outside the corporation and identities of employees.
The latter must all have private keys in order for the employees to be able to sign documents and will be instances of the XYZSigner class; the former need only public keys and will be instances of the XYZIdentity class.
When a new employee comes to the XYZ Corporation, we must generate a private identity database for that employee on a floppy that can be given to the employee.
As a first step, however, we must create the employee in a standard javakey database so that the employee can be given a certificate to accompany her identity.
This program is then run with the name of the employee as an argument.
The correct private key database is created and written to the floppy.
The private key database has the signing identity of the new employee loaded into it.
The shared public database is opened, and the identity of the new employee is added to it.2
When the system administrator for the XYZ Corporation receives a public key (and a certificate) for an entity that is not going to be a signer within the XYZ Corporation, a similar procedure would need to be followed to enter the certificate into the javakey database, and then extract out the new identity and update only the shared identity scope.
Code to do that would be very similar to the code shown previously.
However, some of those steps rely on methods of the class loader that we haven't yet examined.
Find the class object for a class previously loaded by this class loader.
This method returns null if it cannot find the given class.
In addition to implementing the loadClass( ) method, we need our class loader to provide help to the security manager.
There are three things the security manager will need to know:
There are many ways to implement this, but one way is to let the class loader make that decision.
Our class loader will make that decision based on the location from which the class was loaded; it could instead make that decision based on the signers of the class or any other information.
That's needed because the security manager will always allow classes to make a connection back to the host from which they were loaded.
The default thread group will be based on the class loader instance so that threads can be partitioned based on the application that created them.
According to the Java specification, a class loader is required to cache the classes that it has previously loaded so that when it is asked to load a particular class, it is not supposed to reread the class file.
Not only is this more efficient, but it also allows a simpler internal implementation of many methods, including the resolveClass( ) method.
The Java specification hedges this somewhat by stating that this requirement may change in the future, when the classes will be cached by the virtual machine itself.
Hence, the ClassLoader class in Java 1.0 did not do any caching, and it was up to concrete implementations of class loaders to perform this caching.
Beginning with Java 1.1, however, caching within the class loader was considered important enough that the base ClassLoader class now performs this caching automatically: a class is put into the cache of the class loader in the defineClass( ) method and may be retrieved from the cache with the findLoadedClass( ) method.
Since these methods are final, and since the cache itself is a private instance variable of the ClassLoader class, this permits a class loader to be written without any knowledge of whether the class loader or the virtual machine is doing the caching.
The class loader is the only class suited to make these decisions since the class loader can easily keep track of information like where the class came from.
The easiest way to get around that is to use a different tool to sign the classes.
You can put the classes into a guarded object (such as we did in Chapter 12) and have the certificate accompany the classes that way.
If you're ambitious, you can decode the PKCS #7 signature block in the signed jar file.
However you decide to do it, you must create an array of identity objects; each object in the array must contain the public key of the entity that signed the particular class.
Although it's defined as an arbitrary array of objects, each element of the signers array must be an Identity object, or other parts of the Java API will not work.
This is a method of the ClassLoader class and must be called by your class loader.
If a class loader holds the appropriate array of identities in the variable ids, then this is the code you'd need to use:
The isSecure( ) method in this case must base its decision on information obtained from reading the signed class and verifying the signature accompanies it.
The array of ids will need to be created by.
Return all the classes on the stack to see who has called us.
Return the class that was most recently loaded with a class loader.
Return the depth in the call stack where the most recent class loader was found.
Return the depth in the call stack of the given class.
Return true if the given class is on the stack.
Return true if any class on the stack came from a class loader.
We'll discuss each of these methods, starting with the getClassContext( ) method.
This method itself is rarely used in a security manager, but it is the basis for many of the methods we'll discuss in this section.
The first element of the array is always the Class object for the security manager class, the second element is the Class object for the method that called the security manager, and so on.
Accessing all the classes in this array is one way to determine whether the call originally came from code that is in the Java API or whether it came from other code.
For example, we could put the following method into our custom security manager:
In other words, a method in the Test class invoked a method in the FileReader class, which invoked a method in the FileInputStream class, which invoked a method (the checkRead( ) method, in fact) in the MySecurityManager class.
We get this output because the Thread class constructor calls three other internal methods before it calls the security manager.
The simplest test that we can make is to see if any of the classes involved in the current method invocation are loaded from the network, in which case we can deny the attempted operation.
The class loader first calls the findSystemClass( ) method, which attempts to find the class in the user's classpath.
If that call is unsuccessful, the class loader loads the class in a different manner (e.g., by loading the class over the network)
As far as the Java virtual machine is concerned, the class loader associated with a class that was loaded via the findSystemClass( ) method is null.
If an instance of the ClassLoader class defined the class (by calling the defineClass( ) method), then (and only then) does Java make an association between the class and the class loader.
This association is made by storing a reference to the class loader within the class object itself; the getClassLoader( ) method of the Class object can be used to retrieve that reference.
This is true about most of the methods of this section, which for efficiency reasons are written in native code.
We can use this method to disallow writing to a file by any class that was loaded via a class loader:
With this version of checkWrite( ), only the Java virtual machine can open a file for writing.
When the Java virtual machine initializes, for example, it may create a thread for playing audio files.
This thread will attempt to open the audio device on the machine by instantiating one of the standard Java API file classes.
When the instance of this class is created, it (as expected) calls the checkWrite( ) method, but there is no class loader on the stack.
The only methods that are involved in the thread opening the audio device are methods that were loaded by the Java virtual machine itself and hence have no class loader.
Later, however, if an applet class tries to open up a file on the user's machine, the checkWrite( ) method is called again, and this time there is a class loader on the stack: the class loader that was used to load the applet making the call to open the file.
A number of convenience methods of the security manager class also relate to the current class loader:
The appletviewer initiates a print job when the user selects the "Print" item from one of the standard menus.
Since the request comes from a class belonging to the appletviewer itself (that is, the callback method of the menu item), it is initiating the request (at least as far as the security manager is concerned)
An applet initiates the request when it tries to create a print job directly.
The security manager must then look at the classes on the stack and determine if the operation should succeed.
If there is an untrusted (applet) class anywhere on the stack, the print request started with that class and should be rejected; otherwise, the print request originated from the appletviewer classes and is allowed to proceed.
Note the similarity between this technique and the manner in which the access controller works, where the appletviewer classes would be in the system domain and the applet classes in a different domain.
The example that we just gave is typical of the majority of security checks the security manager makes.
You can often make a decision about whether or not an operation should be allowed simply by knowing whether or not there is a class loader on the stack since the presence of a class loader means that an untrusted class has initiated the operation in question.
There's a group of tricky exceptions to this rule, however, and those exceptions mean that you sometimes have to know the exact depth at which the class loader was found.
Before we dive into those exceptions, we must emphasize that the use of the class loader depth is not pretty, and it is very dependent on each release of Java.
The rules that we're about to give will not necessarily apply to any release of Java except 1.1
The depth at which the class loader was found in the class context array can be determined by this method:
Let's look at this method in the context of the following applet:
Under normal circumstances, we would expect the doMath( ) method to inform us (rather inefficiently)
We would further expect the call to the infiltrate( ) method to generate a security exception since an untrusted class is not normally allowed to link in a native library.
The security exception in this case is generated by the checkLink( ) method of the security manager.
If we were to retrieve the array of classes (via the getClassContext( ) method) that led to the call to the checkLink( ) method, we'd see the following classes on the stack:
Because the untrusted class DepthTest appears on the stack, we are tempted to reject the operation and throw a security exception.
This time, when the checkLink( ) method is called, the class array from the getClassContext( ) method looks like this:
If you expect trusted classes in your Java application to work under the scenario we're discussing here, you must also follow that rule.
But while 3 is a magic number for the checkLink( ) method, it is not necessarily a magic number for all other methods.
In general, for most methods the magic number that indicates that an untrusted class directly attempted an operation is 2: the untrusted class calls the Java API, which calls the security manager.
Other classes have other constraints on them that change what their target number should be.
Toolkit implementations of getPrintJob( ) may execute a print command.
Toolkit implementations may create temporary files; the Java API needs to write to audio and other device files.
In the case of the Thread and ThreadGroup classes, operations that affect the state of the thread call the checkAccess( ) method of the Thread or ThreadGroup class itself, which in turn calls the checkAccess( ) method of the SecurityManager class.
Remember that this table only summarizes the methods of the security manager where the actual depth of the class loader matters to the core Java API.
If you're writing your own application, you need to consider whether or not your application classes want to perform certain operations.
In general, for methods that aren't listed in the above table, a depth of 2 is appropriate if you want your application classes (i.e., classes from the classpath) to be able to perform those operations.
There is a single protected instance variable in the security manager class, and that is the inCheck instance variable:
The value of this variable can be obtained from the following method:
As we'll see, it's only set by the security manager in a rare case, and even if it were set consistently, there's no practical way for your untrusted class to examine the variable during the short period of time it is set.
This variable has a single use: it must be set by the security manager before the security manager calls most methods of the InetAddress class.
The reason for this is to prevent an infinite recursion between the security manager and the InetAddress class.
An untrusted class attempts to open a socket to a particular host (e.g., sun.com)
The expectation is that if the untrusted class was loaded from sun.com the operation will succeed; otherwise, the operation will fail.
A complication arises if the two names do not match directly but may still be the same host.
If the untrusted class is loaded from a URL that contained only the string piccolo, and the class attempts to open a.
Hence, the checkConnect( ) method must retrieve the IP address for both names and compare those IP addresses.
If you implement a checkConnect( ) method that calls the InetAddress class and sets the inCheck variable, you must make the checkConnect( ) method and the getInCheck( ) methods synchronized.
This prevents another thread from directly looking up an IP address at the same time that the security manager has told the InetAddress class not to call the checkConnect( ) method.
We'll list the complete security manager first and then explain the rationale behind some of its methods.
There are a number of tests we want our security manager to reject if they are attempted directly by an untrusted class but which should succeed if they are attempted indirectly by an untrusted class.
For these tests, we have to rely on the class depth to tell us whether the call originated from an untrusted class or not.
We use the checkTrustedDepth( ) method to help us with that: we pass it the stack depth number we mentioned earlier, and the string it should place in the exception if the test fails.
Note that in the implementation of the checkTrustedDepth( ) method that we have to add 1 to the class depth since.
Otherwise, there are three interesting policies in this example: the network policy, the thread policy, and the file policy.
Our implementation of the checkConnect( ) method is designed to allow code to connect back to the host from which it was loaded.
If there is no class loader on the stack, we want to permit access to any host, so we simply return.
Otherwise, we obtain the hostname the untrusted class was loaded from (via the getHost( ) method of the class loader) and compare that to the hostname the untrusted class is attempting to contact.
If the strings are equal, we're all set and can return.
Otherwise, we implement the logic we described earlier by obtaining the IP address for each hostname and comparing the two IP addresses.
If you choose to implement a different network security model for your checkConnect( ) method, there are a few things that you should be aware of:
You may want to implement a similar policy in the checkAccept( ) method so that a class can only accept a connection from the host from which it was loaded.
This is a different security model than that which is implemented by Java's appletviewer and by browsers in 1.1
In those models, any thread in any thread group of the applet can modify any other thread in any other thread group of the applet, but threads in one applet are still prevented from modifying threads in another applet or from modifying the system threads.
But the model we'll describe fits the thread hierarchy a little better.
The key to our model of thread security depends on the getThreadGroup( ) method.
We can use this method to ensure that each class loader creates its threads in a new thread group as follows:
If the program attempts to create a thread in a particular thread group, the checkAccess( ) method can throw a security exception if the thread group in question is not a descendant of the thread group that belongs to the class loader.
If the program attempts to create a thread without specifying the thread group to which it should belong, we can arrange for the getThreadGroup( ) method to return the class loader's default thread group.
This works because the constructors of the thread class call the getThreadGroup( ) method directly to obtain the thread group to which a thread should belong.
We want each instance of a class loader to provide a different thread group.
The simplest way to implement this logic is to defer to the class loader to provide the thread group.
If there is no class loader, we'll use the thread group our superclass recommends (which, if we've directly extended the SecurityManager class, will be the thread group of the calling thread)
The second caveat is that threads may not be expecting this type of enforcement of the thread hierarchy since it does not match many popular browser implementations.
Hence, programs may fail under this model while they may succeed under a different model.
If you are going to implement a security manager, you must determine a policy for reading and writing files and implement it in each of the checkRead( ) and checkWrite( ) methods.
The logic you put into each method is slightly different.
In the case where these methods take a single string argument, the logic is straightforward: the program is attempting to open a file with the given name, and you should either accept or reject that operation.
We based our decision on the depth of the class loader since untrusted classes may not directly open a file for reading or writing, but they may cause that to happen through the Java API.
On the other hand, it is important to be sure that these methods are actually being called from the socket class.
An untrusted class could attempt to pass an arbitrary file descriptor to the File*Stream constructor, breaking into your machine.
Typically, then, the only checks you put into this method are to determine that the FileDescriptor object is valid and the FileDescriptor object does indeed belong to the socket class.
D.3 Running Secure Applications Now we can put this altogether and show the framework necessary to run the application.
The main( ) method of this class installs our custom security manager, creates the class loader we showed earlier, creates a new thread group, and runs the target class in that new thread group.
Object reflection is used to find the main( ) method of the target class, which is passed any remaining arguments from the command line.
To run this program, the first argument is expected to be the URL from which the target application should be loaded.
The second argument is the name of the target class, and any remaining arguments are passed to that class.
Remember you may optionally define a trusted base from which trusted code can be loaded; so a command to run the class Cat through the JavaRunner might look like this:
This will attempt to load the Cat class (plus any classes it references) from the trustedClasses directory on piccolo's web server and then from the /files/sdo/classes directory in the local filesystem.
Implementing a JCE Security Provider When we developed engines in the examples throughout the book, we mentioned that the JCE engines must be deployed in a special way.
In this appendix, we'll give the outline of those deployment rules and fill in the missing code required for JCE registration.
The steps we're outlining (along with parts of the code) can be found at http://java.sun.com/products/jce/doc/guide/HowToImplAProvider.html.
We'll give a summary of that information here; for complete information, consult that URL.
Remember that the steps we list in this appendix are required only if you are implementing one of the following engines: KeyGenerator, Mac, SecretKeyFactory, Cipher, or KeyAgreement.
If you want to develop other engines, you deploy the code for those engines just like any other Java code.
Here are the steps necessary to develop a JCE security provider.
Both Sun and IBM are set up to provide these certificates.
The application for such a certificate must be done both online and by mailing hardcopy documents; the resulting test certificate will be valid for 30 days.
Based on the examples throughout this book, you should have a good idea of how to do that.
However, JCE engines must perform special authentication when they are loaded; sample code to do that follows.
Package your provider and engine classes into a jar file, and use jarsigner along with your test JCE signing certificate to sign the jar file.
Now we'll turn our attention to the code conventions that JCE engines must follow.
All JCE engines must perform two things: they must verify that both the JCE framework classes and the engine itself were loaded from a jar file signed by a recognized JCE signing authority.
In our original security provider, we showed a verifyForJCE( ) method that we'll use to perform this verification.
The constructor of each of the JCE engines you develop must call this method (or execute similar code), which will throw a security exception if the classes cannot be verified.
The steps to verify each jar file are the same:
Find a reference to the jar file, using a class that is known to be in the jar file.
For your provider jar file, you should use the provider.
Ensure that each class contained in the jar file has a valid signature.2
Ensure that the signer of the jar file was a trusted JCE signer.
A trusted JCE signer is either one of the root JCE signers (Sun or IBM) or someone who has been issued a certificate from one of the root signers.
Hence, your verification class must have one of those two certificates available.
Here's a complete implementation of our provider that includes this code:
An access control context allows the access controller to substitute a different context (that is, a different set of protection domains) than the context provided by the stack of the current thread.
This class might be used by a server thread to determine if a particular calling thread should be allowed to perform particular operations.
This class is the service provider interface for the algorithm parameter generator.
If you want to implement your own algorithm parameter generator, you subclass this class and register your implementation with an appropriate security provider.
If you want to implement your own algorithm parameters, you do so by subclassing this class and registering your implementation with an appropriate security provider.
This permission is typically granted to extension classes, which (like the core API) need to be able to perform any operation.
Although it is a permission class, instances of this class have no name and no actions.
The implies( ) method of this class always returns true.
Classes that implement this interface can be used to model certificates.
A code source encapsulates the location from which a particular class was loaded and the public keys (if any) that were used to sign the class.
This information is used by a secure class loader to define a protection domain associated with the class; typically, the class loader is the only object that uses a code source.
A digest input stream is an input filter stream that is associated with a message digest object.
As data is read from the input stream, it is automatically passed to its associated message digest object; once all the data has been read, the message digest object will return the hash of the input data.
You must have an existing input stream and an initialized message digest object to construct this class; once the data has passed through the stream, call the methods of the message digest object explicitly to obtain the hash.
A digest output stream is a filter output stream that is associated with a message digest object.
When data is written to the output stream, it is also passed to the message digest object so that when the data has all been written to the output stream, the hash of that data may be obtained from the digest object.
You must have an existing output stream and an initialized message digest object to use this class.
Classes that implement this interface are used by the access controller to optimize domain checking by combining permissions from domains.
An object of a class that implements the Guard interface may be used to protect access to a resource.
In typical usage, a guard is an object of the Permission class, so that access to the guarded resource is granted if and only if the current thread has been granted the given permission.
This interface is used by the GuardedObject class to guard access to another object.
The contained object is guarded using an object that implements the Guard interface; in typical usage, that would be an instance of a Permission object.
The guarded object stores a serialized version of the object it contains; the contained object will be deserialized and returned by the getObject( ) method only if the guarded object allows access.
An identity scope is a collection of identities; an identity may belong to a single identity scope.
The notion is that scope is recursive: an identity scope may itself belong to another identity scope (or it may be unscoped)
A key is essentially a series of bytes that are used by a cryptographic algorithm.
Depending on the type of the key, the key may be used only for particular operations and only for particular algorithms, and it may have certain mathematical properties (including a mathematical relationship to other keys)
The series of bytes that comprise a key is the encoded format of the key.
A key factory is an engine class that is capable of translating between public or private key objects and their external format (and vice versa)
Key factories operate in terms of key specifications; these specifications are the various external formats in which a key may be transmitted.
Keys are imported via the generatePublic( ) and generatePrivate( ) methods, they are exported via the getKeySpec( ) method, and they are translated via the translateKey( ) method.
This is the service provider interface for a key factory; if you want to implement your own key factory, you do so by extending this class and registering your implementation with an appropriate security provider.
Instances of this class are expected to know how to create key objects from external key specifications and vice versa.
Public and private keys are mathematically related to each other and hence are generated together; this class provides an encapsulation of both the keys as a convenience to key generation.
Note that although the keystore associates entities with keys, it does not rely upon the Identity class itself.
The hash value is variously called a digital fingerprint or a digest.
Message digests are components of digital signatures, but they are useful in their own right to verify that a set of data has not been corrupted.
Once a digest object is created, data may be fed to it via the update( ) methods; the hash itself is returned via the digest( ) method.
This is the service provider interface for the message digest engine; if you want to implement your own message digest class, you do so by extending this class and registering your implementation with an appropriate security provider.
Since the MessageDigest class itself extends this class, you may also extend the MessageDigest class directly.
Implementations of this class are expected to accumulate a hash value over data that is fed to it as a series of arbitrary bytes.
This class forms the base class for all types of permissions that are used by the access controller.
A permission object encapsulates a particular operation (e.g., reading the file /tmp/foo)
It does not, however, grant permission for that operation; rather, the permission object is constructed and passed to the access controller to see if that operation is one which the current security policy has defined as a permissible operation.
As you might infer, a permission collection is a collection of permission objects.
In theory, a permission collection can be a set of arbitrary, unrelated permission objects; however, that usage is best avoided and left to the Permissions class.
Hence, a permission collection should be thought of as a collection of one type of permission: a set of file permissions, a set of socket permissions, etc.
A permission collection is responsible for determining if an individual permission (passed as a parameter to the implies( ) method) is contained in the set of permissions in the object; presumably, it will do that more efficiently than by calling the implies( ) method on each permission in the collection.
If you implement a new permission class that has wildcard semantics for its names, then you must implement a corresponding permission collection to aggregate instances of that class (if you don't need wildcard matching, the default implementation of the Permission class will provide an appropriate collection)
Hence, it is an appropriate collection object for a group of unrelated permissions, which is its typical use: the Policy class uses instances of this class to represent all the permissions associated with a particular protection domain.
The Policy class encapsulates all the specific permissions that the virtual machine knows about.
Alternately, a different default implementation of the policy class may be specified by changing the policy.provider property in the java.security file.
A principal is anything that has a name, such as an identity.
The name in this case is often an X.500 distinguished name, but that is not a requirement.
A private key is a key with certain mathematical properties that allows it to perform inverse cryptographic operations with its matching public key.
A protection domain encapsulates the location from which a class was loaded and the keys used to sign the class (that is, a CodeSource object) and the set of permissions that should be granted to that class.
These protection domains are consulted by the access controller to determine if a particular operation should succeed; if the operation is in the set of permissions in each protection domain on the stack, then the operation will succeed.
This class is typically only used within a class loader.
An instance of the Provider class is responsible for mapping particular implementations to desired algorithm/engine pairs; instances of this class are consulted (indirectly) by the getInstance( ) methods of the engine classes to find a class that implements the desired operation.
A public key is a key with certain mathematical properties that allows it to perform inverse cryptographic operations with its matching private key.
A secure class loader is a class loader that is able to associate code sources (and hence protection domains) with the classes that it loads (classes loaded by a traditional class loader have a default, null protection domain)
All new class loaders are expected to extend this class.
This is the service provider interface for the secure random number generator.
Instances of this engine can be registered with a security provider and used to generate the random numbers required by the security algorithms.
This class manages the list of providers that have been installed into the virtual machine; this list of providers is consulted to find an appropriate class to provide the implementation of a particular operation when the getInstance( ) method of an engine class is called.
This class represents permissions to interact with the methods of the java.security package.
This permission is a basic permission; it does not support actions.
Security permissions are checked by the Identity, Signer, and Provider classes.
Constants protected static final int SIGN; protected static final int UNINITIALIZED; protected static final int VERIFY;
A signed object is a container class for another (target) object; the signed object contains a serialized version of the target along with a digital signature of the data contained in the target object.
You must provide a serializable object and a private key to create a signed object, after which you can remove the embedded object and verify the signature of the signed object by providing the appropriate public key.
A signer abstracts the notion of a principal (that is, an individual or a corporation) that has a private key and a corresponding public key.
An unresolved permission is one for which the implementing class has not been loaded.
If you define a custom permission, the Policy class will represent that custom permission as an unresolved permission until it is time for the Policy class to actually load the class; if the class cannot be found, then it will remain an unresolved permission.
By default, the implies( ) method of this class always returns false.
A certificate contains a public key (see getPublicKey( )) and other associated information.
The certificate contains an internal signature that protects its integrity.
You can verify the integrity of the certificate by calling one of the verify( ) methods.
A certificate factory is used to import certificates or certificate revocation lists from a file or other input stream.
This is the service provider interface used to define a certificate factory.
It is responsible for decoding certificates and certificate revocation lists read from the given input stream.
Instances of this class are obtained from a certificate factory, and you can use those instances to determine if a particular certificate has been revoked.
This class represents certificates as defined in the X.509 standard.
Such certificates associate a public key with a subject, which is usually a person or organization.
You can find out the certificate's subject by calling getSubjectDN( ) while you can retrieve the subject's public key using getPublicKey( )
The certificate's issuer is the person or organization that generated and signed the certificate (see getIssuerDN( ))
A Certificate Revocation List (CRL) is a list of certificates whose keys are no longer valid.
This class represents CRLs as defined in the X.509 standard.
If you have a CRL file that you would like to examine, you can construct an X509CRL object from the file using one of the getInstance( ) methods.
A CRL, just like a certificate, has an internal signature that protects its integrity.
To verify the integrity of the CRL itself, call one of the verify( ) methods with the issuer's public key.
To find out if a particular certificate is revoked, call the isRevoked( ) method with the certificate's serial number.
Extensions are additional bits of information contained in a certificate.
An application that handles a certificate should either correctly interpret the critical extensions or produce some kind of error if they cannot be recognized.
This interface represents key generators that can be used to generate pairs of DSA keys.
Key pair generators that implement this interface can be initialized with information specific to DSA key generation.
Classes that implement this interface allow you to obtain the three variables that are common to both DSA public and private keys.
Classes that implement this interface allow you to retrieve the private key parameter used to calculate a DSA private key.
Classes that implement this interface allow you to retrieve the public key parameter used to calculate a DSA public key.
Classes that implement this interface represent an RSA public or private key.
A class that implements this interface represents an RSA private key that uses the Chinese Remainder Theorem to calculate its value.
This class represents a private key that is suitable for use with RSA cryptographic operations.
This class represents an RSA public key, suitable for use with an RSA cryptographic algorithm.
Algorithm parameter specifications are used to import and export keys via a key factory.
This interface is used strictly for type identification; the specifics of the parameters are left to the implementing class.
This class provides the basis for DSA key generation via parameters; it encapsulates the three parameters that are common to DSA algorithms.
This class provides the ability to calculate a DSA private key based upon the four parameters that comprise the key.
This class provides the ability to calculate a DSA public key based upon the four parameters that comprise the key.
This class is used to translate between keys and their external encoded format.
The encoded format is always simply a series of bytes, but the format of the encoding of the key information into those bytes may vary depending upon the algorithm used to generate the key.
A key specification is used to import and export keys via a key factory.
This may be done either based upon the algorithm parameters used to generate the key or via an encoded series of bytes that represent the key.
Classes that deal with the latter case implement this interface, which is used strictly for type identification.
This class represents the PKCS#8 encoding of a private key; the key is encoded in DER format.
This is the class that is typically used when dealing with DSA private keys in a key factory.
This class encapsulates the RSA key generation parameters for use with a key factory.
This class represents the algorithm parameters for an RSA private key that uses the Chinese Remainder Theorem to calculate its value.
This class represents a key specification for an RSA private key; this specification uses a modulus and a private exponent.
Instances of this class may be used with an appropriate key factory to generate private keys.
This class represents a key specification for an RSA public key.
Instances of this class may be used with an appropriate key factory to generate public keys.
This class represents the X509 encoding of a public key.
It may also be used for private keys, although the PKCS#8 encoding is typically used for those keys.
This class is the service provider interface of the Cipher class.
To implement a particular cipher algorithm, create a subclass of this class and register the class with an appropriate security provider.
Like all SPI classes, the methods that begin with engine are called by their corresponding method (without engine) from the Cipher class.
This is a JCE engine, which means it must be deployed in a specially signed jar file.
This class can be used by implementors of a JCE package to provide hooks into the exemption mechanisms of various governments.
This is done in order to satisfy the import and/or export restrictions of those governments, who might require (for example) a key escrow implemented with this class.
This is the service provider interface for developers of providers that must include special exemption algorithms, such as key escrow.
Since it is a JCE engine, it must be deployed in a specially signed jar file.
This engine class represents a key agreement protocol, which is an arrangement by which two parties can agree on a secret value.
You can obtain an instance of this class by calling the getInstance( ) method.
After initializing the object (see init( )), you can step through the phases of the key agreement protocol using the doPhase( ) method.
Once the phases are complete, the secret value (that is, the key) is returned from the generateSecret( ) method.
This is the service provider interface class for the KeyAgreement class.
If you want to implement a key agreement algorithm, create a subclass of this class and register it with an appropriate security provider.
Because it is a JCE engine, implementations of this class must be deployed in a specially signed jar file.
A key generator creates secret keys for use with symmetric ciphers.
Key generators are obtained by calling the getInstance( ) method; they must then be initialized with an init( ) method.
The key itself is then returned from the generateSecret( ) method.
This is the service provider interface for the KeyGenerator class.
To create an implementation of a key generation algorithm, make a subclass of this class and register the implementation with an appropriate security provider.
Because it is a JCE engine, it must be deployed in a specially signed jar file.
This is a secure message digest, otherwise known as a Message Authentication Code.
This class uses a secret key to perform additional calculations on a message digest (resulting in a MAC), making it impossible to change the original data without the secret key.
As its name implies, null cipher is a cipher that does nothing.
Since a null cipher performs no transformations, its ciphertext will be exactly the same as its plaintext.
Note that it is not an engine; you simply instantiate it directly.
The contained object is serialized and then encrypted using a cipher.
You can construct a sealed object using any serializable object and a cipher that is initialized for encryption.
To decrypt the contained object, call the getObject( ) method with a cipher that is initialized for decryption.
A secret key represents a key that is used with a symmetric cipher.
A secret key factory is used to convert between secret key data formats; like a key factory, this is typically used to import a key based on its external format or to export a key to its encoded format or algorithm parameters.
Instances of this class are obtained by calling the getInstance( ) method.
Keys may be exported by using the translateKey( ) method; they are imported by using the generate Secret( ) method.
This class is the service provider interface for the SecretKeyFactory class.
To create a secret key factory, make a subclass of this class and register your implementation with an appropriate provider.
This class represents a key specification for DES keys; this specification may be used with a secret key factory to import and export DES keys.
It can be used with a secret key factory to import and export DESede keys.
This class represents an IV (initialization vector) for a cipher using a feedback mode.
Ciphers in CBC, PCBC, CFB, and OFB modes need to be initialized with an IV.
This class represents a key specification for a key that is used with passphrase encryption.
This class represents the parameters used to create RC2 keys.
This class represents the parameters used to create RC5 keys.
This class provides the specifications to key factories to translate secret keys.
The default implementation of this method (returned from the getDefault( ) method) will provide standard TCP server sockets; subclasses of this class can be used to obtain SSL server sockets.
Instances of this class can be used to create client sockets.
The default factory (returned from the getDefault( ) method) will create standard TCP sockets; subclasses of this class can be used to obtain SSL sockets.
Instances of this class are sent to all registered listeners on an SSL socket when the protocol negotiation of the socket has concluded.
Classes that implement this interface can be registered with an SSL socket and will be notified when the socket has completed its protocol negotiation.
The socket returned by the accept( ) method of this class will be an SSL socket.
Before calling the accept( ) method, you can enable or disable the various cipher suites you want to support; the server and client sockets will negotiate those cipher suites transparently.
Instances of this factory create server sockets that use SSL.
The factories themselves are obtained via the getDefault( ) method.
Events of this class are sent to all registered listeners on an SSL session when a new property is bound into that session.
Classes that implement this interface can be registered with an SSL session and will be notified whenever a new property is bound into that session.
Classes that implement this interface can be used to group together SSL sessions, which can be set or retrieved via their session ID.
Client side instances of this class are retrieved from an SSLSocketFactory instance; servers obtain instances of this class from the accept( ) method of an SSL server socket.
Instances of this class are used to obtain SSL sockets connected to particular servers and port numbers.
The getDefault( ) method is used to obtain the factory.
It is a basic permission, so it accepts a name but no actions.
Allow modifying the set of principals returned by the getPrincipals( ) method of the Subject class.
Classes (usually Subjects) that implement this interface allow their contents to be destroyed.
This is useful if you want to reuse the object or don't want to hold sensitive information about the object in memory.
You can write a new implementation of this class and install it by setting that property or by calling the setPolicy( ) method of this class.
Classes (usually Subjects) that implement this interface allow themselves to be refreshed (e.g., by rereading their data from a persistent store)
The user may have a set of public and/or private credentials, as well as other principal information.
The doAs( ) methods of this class allow the target code to be run with permission checking to ensure the target subject has been granted the appropriate permissions.
This class allows the domain checking of the doAs( ) method to be optimized by providing a combined set of permissions and domains for the target subject.
This is the interface all callback objects share, used only for type identification.
If you want to perform callbacks to obtain information from the user, you must create a class that implements this interface and provide that class to the LoginContext object.
Certain login modules require that you implement certain callbacks; check the login module documentation for more details.
In the handle( ) method, you must loop through the array, find out the actual type of each object, and then handle the type specifically.
Login modules that want the user to make a particular choice will create an instance of this object and pass it to the callback handler.
Your callback handler should call the setSelectedIndex( ) method to indicate which choice(s) the user made.
Login modules that want the user to acknowledge a particular situation will create an instance of this object and pass it to the callback handler.
Constants public static final int CANCEL; public static final int ERROR; public static final int INFORMATION; public static final int NO; public static final int OK; public static final int OK_CANCEL_OPTION;
Login modules use this callback to determine what locale they are running in.
Login modules use this callback to determine the user ID.
Your callback handler should return the appropriate user ID by calling the setName( ) method.
Login modules use this callback to determine the user's password.
Your callback handler should return the appropriate password by calling the setPassword( ) method.
If the isEchoOn( ) method returns false, then the password should not be echoed as the user types it.
Login modules use this callback to retrieve an arbitrary text string from the user.
Your callback handler set the appropriate text by calling the setText( ) method.
Login modules use this callback to display an arbitrary message to the user.
Constants public static final int ERROR; public static final int INFORMATION; public static final int WARNING;
This class represents a single login module for a particular application.
The control flags indicate whether the module is required, optional, etc.
This class is only used by developers who write their own Configuration class.
This class parses the login configuration files and produces a set of entries that represents the information in those files.
You create an instance of this class (perhaps supplying an appropriate callback handler and/or subject) and then invoke the login( ) method to authenticate the user.
If that succeeds, the user may be retrieved with the getSubject( ) method; that subject is then generally passed to the Subject.doAs( ) method.
If you want to write your own login module, you implement this interface and then list the appropriate class in the login configuration file.
The login( ) method should authenticate the user (perhaps requiring a callback)
However, since other modules may be in use, the user is not fully authenticated until all modules pass.
When that happens, the commit( ) method is called, at which point the module should add the appropriate Subject object to the set of principals.
If one or more modules failed, then the abort( ) method is called instead, at which point the module should clean up its internal state.
Even though they are not standard Java classes, they must be used if you want to perform key and certificate handling or HTTPS host verification.
Classes that implement this interface can be registered with an HTTPS connection.
If the underlying HTTPS socket detects a name mismatch between the server to which it connects and the certificate that the server presents, the verify( ) method will be called to allow the user to accept the connection anyway.
This class implements an HTTPS connection to a particular server.
It is used most often to set the hostname verifier or the cipher suite for the connection.
Classes that implement this interface are used to manage which keys are used by an SSL server socket when it accepts a connection.
Key managers are registered by the init( ) method of the SSLContext class; Sun's implementation of that class actually requires an X509KeyManager object.
This class can be used to obtain a key manager, which can be registered with an SSL server socket to determine which keys that socket uses when it accepts a connection.
Once you have a factory (from the getInstance( ) method), you must initialize it with the keystore you want to use; the key managers returned from the getKeyManagers( ) method can then be used to initialize an SSL context object.
If you want to provide your own mechanism for SSL server sockets to handle keys, you must provide an implementation of this class and register that class with a security provider.
This class is used to affect the context in which an SSL socket is created; in particular, the init( ) method allows you to provide the key and trust managers that will be used to provide and verify the credentials used in the SSL protocol negotiation.
If you want to provide your own definition of the SSL context class, you must provide an implementation of this class and register it with a security provider.
That would allow you to use key and trust managers that are not X509 specific.
This class is used to test for permissions within JSSE.
You do not use it in programs, though you must specify it in the appropriate java.policy file if you want code to be able to perform certain operations.
This is a basic permission; it requires a name but no actions.
Classes that implement this interface can be used to determine which certificates are used to verify the identity of an SSL peer.
Trust managers are registered via the init( ) method of the SSLContext class; Sun's implementation of that class requires an X509TrustManager object.
Instances of this class are used to obtain trust managers, which provide the certificates used to verify the identity of an SSL peer.
The trust manager must be initialized with an appropriate keystore.
If you want to implement your own trust manager, you register an instance of this class with an appropriate security provider.
Implementations of this interface are used to select the keys that an SSL socket presents during protocol negotiation.
If you want to provide a custom key manager, create a class that implements this interface.
Classes that implement this interface are used to verify the certificates presented by an SSL peer during protocol negotiation.
Although it is specific to Sun's implementation, you need at least the names of these classes so that you can configure them into JAAS login configuration files.
This represents the Windows NT domain that a subject has logged into.
In a login configuration file, specifying this class requires that the user be in the given domain.
This represents the Windows NT numeric ID that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given ID.
This represents the Windows NT sid that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given ID.
This is the superclass for Windows NT principals based on the sid of the user.
This represents the Windows NT domain sid that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given ID.
This represents the Windows NT group sid that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given ID.
This represents the Windows NT primary group sid that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given primary ID.
This represents the Windows NT user sid that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given user ID.
This represents the Windows NT user ID that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given user ID.
This class is Sun's default implementation of the policy checking performed by the Subject.doAs( ) method.
It supplies the permissions for a given subject executing code from the given codebase.
Classes that implement the Principal interface for use with a login module may also implement this interface to support group or role operations.
A Solaris subject that contains a principal with a UID of 0, for example, implies a Solaris principal with any other UID.
This represents the Solaris group ID that belongs to a subject.
In a login configuration file, specifying this class requires that the user belong to the given group.
This represents the Solaris user ID that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given user ID.
This represents the Solaris user ID that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given user ID.
The ID in this class is specified as a string (e.g., "sdo")
This represents the X500 name that belongs to a subject.
In a login configuration file, specifying this class requires that the user have the given X500 name.
You could subclass this class and install it via the setConfiguration( ) method of that class.
This class allows you to authenticate users via a JNDI database.
This class allows you to authenticate users via their Windows NT login.
It takes all its information from the user's environment to produce a set of NT principals.
This class allows you to authenticate users via their Solaris login.
It takes all its information from the user's environment to produce a set of Solaris principals.
This class represents permission to read, write, delete, or execute files.
The name encapsulated in this permission is the name of the file; the string "<<ALL_FILES>>" represents all files while an asterisk represents all files in a directory and a hyphen represents all files that descend from a directory.
The actions for this permission are read, write, execute, and delete.
This class is the basis for loading a class dynamically in Java.
For historical reasons, it appears in this package, but it is recommended that all new class loaders subclass the SecureClassLoader class in the java.security package instead of using this class.
Loading a class explicitly may be done with the loadClass( ) method of this class (though classes are usually simply loaded as needed)
This class represents permission to perform certain runtime operations, such as executing other programs.
This class forms the primary interface to the security model of the virtual machine; it is recommended for backward compatibility that access to that model occur through this class rather than by calling the access controller directly.
However, most of the methods of this class simply call the access controller.
This class represents the ability to obtain information via object reflections; specifically, whether private and protected variables and methods may be accessed through object reflection.
As with all basic permissions, this permission carries no actions; it has a single name: access.
This class represents the ability to work with multicast sockets and the ability to use the authenticator classes.
As with all basic permissions, this class carries no actions.
This class represents the ability to work with certain sockets.
The name of this permission is constructed from the hostname or IP address of the machine on the other end of the socket and the port number; either portion of the name is subject to wildcard matching.
Valid actions for this class include connect, resolve, accept, and listen.
While not a traditional class loader, this class allows classes to be loaded via the same mechanics as a class loader: the loadClass( ) method may be called to load a class explicitly, and this class will also be used to load all subsequent classes required by the target class.
The internal class loader used by this class is a secure class loader, so the security model of the access controller will be used by classes loaded in this manner.
This class represents the ability to read or write properties.
The name of a property permission is the name of the property itself; the action for a property permission is either set or get.
