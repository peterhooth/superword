License perpetual the right t patent rig Implemen interfaces Space, or Licensor implemen the applic foregoing hereunder extent of interest in Lead's lic registered.
Specification Lead hereby grants you a fully-paid, non-exclusive, ferable, worldwide, limited license (without the right to sublicense), under Specification Lead's intellectual property rights to view, download, use and reproduce the Specification only for the f internal evaluation.
This includes (i) developing applications intended to run on an tation of the Specification, provided that such applications do not themselves implement any of the Specification, and (ii) discussing the Specification with any third party; and (iii) g brief portions of the Specification in oral or written communications which discuss the tion provided that such excerpts do not in the aggregate constitute a significant portion of the tion.
In addition, the license is expressly conditioned on your not acting outside its scope.
No license is granted for any other purpose (including, for example, modifying the Specification, other than to the your fair use rights, or distributing the Specification to third parties)
Also, no right, title, or or to any trademarks, service marks, or trade names of Specification Lead or Specification ensors is granted hereunder.
Java, and Java-related logos, marks and names are trademarks or trademarks of Oracle America, Inc.
You need not include limitations (a)-(c) from the previous paragraph or any icular "pass through" requirements in any license You grant concerning the use of your ent Implementation or products derived from it.
However, except with respect to Independent tations (and products derived from them) that satisfy limitations (a)-(c) from the previous , You may neither:  (a) grant or otherwise pass through to your licensees any licenses under.
With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is condition from You are or wo distribute.
In addition, the Specification could include technical inaccuracies or typographical errors.
The Spec in other c that it has delivery t.
Government or by a ernment prime contractor or subcontractor (at any tier), then the Government's rights in the and accompanying documentation shall be only as set forth in this license; this is in accordance .F.R.
Convention for the International Sale of Goods and the choice of law rules of any jurisdiction pply.
Licensee agrees to comply strictly with all such laws and regulations and acknowledges the responsibility to obtain such licenses to export, re-export or import as may be required after o Licensee.
No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party..
Java EE applications can ly deployed and easily enhanced as the enterprise responds to competitive.
Java EE Reference Implementation - A reference implementation for prototyping Java EE applications and for providing an operational definition of the Jav Thi.
Vlada Matena wrote the first draft as the Transaction Management and Naming chapters.
In addition, most of le who helped with the previous version continued to help with this version, ith Jon Ellis and Ram Jeyaraman.
Thanks also to all the external reviewers, g Jeff Estefan (Adecco Technical Services)
The environ represe by the b Client C Clients, below.
Note that this figure shows the logical relationships of the s; it is not meant to imply a physical partitioning of the elements into machines, processes, address spaces, or virtual machines.
Containers, denoted by the separate rectangles, are Java EE runtime ments that provide required services to the application components nted in the upper half of the rectangle.
The services provided are denoted oxes in the lower half of the rectangle.
Similar access to databases is provided to JSP SF applications, and servlets by the Web Container, and to enterprise y the EJB Container.
A profile is a configuration of the Java EE platform targeted at a specific class of applications.
As In isola specific This sp pertain satisfied technol model s.
Add Commu profiles at comp files are not a new concept, nor are they unique to the Java EE platform.
Edition must be included according to the referencing rules set out in tform Edition Specification.
Java EE profiles share a set of common features, such as naming and e injection, packaging rules, security requirements, etc.
This guarantees a of uniformity across all products and, indirectly, applications that fall e “Java EE platform” umbrella.
If profiles only included pointwise ogies, they would be little more than bundles of APIs with few or no tietead, the definition of profiles adopted here guarantees that whenever this ation defines requirements on combinations of technologies, these.
These requirements must be by any Java EE profile-based product that includes those two.
In particular, are initiated by submitting a Java Specification Request and are released letion on their own schedule, independently of any concurrent revision of.
This ensures maximum flexibility in defining and releasing a new profile or an updated version of an existing one.
As underta drawba general constitu It is als interest EE plat by prof.
This flexibility guarantees that future profiles able to cover uses well beyond those originally envisioned by the platform ation.
The decision to create a profile should take into account its potential cks, especially in terms of fragmentation and developer confusion.
In , a profile should be created only when there is a natural developer ency and a well-understood class of applications that can benefit from it.
Java form features such as optional components and extensibility can be used iles to achieve a better fit to their intended target.
Application clients offer a r experience similar to that of native applications and have access to all of facilities of the Java EE middle tier.
Applets can be used to provide a powerful user interface Java EE applications.
Simple HTML pages can also be used to provide a re limited user interface for Java EE applications.
Servlets, JSP pages, JSF applications, and filters may be used to generate.
They may also be used enerate XML or other format data that is consumed by other application ponents.
A special kind of servlet provides support for web services using SOAP/HTTP protocol.
These components include web rerces such as HTML pages and applets embedded in HTML pages.
Future versions of specification may more fully define deployment and management of Apation Clients.
Java EE application components never interact directly er Java EE application components.
They use the protocols and methods of ainer for interacting with each other and with platform services.
Interposing ner between the application components and the Java EE services allows the er to transparently inject the services required by the component, such as.
The use of applet containers providing 1.1 APIs is outside the scope of this specification.
The Java EE ers provide the APIs that application components use to access these.
This specification also describes standard ways to extend Java EE with connectors to other non-Java EE application systems, such as me systems and ERP systems.
A Java EE Product r typically implements the Java EE server-side functionality using an transaction processing infrastructure in combination with Java Platform, d Edition (Java SE) technology.
Resource adapters may also provide services that are entirely local, perhaps interact platform adapter work w.
The database is accessible from web components, se beans, and application client components.
Some of these standard services are actually provided by Java SE.
The HTTP serverI is defined by the servlet, JSP, and JSF interfaces and by the web services that is a part of the Java EE platform.
An application-level demarcation interface that is used by the container and application components to demarcate transaction boundaries.
I-IIOP subsystem is composed of APIs that allow for the use of RMI-style ming that is independent of the underlying protocol, as well as an.
Java EE applications can use RMI-IIOP, P protocol support, to access CORBA services that are compatible with the.
Such services would typically be defined by components that live outside of a product, usually in a legacy system.
Only Java EE application clients are to be able to define their own CORBA services directly, using the RMIIs.
Typically such CORBA objects would be used for callbacks when g other CORBA objects.
The ability to use the IIOP l is required to enable interoperability between Java EE products, however E product may also use other protocols.
Requirements for use of the RMIPIs when accessing Enterprise JavaBeans components have been relaxed B 3.0
These CORBA objects may be written in any e and typically live outside a Java EE product.
Java EE applications may use L to act as clients of CORBA services, but only Java EE application clients ired to be allowed to use Java IDL directly to present CORBA services ves.
The PI has two parts: an application-level interface used by the application.
Support for the service provider interface is not required adapter product addition.
Many In EE plat allows a parts: an mail, an in Java EE products.
Instead, JDBC drivers should be packaged as resource s that use the facilities of the Connector API to interface with a Java EE.
The JDBC API is included in Java SE, but this specification includes al requirements on JDBC device drivers.
It provides an object/relational mapping facility for ion developers using a Java domain model to manage a relational database.
This specification a JMS provider that implements both point-to-point messaging as well as.
The Java EE Product Provider must also provide a igured, default JMS connection factory for use by the application in g this JMS provider.
I API is the standard API for naming and directory access.
The JNDI API parts: an application-level interface used by the application components to aming and directory services and a service provider interface to attach a r of a naming and directory service.
The JavaMail API has two application-level interface used by the application components to send d a service provider interface used at the Java EE SPI level.
The JAF API provides a framework for handling data in different MIME types, originat JAF AP applicat.
The Connector architecture defines a standard set of system-level contracts a Java EE server and a resource adapter.
This s to a scalable application environment that can support a large number of nts requiring access to EIS systems.
This contract a Java EE server use a transaction manager to manage transactions across ltiple resource managers.
This contract also supports transactions that are aged internal to an EIS resource manager without the necessity of involvan external transaction manager.
This contract proes support for a secure application environment, which reduces security ats to the EIS and protects valuable information resources managed by the.
The resource adapter can control the security context and transaction context used by the worker thread.
Java EE endpoin services XML-b SOAP/H followsupport ontract that allows a resource adapter to deliver messages to message driveans independent of the specific messaging style, messaging semantics, messaging infrastructure used to deliver messages.
This contract also es as the standard message provider pluggability contract that allows a sage provider to be plugged into any Java EE server via a resource adaptontract that allows a resource adapter to propagate an imported transaction text to the Java EE server such that its interactions with the server and any lication components are part of the imported transaction.
This contract serves the ACID (atomicity, consistency, isolation, durability) properties he imported transaction.
Several Java technologies work together to provide support for web.
The Java API for XML Web Services (JAX-WS) and the Java API for ased RPC (JAX-RPC) both provide support for web service calls using the TTP protocol.
JAX-WS is the primary API for web services and is a.
JAX-WS offers extensive web services functionality, with for multiple bindings/protocols.
Support for JAX-RPC has been made optional as of Java.
The services style of program such we of the w.
The SOAP with Attachments API for Java provides support for manipulating low level SOAP messages.
The Web s for Java EE specification fully defines the deployment of web service nd web service endpoints in Java EE, as well as the implementation of vice endpoints using enterprise beans.
The Web Services Metadata ation defines Java language annotations that make it easier to develop web.
The Java API for XML Registries (JAXR) provides client access to gistry servers.
Java API for JSON Processing (JSON-P) provides a convenient way to (parse, generate, transform, and query) JSON text.
The Java API for ket (WebSocket) is a standard API for creating WebSocket applications.
Java API for RESTful Web Services (JAX-RS) provides support for web using the REST style.
JAX-RS provides a simple high-level API for writing b services as well as a low-level API that can be used to control the details eb service interaction.
Management Extensions (JMX) API is also used to provide some management support.
The Java EE products plug-in components that run in the deployment tool and allow the ent tool to deploy applications into the Java EE product.
This spe product in Chap provide Most Ja specific se.
In general, this specification describe the partitioning of services or functions between machines, servers, sses.
As long as the requirements in this specification are met, Java EE Providers can partition the functionality however they see fit.
A Java EE must be able to deploy application components that execute with the cs described by this specification.
A high end Java EE product might split the server components ltiple servers, each of which can be distributed and load-balanced across a on of machines.
While such machines might exist on-site in an enterprise, ght also reside, for example, in a public cloud.
This specification does not e or preclude any of these configurations.
A Java EE profile may include some or all of these facilities, as described ter EE.9, “Profiles”
This specification includes only a few limits to the ability of a product.
In particular, it includes the same restrictions as Java SE on extensions to Java APIs.
A Java EE product must not add classes to the Java program method.
A Java that inc defined server v system to the ap bases th.
A J compon ming language packages included in this specification, and must not add s or otherwise alter the signatures of the specified classes.
In an actual , an organization may divide role functionality differently to match that.
A Java EE Product Provider is typically an application endor, a web server vendor, a database system vendor, or an operating vendor.
A Product Provider frequently eir implementation on an existing infrastructure.
The form of these tools is not prescribed by this ation.
These roles use tools to produce Java EE applications and components.
The Application ler will generally use GUI tools provided by either a Platform Provider or.
The Application Assembler is responsible for providing assembly ions describing external dependencies of the application that the Deployer solve in the deployment process.
The er uses tools supplied by the Java EE Product Provider to carry out.
For example, the Deployer is responsible for mapping security roles defined by the Application Assembler ont.
A Tool applicat types of indepen o user groups and accounts that exist in the target operational environment.
For example, using ovided with a Java EE product, the Deployer may provide simple tion code that wraps an enterprise bean’s business methods, or customizes earance of a JSP or JSF page.
The er would install the application into the cloud environment, configure its l dependencies, and might handle aspects of provisioning its required es.
The System strator is also responsible for overseeing the runtime well-being of the d Java EE applications.
The System Administrator typically uses runtime ing and management tools provided by the Java EE Product Provider to lish these tasks.
Provider provides tools used for the development and packaging of ion components.
A variety of tools are anticipated, corresponding to the application components supported by the Java EE platform.
Platform dent tools can be used for all phases of development through the.
The Connector Architecture defines the primary APIs used to provide e adapters of many types.
These resource adapters may connect to existing se information systems of many types, including databases and messaging.
Another type of system component is an authorization policy provider as by the Java Authorization Service Provider Contract for Containers ation.
Java EE Product Provider must implement the Java EE APIs in a way that s the semantics and policies described in this specification.
The tion Component Provider provides components that conform to these d policies.
The tor APIs define service provider interfaces for integrating resource adapters ava EE application server.
Resource adapter components implementing the tor APIs are called Connectors.
The Java EE Authorization APIs define provider interfaces for integrating security authorization mechanisms with a application server.
The Java EE Product Provider must implement the Java EE SPIs in a way that supports the semantics and policies described in this specification.
Deploy needs o class fil Assemb required security deploym Provide deploym the appl product.
The J2E integrat enterpri provide support interope Provider components (for example, a Connector Provider) should provide ents that conform to these SPIs and policies.
The mapping allows client access to the application ents from systems that have not installed Java EE product technology.
Java EE Product Provider is required to publish the installed application ents on the industry-standard protocols.
This specification defines the g of servlets and JSP pages to the HTTP and HTTPS protocols, and the g of EJB components to IIOP and SOAP protocols.
The deployment descriptor and e annotations are a contract between the Application Component Provider or ler and the Deployer.
The Application Component Provider or Assembler is to specify the application component’s external resource requirements, requirements, environment parameters, and so forth in the component’s ent descriptor or through class file annotations.
The Connector API supports integration with external se information systems.
The EJB specification now requires support for rability using the IIOP protocol.
The EJB specification has a new container-managed persistence model, support for messag.
The JAX-RPC and PIs provide the basic web services interoperability support.
The JSP specification has been enhanced to simplify the ment of web applications.
The Connector API now supports integration nchronous messaging systems, including the ability to plug in JMS.
This new name gets rid of the confusing “2” while izing even in the short name that this is a Java platform.
To simplify the development for programmers just starting with Java EE, or developing small to.
One other de JNDI lo access t works w resourc.
Depend the dep to deal with Java EE deployment descriptors in many cases.
Even large tions can benefit from the simplifications provided by annotations.
Injection augments the existing okup capability to provide a new simplified model for applications to gain o the resources needed from the operational environment.
Injection also ith deployment descriptors to allow the deployer to customize or override.
When the default is t the application wants, a simple annotation can be used to specify the behavior or configuration.
Web services are much easier to develop using otations defined by the Web Services Metadata specification.
To provide the eb services support, the JAX-RPC technology has evolved into the JAXhnology, which makes heavy use of the JAXB technology to bind Java to XML data.
Both JAX-WS and JAXB are new to this version of the.
The Java EE 6 Managed Bean specification defines the commonalities across the spectrum of Java EE managed objects, extending from basic managed beans through.
The well as manage compon declara a more manage se.
Bean Validation specification, introduced in this release, provides a for validation of managed objects.
Bean Validation is integrated into the rsistence API, where it provides an automated facility for the validation of ities.
JAX-RS is the API for the development of Web services built according epresentational State Transfer (REST) architectural style.
In recent releases the platform has considerably ed the APIs for access to container services while broadening the range of ices available.
In this release we continue the direction of improved cation, while extending the range of the Java EE platform to encompass g technologies in the web space.
Most notably, Java EE 7 includes a revised and greatly simplified JMS.
It also improves the ration of application security, including new descriptors for security ions.
Sensitive resources that can be accessed by many users ften traverse unprotected open networks (such as the Internet) need to be d.
Confidentiality or Data Privacy: The means used to ensure that information is made available only to users who are authorized to access it.
Finally, issues being considered for future versions of this ation are briefly mentioned in Section EE.3.7, “Future Directions”
Initial Request web client requests the main application URL, shown in Figure EE.3-1
The web client forwards the authentication data to the web server, where it is validated by the web.
On the basis of the validation, the web server a credential for the user.
The web server consults the urity policy (derived from the deployment descriptor) associated with the resource to determine the security roles that are permitted access to the urce.
The web container then tests the user’s credential against each role etermine if it can map the user to the role.
A “not authorized” outcome is hed if the web server is unable to map the user to any of the permitted s.
The association is lemented as two related security contexts, one in the web server and one.
It consults the security policy (derived from the ent descriptor) associated with the enterprise bean to determine the.
For each role, the EJB er uses the security context associated with the call to determine if it can caller to the role.
A “not authorized” e is reached if the container is unable to map the caller to any of the.
A “not authorized” result causes an exception to be thrown by the container, and propagated back to the calling JSP page.
Abs call Jav role e call “is authorized”, the container dispatches control to the enterprise ethod.
The result of the bean’s execution of the call is returned to the JSP, mately to the user by the web server and the web client.
Applications that rict their interactions to the provided APIs will retain portability.
A Deployer may choose to modify the security properties in ways consistent with the deployment environment.
The ices may be provided by web components or enterprise beans.
Security policies applications and for enterprise information systems vary for many reasons onnected with this specification.
Product Providers can provide the techogy needed to implement and administer desired security policies while ading to the requirements of this specification.
The content and format of the principal name and the authentication data can vary dep.
Security for secu kinds of ending upon the authentication protocol.
This specition uses the security policy domain, or security domain, terminology.
The security ibutes have many uses (for example, access to protected resources and iting of users)
Security attributes can be associated with a principal by an entication protocol and/or by the Java EE Product Provider.
Java EE platform does not specify what security attributes are associated h a principal.
A principal acquires a ential upon authentication, or from another principal that allows its cretial to be used (delegation)
A container provides two security (discussed in the following sections):
Java language annotations and the deployment or are the primary vehicles for declarative security in the Java EE platform.
They can be used by an application programmer to represent an.
A deployment tor can be associated with groups of components.
A Deployer eployment tool to process the annotations and deployment descriptor.
Programmatic security is useful when declarative security alone is not nt to express the security model of the application.
The API for matic security consists of two methods of the EJB EJBContext interface methods of the servlet HttpServletRequest interface:
For example they allow the ent to determine the principal name of the caller or remote user to use as a e key.
Note that the form and content of principal names will vary widely products and enterprises, and portable components will not depend on al contents of a principal name.
The Jav security Compo In particular, if a principal name is used as a key into a database table, and abase table is accessed from multiple components, containers, or products, e logical principal may map to different entries in the database.
In a distributed environment, nication between Java EE components can be subject to security attacks (for e, data modification and replay attacks)
A secure association is shared security state information that hes the basis of a secure communication between components.
Applications can specify uirements for access to web resources using annotations or elements in.
A role is a logical grouping of users that is defined by an Application nent Provider or Assembler.
Security roles are used with both declarative security and programmatic security.
The RolesAllows, PermitAll, and DenyAll annotations are used to method permissions.
An enterprise bean method can also be associated ethod-permission element in the deployment descriptor.
The methodion element contains a list of methods that can be accessed by a given role.
If the calling principal is in one of the security roles allowed access thod, the principal is allowed to execute the method.
Conversely, if the principal is in none of the roles, the caller is not allowed to execute the.
Access to web resources can be protected in a similar manner.
A container makes rmination based on the security attributes of the calling principal.
In this case, the user group of the calling principal is retrieved.
The principal is in the security role if the principal’s r group matches a user group to which the security role has been mapped.
In this case, the principal name of the calling principal is reved from its security attributes.
If this principal name is the same as a prinl name to which the security role was mapped, the calling principal is in security role.
Security attributes may be transmitted in the calling principal’s ial or in the security context.
In other cases, security attributes may be d from a trusted third party, such as a directory service or a security.
Secure interoperability between enterprise beans in different security policy domain to log in to use S using H other st.
In addition, a component may choose to a foreign server via HTTP.
An application component can be configured SL mutual authentication for security when accessing a remote resource TTP.
Applications using HTTP in this way may choose to use XML or some ructured format, rather than HTML.
An end user can authenticate using f the two supported client types:
The Deployer or System Administrator nes which method to apply to an application or to a group of applications.
A server requests a web client to authenticate the user.
The web client obtains the username and the password from the user transmits them to the web server.
The web server then authenticates the r in the specified realm (referred to as HTTP Realm in this document)
The password may be proed by applying security at the transport layer (for example HTTPS) or at.
Despite its limitations, the HTTP Basic Authentication mechanism is included in t.
This mechanism requires the user to possess a Public Key tificate (PKC)
Currently, a PKC is rarely used by end users on the InterHowever, it is useful for e-commerce applications and also for a singleon from within the browser.
For these reasons, HTTPS client authenticais a required feature of the Java EE platform.
This specification introduces the ability ackage standard HTML or servlet/JSP/JSF based forms for logging in, wing customization of the user interface.
The form based authentication hanism introduced by this specification is described in the Servlet specifion.
However, many web applications need support for that can maintain state across multiple requests from a client.
Credentials that are acquired through a web login process are associated with a sessio session access t other co.
The container uses the credentials to establish a security context for the.
The container uses the security context to determine authorization for o web resources and for the establishment of secure associations with mponents (including enterprise beans)
When uccessfully authenticates with a web server, the container establishes a login context for the user.
For example, an authentication may require exchanging multiple messages across the network.
Therefore, it ble to use lazy authentication, that is, to perform authentication only when it.
A refence to the login session state is made available to the client through okies or URL re-writing.
If SSL mutual authentication is used as the thentication protocol, the client can manage its own authentication ntext, and need not depend on references to the login session state.
With lazy authentication, a user is not required to authenticate until there is a request to access a protected resource.
At that point the user can be asked to provide appropriate ication data.
If a user is successfully authenticated, the user is allowed to he resource.
It must be for a login session to span more than one application, allowing a user to log and access multiple applications.
The required login session support is d in the Servlet specification.
This requirement of a session for each web ports single signon.
The Java EE Product Provider has ibility to choose authentication mechanisms independent of the tions secured by these mechanisms.
When authentication is required, one of the three required login isms listed in the next section may be used.
An application is ired to use any of these mechanisms, but they are required to be available application’s use.
Providers are also required to support basic authentication over SSL.
The we EE prod with the HTTP b user int.
Java EE products must support the following cipher suites to ensure rable authentication with clients:
If the Deployer chooses this form of authentication (over asic, or SSL certificate based authentication), this form must be used as the.
This is the common mode of access to ources on the Internet.
The EJB specification requires that Context method getCallerPrincipal always return a valid Principal The method can never return null.
In Java EE products that contain both a web container and an EJB container, components running in a web container must be able to call enterprise beans even when n such a c product.
When a call is made in ase from a component in a web container to an enterprise bean, a Java EE must provide a principal for use in the call.
Note that the EJB specification lude requirements in this area when using the EJB interoperability l.
Applications are encouraged to use the Run As capability in cases where component may be unauthenticated and needs to call EJB components.
The techniques used may vary with the entation of the application client container, and are beyond the control of the ion.
The application client container may integrate with a Java EE product’s ication system, to provide a single signon capability, or the container may cate the user when the application is started.
App security Section Althoug system user ide relate th Chapter.
Additional application client requirements are described in 10 of this specification.
The wide e of authentication mechanisms used to authenticate the caller to resources the requirement that a Java EE product provide the means to authenticate in rity policy domain of the resource.
A Java EE container must be able to authenticate for acs to the resource using a principal and authentication data specified by a Deyer at deployment time.The authentication must not depend in any way on provided by the application components.
Providing for the confidential age of the authentication information is the responsibility of the Product vider.
The Java EE product must provide for specation of the principal and authentication data for a resource by the applicacomponent at runtime using appropriate APIs.
The application may obtain principal and authentication data through a variety of mechanisms, includreceiving them as parameters, obtaining them from the component’s enviment, and so forth.
A resource can have a principal and attributes that are determ ing the tity.
In this case, a resource principal is not based on inheritance of identity or security attributes from a requesting principal, but gets its idenand security attributes based on the mapping.
A resource principal acts on behalf of a requesting cipal.
Acting on behalf of a caller principal requires delegation of the callidentity and credentials to the underlying resource manager.
In some sceios, a requesting principal can be a delegate of an initiating principal and the urce principal is transitively impersonating an initiating principal.
For example, Kerberos supports a mechanism for the delegation of entication.
This technique may be used when an application server an EIS support different authentication domains.
The initiating principal may have been authenticated and have public key certificate-based credentials.
The security environment for the resource manager may be configured with the Kerberos authentication service.
The minimum set of permissions va EE product is required to grant to a Java EE application is defined in.
With this configuration, for all calls to all enterprise beans from a single ion within a single Java EE product, the principal name returned by the ext method getCallerPrincipal must be the same as that returned by the.
If the first enterprise bean in the call chain is y a servlet or JSP page, the principal name must be the same as that returned ttpServletRequest method getUserPrincipal in the calling servlet or JSP owever, if the HttpServletRequest method getUserPrincipal returns.
A single principal must be the principal used in authorization decisions ss to all enterprise beans in the call chain.
The requirements in this section nly when a Java EE product has been configured to propagate caller.
In this case it is the Run As identity that is propagated to subsequent EJB components, rather than the original caller id.
However, the Java Authorization Contract tainers specification does specify the relationship between the Run As and the access control context used by the Java SE security manager.
Applications express their security requirements in terms of security hich the Deployer maps to users (principals) in the operational ment at deployment time.
An application might define a role representing enticated and unauthenticated users and configure some enterprise bean s to be accessible by this role.
A future of this specification may include such a specification for products that to provide auditing.
We refer to this as “instance-based” an “class-based” access control.
This scenario ely discussed in the Servlet expert group (JSR-53) but we were unable to consensus on the appropriate solution.
If the product also includes support for the Connectors specification, each ent may also acquire one or more connections to access one or more ional resource managers.
Application Component Provider specifies, using a combination of matic and declarative transaction demarcation APIs, how the platform.
The Platform Provider ovide the transaction capabilities to support such a scenario.
In order to achieve the ional semantics required by the application, the Java EE Product Provider o execute the application components sharing a transaction in the same tual machine, or distribute them across multiple virtual machines, in nce with the requirements of the component specifications.
If a a JT text wil def Not of e tion defines the transaction support requirements of Java EE Products that supported by Product Providers.
They may access multiple resource rs and invoke multiple enterprise beans within a single transaction.
The d transaction context is automatically propagated to the enterprise beans and ional resource managers.
The result of the propagation may be subject to the se bean transaction attributes (for example, a bean may be required to use er Managed Transactions)
Servlet filters may use transactional resources within their r methods but should not use any transactional resources in the methods of.
Invocations of enterprise beans in another Java EE product instance (for example, using the EJB interoperability protocol) need not propaga.
Product Provider is not required to support transaction context tion via an HTTP request across web components.
When a web component ted with a transaction makes an HTTP request to another web component, saction context is not propagated to the target servlet or page.
If a web ent starts a transaction in the service or doFilter method (or transactional tor of service or doFilter method), it must be completed before the or doFilter method returns to the network client2
A single product instance might use multiple operating system prosses, or might support multiple host machines as part of a distributed ntainer.
In contrast, it might be possible to run multiple instances of a oduct on a single host machine, or possibly even in a single Java virtual achine, for example, as part of a virtual hosting solution.
The transacn propagation requirement applies within a single product instance and independent of the number of Java virtual machines, operating system ocesses, or host machines used by the product instance.
The web container is required to detect this error and abort the transact.
Unless the called class s or aborts the transaction, the transaction must remain active when the lass returns.
The web container may throw an on to the caller, abort the transaction and return to the caller without error, agate the transaction context back to the caller.
Portable servlets will te any transaction they start before returning from the service method.
To ensure correct operation, web components should obey wing guidelines, and the web container must support at least these usages.
Additional threads that are created for any purpose uld not attempt to start JTA transactions.
Such objects can only be associated with transaction at a time.
Storing them in static fields would make it easy to neously share them between threads in different transactions.
The web container ens that requests to a SingleThreadModel servlet are serialized and thus only thread and one transaction will be able to use the object at a time, and that.
For example, a servlet may start a transaction, access a database, invoke an enterprise bean that s the same database as part of the same transaction, and, finally, commit saction.
A Java EE product must provide a transaction manager that is capable of coordinating two-phase commit operations across multiple XA-capable JDBC databas the java using th commit JDBC d drivers.
The Java EE product may discover the XA capabilities of rivers through product-specific means, although normally such JDBC would be delivered as resource adapters using the Connector API.
The platform must enable transactional JMS access from servlets, JSP nd enterprise beans.
For example, a servlet may wish to start a ion, send a JMS message, invoke an enterprise bean that also sends a JMS e as part of the same transaction, and, finally, commit the transaction.
The platform must enable transactional access to urce adapter from servlets, JSP pages, and enterprise beans.
For example, a servlet may wish to start a ion, access the resource adapter, invoke an enterprise bean that also s the resource adapter as part of the same transaction, and, finally, commit saction.
In particular, it must be possible to combine operations on ore JDBC databases, one or more JMS sessions, one or more enterprise.
A local transaction is typically ficient than a global transaction and provides better performance.
Local ation is not available for transactions that are imported from a different er.
Local transaction optimization must be transparent to a Java EE.
When the first connection to a resource manager is established as part of the transaction, a resource manager specific local transaction is started on the connect can sha transact.
Any subsequent connection acquired as part of the transaction that re the local transaction on the first connection is allowed to share the local ion.
Sharing connections typically results in efficient usage of es and better performance.
Containers are required to provide connection in certain situations; see the Connector specification for details.
A Java EE application component that to use a connection in an unshareable way must provide deployment tion to that effect, to prevent the connection from being shared by the er.
Examples of when this may be needed include situations with changed attributes, isolation levels, character settings, and localization ration.
Containers must not attempt to share connections that are marked.
If a connection is not marked unshareable, it must be transparent to the application whether the connection is actually shared or not.
Jav them ac must tra point to to the C.
If th transact that tran Java EE resourc may res transact support means t identity passwo.
Containers must assume connections to be shareable if oyment hint is provided.
Section EE.10.7, “Java EE Application Client chema”, the EJB specification, and the Servlet specification provide tions of the deployment descriptor element.
Containers that provide connection sharing nsparently switch such cached connection objects (at dispatch time) to an appropriate shared connection with the correct transaction scope.
Refer onnector specification for a detailed description of connection sharing.
In addition, a Java EE Product Provider trict the security configuration of all JDBC connections within a ion to a single user identity.
A Java EE Product Provider is not required to transactions where more than one JDBC identity is used.
Specifically, this hat transactions that require the use of more than one JDBC security (which can be done explicitly via component provided user name and rd) may not be portable.
To fully support such usage, portable applications that include JDBC and JMS access in a single global transaction must not e corresponding transactional resources as “unshareable”
This c resourc Java EE requirem and feat specific the Com defined Persist.
These ents are based on annotations defined in the Java Metadata specification.
The Inject annotation d here is defined in the Dependency Injection for Java specification, and its Java EE applications is defined in the Contexts and Dependency Injection ava EE Platform specification.
Application Assembler and Deployer should be able to customize the beior of an application’s business logic without accessing the application’s rce code.
Typically this will involve specification of parameter values, contion to external resources, and so on.
Deployment descriptors provide this ability lications must be able to access resources and external information in their.
A resource manager connection ory reference is a special entry in the application component’s environt.
A resource environment reference is a speentry in the application component’s environment.
Section EE.5.18.7, “Connector Connection Factory Definition,” describes the use by eligible application components of references to Connector connection fact.
The containers for these application ent types are required to provide the naming environment support described.
The annotations described here are available for use by all tion component types.
The deployment descriptor entries described here ent in identical form in the deployment descriptor schemas for each of.
See the corresponding specification of each application component type for the details.
Use of the application component’s environment allows the application ent to be customized without the need to access or change the application ent’s source code.
The business methods may access the environment using the I interfaces or lookup methods on component-specific context objects.
Alentries from the environment may be injected into the application compot’s fields or methods.
The Application Component Provider declares in the loyment descriptor, or via annotations, all the environment entries that the lication component expects to be provided in its environment at runtime.
The container also provides the ls that allow the Deployer to create and manage the environment of each apation component.
Deployer uses the tools provided by the container to initialize the environt entries that are declared in the application component’s deployment deptor or via annotations.
The Deployer can set and modify the values of the ironment entries.
As part of this process, the Deployer is allowed to overany “lookup” information associated with the application component.
The application component’s inces may use the JNDI interfaces or component context lookup methods to.
Except for components in a web module, each component gets wn java:comp namespace, not shared with any other component.
Compots in a web module do not have their own private component namespace.
Note that an application server ince may represent a single server, a cluster of servers, an administrative ain containing many servers, or even more.
The scope of an application er instance is product-dependent, but it must be possible to deploy multiple lications to a single application server instance.
For historical reasons, the java:comp namespace is shared by all components in a web module.
By created in any o before t created entries context the curr such as Names an expl adminis subcont context.
All the java: namespaces accessible in a resource adapter are the aces of the component that called the resource adapter (when called in the of a component)
For example, if multiple components declare a resource reference same java:app name, the authentication and shareable attributes must.
The ent tool may allow the Deployer to correct the error and continue ent.
Environment entries may be declared ne of the defined namespaces by explicitly including the namespace prefix he name.
It is recommended but not required that environment entries be in the env subcontext of the corresponding naming context.
For example, shared within a module should be declared in the java:module/env.
Note that names that are not under the env subcontext may conflict with ent or future versions of this specification, with server-defined names, the names of applications or modules, or with server-defined resources.
The specification of a mp or java:module name for an environment entry declared in the.
A J the shar define r the give defines java:gl.
However, it must be possible to deploy applications that esources in the shared namespaces that are usable by different entities at n scope.
For example, it must be possible to deploy an application that.
EE.8.3, “Class Loading Requirements.” If the object is of type ng.Class, the Class object must refer to a class that is accessible to the ent.
Note that in cases where the container may return an implementation of the requested type, the implementation subtype might not be accessible mponent.
All instances of an application ent within the same application instance within the same container share the vironment entries.
Application component instances are not allowed to the environment at runtime.
In these cases, a shared instance of the object may be returned.
In all other cases, a new instance of the requested object must be returned on each lookup.
Any Injectio corresp access q main cl clients u applica the stat main cl.
Whether a new of the requested object is injected, or whether a shared instance is , is determined by the rules described above.
The specifications ifferent containers indicate which classes are considered container-managed not all classes of a given type are necessarily managed by the container.
Because application se the same lifecycle as Java SE applications, no instance of the.
The annotation also allows the JNDI name to be d explicitly.
When a deployment descriptor entry is used to specify n, the JNDI name and the field name are both specified explicitly.
Note default, the JNDI name is relative to the java:comp/env naming context.
The annotation is to the set method for the property, which is the method that is called to e environment entry into the class.
The JavaBeans property name (not the name) is used as the default JNDI name.
The all supp callback also sup Depend with su PostCo field inj.
Note, however, that either the field or the could request injection of a resource of a different (non-default) name.
By ly specifying the JNDI name of a resource, a single resource may be into multiple fields or methods of multiple classes.
The component classes listed pport level “Limited” only support Java EE field injection and the nstruct callback.
Note that these are application client main classes, where ection is into static fields.
If the container fails to find a resource needed for injection, ation of the class must fail, and the class must not be put into service.
I otations may also be applied to the class itself.
These annotations declare in the application component’s environment but do not cause the resource jected.
Instead, the application component is expected to use JNDI or a ent context lookup method to lookup the entry.
A resource annotation on any class in the nce hierarchy defines a resource needed by the application component.
A method definition that overrides a method on a ass defines the resource, if any, to be injected into that method.
An ing method may request injection even though the superclass method does est injection, it may request injection of a different resource than is.
This allows, for example, e field to be the target of injection and that field to be used in the entation of the superclass, even though the subclass has no visibility into d and doesn’t know that the implementation of the superclass is using an resource.
Note a declaration of a field in a subclass with the same name as n a superclass always causes the field in the superclass to be hidden.
To support this case, one method of the class may be ed with the PostConstruct annotation (or, equivalently, specified using the nstruct entry of a deployment descriptor)
This method will be called injections have occured and before the class is put into service.
This will be called even if the class doesn’t request any resources to be.
Each class in a erarchy may have PostConstruct and PreDestroy methods.
The order in he methods are called matches the order of the class hierarchy with s on a superclass being called before methods on a subclass.
PostConstruct and PreDestroy annotations are specified by the n Annotations specification.
All classes for which the container manages the cycle of the object also support the PreDestroy annotation.
Environ deploym deploym both an in the d provide Assemb Compo to reque for injec.
The not tors specification for the rules that determine which classes are CDI beans treatment of interceptors.
Environment entries may also be declared by ent descriptor entries.
In this case, the information eployment descriptor entry may be used to override some of the information d in the annotation.
This approach may be used by an Application ler or Deployer to override information provided by the Application.
Applications should not use deployment descriptor entries st injection of a resource into a field or method that has not been designed tion.
It is an error to request injection of two resources into the same target.
The behavior of an application that does so is undefined.
The rules for how a deployment tor entry may override a WebServiceRef annotation are included in the rvices for Java EE specification.
This is not an exhaustive list; consult the onding specification for details.
The names respond to the complete URL of the web application.
The Application Component Provider may make use of three techniques for accessin Provide the nam Second context in the n compon informa.
The Ap set by th entries f The Ap made by.
The Applica values o annotat the look target o g and managing the naming context.
First, the Application Component r may use Java language annotations to request injection of a resource from ing context, or to declare elements that are needed in the naming context.
Third, deployment descriptor entries may be used to declare entries needed aming context, and to request injection of these entries into application ents.
Deployment descriptor entries may also be used to override tion provided by annotations.
Deployer can modify the entries that have been previously set by the tion Component Provider and/or Application Assembler, and must set the f those entries for which a required value has not been specified.
The description deployment descriptor elements and annotation elements provided by the Application Component Provider or Application Assembler help the Dep.
The environment naming context st allow the Deployer to create subcontexts if they are needed by an applion component.
Certain entries in the naming context may have to be iniized with the values of other entries, specifically when the “lookup” lity is used.
In this case, it is an error if there are any circular dependencies een entries.
Similarly, it is an error if looking up the specified JNDI name.
This sec applicat so in th entries, third de descript.
It does ree sections, the first describing annotations for injecting environment the second describing the API for accessing environment entries, and the scribing syntax for declaring the environment entries in a deployment or.
The name and type of the environment entry are as described ote that the container will unbox the environment entry as required to.
The icationType and shareable elements of the Resource annotation must not.
The maximum number of tax exemptions, configured by the Deployer.
The minimum number of tax exemptions, configured by the Deployer.
In addit compon instance instance with no under th are stor subcont.
An application component locates the environment naming context using the JNDI interfaces.
The environment entries are using either annotations on the application component’s code, or using the ry elements in the deployment descriptor.
The env-entry element consists of an optional ion of the environment entry, the environment entry name, which by default ve to the java:comp/env context, the expected Java programming language the environment entry value (the type of the object returned from the JNDI method), and an optional environment entry value.
This means that the environment not accessible from other application components at runtime, and that plication components may define env-entry elements with the same envame without causing a name conflict.
The value must be a string that is valid for.
The minimum number of tax exemptions allowed to be set.
The following example is aration of environment entries corresponding to the earlier injection e.
The maximum number of tax exemptions, configured by the Deployer.
The env-entrylement in the deployment descriptor is optional when an injection target is d.
If the element is not specified, no value will be injected.
In addition, if ent is not specified, the named resource is not initialized in the naming.
The following deployment descriptor t is equivalent to the earlier example that used lookup.
If either element exists, an eventual element of the corresponding Resource annotation (if any) must be.
In other words, assignment of a value to an environment entry via a deployment descriptor, either directly (env-entry-value) or indirectly (lookupname), o.
This sec allow th or to en EJB ref environ busines environ.
A field annotat entity b bean’s n or entity verrides any assignments made via annotations.
The erences are special entries in the application component’s naming ment.
The Deployer binds the EJB reference to the enterprise bean’s s interface, no-interface view, or home interface in the target operational ment.
The link is an ion to the tools used by the Deployer describing the binding of the EJB e to the business interface, no-interface view, or home interface of the d target enterprise bean.
The same linking can also be specified by the tion Component Provider using annotations in the source code of the ent.
It does so in three sections, the first ng annotations for injecting EJB references, the second describing the API ssing EJB references, and the third describing the syntax for declaring the erences in a deployment descriptor.
The EJB annotation represents a reference to an EJB session bean or ean.
The reference may be to a session bean’s business interface, to a session o-interface view, or to the local or remote home interface of a session bean bean.
The following example illustrates how an application component uses the EJB annotation to reference an instance of an enterprise bean.
The target of the reference is not named and resolved by the Deployer, unless there is only one session bean ent within the application that exposes a client view type that matches the erence.
Note that enrise bean references declared via annotations will not, by default, be in subcontext.
This allows the consumer of the ion component’s JAR file (the Application Assembler or Deployer) to r all the EJB references used by the application component.
Deployment or entries may also be used to specify injection of an EJB reference into an ion component.
The ejb-ref element contains a description element and ref-name, ejb-ref-type, home, and remote elements.
Its value is the environment entry name used in the application component code.
Likewise, if the reference is to 2.x local client view interface, the local-home element is required.
The element of the ejb-ref element refers to either the business interface type omponent interface, depending on whether the reference is to a bean’s EJB JB 2.x remote client view.
Likewise, the local element of the ejb-localent refers to either the business interface type, bean class type, or the.
This means that the EJB e is not accessible from other application components at runtime and that plication components may define ejb-ref or ejb-local-ref elements same ejb-ref-name without causing a name conflict.
Application Assembler specifies the link to an enterprise bean as follows:
Application Assembler uses the optional ejb-link element of the ejb-ref jb-local-ref element of the referencing application component.
The valf the ejb-link element is the name of the target enterprise bean.
This is the e as defined by the metadata annotation (or default) on the bean class or in ejb-name element for the target enterprise bean.
The target enterprise bean be in any ejb-jar file or war file in the same Java EE application as the refcing application component.
The Application Assembler specifies the module name of the ejb-jar file or war file containing the referenced enterprise bean and appends the ejbname of the target bean separated by “/”
The module name is the base name of the bundle with no filename extension, unless specified in the deployment descriptor.
The Application Assembler specifies the path name of the ejb-jar file containing the referenced enterprise bean and appends the ejb-name of the target bean separated from the path name by “#”
The path name is relative to the referencing application component JAR file.
In this manner, multiple beans with the same ejb-name may be uniquely identified when the Application Assembler cannot change ejb-names.
Alternatively to the use of ejb-link, the Application Assembler may use the lookup-name element to reference the target EJB component by means of one of i insi.
The EmployeeRecord enterprise bean may be d in the same module as the component making this reference, or it may aged in another module within the same Java EE application as the ent making this reference.
Deployer must ensure that all the declared EJB references are bound to the iness interfaces, no-interface views, or home interfaces of enterprise beans exist in the operational environment.
Info Deployer must ensure that the target enterprise bean is type-compatible h the types declared for the EJB reference.
This means that the target entere bean must be of the type indicated in the ejb-ref-type element or specd via the EJB annotation, and that the business interface, no-interface view, ome and remote interfaces of the target enterprise bean must be Java typepatible with the type declared in the EJB reference (if specified)
If an EJB annotation includes the lookup element or the EJB refce declaration includes the lookup-name element, the Deployer should.
It is an error for an EJB reference declaration to include both an -link and a lookup-name element.
The e was originally declared in the bean’s code using an annotation.
The deployment ovided by the Java EE Product Provider must be able to process the tion supplied in class file annotations and in the ejb-ref and ejb-localents in the deployment descriptor.
For example, an object that implements the ql.DataSource interface is a resource manager connection factory for l.Connection objects that implement connections to a database ment system.
The resource manager connection factory es are special entries in the application component’s environment.
Because these resource manager connection factories allow the er to affect resource management, the connections acquired through the e manager connection factory references are called managed resources (for e, these resource manager connection factories allow the Container to ent connection pooling and automatic enlistment of the connection with a ion)
The name and type of the factory are as described above.
The icationType and shareable elements of the Resource annotation may be control the type of authentication desired for the resource and the ility of connection acquired from the factory, as described in the following.
From a practical standpoint, declaring a commonly used data source at the application level and referring to it using lookup from multiple components may simplify to perfo multipl definiti nothing if neces.
The task can be further simplified by using a data source resource on, see Chapter EE.5, “DataSource Resource Definition”
Of course, prevents the Deployer from separately binding each data source reference sary.
Note that resource manager contion factory references declared via annotations will not, by default, ear in any subcontext.
It is possible to obtain multiple connections by calling the facobject multiple times.
Application Component Provider can control the shareability of the ions acquired from the resource manager connection factory.
By default, ions to a resource manager are shareable across other application.
The Application Component Provider can specify that connections obtaine by spec sharing.
In this case, the application component code invokes a resource ager connection factory method that has no security-related parameters.
In this case, the lication component invokes the appropriate resource manager connection ory method that takes the sign on information as method parameters.
Application Component Provider uses the authenticationType ion element or the res-auth deployment descriptor element to indicate f the two resource authentication approaches is used.
This allows the consumer of the application component’s JAR file (the tion Assembler or Deployer) to discover all the resource manager ion factory references used by an application component.
Deployment or entries may also be used to specify injection of a resource manager ion factory reference into an application component.
The f the environment entry is relative to the java:comp/env context (for e, the name should be jdbc/EmployeeAppDB rather than java:comp/env/ ployeeAppDB)
The res-type element contains the Java programming e type of the resource manager connection factory that the application ent code expects.
The res-type element is optional if an injection target is d for this resource; in this case the res-type defaults to the type of the n target.
The res-auth element indicates whether the application ent code performs resource sign on programmatically, or whether the.
The Application Component Provider indicates the sign onsibility by setting the value of the res-auth element to Application or er.
The value of the res-sharing-scope element is le or Unshareable.
If the res-sharing-scope element is not specified, ions are assumed to be shareable.
It is data sou in the j the jav java:co.
Application Component Provider must use the java.net.URL resource r connection factory type for obtaining URL connections.
Note that resource manager connection factory es declared via annotations will not, by default, appear in any subcontext.
Java EE Connector Architecture allows an application component to use.
Deployer must perform the following tasks for each resource manager ion factory reference declared in the deployment descriptor:
The Deployer use, for example, the JNDI LinkRef mechanism to create a symbolic link.
The rerce manager connection factory type must be compatible with the type deed in the source code or in the res-type element.
If the resource manager nection factory references includes a lookup annotation element or a kup-name deployment descriptor element, the Deployer may choose whetho honor it and have the corresponding lookup be performed, or override it h a binding of his or her own choosing.
The configuration mechanism esource manager specific, and is beyond the scope of this specification.
This is performed in a manner specific to the container and resource manager; it is beyond the scope of this specification For cipa and istr cifi spe.
The mapping is performed in a manner spec to the container and resource manager; it is beyond the scope of this cification.
The minimum requirement is that the Deyer must be able to specify the username/password information for each rerce manager connection factory reference declared by the application ponent, and the container must be able to use the username/password comnnections obtained from the same resource manager connection factothrough a different resource manager connection factory reference ay be shareable.
The container will allow the Deployer to set up the es such that the principal can be propagated (directly or through principal g) to a resource manager, if required by the application.
The Deployer binds the resource environment references to tered objects in the target operational environment.
A field or a method of an application component may be annotated with the Resourc.
The d type of the resource environment reference are as described earlier.
The icationType and shareable elements of the Resource annotation must not.
The use of the Resource annotation to declare a resource ment reference differs from the use of the Resource annotation to declare vironment references only in that the type of a resource environment e is not one of the Java language types used for other environment es.
Note that resource environment rences declared via annotations will not, by default, appear in any subcon.
Instead, the Application Component Provider must all references to administered objects associated with resources using either ions on the application component’s code or the resource-env-ref elements eployment descriptor.
This allows the application component’s JAR file er to discover all the resource environment references used by the ion component.
Deployment descriptor entries may also be used to specify n of a resource environment reference into an application component.
Each resource-env-ref element describes the requirements that the referencing application component has for the referenced administered object.
Its value is the environment entry name used in the application ent code.
The name of the resource environment reference is relative to a:comp/env context.
Deployer must ensure that all the declared resource environment referencre bound to administered objects that exist in the operational environment.
Deployer may use, for example, the JNDI LinkRef mechanism to create a bolic link to the actual JNDI name of the target object.
The Deployer may rride the linkage preferences of a resource environment reference that ines a lookup annotation element or lookup-name deployment descriptor elnt.
Deployer must ensure that the target object is type-compatible with the.
This means that the tarobject must be of the type indicated in the Resource annotation or the ource-env-ref-type element.
The Java EE Product Provider must provide the deployment tools that allow the Deploy tools pr informa element.
Not destinat the sam used to er to perform the tasks described in the previous subsection.
The deployment ovided by the Java EE Product Provider must be able to process the tion supplied in the class file annotations and the resource-env-ref s in the deployment descriptor.
The Deployer binds the message destination references to tered message destinations in the target operational environment.
The d type of the resource environment reference are as described earlier.
The icationType and shareable elements of the Resource annotation must not.
The tion Assembler may use these message destination links to link together e destination references that have been declared using the Resource ion.
A message destination reference declared via the Resource annotation ed to be used to both produce and consume messages; this default may be.
Instead, the Application Component Provider eclare all references to message destinations using either the Resource.
This allows the application component’s consumer to discover all the message destination references used by the ion component.
Deployment descriptor entries may also be used to specify n of a message destination reference into an application component.
Its value is the environment entry name used in the tion component code.
The messagetion-type element specifies the expected type of the referenced ion.
For example, in the case of a JMS Destination, its value might be ms.Queue.
If not specified, messages are assumed to be both consumed and produced.
This is a reference to a JMS queue used in the.
Application Assembler specifies the link between message consumers ducers as follows:
The path name is relative to the referencing application compot JAR file.
Deployer must ensure that all the declared message destination references bound to administered objects that exist in the operational environment.
Deployer may use, for example, the JNDI LinkRef mechanism to create a bolic link to the actual JNDI name of the target object.
The Deployer may rride the linkage preferences of a message destination reference that ines a lookup-name element.
Deployer must ensure that the target object is type-compatible with the.
Deployer must observe the message destination links specified by the Apation Assembler.
Java EE application component types are allowed to use the JTA nsaction interface to start, commit, and abort transactions.
Such ion components can find an appropriate object implementing the nsaction interface by looking up the JNDI name java:comp/ nsaction or by requesting injection of a UserTransaction object using the e annotation.
The authenticationType and shareable elements of the e annotation must not be specified.
Any such reference to a UserTransaction object is only valid within the component instance that performed the look.
A UserTransaction object reference may also be declared in a deployment descriptor in the same way as a resource environment reference.
The authenticationType and shareable elements of the e annotation must not be specified.
Some Ja certain the ORB injectio name fo valid w.
Such applications can find an appropriate object implementing interface by looking up the JNDI name java:comp/ORB or by requesting n of an ORB object.
The container is required to provide the java:comp/ORB r all components except applets.
The following example illustrates how an application component acquires and uses an ORB object using a JNDI lookup.
Such a ent descriptor entry may be used to specify injection of an ORB object.
By default, the ORB instance injected into a component or.
If the shareable element of the Resource annotation is set to false, the ject injected will not be the shared instance used by other components in the ion but instead will be a private ORB instance used only by this component.
This sec that allo a persis Persiste environ factorie for the p.
Ent tion describes the metadata annotations and deployment descriptor elements w the application component code to refer to the entity manager factory for tence unit using a logical name called a persistence unit reference.
The Deployer binds the persistence unit references to entity manager s that are configured in accordance with the persistence.xml specification ersistence unit, as described in the Java Persistence specification.
The first subsection describes annotations for injecting references to y manager factory for a persistence unit; the second describes the API for g an entity manager factory using a persistence unit reference; and the third s syntax for declaring persistence unit references in a deployment or.
The name element specifies the name under which the anager factory for the referenced persistence unit may be located in the ming context.
The Application Component Provider must use persistence unit references to obtain referenc.
See subsection 5.13.1.3 for information on how persistence t references are declared in the deployment descriptor.
This allows the Application ler or Deployer to discover all the persistence unit references used by an.
Deployment descriptor entries may also be used to injection of a persistence unit reference into an application component.
The Application Assembler specifies the path name of of the persistence.xml file for the referenced persistence unit and appends e of the persistence unit separated from the path name by  #
The path name ve to the referencing application component jar file.
In this manner, multiple nce units with the same persistence unit name may be uniquely identified e Application Assembler cannot change persistence unit names.
The Application Assembler or Deployer should exercise caution in nging this value, if specified, as doing so is likely to break the application.
The injection target, if specified, must name exactly the annotated field or property method.
Deployer must perform the following tasks for each persistence unit e declared in the metadata annotations or deployment descriptor:
The Deployer use, for example, the JNDI LinkRef mechanism to create a symbolic link.
The implementation of the ty manager factory classes may be provided by the container directly or by container in conjunction with a third-party persistence provider, as debed in the Java Persistence specification.
Add, remove, and configure entity manager factories in the server environment.
This sec that allo manage persiste the appl context the spec describe.
Persistence context references are special entries in ication component’s environment.
The Deployer binds the persistence references to container-managed entity managers for persistence contexts of ified type and configured in accordance with their persistence unit, as d in the Java Persistence specification.
The first ion describes annotations for injecting references to container-managed anagers; the second describes the API for accessing references to containerd entity managers; and the third describes syntax for declaring these es in a deployment descriptor.
The name element specifies the name under which ner-managed entity manager for the referenced persistence unit may be in the JNDI naming context.
The optional unitName element specifies the the persistence unit as declared in the persistence.xml file that defines the nce unit.
The optional type element specifies whether a transaction-scoped ded persistence context is to be used.
If the type is not specified, a ion-scoped persistence context will be used.
References to containerd entity managers with extended persistence contexts can only be injected eful session beans.
The optional synchronization element specifies the persistence context is always automatically synchronized with the.
If the synchronization element is not specified, the persistence context will be automa configu manage.
The optional properties element specifies ration properties to be passed to the persistence provider when the entity r is created.
See subsection 5.14.1.3 for information on how persistence text references are declared in the deployment descriptor.
This allows the tion Assembler or Deployer to discover all the persistence context es used by an application component.
Deployment descriptor entries may used to specify injection of a persistence context reference into a bean.
If the persistence context type is not specified, a transaction-scoped nce context will be used.
If the persistence context synchronization is ified, the persistence context will be automatically synchronized.
The following example is the declaration of a persistence context reference used by the InventoryManager enterprise bean illustrated in the previous subsect.
The Application Assembler or Deployer should exercise caution in nging this value, if specified, as doing so is likely to break the application.
In general, the Application Assembler or Deployer should er change the value of this element, as doing so is likely to break the applion.
In general, the Application Asbler or Deployer should never change the value of this element, as doing s likely to break the application.
If the name of a specified property is the e as one specified by the PersistenceContext annotation, the value specd in the annotation is overridden.
Deployer must perform the following tasks for each persistence context e declared in the metadata annotations or deployment descriptor:
A comp JNDI na module names a e persistence unit name is specified, the Deployer should bind the persise context reference to an entity manager for the persistence unit specified.
This implementation may be proed by the container directory or by the container in conjunction with a thirdty persistence provider, as described in the Java Persistence specification.
An appl contain This pro Java EE applicat is false.
If the application is running in a application client container, the value of this property is true.
If the ion is running in a Java EE web or EJB container, the value of this property.
ValidatorFactory for ValidatorFactory, or by requesting the injection of an object of the appropriate type via the Resource annotation.
The icationType and shareable elements of the Resource annotation must not ified.
This means that Validators will be equivalent to those obtained by first acquiring a Valictory and then invoking the getValidator method on it with no.
Such resources may be scoped to the application instance be shareable.
An application may define a dependency upon such es in its environment by means of resource definition metadata.
It may expect the resource to be visioned and configured for it by the Deployer or System Administrator.
For example, the resource may viously have been created and configured by the Deployer or System Adistrator.
Wh specifie definiti physica support function support System by the a se.
If multiple resource definitions are cified for a given resource, they must be consistent.
Java EE Product Provider may choose suitable server-specific default valfor optional elements for which values have not been specified.
The automatic provisioning of resources may be ed by an implementation of this specification, but support for this ality is not required.
If the A address should a not supp System applicat.
If the requested resource cannot be vailable or created, the application must fail to deploy.
The Java EE Product r is permitted to impose restrictions upon quality of service elements in nce with its implementation limits and quality of service guarantees.
A Java EE Product r is permitted to reject a deployment if a property that it recognizes has a at it does not support.
A Java EE Product Provider must not reject a ent on the basis of a property that it does not recognize.
DataSource resource may be defined in any of the JNDI namespaces.
Passwords, or other parts of the rce definition, can be overridden by a deployment descriptor when the.
For example, the above DataSource could be referenced as follows:
A URL should not be specified in conjunction with address elements such as server name and port.
If it is, the precedence order is undefined and implem.
If the class name is specified as ataSource, an XA datasource must be provided.
If the request cannot be satisfied, the duct Provider must reject the deployment.
For example, the above JMS ConnectionFactory could be ed as follows:
Mail Session resource may be defined in any of the JNDI namespaces.
For example, the above Destination could be referenced as follows:
The Application Component Provider is responsible for the definition of a Connec annotat.
The tered object resource may be defined in any of the JNDI namespaces d in Section EE.5.2.2, “Application Component Environment aces”
Properties that are specified are used in the configuration of the tered object, as described in the Connector specification.
For example, the above administered object resource could enced as follows:
Requirements common to all resource definition types are described in Section.
The Java EE Provider must also provide a preconfigured, default data source for use by ication in accessing this database.
Application Component Provider or Deployer may explicitly bind a urce resource reference to the default data source using the lookup element esource annotation or the lookup-name element of the resource-ref ent descriptor element.
DataSource resource reference is not mapped to a specific data source by lication Component Provider or Deployer, it must be mapped by the Java uct Provider to a preconfigured data source for the Java EE Product.
Java EE Product Provider must make the default Concurrency Utilities EE objects accessible to the application under the following JNDI names:
Concurrency Utilities object resource environment reference is not to a specific configured object by the Application Component Provider or er, it must be mapped by the Java EE Product Provider to a preconfigured rency Utilities object for the Java EE Product Provider.
If a name is specified using the element then the type of the resource can be any of the types that the d Bean class implements, including any of its interfaces.
If no name is d, the type must be the Managed Bean class itself.
Note that the name t of the Resource annotation serves an entirely different purpose than the element, consistently with other uses of Resource in this specification.
Ref using th the man manage omitted respecti the Res.
The res-type element must contain a type that aged bean implements.
The lookup-name must be present and refer to a d bean by name.
The res-sharing-scope and res-auth elements may be ; if present, they must have the values Shareable and Container vely, so as to match the default values of the corresponding elements of ource annotation.
To make the example at more realistic, one should add an injection-target child element to e-ref.
In Java Depend support to the ex tion describes the metadata annotations and deployment descriptor entries w an application to obtain instances of the CDI BeanManager type.
If r, the authenticationType and shareable elements of the Resource.
EE, support for dependency injection annotations as specified in the ency Injection for Java specification is mediated by CDI.
Per the CDI specification, dependency injection is supported on managed beans.
There are currently three ways for a class to become a managed bean:
Com above, aged be in a bea manage manage tainer.
However, if they are used as CDI d beans (e.g., injected into other managed classes), the instances that are d by CDI may not be the instances that are managed by the Java EE conrefore, to make injection support more uniform across all Java EE ent types, Java EE containers are required to support field, method, and.
Such injection performed in the same logical phase as resource injection of fields and s annotated with the Resource annotation.
In particular, dependency n must precede the invocation of any methods annotated with the struct annotation.
In supporting such injection points, the container must as if it carried out the following steps, involving the use of the CDI SPI.
When such a non-contextual instance is to be destroyed, the container should.
Con CDI SP outcom as if it carried out the following steps.
Java EE contain support types: a JSP pag support EE prof.
The full Java EE platform s four types of containers corresponding to Java EE application component pplication client containers; applet containers; web containers for servlets, es, JSF applications; and enterprise bean containers.
A Java EE profile may only a subset of these component types, as defined by the individual Java ile specification.
Note that even though a Java EE profile might not support for a particular technology, a Java EE product based on that Java ile might nonetheless include support for the technology.
In such a case, irements for that technology described in this chapter would apply.
Java SE platform, provided they meet all the Java EE platform requirements.
In p Since ty make u Use of requirem This sp specifie.
Java EE platform also provides a number of Java technologies in each of ainers defined by this specification.
Table EE.6-1 indicates the technologies ir required versions, which containers include the technologies, and whether nology is required (REQ), proposed optional (POPT), or optional (OPT)
Each Java EE profile specification will include a similar table describing which technologies are required for the profile.
In some cases, a Java EE is not required to provide objects that implement interfaces intended to be ented by an application server, nevertheless, the definitions of such es must be included in the Java EE platform.
If an implementation s support for a technology marked as Optional, that technology must be ed in the containers specified above.
If a product implementation does not a technology marked as Optional, it must not include the APIs for that ogy.1
As the Java EE specification has evolved, some of the technologies originally include introduc by the J removin.
Thi compon provide of the f d in Java EE are no longer as relevant as they were when they were ed to the platform.
The Java EE expert group follows a process first defined ava SE expert group (http://blogs.oracle.com/mr/entry/ g_features) to prune technologies from the platform in a careful and way that minimizes the impact to developers using these technologies, while g the platform to grow even stronger.
Umbrella Expert Group (UEG) for release N of the platform decides to pose that a particular feature be removed.
No actual removal from ification occurs, although the feature may be removed from products at.
Technologies that may be pruned in a future release are marked d Optional in Table EE.6-1
If application components contain the same functionality d by Java EE system infrastructure, there are clashes and mis-management unctionality.
For example, if enterprise beans were allowed to manage threads, the Java EE platform could not manage the life cycle of the enterprise beans, and it could not properl.
In t Product permiss permiss set of p being p which a permiss.
We call these ions the Java EE security permissions set.
The Java EE security ions set is a required part of the Java EE API contract.
We also specify the ermissions that the Java EE Product Provider must be able to restrict from rovided to application components.
In addition, we specify the means by pplication component providers may declare the need for specific ions and how these declarations must be processed by Java EE products.
Java EE products must allow the set of permissions available to tion classes in a module to be configurable, providing application.
When a ent provider has declared the permissions required by a module, on ful deployment of the module, at least the declared permissions must have anted to the application classes and libraries packaged in the module.
If permissions are declared that conflict with the policy of the product.
The Java EE product must ensure that the system trator for the installation be able to define the security policy for the.
That ment must otherwise fully support the requirements of this specification.
This may result in a runtime failure to access these resources even though deployment of the application has succeeded.
For example, cloud environments may require greater restrictions on em resources available to applications than on-premise enterprise ions.
Note that restricting the permissions beyond those in Table EE.6-2 vent some applications from working correctly.
E.6-2 lists the Java permissions that Java EE components (by type) can be granted by a Java EE product, given appropriate local installation ration.
E.6-3 lists the Java permissions that a Java EE product must be capable of ng when running a Web or EJB application component.
If the Target field is Java EE product must be capable of deploying application modules such.
It must be possible to grant FilePermission for dir provided to web components through the ServletContext regardless of its location.
In addition, it must be possible to grant FilePermission for the without granting it for all files under the current directory.
Thus, if a library is packaged in a .war file, it gets the permissions of the e.
This permission set is applied to all modules and libraries d within the .ear file or within its contained modules.
Any ions.xml files within such packaged modules are ignored, regardless of.
This simplifies the syntax that is needed to just the Permission me and two String arguments.
This aligns the declaration syntax with the policy language and the constructor signature for permissions that is nt with the default policy syntax.
Ideally a container would be capable of restricting those as well, but ot a requirement.
File access is restricted according to the permiss described above.
ContentHandler objects are typically d indirectly using the getContent method of URL and URLConnection.
When accessing data of the following MIME types using the getContent method, objects of the corresponding Java type listed in Table EE.6-4 must be returned.
The commu HTTP a EE prod firewall conside view of HTTP-b.
If HTTP proxies are being used in the local environment, the upport in the Java SE platform should be configured to use the proxy iately.
Application components must not be required to configure proxy in order to use an http URL.
It is typical ss using the HTTP protocol to pass through such firewalls, perhaps by.
It is not typical that general TCP/IP traffic, including RMIand RMI-IIOP, can pass through firewalls.
This specification requires that ccess through firewalls be possible where local policy allows.
Some Java ucts may provide support for tunneling other communication through s, but this is neither specified nor required.
Application developers should r the impact of these issues in the design of applications, particularly in cloud environments, where a cloud platform provider might only allow ased access.
Such a database must be accessible from web components, enterprise beans, and application clients, but need not be accessib JDBC C.
In addition, the driver for the database must meet the ompatible requirements in the JDBC specification.
The JNDI name of the rce object should be chosen as described in Section EE.5.7, “Resource r Connection Factory References.” The Java EE platform must be able to.
Of course, tions may also supply a user name and password when connecting to the e.
The component not attempt to change the transaction characteristics of the connection, the transaction, roll back the transaction, or set autocommit mode.
The EJB specification s the precise rules for enterprise beans.
The component should not attempt the ns listed above on the JDBC Connection object that would conflict with.
The connection pooling and ted transaction features are intended for use by JDBC drivers to coordinate application server.
Java EE products are not required to support the tion server facilities described by these APIs, although they may prove.
Connector architecture defines an SPI that essentially extends the ality of the JDBC SPI with additional security functionality, and a full ng and deployment functionality for resource adapters.
A Java EE product ports the Connector architecture must support deploying and using a river that has been written and packaged as a resource adapter using the tor architecture.
The Java EE security restrictions y prevent all application component types except application clients from and exporting a CORBA object, but all Java EE application component n be clients of CORBA objects.
All Java EE products must support requests from clients that ex calls on a connection to either Java IDL server objects or RMI-IIOP bjects (such as enterprise beans)
The server must allow replies to be sent rder, to avoid deadlocks where one call would be blocked waiting for call to complete.
Java EE clients are not required to multiplex calls, h such support is highly recommended.
A Java EE tion that defines or uses CORBA objects other than enterprise beans must such portable stub, skeleton, and tie classes in the application package.
The default ORB returned by ORB.init(new String[0], null) must be usable for such purposes; an.
To support such usage, all web, se bean, and application client containers are required to provide an ORB in the JNDI namespace under the name java:comp/ORB.
The container is , but not required, to share this instance between components.
To support isolation between tions, an ORB instance should not be shared between components in t applications.
To allow this ORB instance to be safely shared between.
Applications with appropriate es must be able to lookup objects in the COSNaming service.
I-IIOP allows objects defined using RMI style interfaces to be accessed e IIOP protocol.
It must be possible to make any remote enterprise bean le via RMI-IIOP.
Some Java EE products will simply make all remote se beans always (and only) accessible via RMI-IIOP; other products might this via an administrative or deployment action.
These and other hes are allowed, provided that any remote enterprise bean (or by n, all remote enterprise beans) can be made accessible using RMI-IIOP.
Because remote enterprise beans may be d using other RMI protocols, portable applications must not depend on the.
Java EE security restrictions typically prevent all application component xcept application clients, from creating and exporting an RMI-IIOP.
All Java EE application component types can be clients of RMI-IIOP objects.
Java EE applications should also use JNDI to lookup non-EJB RMI-IIOP objects.
The application should fetch a om JNDI using an environment entry, and use the name to lookup the OP object.
Typically such names will be configured to be names in the ming name service.
Some products may support use of JNDI and ming for binding objects, but this is not required.
Portable Java EE tion clients can create non-EJB RMI-IIOP server objects for use as objects, or to pass in calls to other RMI-IIOP objects.
This specification only requires that the tion of context information as defined in the EJB specification be ed in the use of RMI-IIOP to access enterprise beans.
The propagation of information is not required in the uses of RMI-IIOP to access objects an enterprise beans.
RMI-IIOP specification describes how portable Stub and Tie classes can ed.
This is typically done by using the -poa o the rmic command.
A Java EE product must provide support for these Stub and Tie classes, typically using the required CORBA POA.
A Java EE product that supports the following types of objects must be able to make them av EJBLoca.
Application ents will generally create a JNDI InitialContext using the default.
The application component may then perform on that InitialContext to find objects as specified above.
The application component’s metadata annotations and/or deployment tor are used to list the names and types of objects expected.
The Deployer res the JNDI namespace to make appropriate components available.
The ames used to lookup such objects must be in the JNDI java: namespace.
For all application ents that have access to the JTA UserTransaction interface, the iate UserTransaction object can be found using the name java:comp/ nsaction.
In all containers except the applet container, application ents may lookup a CORBA ORB instance using the name java:comp/ORB.
It is up to a Java EE product to provide the necessary JNDI service providers for accessing the various.
Thi loader t See Sec librarie objects defined in this specification.
Different JNDI service providers vide different capabilities, for instance, some service providers may.
In such a case, a COSNaming JNDI provider must be available through the web, EJB, and application client ers.
It will also typically be available in the applet container, but this is not.
OSNaming JNDI service provider is a part of the Java SE 7 SDK and JRE.
Chapter EE.5, “Resources, Naming, and Injection” for the complete requirements for the Java EE platform.
The EJB specification requires that all EJB client ers provide a per thread context class loader for dynamically loading system asses.
There may be a top level application class loader, an extension class and so on, down to a system class loader.
The top level application class elegates to the lower class loaders as needed.
The Log package does no will not configu of this s log cert.
This specification does not define any ship between the principal used by a Java EE application and the user ces tree defined by the Preferences API.
A future version of this ation may define the use of the Preferences API by Java EE applications.
All containers that support EJB ust be capable of using the EJB interoperability protocol to invoke.
A Java EE product may also support other protocols for the invocation of enterprise beans.
We objects into a j putValu ava EE product may support multiple object systems (for example, RMId RMI-JRMP)
It may not always be possible to pass object references e object system to objects in another object system.
However, when an se bean is using the RMI-IIOP protocol, it must be possible to pass object es for RMI-IIOP or Java IDL objects as arguments to methods on such an se bean, and to return such object references as return values of a method an enterprise bean.
In addition, it must be possible to pass a reference to -IIOP-based enterprise bean’s Home or Remote interface to a method on -IIOP or Java IDL object, or to return such an enterprise bean object e as a return value from such an RMI-IIOP or Java IDL object.
Java EE product that includes both an EJB container and a web container, ntainers are required to support access to local enterprise beans.
No is provided for access to local enterprise beans from the application client er or the applet container.
The Servlet ation also addresses security, both standalone and within the Java EE.
These optional components of the Servlet specification are requirements va EE platform.
Servlet specification includes additional requirements for web containers part of a Java EE product and a Java EE product must meet these.
To support applications that are distributable, this specification adds the following ents.
Java EE web con that sup one VM target V.
This exception indicates to the programmer that the tainer does not support moving the object between VMs.
A web container ports multi-VM operation must ensure that, when a session is moved from to another, all objects of supported types are accurately recreated on the M.
Servlet specification defines access to local enterprise beans as an l feature.
This specification requires that all Java EE products that include eb container and an EJB container provide support for access to local.
It was split off into its own specification so that it could be used.
The executi Expression Language specification is available at http://jcp.org/en/ ail?id=341
Message Service provider must be included in a Java EE product that support for JMS.
The JMS implementation must provide support for both int-to-point and publish/subscribe messaging, and thus must make those s available using the ConnectionFactory and Destination APIs.
An attempt to use the JMSContext object’s createContext method be prohibited by the container.
The container should throw a imeException, since the first JMSContext already contains a connection.
Application client containers must support the creation of multiple s for each connection.
In general, the behavior of a JMS provider should be the.
In addition, support for other transaction facilities provided transparently to the application by a Java EE product.
The JavaMail API specification does not require any protocol providers, but the JavaMail reference implementation includes an essage store provider, a POP3 message store provider, and an SMTP.
To allow the Java EE platform to configure and manage il API sessions, an application component that uses the JavaMail API request a Session object using JNDI, and should list its need for a Session n its deployment descriptor using a resource-ref element, or by using a e annotation.
In full J full set o use any support specific Adapter.
The use of these notification facilities may be by the restrictions on the use of threads in various containers.
In EJB ers, for instance, it is typically not possible to create threads.
The Java EE deployment tools must deployment of Resource Adapters, as defined in the Connector ation, and must support the deployment of applications that use Resource s.
The can pro execute as the J These m as their are trea.
A te deployment model is defined, including several new deployment ors.
All Java EE products must support the deployment and execution of vices as specified by the Web Services for Java EE specification (JSR-109)
Web Services for Java EE specification is available at http://jcp.org/ detail?id=109
The Web Services for Java ification describes the deployment of JAX-RPC-based services and clients.
In products that support JAX-RPC, it must be possible to deploy JAX-RPCpplications using any of these deployment models.
JAX-RPC specification describes the support for message handlers that cess message requests and responses.
In general, these message handlers in the same container and with the same privileges and execution context AX-RPC client or endpoint component with which they are associated.
Custom serializers and deserializers, if supported, ted in the same way as message handlers.
New applications are encouraged to use S to take advantage of these new facilities that make it easier to write web.
The can pro execute as the J These m as their are trea.
The JAX-WS specification defines client r accessing web services as well as techniques for implementing web service ts.
The Web Services for Java EE specification describes the deployment of S-based services and clients.
The EJB and Servlet specifications also aspects of such deployment.
It must be possible to deploy JAX-WS-based ions using any of these deployment models.
JAX-WS specification describes the support for message handlers that cess message requests and responses.
In general, these message handlers in the same container and with the same privileges and execution context AX-WS client or endpoint component with which they are associated.
Custom serializers and deserializers, if supported, ted in the same way as message handlers.
It must be to deploy JAX-RS-based applications using this deployment model with vlet-class element of the web.xml descriptor naming the applicationd extension of the JAX-RS Application abstract class.
The jcp.org a API for WebSocket (WebSocket) is a standard API for creating ket applications.
Java API for WebSocket specification can be found at http://jcp.org/ detail?id=356
The Java API for JSON Processing (JSON-P) provides a ent way to process (parse, generate, transform, and query) JSON text.
In a full Java EE product, all Java EE web ers and EJB containers are required to support the Concurrency Utilities e Java EE Product Provider must provide preconfigured default managed r service, managed scheduled executor service, managed thread factory, and service objects for use by the application in the containers in which the rency Utilities API is required to be supported.
In a full Java EE product, all Java EE application ntainers, web containers, and EJB containers are required to support the PI.
The detail? a EE Management API provides APIs for management tools to query a Java ication server to determine its current status, applications deployed, and so Java EE products must support this API as described in its specification.
Java EE Management API specification is available at http://jcp.org/ detail?id=77
These plug-in components execute in the deployment tool and ent the Java EE product-specific deployment mechanisms.
Java EE products port the Java EE Deployment API are required to supply these plug-in ents for use in tools from other vendors.
However, it would be possible to create a Java lication that acts as a deployment tool and provides the runtime ment required by the Java EE Deployment specification.
Java EE Deployment API specification is available at http://jcp.org/ detail?id=88
They transform outgoing es such that the source of the message may be authenticated by the receiving er, and the recipient of the message may be authenticated by the message They authenticate incoming messages and return to their calling container tity established as a result of the message authentication.
In a full Java EE product, all tainers must also support the Servlet Container Profile as defined in the specification.
The Debugging Support for Other Languages specification s information that can be included in a class file to relate class file data to he original source file.
All Java EE products are required to be able to.
All products are required to provide JSTL for use by all JSP pages.
The Co used by that use applet c must pr of these summar.
PostCon b Services Metadata for the Java Platform specification defines Java e annotations that can be used to simplify the development of web services.
Developers of various skill levels can quickly build web applications mbling reusable UI components in a page; connecting these components to cation data source; and wiring client-generated events to server-side event s.
In a full Java EE product, all Java EE web containers are required to applications that use the JavaServer Faces technology.
The specifications these annotations fully define the requirements for these annotations.
All other containers ovide definitions for all of these annotations, and must support the semantics annotations as described in the corresponding specifications and ized in the following table.
The Java Persistence specification provides an object/relational g facility for application developers using a Java domain model to manage a al database.
The detail? n Validation specification defines a metadata model and API for JavaBean on.
The default metadata source is annotations, with the ability to override nd the metadata through the use of XML validation descriptors.
Java EE platform requires that web containers make an instance of orFactory available to JSF implementations by storing it in a servlet.
The enterprise environments will add new services to existing ise Information Systems (EISs)
They will be using various hardware s and applications written in various languages.
Java EE applications to connect to legacy systems using CORBA or low-level socket interfaces.
The specification support for the following groups of protocols and formats:
P/IP protocol family—This is the core component of Internet communica.
TCP/IP and UDP/IP are the standard transport protocols for the Internet.
P/IP is supported by Java SE and the underlying operating system.
As with TCP/IP, TP 1.1 is supported by Java SE and the underlying operating system.
It is available indirectly when using the https UR of a 3.0 in t.
Support for SOAP layered on HTTP is required, as described in the -RPC and JAX-WS specifications.
It enables bi-directional communication over a single nection established by an initial HTTP handshake and upgrade request.
This interoperability is delivthrough IIOP, and is typically found in an intranet setting.
The EJB interoperability protocol is defined in the EJB specification.
In addition, it must be possible to use the Java IDL SNaming API to access the INS name service.
All Java EE products must vide a name service that meets the requirements of the Interoperable NamService specification, available at http://omg.org/cgi-bin/doc?formal/ 0-06-19
This name service may be provided as a separate name server or protocol bridge or gateway to another name service.
The JAXP API provides support for processing XML format data.
JAX-RPC API provides support for XML RPC messages, as well as a ping between Java classes and XML.
N—JSON is a language-neutral plain text format commonly used to sfer structured data between a server and web application.
This allows multiple Java components to be buninto one JAR file and downloaded to a browser in a single HTTP transac.
For plete information on the class file format, see http://docs.oracle.com/ ase/specs/
If the ent descriptor is not present, the application’s modules are discovered.
A Java EE module represents the basic unit of ition of a Java EE application.
Java EE modules consist of one or more components and an optional module level deployment descriptor.
An alternate deployment descriptor may also be provided external to the tion package as described in Section EE.8.4.1, “Assembling a Java EE tion.”
These components may then be packaged with a level deployment descriptor to create a Java EE module.
Java EE modules eployed as stand-alone units or can be assembled with a Java EE application ent descriptor and deployed as a Java EE application.
The ion client specification is found in Chapter EE.10 of this document.
Any number of components of the same container type can aged together with a single Java EE deployment descriptor appropriate to tainer type to produce a Java EE module.
Components of different er types may not be mixed in a single Java EE module, except for the ng of EJB components within a web module.
In some cases a single Java EE module (not necessarily packaged into va EE application package) will contain an entire application.
In other casn application will be composed of multiple Java EE modules.
The deployment descriptor a Java EE module also contains assembly instructions that describe how components are composed into an application.
Starting with version 5 of the Java EE platform, a web application module, an enterprise bean module, or an application client module need not contain a deplo ann.
All deploym pathnam remove unique two nam deploym module for choo depend unique.
Instead, the deployment information may be specified by otations present in the class files of the module.
Instead, the deployt information may be determined using default naming rules for edded modules.
The name can be explicitly set in the ent descriptor for the module.
If not set, the name of the module is the e of the module in the ear file with any filename extension (.jar, .war, .rar)
The name of a module must be within an application.
If and only if the name is not unique (e.g., because es are identical after removing different filename extensions) the ent tool may choose new unique names for any of the conflicting.
The algorithm sing unique names in such a case is product specific.
In c be depl applica EE mod an appl graphic applica.
All applica base na names r server i conflict new un differen a default application name of "bigapp", and defines four modules with names "ejbs/inventory", "ejbs/accounts", "ui/store", and "ui/admin"
A Java EE application is packaged using the chive (JAR) file format into a file with a .ear (Enterprise ARchive) e extension.
A minimal Java EE application package will only contain Java ules and, optionally, the application deployment descriptor.
Java EE application deployment descriptor represents the top level view a EE application’s contents.
The Java EE application deployment tor is specified by an XML schema or document type definition (see EE.8.6, “Java EE Application XML Schema”)
New Java EE modules may be added to the tion.
Some Java ules may need custom content created, changed, or replaced.
The name can be explicitly set in the tion deployment descriptor.
If not set, the name of the application is the me of the ear file with any .ear extension removed and with any directory emoved.
The name of an application must be unique in an application nstance.
If an attempt is made to deploy an application with a name that s with an already deployed application, the deployment tool may choose a ique name for the application.
The deployment tool may also allow a t name to be specified at deployment time.
The module name can be explicitly set in the module.
If not set, the name of the module is the base name of the file with any extension (.war, .jar, .rar) removed and with any directory emoved.
Each Java EE module listed in the application deployment or (or discovered using the default rules described below) must be deployed ng to the requirements of the specification for the respective Java EE module ch module listed must be installed in the appropriate container type and the ment properties of each module must be set appropriately in the target er to reflect the values declared by the deployment descriptor element for mponent.
Libraries may be with an application or may be installed separately for use by any ion.
Using this mechanism a Java EE JAR file can reference utility classes shared classes or resources packaged in a separate .jar file or directory ncluded in the same Java EE application package, or that has been sly installed in the Java EE containers.
Libraries bundled with an application may be referenced in the following ways:
The referenced r file or directory is named using a URL relative to the URL of the refering JAR file.
The Class-Path entry in the Manifest file is of the form.
The Java EE deployment tools must process such referenced files and directories when processing a Java EE module.
The deployment tool must install the r files and directories in a way that preserves the relative references.
Typically this is done by installing the .jar files into a ctory hierarchy that matches the original application directory hierarchy.
Top level JAR s that are processed by a deployment tool should not contain Class-Path ies; such entries would, by definition, reference other files external to the loyment unit.
A deployment tool is not required to process such external rences.
The library-directory element of the .ear file’s deployment descriptor tains the name of this directory.
If a library-directory element isn’t specd, or if the .ear file does not contain a deployment descriptor, the directory ed lib is used.
A J the <ex Java EE installe installe depend has requ be requ that a Ja default express se.
These libraries may reference other libraries, er bundled with the application or installed separately, using any of the niques described herein.
The JAR File cification defines the semantics of such attributes for use by applets; this cification requires support for such attributes for all component types and responding JAR format files.
The deployment tool is required to check such endency information and reject the deployment of any component for ch the dependency can not be met.
Portable applications should not assume any installed libraries will be available to a component unless the compot’s JAR format file, or one of the containing JAR format files, expresses a endency on the library using the Extension-List and related attributes.
For example, if a .ear file referes an installed library, the library must be made available to all compots in all .war files, EJB .jar files, application .jar files, and resource pter .rar files within the .ear file.
A product is also not required to support more than a single version of an.
A Java EE product is not required to limit access to d libraries to only those for which the application has expressed a ency; the application may be given access to more installed libraries than it ested.
In all of these cases, such support is highly recommended and may.
In particular, we recommend va EE product support multiple versions of an installed library, and by.
If an application includes a bundled version of a library, and the same library exists as an in be used applicat influenc compon deploye.
Librarie of a Jav parent c thus wil that onl use the classes class loa each mo Runtime.
This allows an ion to bundle exactly the version of a library it requires without being ed by any installed libraries.
Note that if the library is also a required ent of the Java EE platform version on which the application is being d, the platform version may (and typically will) take precedence.
An application will typically have the security ions required to access resources in any of the JAR files packaged with the ion.
Libraries will often be loaded by a class loader that is a lass loader of the class loader that is used to load application classes and l not have direct visibility to classes of the application modules.
A library y needs to dynamically load classes provided by the library itself can safely Class method forName.
However, libraries that need to dynamically load that have been provided as a part of the application need to use the context der to load the classes.
Note that the context class loader may be different in dule of an application.
In this example the Developer has chosen to package the enterprise ent view classes in a separate JAR file and reference that JAR file from the R files that need those classes.
Those classes are also needed .jar itself because they define the remote interface of the enterprise beans .jar, and the developer has chosen the by reference model of making these.
The deployment descriptor for ejb1.jar names the client view JAR file in the ejb-client-jar element.
These enterprise beans are referenced by se beans in ejb3.jar and by the servlets packaged in webapp.war.
Instead, the ation defines requirements in terms of what classes must or must not be o components.
A Java EE product is free to use whatever class loaders it to meet these requirements.
Portable applications must not depend on the class loaders used or the hierarchical arrangement of class loaders, if any.
This s the use of old applications and extension libraries that do not use the extension dependency mechanism.
In s, access to classes is governed by the rules of the Java language and the tual machine.
In all cases, access to classes and resources is governed by s of the Java security model.
Note that as of Java EE 6, EJB components may be packaged in a ponent module.
The transitive closure of any libraries specified by or referenced by the containing ear file (as specified in Section EE.8.2, “Library Support”)
Portable applications must not depend on having or not having.
Java EE API classes specified in Table EE.6-1 for the containers other the web container.
Other classes or resources contained in the application package, and specified.
For example, the applion should not have access to the classes in application client jar files.
Compo classes ponents in the EJB container may have access to the following classes urces.
Portable applications must not depend on having or not having.
Java EE API classes specified in Table EE.6-1 for the containers other the EJB container.
For example, the applion should not have access to the classes in application client jar files.
Java EE API classes specified in Table EE.6-1 for the application client tainer.
Portable applications must not depend on having aving access to these classes or resources.
Java EE API classes specified in Table EE.6-1 for the containers other than application client container.
For example, the applion client should not have access to the classes in other application client jar s in the same ear file, nor should it have access to the classes in web applions or ejb jar files in the same ear file.
This specification adds no new requirements for the applet container.
The structure uld be designed around the requirements of the contained components.
An optional element alt-dd (described in Section EE.8.6, “Java EE lication XML Schema”) may be used when it is desirable to preserve the inal deployment descriptor.
The element alt-dd specifies an alternate loyment descriptor to use at deployment time.
The edited copy of the loyment descriptor file may be saved in the application directory tree in a tion determined by the Application Assembler.
Choose unique names for the modules contained in the application.
If two modules specify conflicting names in their deployment descriptors, create an alternate deployment descriptor for at least one of the modules and change its name.
If two modules in the same directory of the ear file have the same base name (e.g., foo.jar and foo.war), rename one of the modules or create an alternate deployment descriptor to specify a unique name for one of the modules.
Link the internally satisfied dependencies of all components in every module contained in the application.
For each component dependency, there must only be one corresponding component that fulfills that dependency in the scope of the application.
External dependencies must be linked to the resources on the platform during deployment.
Rename unique role-names with redundant meaning to a common name.
Rename rolenames with common names but different meanings to unique names.
Descriptions of role-names that are used by many components of the application can be included in the application-level deployment descriptor.
Assign a context root for each web module included in the Java EE application.
The context root is a relative name in the web namespace for the application.
Each web module must be given a distinct and nonoverlapping name for its context root.
The web modules will be assigned a complete name in the namespace of the web server at deployment time.
If there is only one web module in the Java EE application, the context root may be the empty string.
If no deployment descriptor is included in the application package, the context root of the web module will be the module name.
See the Servlet specification for detailed requirements of context root naming.
Make sure that each component in the application properly describes any dependencies it may have on other components in the application.
A Java EE application should not assume that all components in the application will be available on the class path of the application at run time.
Each component might be loaded into a separate class loader with a separate namespace.
If the classes in a JAR file depend on classes in another JAR file, the first JAR file should reference the second JAR file using the ClassPath mechanism.
A notable exception to this rule is JAR files located in the WEB-INF/lib directory of a web application.
All such JAR files are included in the class path of the web application at runtime; explicit references to them using the Class-Path mechanism are not needed.
Another exception to this rule is JAR files located in the library directory (usually named lib) in the application package.
There must be only one version of each class in an application.
With the exception of application clients, a Java EE application should not assume that each component is loaded in a separate class loader and has a separate namespace.
All components in a single application may be loaded in a single class loader and share a single namespace.
Note, however, that it must be possible to deploy an application such that all components of the application are in a namespace (or namespaces) separate from that of other applications.
By default, application clients are each deployed into their own Java virtual machine instance, and thus each application client has its own class namespace, and the classes from application clients are not visible in the class namespace of other components.
The loyment descriptor must be a valid XML document according to the XML ema for a Java EE application XML document.
Alternatively, the deployt descriptor may meet the requirements of previous versions of Java EE.
The deployment tool will detere the components of the application using some simple rules.
Place the Java EE modules and the deployment descriptor in the appropriate directories.
Package the application directory hierarchy in a file using the JAR file format.
The file should be named with a .ear filename extension.
After the application is created, Java EE modules may be added or removed before deploym perform.
When adding or removing a module the following steps must be ed:
Optionally te new directories in the application package hierarchy to contain any Java modules that are being added to the application.
The packaged modules are inserted directly in the desired location; the dules are not unpackaged.
If the tion is delivered as a .ear, an enterprise bean module delivered as a .jar eb application delivered as a .war file, or an application client delivered as.
The deploym and tho this spe combin the ven specific.
Typically this will require the use of a separate class or each application.
Standalone resource adapters delivered in .rar files dalone class libraries delivered in .jar files that become installed.
When an tion is started, the container must first initialize all startup-time singleton bean components before delivering any requests to enterprise bean ents.
In some cases a deployment tool might Application Assembly functionality as well, allowing the Deployer to ct, modify, or customize the application before deployment.
Still, it must ible to deploy a portable Java EE application, module, or library ing no product-specific deployment information without modifying the files or artifacts that the Deployer specified to the deployment tool.
The appropriate or DTD is chosen by analyzing the deployment descriptor to determine ersion it claims to conform to.
Validation errors must cause an error to be to the Deployer.
The deployment tool may allow the Deployer to correct r and continue deployment.
Note that the deployment descriptor version nly to the version of the XML schema or DTD against which the tor is to be validated.
It does not provide any information as to what of the Java EE platform the application is written to.
The required deployment information is determined by using default rules, or by annotations present on applica applica deploym informa informa required applica deploym deploym compon descrip comple deploym.
If th ver dep Any mer resp tion spe se.
Some deployment descriptors that are included in an tion may exist in either complete or incomplete forms.
An incomplete deployment descriptor provides only a subset of the deployment information; a deployment tool must examine the.
Any ent information specified in a deployment descriptor overrides any ent information specified in an application’s class files.
See the coment specifications for the required location and name of the deployment deptor for each component type.
The corondence of annotation information with deployment descriptor informa, as well as the overriding rules, are described in this and other Java EE cifications.
Note that there is no requirement for the merge process to produce a new deployment descriptor, altho.
The scri plic is p plo dete ugh that might be a common implementation technique.
The deployment tool must ensure that the application name is.
If the name is not unique, the deployt tool may automatically choose a unique name or allow the Deployer to.
If the module, or any JAR format files within the module, lares a dependency on an installed library, that dependency must be satis.
For example, the enterprise beans in an ejb-jar file might be loyed multiple times under different JNDI names and with different configtions of their resources.
If the deployment descriptor resent, it fully specifies the modules included in the application.
If no deyment descriptor is present, the deployment tool uses the following rules to rmine the modules included in the application.
All files in the application package with a filename extension of .war are considered web modules.
The context root of the web module is the module.
All files in the application package with a filename extension of .rar are considered resource adapters.
A directory named lib is considered to be the library directory, as described in Section EE.8.2.1, “Bundled Libraries.” For all files in the application package with a filename extension of .jar, but not contained in the lib directory, do the following:
All other JAR files are ignored unless referenced by a JAR file discovered above using one of the JAR file reference mechanisms such as the Class-Path header in a manifest file.
If the name is not unique, the deployment tool may matically choose a unique name or allow the Deployer to choose a unique e, but must not fail the deployment.
See Enterprise JavaBeans, servlet, Java EE Connector and application client cifications for the required location and name of the deployment descriptor each component type.
Any ann wit pre bra ule con form rule log dep pro plem.
Wh too rath role dep scri dep otations that specify deployment information must be logically merged h the information in the deployment descriptor (if present)
The correspondence of annotation ination with deployment descriptor information, as well as the overriding.
The result of this ical merge process provides the deployment information used in subsequent loyment steps.
Note that there is no requirement for the merge process to duce a new deployment descriptor, although that might be a common imentation technique.
All classes in .jar files or directories referenced from other JAR files g the Class-Path manifest header must be included in the deployment.
If .ear file, or any JAR format files within the .ear file, declares a dependenn an installed library, that dependency must be satisfied.
However, for security roles that appear in a module loyment descriptor but do not appear in the application deployment deptor, the deployment tool must use the description provided in the module loyment descriptor.
After a applicat module of initia importa in one m applicat the appl order>t.
Note that the library itself may include dependencies on er libraries and these dependencies must also be satisfied.
The library may nstalled with the full security permissions of the container.
Librarthat conflict with the operation of the Java EE product may not be deploy.
For example, an attempt to deploy an older version of a library that has.
Similarly, deployment of a library that is also used in the implementaof the Java EE product may be rejected.
Deployment of a library that is in ve use by an application may be rejected.
The specifications for the different types describe the steps required to initialize a module.
By default, the order lization of modules in an application is unspecified.
In rare cases it may be nt that modules are initialized in a certain order, for example, if a component odules uses a component in another module during its initialization.
If the application deployment descriptor specifies a module initialization at conflicts with the initialization order specified by any of the modules (for e, by the use of the EJB DependsOn annotation), the deployment tool must n error.
Application client modules are initialized on their own schedule, y when an end user invokes them; as such, they are excluded from any ation ordering requirements.
The XM the Java Jaav EE applicat descript icon for applicat means, <role-n.
Fig applica L grammar for a Java EE application deployment descriptor is defined by EE application schema.
The root element of the deployment descriptor for a application is application.
The granularity of composition for Java EE ion assembly is the Java EE module.
A Java EE application deployment or contains a name and description for the application and the URI of a UI the application, as well a list of the Java EE modules that comprise the ion.
The content of the XML elements is in general case sensitive.
It does ne any concrete profiles, delegating this task to separate specifications.
By doing so, a profile can effectively drop technologies which the supports but which are not generally useful in a particular domain.
Naturally, if they do, they need to obey all the relevant requirements ed by the profile specification.
Alt platform profiles order to incomp of the J is also r as much version.
Once the JSR is approved, an roup will be formed and conduct work as dictated by the process.
The JSR file must mention the version of the Java EE Platform that it builds on.
To this end, a profile must build on the most recent version ava EE platform available at the time the JSR for the profile is approved.
It ecommended that profile expert groups go beyond this requirement and, as it is practical, ensure that their profile builds on the most recent.
Typically, the preconditions olve the presence of one or more technologies among those included in the Unconditional requirements must be obeyed unconditionally.
A p include specific sets of r attempt not allo unless t.
Ann Pre specification for individual technologies may allow for certain features of nology in question to be optional.
In this case, a profile may promote one of these features to required status, assuming the Java EE platform or any on which it builds hasn’t done so already.
Therefore, unless the ation for an individual technology explicitly allows for certain features or equirements to be optionally implementable, a profile must not itself to redefine any such features or requirements.
For example, a profile may w omitting a package or type or method from an API specified elsewhere, he specification for that API explicitly allows for this to happen.
The following functionality is required to be supported in all Java EE profiles:
These ents correspond to the full set of requirements in previous versions of the.
The set of technologies that en made optional and/or identified as candidates for pruning is given in EE.6.1.3, “Pruned Java Technologies”
Applica virtual m applicat is termi clients d contain only the.
However, like other Java EE application components, application epend on a container to provide system services.
The authentication mechanisms for enterprise beans include those required in the EJB specific used.
An applica may be single s when th the user describ do so.
The container’s service integrated with the native platform’s authentication system, so that a ignon capability is employed.
The container may authenticate the user e application is started, or it may use lazy authentication, authenticating when a protected resource is accessed.
This specification does not e the technique used to authenticate the user, although a later version may.
A Java EE product is not required to provide a JTA nsaction object for use by application clients.
If a JDBC API transaction is open when an application.
Applica include The dep types of descript annotat the reso .4 Resources, Naming, and Injection.
Because the tion client container does not create instances of the application client main ut merely loads the class and invokes the static main method, injection into lication client class uses static fields and methods, unlike other Java EE ents.
Application clients start execution at the thod of the class specified in the Main-Class attribute in the manifest file of ication client’s JAR file (although note that application client container code ically execute before the application client itself, in order to prepare the ment of the container, install a SecurityManager, initialize the name service brary, and so on)
If the deployment or is not included, or is included but not marked metadata-complete, ions on the main class of the application client may also be used to describe urces needed by the application.
The mechan sophisti a Java E intranet bundle each cli on the J each cli this spe the app process.
Other Java EE products may require the Java EE application containing the application client to be manually deployed and installed on ent machine.
And yet another approach would be for the deployment tool ava EE server to produce an installation package that could be used by ent to install the application client.
There are many possibilities here and cification doesn’t prescribe any one.
It only defines the package format for lication client and the things that must be possible during the deployment.
Typically E Product Provider will provide an application launcher that integrates application client machine’s native operating system, but the level of egration is unspecified.
Schema xmlns.j L grammar for a Java EE application client deployment descriptor is by the Java EE application-client schema.
The root element of the ent descriptor for an application client is application-client.
Many types of service providers can be provided using the tor API and packaging, including JDBC drivers, JMS providers, and JAXR rs.
All Java EE products must support the Connector APIs, as specified in nector specification.
The Jav interfac as persi compon special get the t and mar.
This provides the ability to register synchronization objects with ordering semantics, associate resource objects with the current transaction, ransaction context of the current transaction, get current transaction status, k the current transaction for rollback.
This allows the JavaMail API to be extended with support for new tocols and mailbox formats.
The wo compat required EE plat platform releases the plat of the p.
Com required platform Run An Java EE specific required a previo identica 239 ompatibility and Migration.
The specifications for each of the component technologies included in also describe compatibility and migration issues for that technology in ore detail.
Java EE products are ible with the Java EE specification if they implement the APIs and behavior by the specification.
A new release of the Java EE platform is compatible with previous.
A Java EE product is to support portable applications written to previous versions of the.
Java EE products conform to the specifications by providing APIs and behavior as required by the ations.
Portable applications depend only on the APIs and behavior by the Java EE specifications.
In general, portable applications written to us version of the platform will continue to work without change and with l behavior on the current version of the platform.
JAX-W provide the JAX Java EE conside support migrate se.
Given the strong level of compatibility in this release of EE platform, migration is largely an optional exercise.
Applications are strongly encouraged to migrate applications JB entity beans to the Java Persistence API.
S, along with JAXB and the Metadata for Web Services specification, s simpler and more complete support for web services than is available using -RPC technology.
Support for JAX-RPC has been made optional with the 7 release.
Applications that provide web services using JAX-RPC should r migrating to the JAX-WS API.
Note that because both technologies the same web service interoperability standards, clients and services can be d to the new API independently.
A future version of this ation may require that Java EE products be able to deploy application clients that allows them to be launched by a JNLP client, and that application ntainers be able to launch application clients deployed using the JNLP.
Future versions of this specification will more fully define the Java EE.
This a Deploy Java EE schema written support restricti any com.
The XM the Java Jaav EE applicat descript icon for applicat means, <role-n.
All products are required to support these DTDs and schemas as well as the s specified in this version of the specification.
This ensures that applications to previous versions of this specification can be deployed on products ing the current version of this specification.
In addition, there are no ons on mixing versions of deployment descriptors in a single application; bination of valid deployment descriptor versions must be supported.
The root element of the deployment descriptor for a application is application.
The granularity of composition for Java EE ion assembly is the Java EE module.
A Java EE application deployment or contains a name and description for the application and the URI of a UI the application, as well a list of the Java EE modules that comprise the ion.
The content of the XML elements is in general case sensitive.
The deployment descriptor must be named METAlication.xml in the .ear file.
Figure EE.A-1 shows a graphic representation of the structure of the Java EE application XML Schema.
The root element of the ent descriptor for an application client is application-client.
The XM the Java Jaav EE applicat descript icon for applicat means, <role-n.
The root element of the deployment descriptor for a application is application.
The granularity of composition for Java EE ion assembly is the Java EE module.
A Java EE application deployment or contains a name and description for the application and the URI of a UI the application, as well a list of the Java EE modules that comprise the ion.
The content of the XML elements is in general case sensitive.
The root element of the ent descriptor for an application client is application-client.
This sec descript defined applicat descript icon for applicat means, <role-n.
The content of the XML elements is in general case sensitive.
The deployment descriptor must be named META-INF/ tion.xml in the .ear file.
A plication deployment descriptor contains a name and description for the ion and the URI of a UI icon for the application, as well as a list of the J2EE s that comprise the application.
The content of the XML elements is in case sensitive.
The content of the XML elements is in general case sensitive.
The root element of the deployment descriptor for an application client is tion-client.
The content of the XML elements is in general case sensitive.
A valid application client deployment descriptor may the following DOCTYPE declaration:
Added Section “Tenant Identifier References”, to reflect requirement that identifier for current tenant be made available as java:comp/tenantId.
The terms used to refer to ments in this specification are included in parentheses.
