Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.
The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions.
No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.
This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise.
This book is written in the “impatient” style that I ﬁrst tried out in a book called Scala for the Impatient.
In that book, I wanted to quickly cut to the chase without lecturing the reader about the superiority of one paradigm over another.
I presented information in small chunks organized to help you quickly retrieve it when needed.
The approach was a big success in the Scala community, and I am employing it again in this book.
With Java 8, the Java programming language and library receive a major refresh.
Lambda expressions make it possible to write “snippets of computations” in a concise way, so that you can pass them to other code.
The recipient can choose to execute your computation when appropriate and as often as appropriate.
Instead of specifying how to compute a result (“traverse from the beginning to the end, and if an element matches a condition, compute a value from it, and add that value to a sum”), you specify what you want (“give me the sum of all elements that match a condition”)
The library is then able to reorder the computation—for example, to take advantage of parallelism.
Or, if you just want to have the ﬁrst hundred matches, it can stop the computation without you having to maintain a counter.
The brand-new stream API of Java 8 puts this idea to work.
In the ﬁrst chapter, you learn all about the syntax of lambda expressions, and Chapter 2 gives a complete overview of streams.
In Chapter 3, I provide you with tips on how to effectively design your own libraries with lambdas.
Having waited for far too many years, programmers are ﬁnally able to use a well-designed date/time library.
Each version of Java brings enhancements in the concurrency API, and Java 8 is no exception.
In Chapter 6, you learn about improvements in atomic counters, concurrent hash maps, parallel array operations, and composable futures.
In Chapter 7, you will see how to execute JavaScript on the Java Virtual Machine, and how to interoperate with Java code.
Dmitry Kirsanov and Alina Kirsanova once again turned an XHTML manuscript into an attractive book with amazing speed and attention to detail.
I am grateful to the reviewers who spotted many embarrassing errors and gave excellent suggestions for improvement.
I hope that you enjoy reading this concise introduction to the new features of Java 8, and that it will make you a more successful Java programmer.
If you ﬁnd errors or have suggestions for improvement, please visit http://horstmann.com/ java8 and leave a comment.
On that page, you will also ﬁnd a link to an archive ﬁle containing all code examples from the book.
Long before there was object-oriented programming, there were functional programming languages such as Lisp and Scheme, but their beneﬁts were not much appreciated outside academic circles.
Recently, functional programming has risen in importance because it is well suited for concurrent and event-driven (or “reactive”) programming.
Instead, the winning strategy is to blend object-oriented and functional programming.
This makes sense even if you are not interested in concurrency.
For example, collection libraries can be given powerful APIs if the language has a convenient syntax for function expressions.
The principal enhancement in Java 8 is the addition of functional programming constructs to its object-oriented roots.
The next chapter shows you how to put that syntax to use with Java collections, and in Chapter 3 you will learn how to build your own functional libraries.
A lambda expression is a block of code with parameters.
Use a lambda expression whenever you want a block of code executed at a later point in time.
Lambda expressions can access effectively ﬁnal variables from the enclosing scope.
Method and constructor references refer to methods or constructors without invoking them.
You can now add default and static methods to interfaces that provide concrete implementations.
You must resolve any conﬂicts between default methods from multiple interfaces.
Before getting into the syntax (or even the curious name), let’s step back and see where you have used similar code blocks in Java all along.
When you want to do work in a separate thread, you put the work into the run method of a Runnable, like this:
Then, when you want to execute this code, you construct an instance of the Worker class.
You can then submit the instance to a thread pool, or, to keep it simple, start a new thread:
The key point is that the run method contains code that you want to execute in a separate thread.
If you want to sort strings by length instead of the default dictionary order, you can pass a Comparator object to the sort method:
The sort method keeps calling the compare method, rearranging the elements if they are out of order, until the array is sorted.
You give the sort method a snippet of code needed to compare elements, and that code is integrated into the rest of the sorting logic, which you’d probably not care to reimplement.
Note that you shouldn’t compute x - y to compare x and y since that computation can overﬂow for large operands of opposite sign.
As another example for deferred execution, consider a button callback.
You put the callback action into a method of a class implementing the listener interface, construct an instance, and register the instance with the button.
That happens so often that many programmers use the “anonymous instance of anonymous class” syntax:
NOTE: Since Java 8 positions JavaFX as the successor to the Swing GUI toolkit, I use JavaFX in these examples.
In every user interface toolkit, be it Swing, JavaFX, or Android, you give a button some code that you want to run when the button is clicked.
A block of code was passed to someone—a thread pool, a sort method, or a button.
Up to now, giving someone a block of code hasn’t been easy in Java.
Java is an object-oriented language, so you had to construct an object belonging to a class that has a method with the desired code.
In other languages, it is possible to work with blocks of code directly.
The Java designers have resisted adding this feature for a long time.
A language can become an unmaintainable mess if it includes every feature that yields marginally more concise code.
However, in those other languages it isn’t just easier to spawn a thread or to register a button click handler; large swaths of their APIs are simpler, more consistent, and more powerful.
In Java, one could have written similar APIs that take objects of classes implementing a particular function, but such APIs would be unpleasant to use.
For some time now, the question was not whether to augment Java for functional programming, but how to do it.
It took several years of experimentation before a design emerged that is a good ﬁt for Java.
We pass code that checks whether one string is shorter than another.
Java is a strongly typed language, and we must specify that as well:
Such an expression is simply a block of code, together with the speciﬁcation of any variables that must be passed to the code.
If a lambda expression has no parameters, you still supply empty parentheses, just as with a parameterless method:
If the parameter types of a lambda expression can be inferred, you can omit them.
Here, the compiler can deduce that first and second must be strings because the lambda expression is assigned to a string comparator.
We will have a closer look at this assignment in the next section.
If a method has a single parameter with inferred type, you can even omit the parentheses:
NOTE: You can add annotations or the final modiﬁer to lambda parameters in the same way as for method parameters:
You never specify the result type of a lambda expression.
As we discussed, there are many existing interfaces in Java that encapsulate blocks of code, such as Runnable or Comparator.
You can supply a lambda expression whenever an object of an interface with a single abstract method is expected.
NOTE: You may wonder why a functional interface must have a single abstract method.
Aren’t all methods in an interface abstract? Actually, it has always been possible for an interface to redeclare methods from the Object class such as toString or clone, and these declarations do not make the methods abstract.
Some interfaces in the Java API redeclare Object methods in order to attach javadoc comments.
To demonstrate the conversion to a functional interface, consider the Arrays.sort method.
Its second parameter requires an instance of Comparator, an interface with a single method.
Behind the scenes, the Arrays.sort method receives an object of some class that implements Comparator<String>
Invoking the compare method on that object executes the body of the lambda expression.
The management of these objects and classes is completely implementation dependent, and it can be much more efﬁcient than using traditional inner classes.
It is best to think of a lambda expression as a function, not an object, and to accept that it can be passed to a functional interface.
This conversion to interfaces is what makes lambda expressions so compelling.
That’s a lot easier to read than the alternative with inner classes.
In fact, conversion to a functional interface is the only thing that you can do with a lambda expression in Java.
In other programming languages that support function literals, you can declare function types such as (String, String) -> int, declare variables of those types, and use the variables to save function expressions.
However, the Java designers decided to stick with the familiar concept of interfaces instead of adding function types to the language.
NOTE: You can’t even assign a lambda expression to a variable of type Object—Object is not a functional interface.
You can save our string comparison lambda in a variable of that type:
If you have used a functional programming language before, you may ﬁnd this curious.
An interface such as Comparator has a speciﬁc purpose, not just a method with given parameter and return types.
When you want to do something with lambda expressions, you still want to keep the purpose of the expression in mind, and have a speciﬁc functional interface for it.
But keep in mind that you can equally well convert a lambda expression into a functional interface that is a part of whatever API you use today.
The compiler checks that the annotated entity is an interface with a single abstract method.
And the javadoc page includes a statement that your interface is a functional interface.
Any interface with a single abstract method is, by deﬁnition, a functional interface.
Finally, note that checked exceptions matter when a lambda is converted to an instance of a functional interface.
Since the Runnable.run cannot throw any exception, this assignment is illegal.
You can catch the exception in the body of the lambda expression.
Or assign the lambda to an interface whose single abstract method can throw the exception.
For example, the call method of the Callable interface can throw any exception.
Therefore, you can assign the lambda to a Callable<Void> (if you add a statement return null)
Sometimes, there is already a method that carries out exactly the action that you’d like to pass on to some other code.
For example, suppose you simply want to print the event object whenever a button is clicked.
It would be nicer if you could just pass the println method to the setOnAction method.
As another example, suppose you want to sort strings regardless of letter case.
As you can see from these examples, the :: operator separates the method name from the name of an object or class.
In the ﬁrst two cases, the method reference is equivalent to a lambda expression that supplies the parameters of the method.
Similarly, Math::pow is equivalent to (x, y) -> Math.pow(x, y)
In the third case, the ﬁrst parameter becomes the target of the method.
NOTE: When there are multiple overloaded methods with the same name, the compiler will try to ﬁnd from the context which one you mean.
For example, there are two versions of the Math.max method, one for integers and one for double values.
Which one gets picked depends on the method parameters of the functional interface to which Math::max is converted.
Just like lambda expressions, method references don’t live in isolation.They are always turned into instances of functional interfaces.
You can capture the this parameter in a method reference.
For example, this::equals is the same as x -> this.equals(x)
When the thread starts, its Runnable is invoked, and super::greet is executed, calling the greet method of the superclass.
Constructor references are just like method references, except that the name of the method is new.
For example, Button::new is a reference to a Button constructor.
Then you can turn it into an array of buttons, by calling the constructor on each of the strings, with the following invocation:
For now, what’s important is that the map method calls the Button(String) constructor for each list element.
There are multiple Button constructors, but the compiler picks the one with a String parameter because it infers from the context that the constructor is called with a string.
For example, int[]::new is a constructor reference with one parameter: the length of the array.
It is equivalent to the lambda expression x -> new int[x]
Array constructor references are useful to overcome a limitation of Java.
It is not possible to construct an array of a generic type T.
The expression new T[n] is an error since it would be erased to new Object[n]
For example, suppose we want to have an array of buttons.
The Stream interface has a toArray method that returns an Object array:
The toArray method invokes this constructor to obtain an array of the correct type.
Often, you want to be able to access variables from an enclosing method or class in a lambda expression.
Now look at the variables count and text inside the lambda expression.
Note that these variables are not deﬁned in the lambda expression.
If you think about it, something nonobvious is going on here.
The code of the lambda expression may run long after the call to repeatMessage has returned and the parameter variables are gone.
To understand what is happening, we need to reﬁne our understanding of a lambda expression.
Values for the free variables, that is, the variables that are not parameters and not deﬁned inside the code.
In our example, the lambda expression has two free variables, text and count.
We say that these values have been captured by the lambda expression.
For example, one can translate a lambda expression into an object with a single method, so that the values of the free variables are copied into instance variables of that object.
NOTE: The technical term for a block of code together with the values of the free variables is a closure.
If someone gloats that their language has closures, rest assured that Java has them as well.
As you have seen, a lambda expression can capture the value of a variable in the enclosing scope.
In Java, to ensure that the captured value is well-deﬁned, there is an important restriction.
In a lambda expression, you can only reference variables whose value doesn’t change.
Consider a sequence of concurrent tasks, each updating a shared counter.
If this code were legal, it would be very, very bad.
The increment matches++ is not atomic, and there is no way of knowing what would happen if multiple threads execute that increment concurrently.
NOTE: Inner classes can also capture values from an enclosing scope.
Before Java 8, inner classes were only allowed to access final local variables.
This rule has now been relaxed to match that for lambda expressions.
An inner class can access any effectively ﬁnal local variable—that is, any variable whose value does not change.
Don’t count on the compiler to catch all concurrent access errors.
If matches is an instance or static variable of an enclosing class, then no error is reported, even though the result is just as undeﬁned.
Also, it’s perfectly legal to mutate a shared object, even though it is unsound.
An effectively ﬁnal variable is a variable that is never assigned a new value after it has been initialized.
However, the object is mutated, and that is not threadsafe.
There are safe mechanisms for counting and collecting values concurrently.
In Chapter 2, you will see how to use streams to collect values with certain properties.
In other situations, you may want to use threadsafe counters and collections.
See Chapter 6 for more information on this important topic.
NOTE: As with inner classes, there is an escape hatch that lets a lambda expression update a counter in an enclosing local scope.
The body of a lambda expression has the same scope as a nested block.
It is illegal to declare a parameter or a local variable in the lambda that has the same name as a local variable.
Inside a method, you can’t have two local variables with the same name, and therefore, you can’t introduce such variables in a lambda expression either.
When you use the this keyword in a lambda expression, you refer to the this parameter of the method that creates the lambda.
The expression this.toString() calls the toString method of the Application object, not the Runnable instance.
There is nothing special about the use of this in a lambda expression.
The scope of the lambda expression is nested inside the doWork method, and this has the same meaning anywhere in that method.
Many programming languages integrate function expressions with their collections library.
This often leads to code that is shorter and easier to understand than the loop equivalent.
The library designers can supply a forEach method that applies a function to each element.
That’s ﬁne if the collections library has been designed from the ground up.
But the Java collections library has been designed many years ago, and there is a problem.
If the Collection interface gets new methods, such as forEach, then every program that deﬁnes its own class implementing Collection will break until it, too, implements that method.
The Java designers decided to solve this problem once and for all by allowing interface methods with concrete implementations (called default methods)
In this section, we’ll look into default methods in detail.
NOTE: In Java 8, the forEach method has been added to the Iterable interface, a superinterface of Collection, using the mechanism that I will describe in this section.
The interface has two methods: getId, which is an abstract method, and the default method getName.
A concrete class that implements the Person interface must, of course, provide an implementation of getId, but it can choose to keep the implementation of getName or to override it.
Now you can just implement the methods in the interface.
What happens if the exact same method is deﬁned as a default method in one interface and then again as a method of a superclass or another interface? Languages such as Scala and C++ have complex rules for resolving such ambiguities.
If a superclass provides a concrete method, default methods with the same name and parameter types are simply ignored.
If a superinterface provides a default method, and another interface supplies a method with the same name and parameter types (default or not), then you must resolve the conﬂict by overriding that method.
What happens if you form a class that implements both of them?
The class inherits two inconsistent getName methods provided by the Person and Named interfaces.
Rather than choosing one over the other, the Java compiler reports an error and leaves it up to the programmer to resolve the ambiguity.
In that method, you can choose one of the two conﬂicting methods, like this:
Now assume that the Named interface does not provide a default implementation for getName:
Can the Student class inherit the default method from the Person interface? This might be reasonable, but the Java designers decided in favor of uniformity.
If at least one interface provides an implementation, the compiler reports an error, and the programmer must resolve the ambiguity.
NOTE: Of course, if neither interface provides a default for a shared method, then we are in the pre-Java 8 situation, and there is no conﬂict.An implementing class has two choices: implement the method, or leave it unimplemented.
Now consider a class that extends a superclass and implements an interface, inheriting the same method from both.
For example, suppose that Person is a class and Student is deﬁned as.
In that case, only the superclass method matters, and any default method from the interface is simply ignored.
In our example, Student inherits the getName method from Person, and it doesn’t make any difference whether the Named interface provides a default for getName or not.
If you add default methods to an interface, it has no effect on code that worked before there were default methods.
CAUTION: You can never make a default method that redeﬁnes one of the methods in the Object class.
For example, you can’t deﬁne a default method for toString or equals, even though that might be attractive for interfaces such as List.
As a consequence of the “classes win” rule, such a method could never win against Object.toString or Object.equals.
As of Java 8, you are allowed to add static methods to interfaces.
There was never a technical reason why this should be outlawed.
It simply seemed to be against the spirit of interfaces as abstract speciﬁcations.
Up to now, it has been common to place static methods in companion classes.
In Java 8, one could have added this method to the Path interface:
When you look at the Collections class, you will ﬁnd two kinds of methods.
For a factory method that doesn’t work since you don’t have an object on which to invoke the method.
It is unlikely that the Java collections library will be refactored in this way, but when you implement your own interfaces, there is no longer a reason to provide a separate companion class for utility methods.
In Java 8, static methods have been added to quite a few interfaces.
For example, the Comparator interface has a very useful static comparing method that accepts a “key extraction” function and yields a comparator that compares the extracted keys.
But with the static compare method, we can do much better and simply use Comparator.
This is a ﬁtting way of closing this chapter because it demonstrates the power of working with functions.
The compare method turns a function (the key extractor) into a more complex function (the key-based comparator)
Given an array of File objects, sort it so that the directories come before the ﬁles, and within each group, elements are sorted by path name.
Take a ﬁle from one of your projects that contains a number of ActionListener, Runnable, or the like.
How many lines did it save? Was the code easier to read? Were you able to use method references?
Runnable? Write a method uncheck that catches all checked exceptions and turns them into unchecked exceptions.
Hint: Deﬁne an interface RunnableEx whose run method may throw any exceptions.
Write a static method andThen that takes as parameters two Runnable instances and returns a Runnable that runs the ﬁrst, then the second.
In the main method, pass two lambda expressions into a call to andThen, and run the returned instance.
What happens when a lambda expression captures values in an enhanced for loop such as this one?
If you were king for a day, into which interface would you place each method? Would it be a default method or a static method?
Suppose you have a class that implements two interfaces I and J, each of which has a method void f()
Exactly what happens if f is an abstract, default, or static method of I and an abstract, default, or static method of J? Repeat where a class extends a superclass S and implements an interface I, each of which has a method void f()
In the past, you were told that it’s bad form to add methods to an interface because it would break existing code.
Now you are told that it’s okay to add new methods, provided you also supply a default implementation.
How safe is that? Describe a scenario where the new stream method of the Collection interface causes legacy code to fail compilation.
What about binary compatibility? Will legacy code from a JAR ﬁle still run?
For example, if you want to compute the average of the values of a certain method, you specify that you want to call the method on each element and get the average of the values.
You leave it to the stream library to parallelize the operation, using multiple threads for computing sums and counts of each segment and combining the results.
You can create streams from collections, arrays, generators, or iterators.
Use filter to select elements and map to transform elements.
Other operations for transforming streams include limit, distinct, and sorted.
To obtain a result from a stream, use a reduction operator such as count, max, min, findFirst, or findAny.
The Optional type is intended as a safe alternative to working with null values.
To use it safely, take advantage of the ifPresent and orElse methods.
You can collect stream results in collections, arrays, strings, or maps.
The groupingBy and partitioningBy methods of the Collectors class allow you to split the contents of a stream into groups, and to obtain a result for each group.
There are specialized streams for the primitive types int, long, and double.
When you work with parallel streams, be sure to avoid side effects, and consider giving up ordering constraints.
You need to be familiar with a small number of functional interfaces in order to use the stream library.
When you process a collection, you usually iterate over its elements and do some work with each of them.
For example, suppose we want to count all long words in a book.
What’s wrong with it? Nothing really—except that it is hard to parallelize the code.
The stream method yields a stream for the words list.
The filter method returns another stream that contains only the words of length greater than twelve.
A stream seems superﬁcially similar to a collection, allowing you to transform and retrieve data.
They may be stored in an underlying collection or generated on demand.
This means they are not executed until their result is needed.
For example, if you only ask for the ﬁrst ﬁve long words instead of counting them all, then the filter method will stop ﬁltering after the ﬁfth match.
Many people ﬁnd stream expressions easier to read than the loop equivalents.
Simply changing stream into paralleStream allows the stream library to do the ﬁltering and counting in parallel.
In our stream example, we describe what needs to be done: get the long words and count them.
We don’t specify in which order, or in which thread, this should happen.
In contrast, the loop at the beginning of this section speciﬁes exactly how the computation should work, and thereby forgoes any chances of optimization.
When you work with streams, you set up a pipeline of operations in three stages.
You specify intermediate operations for transforming the initial stream into others, in one or more steps.
This operation forces the execution of the lazy operations that precede it.
In our example, the stream was created with the stream or parallelStream method.
The filter method transformed it, and count was the terminal operation.
NOTE: Stream operations are not executed on the elements in the order in which they are invoked on the streams.
In the next section, you will see how to create a stream.
You have already seen that you can turn any collection into a stream with the stream method that Java 8 added to the Collection interface.
If you have an array, use the static Stream.of method instead.
The of method has a varargs parameter, so you can construct a stream from any number of arguments:
To make a stream with no elements, use the static Stream.empty method:
The Stream interface has two static methods for making inﬁnite streams.
Whenever a stream value is needed, that function is called to produce a value.
It takes a “seed” value and a function (technically, a UnaryOperator<T>), and repeatedly applies the function to the previous result.
The ﬁrst element in the sequence is the seed BigInteger.ZERO.
The second element is f(seed), or 1 (as a big integer)
The next element is f(f(seed)), or 2, and so on.
NOTE: A number of methods that yield streams have been added to the API with the Java 8 release.
For example, the Pattern class now has a method splitAsStream that splits a CharSequence by a regular expression.You can use the following statement to split a string into words:
The static Files.lines method returns a Stream of all lines in a ﬁle.
When the close method is called on the stream, the underlying ﬁle is also closed.To make sure that this happens, it is best to use the Java 7 try-with-resources statement:
The stream, and the underlying ﬁle with it, will be closed when the try block exits normally or through an exception.
A stream transformation reads data from a stream and puts the transformed data into another stream.
You have already seen the filter transformation that yields a new stream with all elements that match a certain condition.
Here, we transform a stream of strings into another stream containing only long words:
The argument of filter is a Predicate<T>—that is, a function from T to boolean.
Often, you want to transform the values in a stream in some way.
Use the map method and pass the function that carries out the transformation.
For example, you can transform all words to lowercase like this:
The resulting stream contains the ﬁrst character of each word.
When you use map, a function is applied to each element, and the return values are collected in a new stream.
Now suppose that you have a function that returns not just one value but a stream of values, such as this one:
Suppose you map this method on a stream of strings:
NOTE: You may ﬁnd a flatMap method in classes other than streams.
Then you can compose them, that is, ﬁrst apply f and then g, by using flatMap.
This is a key idea in the theory of monads.
But don’t worry—you can use flatMap without knowing anything about monads.
The call stream.limit(n) returns a new stream that ends after n elements (or when the original stream ends if it is shorter)
This method is particularly useful for cutting inﬁnite streams down to size.
This is handy in our book reading example where, due to the way the split method works, the ﬁrst element is an unwanted empty string.
You can concatenate two streams with the static concat method of the Stream class:
Of course, the ﬁrst stream should not be inﬁnite—otherwise the second wouldn’t ever get a chance.
TIP: The peek method yields another stream with the same elements as the original, but a function is invoked every time an element is retrieved.
When an element is actually accessed, a message is printed.
This way you can verify that the inﬁnite stream returned by iterate is processed lazily.
When an element is retrieved from a ﬁltered or mapped stream, the answer does not depend on the previous elements.
For example, the distinct method returns a stream that yields elements from the original stream, in the same order, except that duplicates are suppressed.
The stream must obviously remember the elements that it has already seen.
The sorted method must see the entire stream and sort it before it can give out any elements—after all, the smallest one might be the last one.
One works for streams of Comparable elements, and another accepts a Comparator.
Here, we sort strings so that the longest ones come ﬁrst:
Of course, you can sort a collection without using streams.
The sorted method is useful when the sorting process is a part of a stream pipeline.
NOTE: The Collections.sort method sorts a collection in place, whereas Stream.sorted returns a new sorted stream.
Now that you have seen how to create and transform streams, we will ﬁnally get to the most important point—getting answers from the stream data.
The methods that we cover in this section are called reductions.
They reduce the stream to a value that can be used in your program.
After a terminal operation has been applied, the stream ceases to be usable.
You have already seen a simple reduction: the count method that returns the number of elements of the stream.
Other simple reductions are max and min that return the largest or smallest value.
There is a twist—these methods return an Optional<T> value that either wraps the answer or indicates that there is none (because the stream happened to be empty)
In the olden days, it was common to return null in such a situation.
But that can lead to null pointer exceptions when an unusual situation arises in an incompletely tested program.
In Java 8, the Optional type is the preferred way of indicating a missing return value.
We discuss the Optional type in detail in the next section.
Here is how you can get the maximum of a stream:
The findFirst returns the ﬁrst value in a nonempty collection.
For example, here we ﬁnd the ﬁrst word that starts with the letter Q, if it exists:
If you are okay with any match, not just the ﬁrst one, then use the findAny method.
This is effective when you parallelize the stream since the ﬁrst match in any of the examined segments will complete the computation.
If you just want to know there is a match, use anyMatch.
That method takes a predicate argument, so you won’t need to use filter.
There are also methods allMatch and noneMatch that return true if all or no elements match a predicate.
These methods always examine the entire stream, but they still beneﬁt from being run in parallel.
An Optional<T> object is either a wrapper for an object of type T or for no object.
It is intended as a safer alternative than a reference of type T that refers to an object or null.
But it is only safer if you use it right.
As you saw in the preceding section, the isPresent method reports whether an Optional<T> object has a value.
In the next section, you will see how you should really work with Optional values.
The key to using Optional effectively is to use a method that either consumes the correct value or produces an alternative.
There is a second form of the ifPresent method that accepts a function.
If the optional value exists, it is passed to that function.
For example, if you want to add the value to a set if it is present, call.
When calling this version of ifPresent, no value is returned.
If you want to process the result, use map instead:
Now added has one of three values: true or false wrapped into an Optional, if optionalValue was present, or an empty optional otherwise.
Simply imagine an optional value as a stream of size zero or one.
The result again has size zero or one, and in the latter case, the function has been applied.
You have just seen how to gracefully consume an optional value when it is present.
The other strategy for working with optional values is to produce an alternative if no value is present.
Often, there is a default that you want to use when there was no match, perhaps the empty string:
So far, we have discussed how to consume an Optional object that someone else created.
If you write a method that creates an Optional object, there are several static methods for that purpose.
The ofNullable method is intended as a bridge from the use of null values to optional values.
If they were normal methods, you could compose them by calling s.f().g()
But that composition doesn’t work here, since s.f() has type Optional<T>,has not T.
If s.f() is present, then g is applied to it.
Clearly, you can repeat that process if you have more methods or lambdas that yield Optional values.
You can then build a pipeline of steps that succeeds only when all parts do, simply by chaining calls to flatMap.
For example, consider the safe inverse method of the preceding section.
Then you can compute the square root of the inverse as.
The Optional.flatMap method works in the same way if you consider an optional value to be a stream of size zero or one.
If you want to compute a sum, or combine the elements of a stream to a result in another way, you can use one of the reduce methods.
The simplest form takes a binary function and keeps applying it, starting with the ﬁrst two elements.
It’s easy to explain this if the function is the sum:
The method returns an Optional because there is no valid result if the stream is empty.
The operation should be associative: It shouldn’t matter in which order you combine the elements.
In math notation, (x op y) op z = x op (y op z)
Often, there is an identity e such that e op x = x, and you can use that element as the start of the computation.
The identity value is returned if the stream is empty, and you no longer need to deal with the Optional class.
Now suppose you have a stream of objects and want to form the sum of some property, such as all lengths in a stream of strings.
It requires a function (T, T) -> T, with the same types for the arguments and the result.
The stream elements have type String, and the accumulated result is an integer.
There is a form of reduce that can deal with this situation.
First, you supply an “accumulator” function (total, word) -> total + word.length()
But when the computation is parallelized, there will be multiple computations of this kind, and you need to combine their results.
NOTE: In practice, you probably won’t use the reduce method a lot.
It is usually easier to map to a stream of numbers and use one of its methods to compute sum, max, or min.
When you are done with a stream, you often just want to look at the results instead of reducing them to a value.
You can call the iterator method, which yields an old-fashioned iterator that you can use to visit the elements.
Or you can call toArray and get an array of the stream elements.
Since it is not possible to create a generic array at runtime, the expression stream.toArray() returns an Object[] array.
If you want an array of the correct type, pass in the array constructor:
Now suppose you want to collect the results in a HashSet.
If the collection is parallelized, you can’t put the elements directly into a single HashSet because a HashSet object is not threadsafe.
Each segment needs to start out with its own empty hash set, and reduce only lets you supply one identity value.
A supplier to make new instances of the target object, for example, a constructor for a hash set.
It could be a StringBuilder or an object that tracks a count and a sum.
Here is how the collect method works for a hash set:
In practice, you don’t have to do that because there is a convenient Collector interface for these three functions, and a Collectors class with factory methods for common collectors.
To collect a stream into a list or set, you can simply call.
If you want to control which kind of set you get, use the following call instead:
Suppose you want to collect all strings in a stream by concatenating them.
If you want a delimiter between elements, pass it to the joining method:
If your stream contains objects other than strings, you need to ﬁrst convert them to strings, like this:
NOTE: So far, you have seen how to reduce or collect stream values.
But perhaps you just want to print them or put them in a database.
The function that you pass is applied to each element.
On a parallel stream, it’s your responsibility to ensure that the function can be executed concurrently.
On a parallel stream, the elements can be traversed in arbitrary order.
If you want to execute them in stream order, call forEachOrdered instead.
Of course, you might then give up most or all of the beneﬁts of parallelism.
The forEach and forEachOrdered methods are terminal operations.You cannot use the stream again after calling them.
Suppose you have a Stream<Person> and want to collect the elements into a map so that you can later look up people by their ID.
The Collectors.toMap method has two function arguments that produce the map keys and values.
In the common case that the values should be the actual elements, use Function.
You can override that behavior by supplying a third function argument that determines the value for the key, given the existing and the new value.
Your function could return the existing value, the new value, or a combination of them.
Here, we construct a map that contains, for each language in the available locales, as key its name in your default locale (such as "German"), and as value its localized name (such as "Deutsch")
We don’t care that the same language might occur twice—for example, German in Germany and in Switzerland, and we just keep the ﬁrst entry.
However, suppose we want to know all languages in a given country.
For example, the value for "Switzerland" is the set [French, German, Italian]
At ﬁrst, we store a singleton set for each language.
Whenever a new language is found for a given country, we form the union of the existing and the new set.
You will see a simpler way of obtaining this map in the next section.
If you want a TreeMap, then you supply the constructor as the fourth argument.
Here is one of the examples from the beginning of the section, now yielding a TreeMap:
NOTE: For each of the toMap methods, there is an equivalent toConcurrentMap method that yields a concurrent map.
A single concurrent map is used in the parallel collection process.
When used with a parallel stream, a shared map is more efﬁcient than merging maps, but of course, you give up ordering.
In the preceding section, you saw how to collect all languages in a given country.
You had to generate a singleton set for each map value, and then specify how to merge the existing and new values.
Forming groups of values with the same characteristic is very common, and the groupingBy method supports it directly.
Let’s look at the problem of grouping locales by country.
The function Locale::getCountry is the classiﬁer function of the grouping.
You can now look up all locales for a given country code, for example.
NOTE: A quick refresher on locales: Each locale has a language code (such as en for English) and a country code (such as US for the United States)
For example, ga_IE is Gaelic in Ireland, and, as the preceding example shows, my JVM knows three locales in Switzerland.
When the classiﬁer function is a predicate function (that is, a function returning a boolean value), the stream elements are partitioned into two lists: those where the function returns true and the complement.
In this case, it is more efﬁcient to use partitioningBy instead of groupingBy.
For example, here we split all locales into those that use English, and all others:
The groupingBy method yields a map whose values are lists.
If you want to process those lists in some way, you supply a “downstream collector.” For example, if you want sets instead of lists, you can use the Collectors.toSet collector that you saw in the preceding section:
Several other collectors are provided for downstream processing of grouped elements:
Within each state, we produce the names of the cities and reduce by maximum length.
The mapping method also yields a nicer solution to a problem from the preceding section, to gather a set of all languages in a country.
In the preceding section, I used toMap instead of groupingBy.
In this form, you don’t need to worry about combining the individual sets.
Then you can get the sum, count, average, minimum, and maximum of the function values from the summary statistics objects of each group.
Finally, the reducing methods apply a general reduction to downstream elements.
Note that this is different from the forms of Stream::reduce, where the method without an identity parameter yields an Optional result.
In the third form, the mapper function is applied and its values are reduced.
Here is an example that gets a comma-separated string of all city names in each state.
We map each city to its name and then concatenate them.
In this case, you can achieve the same result more naturally as.
You should only use them in connection with groupingBy or partitioningBy to process the “downstream” map values.
Otherwise, simply apply methods such as map, reduce, count, max, or min directly on streams.
So far, we have collected integers in a Stream<Integer>, even though it is clearly inefﬁcient to wrap each integer into a wrapper object.
The same is true for the other primitive types double, float, long, short, char, byte, and boolean.
The stream library has specialized types IntStream, LongStream, and DoubleStream that store primitive values directly, without using wrappers.
If you want to store short, char, byte, and boolean, use an IntStream, and for float, use a DoubleStream.
The library designers didn’t think it was worth adding another ﬁve stream types.
To create an IntStream, you can call the IntStream.of and Arrays.stream methods:
As with object streams, you can also use the static generate and iterate methods.
In addition, IntStream and LongStream have static methods range and rangeClosed that generate integer ranges with step size one:
The CharSequence interface has methods codePoints and chars that yield an IntStream of the Unicode codes of the characters or of the code units in the UTF-16 encoding.
If you don’t know what code units are, you probably shouldn’t use the chars method.
When you have a stream of objects, you can transform it to a primitive type stream with the mapToInt, mapToLong, or mapToDouble methods.
For example, if you have a stream of strings and want to process their lengths as integers, you might as well do it in an IntStream:
To convert a primitive type stream to an object stream, use the boxed method:
Generally, the methods on primitive type streams are analogous to those on object streams.
Methods that yield an optional result return an OptionalInt, OptionalLong, or OptionalDouble.
These classes are analogous to the Optional class, but they have methods getAsInt, getAsLong, and getAsDouble instead of the get method.
There are methods sum, average, max, and min that return the sum, average, maximum, and minimum.
NOTE: The Random class has methods ints, longs, and doubles that return primitive type streams of random numbers.
The process is mostly automatic, but you need to follow a few rules.
The parallel method converts any sequential stream into a parallel one.
As long as the stream is in parallel mode when the terminal method executes, all lazy intermediate stream operations will be parallelized.
When stream operations run in parallel, the intent is that the same result is returned as if they had run serially.
It is important that the operations are stateless and can be executed in an arbitrary order.
Suppose you want to count all short words in a stream of strings:
The function passed to forEach runs concurrently in multiple threads, updating a shared array.
If you run this program multiple times, you are quite likely to get a different sequence of counts in each run, each of them wrong.
It is your responsibility to ensure that any functions that you pass to parallel stream operations are threadsafe.
In our example, you could use an array of AtomicInteger objects for the counters (see Exercise 12)
Or you could simply use the facilities of the streams library and group strings by length (see Exercise 13)
By default, streams that arise from ordered collections (arrays and lists), from ranges, generators, and iterators, or from calling Stream.sorted, are ordered.
Results are accumulated in the order of the original elements, and are entirely predictable.
If you run the same operations twice, you will get exactly the same results.
For example, when computing stream.map(fun), the stream can be partitioned into n segments, each of which is concurrently processed.
Some operations can be more effectively parallelized when the ordering requirement is dropped.
By calling the Stream.unordered method, you indicate that you are not interested in ordering.
On an ordered stream, distinct retains the ﬁrst of all equal elements.
If it is acceptable to retain any of the unique elements, all segments can be processed concurrently (using a shared set to track duplicates)
You can also speed up the limit method by dropping ordering.
If you just want any n elements from a stream and you don’t care which ones you get, call.
Clearly, to beneﬁt from parallelism, the order of the map values will not be the same as the stream order.
Even on an ordered stream, that collector has a “characteristic” of being unordered, so that it can be used efﬁciently without having to make the stream unordered.
CAUTION: It is very important that you don’t modify the collection that is backing a stream while carrying out a stream operation (even if the modiﬁcation is threadsafe)
Remember that streams don’t collect their own data—the data is always in a separate collection.
If you were to modify that collection, the outcome of the stream operations would be undeﬁned.
To be exact, since intermediate stream operations are lazy, it is possible to mutate the collection up to the point when the terminal operation executes.
In this chapter, you have seen many operations whose argument is a function.
In the javadoc of the Stream class, the filter method is declared as follows:
To understand the documentation, you have to know what a Predicate is.
It is an interface with one nondefault method returning a boolean value:
In practice, one usually passes a lambda expression or method reference, so the name of the method doesn’t really matter.
When reading the documentation of Stream.filter, just remember that a Predicate is a function returning a boolean.
For example, you may want to use Person::isAlive to ﬁlter a Stream<Employee>
That only works because of the wildcard in the parameter of the filter method.
Table 2–1 summarizes the functional interfaces that occur as parameters of the Stream and Collectors methods.
You will see additional functional interfaces in the next chapter.
A function with argument of type int, long, or double.
Make that many separate threads, each working on a segment of the list, and total up the results as they come in.
You don’t want the threads to update a single counter.
Verify that asking for the ﬁrst ﬁve long words does not call the ﬁlter method once the ﬁfth long word has been found.
Measure the difference when counting long words with a parallelStream instead of a stream.
Switch to a larger document (such as War and Peace) if you have a fast computer.
Using Stream.iterate, make an inﬁnite stream of random numbers—not by calling Math.random but by directly implementing a linear congruential generator.
You should implement a method with parameters a, c, m, and seed that yields a Stream<Long>
Why isn’t that such a good idea? Go ahead and write it anyway.
Show how to do this with the three forms of reduce.
Write a call to reduce that can be used to compute the average of a Stream<Double>
Why can’t you simply compute the sum and divide by count()?
It should be possible to concurrently collect stream results in a single ArrayList, instead of merging multiple array lists, provided it has been constructed with.
Use the atomic getAndIncrement method to safely increment each counter.
In this chapter, you will learn how to create your own libraries that make use of lambda expressions and functional interfaces.
The main reason for using a lambda expression is to defer the execution of the code until an appropriate time.
When a lambda expression is executed, make sure to provide any required data as inputs.
Choose one of the existing functional interfaces if you can.
It is often useful to write methods that return an instance of a functional interface.
When you work with transformations, consider how you can compose them.
To compose transformations lazily, you need to keep a list of all pending transformations and apply them in the end.
If you need to apply a lambda many times, you often have a chance to split up the work into subtasks that execute concurrently.
Think what should happen when you work with a lambda expression that throws an exception.
When working with generic functional interfaces, use ? super wildcards for argument types, ? extends wildcards for return types.
When working with generic types that can be transformed by functions, consider supplying map and flatMap.
After all, if you wanted to execute some code right now, you’d do that, without wrapping it inside a lambda.
There are many reasons for executing code later, such as.
Running the code at the right point in an algorithm (for example, the comparison operation in sorting)
Running the code when something happens (a button was clicked, data has arrived, and so on)
It is a good idea to think through what you want to achieve when you set out programming with lambdas.
What happens if the log level is set to suppress INFO messages? The message string is computed and passed to the info method, which then decides to throw it away.
Wouldn’t it be nicer if the string concatenation only happened when necessary?
Running code only when necessary is a use case for lambdas.
The standard idiom is to wrap the code in a no-arg lambda:
To accept the lambda, we need to pick (or, in rare cases, provide) a functional interface.
We use the isLoggable method of the Logger class to decide whether INFO messages should be logged.
If so, we invoke the lambda by calling its abstract method, which happens to be called get.
NOTE: Deferring logging messages is such a good idea that the Java 8 library designers beat me to it.
When you ask your user to supply a comparator, it is pretty obvious that the comparator has two arguments—the values to be compared.
Why an IntConsumer and not a Runnable? We tell the action in which iteration it occurs, which might be useful information.
The action needs to capture that input in a parameter.
The event object carries information that the action may need.
In general, you want to design your algorithm so that it passes any required information as arguments.
For example, when editing an image, it makes sense to have the user supply a function that computes the color for a pixel.
Such a function might need to know not just the current color, but also where the pixel is in the image, or what the neighboring pixels are.
However, if these arguments are rarely needed, consider supplying a second version that doesn’t force users into accepting unwanted arguments:
In Java, you instead declare the intent of the function, using a functional interface such as Comparator<String>
In the theory of programming languages this is called nominal typing.
Of course, there are many situations where you want to accept “any function” without particular semantics.
There are a number of generic function types for that purpose (see Table 3–1), and it’s a very good idea to use one of them when you can.
For example, suppose you write a method to process ﬁles that match a certain criterion.
The only reason not to do so would be if you already have many useful methods producing FileFilter instances.
NOTE: Most of the standard functional interfaces have nonabstract methods for producing or combining functions.
And there are default methods and, or, negate for combining predicates.
We want to transform images, applying a Color -> Color function to each pixel.
For example, the brightened image in Figure 3–1 is obtained by calling.
That is a good choice, and there is no need to come up with a ColorTransformer interface.
NOTE: This method uses the Color and Image classes from JavaFX, not from java.awt.
Sometimes, you need to supply your own functional interface because there is nothing in the standard library that works for you.
Suppose you want to modify colors in an image, allowing users to specify a function (int, int, Color) -> Color that computes a new color depending on the (x, y) location in the image.
NOTE: I called the abstract method apply because that is used for the majority of standard functional interfaces.
Should you call the method process or transform or getColor instead? It doesn’t matter much to users of the color manipulation code—they will usually supply a lambda expression.
Sticking with the standard name simpliﬁes the life of the implementor.
Just like you can pass numbers to methods and have methods that produce numbers, you can have arguments and return values that are functions.
This sounds abstract, but it is very useful in practice.
Java is not quite a functional language because it uses functional interfaces, but the principle is the same.
In this section, we consider methods whose return type is a functional interface.
What if you want it even brighter, or not quite so bright? Could you supply the desired brightness as an additional parameter to transform?
That can be made to work (see Exercise 6), but what if one wants to supply two arguments? Or three? There is another way.
The brighten method returns a function (or, technically, an instance of a functional interface)
That function can be passed to another method (here, transform) that expects such an interface.
In general, don’t be shy to write methods that produce functions.
This is useful to customize the functions that you pass to methods with functional interfaces.
For example, consider the Arrays.sort method with a Comparator argument.
NOTE: As you will see in Chapter 8, the Comparator class has several methods that yield or modify comparators.
If you have two such transformations, then doing one after the other is also a transformation.
Consider image manipulation: Let’s ﬁrst brighten an image, then turn it to grayscale (see Figure 3–2)
Just run the program in the companion code to see the effect.
For large images, that requires a considerable amount of storage.
If we could compose the image operations and then apply the composite operation to each pixel, that would be better.
That type has a method compose that, for rather depressing reasons that are explored in Exercise 10, is not useful for us.
Now the composed transformation is directly applied to each pixel, and there is no need for an intermediate image.
Generally, when you build a library where users can carry out one effect after another, it is a good idea to give library users the ability to compose these effects.
In the preceding section, you saw how users of an image transformation method can precompose operations to avoid intermediate images.
But why should they have to do that? Another approach is for the library to accumulate all operations and then fuse them.
If you do lazy processing, your API needs to distinguish between intermediate operations, which accumulate the tasks to be done, and terminal operations which deliver the result.
In the image processing example, we can make transform lazy, but then it needs to return another object that is not an Image.
A LatentImage can simply store the original image and a sequence of image operations.
To avoid duplicate transform methods, you can follow the approach of the stream library where an initial stream() operation is required to turn a collection into a.
Since we can’t add a method to the Image class, we can provide a LatentImage constructor or a static factory method.
We can provide a toImage method that applies all operations and returns the result:
CAUTION: In real life, implementing lazy operations is quite a bit harder.
Usually you have a mixture of operations, and not all of them can be applied lazily.
When expressing operations as functional interfaces, the caller gives up control over the processing details.
As long as the operations are applied so that the correct result is achieved, the caller has nothing to complain about.
For example, in image processing we can split the image into multiple strips and process each strip separately.
Here is a simple way of carrying out an image transformation in parallel.
This code operates on Color[][] arrays instead of Image objects because the JavaFX PixelWriter is not threadsafe.
Supporting image operations that combine multiple pixels would be a major challenge.
In general, when you are given an object of a functional interface and you need to invoke it many times, ask yourself whether you can take advantage of concurrency.
When you write a method that accepts lambdas, you need to spend some thought on handling and reporting exceptions that may occur when the lambda expression is executed.
When an exception is thrown in a lambda expression, it is propagated to the caller.
There is nothing special about executing lambda expressions, of course.
They are simply method calls on some object that implements a functional interface.
Often it is appropriate to let the expression bubble up to the caller.
If first.run() throws an exception, then the doInOrder method is terminated, second is never run, and the caller gets to deal with the exception.
If first.run() throws an exception, the thread is terminated, and second is never run.
However, the doInOrderAsync returns right away and does the work in a separate thread, so it is not possible to have the method rethrow the exception.
In this situation, it is a good idea to supply a handler:
Now suppose that first produces a result that is consumed by second.
It is often inconvenient that methods in functional interfaces don’t allow checked exceptions.
A Callable<T> has a method that is declared as T call() throws Exception.
If you want an equivalent for a Consumer or a Function, you have to create it yourself.
You sometimes see suggestions to “ﬁx” this problem with a generic wrapper, like this:
You would need to implement a variation of unchecked for each functional interface.
You have seen a number of examples where we wrote generic mechanisms, such as the unchecked method of the preceding section.
There are just a couple of issues to keep in mind.
One of the unhappy consequences of type erasure is that you cannot construct a generic array at runtime.
In the past, the solution was to provide a second method that accepts an array.
That array was either ﬁlled or used to create a new one via reﬂection.
With lambdas, you have a new option, namely to pass the constructor.
When you implement such a method, the constructor expression is an IntFunction<T[]>, since the size of the array is passed to the constructor.
In this regard, lambdas help you overcome a limitation of generic types.
Unfortunately, in another common situtation lambdas suffer from a different limitation.
To understand the problem, recall the concept of type variance.
Note that staff and tenants are references to the same list.
We say that the type parameter T of List<T> is invariant.
If List was immutable, as it is in a functional programming language, then the problem would disappear, and one could have a covariant list.
That is what is done in languages such as Scala.
However, when generics were invented, Java had very few immutable generic classes, and the language designers instead embraced a different concept: use-site variance, or “wildcards.”
It is okay to write employees into a List<Person>, so you can pass such a list.
In general, reading is covariant (subtypes are okay) and writing is contravariant (supertypes are okay)
It gives each service the choice which variance, if any, is appropriate.
A function type is always contravariant in its arguments and covariant in its return value.
They will only call it with employees, whereas your function can handle any person.
They will expect the function to return a person, and you give them something even better.
In Java, when you declare a generic functional interface, you can’t specify that function arguments are always contravariant and return types always covariant.
The general rule is that you use super for argument types, extends for return types.
If it is willing to consume any object, surely it can consume strings.
Since T is the argument and return type of BinaryOperator, the type does not vary.
In effect, the contravariance and covariance cancel each other out.
As the implementor of a method that accepts lambda expressions with generic types, you simply add ? super to any argument type that is not also a return type, and ? extends to any return type that is not also an argument type.
For example, consider the doInOrderAsync method of the preceding section.
When you work with generic types, and with functions that yield values from these types, it is useful to supply methods that let you compose these functions—that is, carry out one after another.
In this section, you will see a design pattern for providing such compositions.
How this works exactly depends on the nature of the generic type G.
Applying f to a Future<T> simply means to apply it whenever it is available.
The CompletableFuture class that we will discuss in Chapter 6 has an operation that does just what map should do, but it is called thenApply.
For example, consider getting the web page for a URL.
Now suppose you have a Future<URL>, a URL that will arrive sometime.
Clearly it makes sense to map the function to that Future.
Wait for the URL to arrive, then feed it to the function and wait for the string to arrive.
NOTE: These operations are important in the theory of monads, but you don’t need to know the theory to understand map and flatMap.
The concept of mapping a function is both straightforward and useful, and the point of this section is to make you aware of it.
Don’t evaluate the condition if the logger won’t log the message.
When you use a ReentrantLock, you are required to lock and unlock with the idiom.
Java 1.4 added assertions to the language, with an assert keyword.
Why were assertions not supplied as a library feature? Could they be implemented as a library feature in Java 8?
We want to put a frame around an image, like this:
Then call it with an appropriate lambda expression to put a 10 pixel gray frame replacing the pixels on the border of an image.
Write a method that generates a Comparator<String> that can be normal or reversed, case-sensitive or case-insensitive, space-sensitive or space-insensitive, or any combination thereof.
Generalize Exercise 5 by writing a static method that yields a ColorTransformer that adds a frame of arbitrary thickness and color to an image.
If they are different, return the difference, otherwise move on to the firstname ﬁeld.
Look carefully at the return type of the compose method of UnaryOperator<T>
Why is it not appropriate for the transform method? What does that say about.
Then use these methods to add a gray frame to a brightened image.
Convolution ﬁlters such as blur or edge detection compute a pixel from neighboring pixels.
To blur an image, replace each color value by the average of itself and its eight neighbors.
For edge detection, replace each color value c with 4c – n – e – s – w, where the other colors are those of the pixel to the north, east, south, and west.
Enhance the lazy image processing to deal with these operations.
Force computation of the previous stage when one of these operators is evaluated.
Note that you will need to ﬁnd or provide a functional interface whose abstract method throws arbitrary exceptions.
Should U be declared as ? super U in the ﬁrst type argument to BiFunction? Why or why not?
Return an object of an anonymous class that implements all methods of the Future interface.
Is there a flatMap operation for CompletableFuture? If so, what is it?
Deﬁne a map operation for a class Pair<T> that represents a pair of objects of type T.
Can you deﬁne a flatMap method for Pair<T>? If so, what is it? If not, why not?
JavaFX is now bundled with all supported versions of Oracle’s Java platform.
In this chapter, you will learn the basics of JavaFX development.
If you develop rich client user interface platforms, you will see how to transition from Swing to JavaFX.
If you don’t, skim over the chapter anyway so you can understand the sample applications we use elsewhere when it is convenient to illustrate a concept with a graphical program.
A scene graph is made up of nodes which may contain other nodes.
A scene is displayed on a stage (a top-level window, the surface of an applet, or the full screen)
Some controls (such as buttons) emit events, but most JavaFX events come from property changes.
When you bind a property to another, it is updated when the other one changes.
JavaFX uses layout panes that work similar to layout managers in Swing.
You can use CSS to change the visual appearance of your application.
JavaFX provides some advanced controls out of the box, such as charts, an embedded WebKit browser, and a media player.
When Java was born, the Internet was in its infancy and personal computers were on every desktop.
Business applications were implemented with “fat clients”—programs with lots of buttons and sliders and text ﬁelds that communicated with a server.
This was considered a lot nicer than the “dumb terminal” applications from an even earlier era.
Java 1.0 included the AWT, a toolkit for graphical user interfaces, that had the distinction of being cross-platform.
The idea was to serve up the fat clients over the nascent Web, eliminating the cost of managing and updating the applications on every desktop.
The AWT had a noble idea: provide a common programming interface for the native buttons, sliders, text ﬁelds, and so on of various operating systems.
There were subtle differences in the functionality of the user interface widgets in each operating system, and what should have been “write once, run anywhere” turned into “write many times, debug everywhere.”
The central idea behind Swing was not to use the native widgets, but to paint its own.
That way, the user interface would look and feel the same on every platform.
Or, if users preferred, they could ask for the native look and feel of their platform, and the Swing widgets would be painted to match the native ones.
Of course, all that painting was slow, and users complained.
After a while, computers got faster, and users complained that Swing was ugly—indeed, it had fallen behind the native widgets that had been spruced up with animations and fancy effects.
More ominously, Flash was increasingly used to create user interfaces with even ﬂashier effects that didn’t use the native controls at all.
In 2007, Sun Microsystems introduced a new technology, called JavaFX, as a competitor to Flash.
It ran on the Java VM but had its own programming language, called JavaFX Script.
The language was optimized for programming animations and fancy effects.
Programmers complained about the need to learn a new language, and they stayed away in droves.
Of course, Flash is now a bad memory, and most user interfaces live in a browser or a mobile device.
Still, there are situations where a “fat client” on a desktop makes users more productive.
JavaFX is what Oracle wants us to use for those applications.
Why didn’t Oracle just put the good parts of JavaFX into Swing? Swing would have to be redesigned from the ground up to run efﬁciently on modern graphics hardware.
Oracle decided that it wasn’t worth the trouble and declared that Swing will not be further developed.
In this chapter, we go over the basics of writing user interfaces in JavaFX, focusing on boring business applications with buttons, sliders, and text ﬁelds, not the ﬂashy effects that were the original motivation behind JavaFX.
In Swing, the equivalent control was called JLabel to distinguish it from the AWT Label.
This Font constructor makes a font object representing the default font at 100 points.
In JavaFX, you put everything you want to show onto a scene.
There, you can decorate and animate your “actors”—that is, your controls and shapes.
In our program, we won’t do any decorating or animating, but we still need the scene.
That is a top-level window if the program runs on a desktop, or a rectangular area if it runs as an applet.
The stage is passed as a parameter to the start method that you must override in a subclass of the Application class.
NOTE: As you see from this example, no main method is required to launch a JavaFX application.
In previous versions of JavaFX, you were required to include a main method of the form.
As they carry out these actions, the UI reacts and updates itself.
As in Swing, you add an event handler to a button so you can be notiﬁed when it is clicked.
In this case, it sets the text color to red.
However, you shouldn’t listen to the low-level events that the slider emits to indicate those changes.
Instead, the slider has a JavaFX property called value, and the property emits events when it changes.
We will discuss properties in detail in the next section, but here is how you can listen to the property’s events and adjust the font size of the message:
For example, if you want to change a part of the user interface as a user enters text into a text ﬁeld, add a listener to the text property.
A property is an attribute of a class that you can read or write.
Commonly, the property is backed by a ﬁeld, and the property getter and setter simply read and write that ﬁeld.
But the getter and setter can also take other actions, such as reading values from a database or sending out change notiﬁcations.
In many programming languages, there is convenient syntax for invoking property getters and setters.
Typically, using the property on the right-hand side of an assignments calls the getter, and using it on the left-hand side calls the setter.
But it has supported properties by convention since Java 1.1
The JavaBeans speciﬁcation states that a property should be inferred from a getter/setter pair.
For example, a class with methods String getText() and void setText(String newValue) is deemed to have a text property.
The Introspector and BeanInfo classes in the java.beans package let you enumerate all properties of a class.
The JavaBeans speciﬁcation also deﬁnes bound properties, where objects emit property change events when the setters are invoked.
JavaFX does not make use of this part of the speciﬁcation.
For example, a JavaFX text property has a method Property<String> textProperty()
In JavaFX, the property object, not the bean, sends out notiﬁcations.
Implementing bound JavaBeans properties required boilerplate code to add, remove, and ﬁre listeners; in JavaFX it’s much simpler because there are library classes that do all that work.
Let’s see how we can implement a property text in a class Greeting.
It has methods for getting and setting the wrapped value and for managing listeners.
As you can see, implementing a JavaFX property requires some boilerplate code, and there is unfortunately no way in Java to generate the code automatically.
But at least you won’t have to worry about managing listeners.
It is not a requirement to declare property getters and setters as final, but the JavaFX designers recommend it.
NOTE: With this pattern, a property object is needed for each property, whether anyone listens to it or not.
Exercise 2 explores a useful optimization for the pattern, creating the property objects lazily.
NOTE: The property classes have methods getValue and setValue in addition to the get and set methods.
In the StringProperty class, get is identical to getValue, and set to setValue.
For example, in an IntegerProperty, getValue returns an Integer, and get returns an int.
Generally, use get and set unless you write generic code that needs to work with properties of any type.
There are two kinds of listeners that can be attached to a property.
As you will see in the next section, some properties are computed from others, and the computation is only done when necessary.
The ChangeListener callback tells you the old and new value, which means it has to compute the new value.
It doesn’t matter much whether you get the new value as a callback parameter or from the property.
And usually, it is not worth worrying about computed properties that happen to stay unchanged even though one of their inputs changed.
CAUTION: It is a bit tricky to use the ChangeListener interface for numeric properties.
Therefore, the type for oldValue and newValue is Number and not Double, so you have to manually unbox:
This is achieved by binding one property to the other:
Under the hood, a change listener is added to the text property of shipping that sets the text property of billing.
If either of the properties changes, the other is updated.
The binding mechanism solves a common problem in user interface programming.
For example, consider a date ﬁeld and a calendar picker.
When the user picks a date from the calendar, the date ﬁeld should be automatically updated, as should be the date property of the model.
Of course, in many situations, one property depends on another, but the relationship is more complex.
That is, its centerX property should be one half of the width property of the scene.
To achieve this, we need to produce a computed property.
Figure 4–4 The center of this circle is bound to half the width and height of the scene.
All that remains is to bind that computed property to the circle’s centerX property:
With more complex expressions, the static Bindings methods seems a bit easier to read, particularly if you use.
We want to disable the Smaller and Larger buttons when the gauge is too small or large (Figure 4–5)
Table 4–1 lists all operators that the Bindings class provides.
One or both of the arguments implement the Observable interface or one of its subinterfaces.
The ObservableValue interface adds ChangeListener management and a getValue method.
Its subinterfaces provide methods to get the value in the appropriate type.
Figure 4–5 When the gauge reaches either end, a button is disabled.
A Binding knows about all properties on which it depends.
In practice, you don’t need to worry about all of these interfaces.
You combine properties and you get something that you can bind to another property.
If any of the objects is an ObservableValue that changes, the concatenation changes too.
An optional locale, a MessageFormat string, and a sequence of objects that are formatted.
If any of the objects is an ObservableValue that changes, the formatted string changes too.
An ObservableList and an index, or an ObservableMap and a key.
An Object or ObservableValue and a sequence of public property names, yielding the property obj.p1.p2
The conditional value is recomputed whenever an observable value changes.
Building up a computed property with the methods of the Bindings class can get quite baroque.
There is another approach for producing computed bindings that you may ﬁnd easier.
Simply put the expression that you want to have computed into a lambda, and supply a list of dependent properties.
When any of the properties changes, the lambda is recomputed.
Exercise 5 suggests a slightly more elegant way of lazily evaluating bindings with lambda expressions.
Of course, in Java, the programmer needs to supply this information.
When a graphical user interface contains multiple controls, they need to be arranged on the screen in a functional and attractive way.
One way to obtain a layout is with a design tool.
The tool’s user, often a graphics designer, drags images of the controls onto a design view and arranges, resizes, and conﬁgures them.
However, this approach can be problematic when the sizes of the elements change, for example, because labels have different lengths in international versions of a program.
Alternatively, the layout can be achieved programmatically, by writing code in a setup method that adds the user interface controls to speciﬁc positions.
That is what was done in Swing, using layout manager objects.
Another approach is to specify the layout in a declarative language.
For example, web pages are laid out with HTML and CSS.
When you understand the concepts of this section, you will ﬁnd it straightforward to use.
However, instead of layout managers that are added to arbitrary panels, one uses panes—containers with a layout policy.
NOTE: With the Swing BorderLayout, buttons were expanded to ﬁll each region of the layout.
In JavaFX, a button does not expand past its natural size.
Now suppose you want more than one button in the South area.
Of course, there is a VBox for laying out controls vertically.
Without it, the label and the buttons would touch the window border.
In our example, we use ten pixels for the box spacing and padding.
This is not really appropriate nowadays, when pixel densities can vay widely.
One way to overcome this is to compute dimensions in rem, as you would do in CSS3
A rem or “root em” is the height of the default font of the document root.
There is only so much you can achieve with horizontal and vertical boxes.
Just as Swing had the GridBagLayout as “the mother of all layout managers,” JavaFX has the GridPane.
Think of a GridPane as an equivalent of an HTML table.
You can set the horizontal and vertical alignment of all cells.
Figure 4–9 A GridPane can arrange the controls for this login dialog.
The buttons are in an HBox that spans two rows.
When you add a child to a GridPane, specify its column and row index (in that order; think x- and y-coordinates)
If a child spans multiple columns or rows, specify the spans after the positions.
For example, the button panel spans two columns and one row:
To set the horizontal alignment of a child, use the static setHalignment method, and pass the child reference and a constant LEFT, CENTER, or RIGHT from the HPos enumeration.
Similarly, for vertical alignment, call setValignment and use TOP, CENTER, or BOTTOM from the VPos enumeration.
NOTE: These static calls look rather inelegant in Java code, but they make sense in the FXML markup language—see the next section.
CAUTION: Do not center the HBox with the buttons inside the grid.
That box has expanded to the full horizontal size, and centering will not change its position.
You will also want to provide some spacing around the rows and columns and some padding around the table:
TIP: For debugging, it can be useful to see the cell boundaries (see Figure 4–10)
If you want to see the borders of an individual child (for example, to see whether it has grown to ﬁll the entire cell), set its border.
Figure 4–10 Use visible grid lines when debugging a GridPane.
These layout panes should sufﬁce for the majority of applications.
Lays out children in a grid, giving them all the same size, similar to the Swing GridLayout.
Flows children in rows, making new rows when there isn’t sufﬁcient space, similar to the Swing FlowLayout.
Children can be positioned in absolute positions, or relative to pane’s boundaries.
Can be useful for decorating components, such as stacking a button over a colored rectangle.
NOTE: In this section, we built up user interfaces by manually nesting panes and controls.
JavaFX Script had a “builder” syntax for describing such nested structures (called the “scene graph”)
That’s amazingly verbose, and it’s not even the full story—one still needed to specify the grid constraints.
Builders have been deprecated in JavaFX 8, not because they are so verbose, but because of an implementation issue.
To save code, builders have an inheritance tree that parallels the inheritance of the corresponding nodes.
The JavaFX designers tried to solve this problem with generics.
The markup language that JavaFX uses to describe layouts is called FXML.
I discuss it in some detail because the concepts are interesting beyond the needs of JavaFX, and the implementation is fairly general.
Here is the FXML markup for the login dialog of the preceding section:
First off, the nesting of the GridPane, the labels and text ﬁelds, the HBox and its button children reﬂects the nesting that we built up with Java code in the preceding section.
When an attribute starts with a class name and a static method, that method is invoked.
NOTE: Generally, an FXML element is constructed with its default constructor and then customized by calling property setters or static methods, in the spirit of the JavaBeans speciﬁcation.
There are a few exceptions that we will consider later.
When a property value is too complex to express as a string, one uses nested elements instead of attributes.
You can write FXML ﬁles by hand, or you can use the SceneBuilder program that I mentioned in the preceding section.
Once you have such a ﬁle, load it like this:
The user interface is displayed, but the program cannot access the values that the user provides.
One way of establishing a connection between the controls and the program is to use id attributes, as you would in JavaScript.
You can use the @FXML annotation to “inject” the control objects into a controller class.
In the controller’s initialize method, you wire up the binders and event handlers.
Any class can be the controller, even the FX application itself.
For example, here is a controller for our login dialog:
In the FXML ﬁle, provide the names of the controller’s instance variables to the corresponding control elements in the FXML ﬁle, using the fx:id (not id) attribute:
In the root element, you also need to declare the controller class, using the fx:controller attribute:
NOTE: If your controller doesn’t have a default constructor (perhaps, because it is being initialized with a reference to a business service), you can set it programmatically:
CAUTION: If you set the controller programmatically, really use the code from the preceding note.
The following code will compile, but it will invoke the static FXMLLoader.load method, ignoring the constructed loader:
When the FXML ﬁle is loaded, the scene graph is constructed, and references to the named control objects are injected into the annotated ﬁelds of the controller object.
It is even possible do much of the initialization in the FXML ﬁle.
You can deﬁne simple bindings, and you can set annotated controller methods as event listeners.
It seems better to separate the visual design from the program behavior, so that a user interface designer can produce the design and a programmer can implement the behavior.
NOTE: It is also possible to add scripts in JavaScript or another scripting language to an FXML ﬁle.
JavaFX lets you change the visual appearance of the user interface with CSS, which is usually more convenient than supplying FXML attributes or calling Java methods.
You can load a CSS style sheet programmatically and have it applied to a scene graph:
In the style sheet, you can reference any controls that have an ID.
For example, here is how you can control the appearance of a GridPane.
Unfortunately, you can’t use the familiar CSS attributes but need to know FX-speciﬁc attributes that start with -fx-
The attribute names are formed by changing the property names to lowercase and using hyphens instead of camel case.
Using CSS is nicer than cluttering up the code with layout minutiae.
Of course CSS can be used both for good and for evil (see Figure 4–11), and I hope you will resist the temptation to apply gratuitous background textures to your login dialogs.
Instead of styling by individual IDs, you can use style classes.
Every JavaFX control and shape class belongs to a CSS class whose name is the decapitalized Java class name.
Here is how you can change the font for all labels to Comic Sans:
Then you can specify most styling in CSS, and use FXML only for layout.
Unfortunately, you can’t completely remove all styling from the FXML.
For example, there is currently no way to specify grid cell alignment in CSS.
NOTE: You can also apply a CSS style programmatically, such as.
That can be handy for debugging, but in general, it seems better to use an external stylesheet.
When JavaFX was born, special effects were all the rage, and JavaFX makes it easy to produce shadows, blurs, and movement.
I thought you’d enjoy some useful tips on how to bring these animations to the world of business applications.
Figure 4–12 shows an application where the Yes button increases in size while the No button fades into the background and the Maybe button rotates.
JavaFX deﬁnes a number of transitions that, over a period of time, vary a property of a node.
Here is how you grow a node by 50% in both x and y directions over three seconds:
The node can be any node in a scene graph, such as a circle in an animation of soap bubbles or the ever more enticing Yes button in our example.
As set up, the transition will end when its goal is met.
Now the node will get bigger, then smaller, then bigger again, and so on.
Here is how the No button fades into the background:
The following code animates the rotation of the Maybe button:
If you need to animate multiple nodes, you can place them into a Group node and animate that.
When you need to create this kind of behavior, the JavaFX classes are a joy to work with.
If you need a drop shadow for a spiffy caption, make a DropShadow effect and set it as the effect property of a node.
To set a glow or a blur effect is just as simple:
Admittedly, the glow effect looks a bit cheesy and the blur effect doesn’t seem to have many applications in the world of business, but it is impressive how easy it is to produce these effects.
Of course, JavaFX has combo boxes, tab panes, trees, and tables, just like Swing does, as well as a few user interface controls that Swing never got, such as a date picker and an accordion.
It would take an entire book to describe these in detail.
In this section, I want to dispel any remaining Swing nostalgia by showing you three fancy controls that are far beyond what Swing had to offer.
Figure 4–14 shows one of many charts that you can make with JavaFX, out of the box, without having to install any third-party libraries.
Altogether, there are half a dozen chart types that you can use and customize.
In Swing, you could show HTML in a JEditorPane, but the rendering was poor for most real-world HTML.
In fact, it is so hard that most browsers are built on top of the open source WebKit engine.
A WebView displays an embedded native WebKit window (see Figure 4–15)
The browser is live—you can click on links in the usual way.
However, if you want to display status line or popup messages from JavaScript, you need to install notiﬁcation handlers and implement your own status line and popups.
NOTE: WebView does not support any plugins, so you cannot use it to show Flash animations or PDF documents.
A Java Media Framework was available as an optional download, but it did not get much love from the developers.
Of course, implementing audio and video playback is even harder than writing a browser.
Therefore, JavaFX leverages an existing toolkit, the open source GStreamer framework.
To play a video, construct a Media object from an URL string, construct a MediaPlayer to play it, and a MediaView to show the player:
As you can see in Figure 4–16, the video is played—but, unfortunately, there are no video controls.
NOTE: Ever so often, GStreamer can’t handle a particular video ﬁle.The error handler in the code sample displays GStreamer messages so that you can diagnose playback problems.
That brings us to the end of this quick tour through JavaFX.
It has a few rough edges, mostly due to a hurried transformation from the original scripting language.
But it is certainly no harder to use than Swing, and it has many more useful and attractive controls than Swing ever had.
Write a program with a text ﬁeld and a label.
As with the Hello, JavaFX program, the label should have the string Hello, FX in a 100 point font.
Update the label as the user edits the text ﬁeld.
Consider a class with many JavaFX properties, such as a chart or table.
Chances are that in a particular application, most properties never have listeners attached to them.
It is therefore wasteful to have a property object per property.
Show how the property can be set up on demand, ﬁrst using a regular ﬁeld for storing the property value, and then using a property object only when the xxxProperty() method is called for the ﬁrst time.
Consider a class with many JavaFX properties, most of which are never changed from a default.
Show how the property can be set up on demand, when it is set to a nondefault value or when the xxxProperty() method is called for the ﬁrst time.
Find out how to set the border of a control without using CSS.
Since there is no JavaFX-speciﬁc knowledge in parsing FXML ﬁles, come up with an example where you load an object that has nothing to do with JavaFX, with some nested objects, and set the properties in FXML syntax.
Animate a circle, representing a planet, so it travels along an elliptical orbit.
Using the web viewer, implement a browser with a URL bar and a back button.
An Instant is a point on the time line (similar to a Date)
In Java time, each day has exactly 86,400 seconds (i.e., no leap seconds)
TemporalAdjuster methods handle common calendar computations, such as ﬁnding the ﬁrst Tuesday of a month.
ZonedDateTime is a point in time in a given time zone (similar to GregorianCalendar)
Use a Period, not a Duration, when advancing zoned time, in order to account for daylight savings time changes.
Ever so often, the ofﬁcial time keepers synchronize the absolute time with the rotation of Earth.
At ﬁrst, the ofﬁcial seconds were slightly adjusted, but starting in 1972, “leap seconds” were occasionally inserted.
In theory, a second might need to be removed once in a while, but that has not yet happened.
Clearly, leap seconds are a pain, and many computer systems instead use “smoothing” where time is artiﬁcially slowed down or sped up just before the leap second, keeping 86,400 seconds per day.
This works because the local time on a computer isn’t all that precise, and computers are used to synchronizing themselves with an external time service.
The Java Date and Time API speciﬁcation requires that Java uses a time scale that.
That gives Java the ﬂexibility to adjust to future changes in the ofﬁcial time.
In Java, an Instant represents a point on the time line.
This is the same convention used in the Unix/POSIX time.
Starting from that origin, time is measured in 86,400 seconds per day, forwards and backwards, in nanosecond precision.
The Instant values go back as far as a billion years (Instant.MIN)
That’s not quite enough to express the age of the universe (around 13.5 billion years), but it should be enough for all practical purposes.
After all, a billion years ago, the earth was covered in ice and populated by microsocopic ancestors of today’s plants and animals.
To ﬁnd out the difference between two instants, use the static method Duration.between.
For example, here is how you can measure the running time of an algorithm:
A Duration is the amount of time between two instants.
You can get the length of a Duration in conventional units by calling toNanos, toMillis, toSeconds, toMinutes, toHours, or toDays.
Durations require more than a long value for their internal storage.
The number of seconds is stored in a long, and the number of nanoseconds in an additional int.
If you want to make computations in nanosecond accuracy, and you actually need the entire range of a Duration, then you can use one of the methods in Table 5–1
Otherwise, you can just call toNanos and do your calculations with long values.
NOTE: It takes almost 300 years of nanoseconds to overﬂow a long.
Adds a duration to, or subtracts a duration from, this Instant or Duration.
Adds a number of the given time units to this Instant or Duration.
Subtracts a number of the given time units from this Instant or Duration.
Returns a duration that is obtained by multiplying or dividing this Duration by a given long, or by –1
For example, if you want to check whether an algorithm is at least ten times faster than another, you can compute.
NOTE: The Instant and Duration classes are immutable, and all methods, such as multipliedBy or minus, return a new instance.
Now let us turn from absolute time to human time.
There are two kinds of human time in the new Java API, local date/time and zoned time.
Local date/time has a date and/or time of day, but no associated time zone information.
Since that date has neither a time of day nor time zone information, it does not correspond to a precise instant of time.
For that reason, the API designers recommend that you do not use zoned time unless you really want to represent absolute time instances.
Birthdays, holidays, schedule times, and so on are usually best represented as local dates or times.
A LocalDate is a date, with a year, month, and day of the month.
To construct one, you can use the now or of static methods:
Table 5–2 shows the most useful methods for working with LocalDate objects.
These static methods construct a LocalDate, either from the current time or from a given year, month, and day.
Adds a number of days, weeks, months, or years to this LocalDate.
Subtracts a number of days, weeks, months, or years from this LocalDate.
Returns a new LocalDate with the day of month, day of year, month, or year changed to the given value.
Gets the day of the week, returning a value of the DayOfWeek enumeration.
Gets the Period, or the number of the given ChronoUnits, between two dates.
The algorithm is applied for all past years, even though that is historically inaccurate.
For example, Programmer’s Day is the 256th day of the year.
Recall that the difference between two time instants is a Duration.
The equivalent for local dates is a Period, which expresses a number of elapsed years, months, or days.
The until method yields the difference between two local dates.
That is actually not terribly useful because the number of days per month varies.
CAUTION: Some methods in Table 5–2 could potentially create nonexistent dates.
Instead of throwing an exception, these methods return the last valid day of the month.
The getDayOfWeek yields the weekday, as a value of the DayOfWeek enumeration.
NOTE: The weekend days actually come at the end of the week.
In addition to LocalDate, there are also classes MonthDay, YearMonth, and Year to describe partial dates.
For example, December 25 (with the year unspeciﬁed) can be represented as a MonthDay.
For scheduling applications, you often need to compute dates such as “the ﬁrst Tuesday of every month.” The TemporalAdjusters class provides a number of static methods for common adjustments.
You pass the result of an adjustment method to the with method.
For example, the ﬁrst Tuesday of a month can be computed like this:
As always, the with method returns a new LocalDate object without modifying the original.
You can also roll your own adjuster by implementing the TemporalAdjuster interface.
Note that the parameter of the lambda expression has type Temporal, and it must be cast to LocalDate.
Next or previous date that falls on the given weekday.
Next or previous date that falls on the given weekday, starting from the given date.
A LocalTime represents a time of day, such as 15:30:00
You can create an instance with the now or of methods:
The plus and minus operations wrap around a 24-hour day.
These static methods construct a LocalTime, either from the current time, or from the given hours, minutes, and optionally, seconds and nanoseconds.
Adds a number of hours, minutes, seconds, or nanoseconds to this LocalTime.
Subtracts a number of hours, minutes, seconds, or nanoseconds from this LocalTime.
Returns a new LocalTime with the hour, minute, second, or nanosecond changed to the given value.
Gets the hour, minute, second, or nanosecond of this LocalTime.
Returns the number of seconds or nanoseconds between midnight and this LocalTime.
There is a LocalDateTime class, representing a date and time.
That class is suitable for storing points in time in a ﬁxed time zone, for example, for a schedule of classes or events.
However, if you need to make calculations that span the daylight savings time, or if you need to deal with users in different time zones, you should use the ZonedDateTime class that we discuss next.
Time zones, perhaps because they are an entirely human creation, are even messier than the complications caused by the earth’s irregular rotation.
This is actually done in China, which spans four conventional time zones.
Elsewhere, we have time zones with irregular and shifting boundaries, and, to make matters worse, the daylight savings time.
As capricious as the time zones may appear to the enlightened, they are a fact of life.
When you implement a calendar application, it needs to work for people who ﬂy from one country to another.
When you have a conference call at 10:00 in New York, but happen to be in Berlin, you expect to be alerted at the correct local time.
The bulk of the updates deals with the changing rules for daylight savings time.
Each time zone has an ID, such as America/New_York or Europe/Berlin.
At the time of this writing, there were almost 600 IDs.
Given a time zone ID, the static method ZoneId.of(id) yields a ZoneId object.
Many of the methods of ZonedDateTime are the same as those of LocalDateTime (see Table 5–5)
Most are straightforward, but daylight savings time introduces some complications.
When daylight savings time starts, clocks advance by an hour.
Conversely, when daylight time ends, clocks are set back by an hour, and there are two instants with the same local time! When you construct a time within that span, you get the earlier of the two.
An hour later, the time has the same hours and minutes, but the zone offset has changed.
You also need to pay attention when adjusting a date across daylight savings time boundaries.
For example, if you set a meeting for next week, don’t add a duration of seven days:
These static methods construct a ZonedDateTime from the current time, or from a year, month, day, hour, minute, second, nanosecond (or a LocalDate and LocalTime), and ZoneId, or from an Instant and ZoneId.
Returns a new ZonedDateTime, with one temporal unit changed to the given value.
Returns a new ZonedDateTime in the given time zone, either representing the same instant or the same local time.
Gets the day of the week, returning a value of the DayOfWeek enumeration.
Gets the hour, minute, second, or nanosecond of this ZonedDateTime.
Yields the local date or local time, or the corresponding instant.
CAUTION: There is also an OffsetDateTime class that represents times with an offset from UTC, but without time zone rules.
That class is intended for specialized applications that speciﬁcally require the absence of those rules, such as certain network protocols.
The DateTimeFormatter class provides three kinds of formatters to print a date/time value:
To use one of the standard formatters, simply call its format method:
To present dates and times to human readers, use a locale-speciﬁc formatter.
There are four styles, SHORT, MEDIUM, LONG, and FULL, for both date and time—see Table 5–7
To change to a different locale, simply use the withLocale method.
Finally, you can roll your own date format by specifying a pattern.
Each letter denotes a different time ﬁeld, and the number of times the letter is repeated selects a particular format, according to rules that are arcane and seem to have organically grown over time.
To parse a date/time value from a string, use one of the static parse methods.
The ﬁrst call uses the standard ISO_LOCAL_DATE formatter, the second one a custom formatter.
In Java 8, that class has two added methods: the toInstant method that converts a Date to an Instant, and the static from method that converts in the other direction.
The toZonedDateTime method converts a GregorianCalendar to a ZonedDateTime, and the static from method does the opposite conversion.
Another set of conversions is available for the date and time classes in the java.sql package.
Write an equivalent of the Unix cal program that displays a calendar for a month.
Write a program that prints how many days you have been alive.
Again using stream operations, ﬁnd all time zones whose offsets aren’t full hours.
When does it arrive? Write a program that can handle calculations like this.
How long is the ﬂight? Write a program that can handle calculations like this.
Read a set of appointments in different time zones and alert the user which ones are due within the next hour in local time.
Early Java releases had minimal support for concurrency, and programmers busily created code with deadlocks and race conditions.
That package gives us threadsafe collections and thread pools, allowing many application programmers to write concurrent programs without using locks or starting threads.
In this chapter, we focus squarely on the needs of the application programmer.
Updating atomic variables has become simpler with the updateAndGet/ accumulateAndGet methods.
Updating entries in a ConcurrentHashMap has become simpler with the compute and merge methods.
ConcurrentHashMap now has bulk operations search, reduce, forEach, with variants operating on keys, values, keys and values, and entries.
A set view lets you use a ConcurrentHashMap as a Set.
The Arrays class has methods for parallel sorting, ﬁlling, and preﬁx operations.
For example, you can safely generate a sequence of numbers like this:
The incrementAndGet method atomically increments the AtomicLong and returns the post-increment value.
That is, the operations of getting the value, adding 1, setting it, and producing the new value cannot be interrupted.
It is guaranteed that the correct value is computed and returned, even if multiple threads access the same instance concurrently.
There are methods for atomically setting, adding, and subtracting values, but if you want to make a more complex update, you have to use the compareAndSet method.
For example, suppose you want to keep track of the largest value that is observed by different threads.
Instead, compute the new value and use compareAndSet in a loop:
If another thread is also updating largest, it is possible that it has beat this thread to it.
Then compareAndSet will return false without setting the new value.
In that case, the loop tries again, reading the updated value and trying to change it.
Eventually, it will succeed replacing the existing value with the new one.
This sounds tedious, but the compareAndSet method maps to a processor operation that is faster than using a lock.
In Java 8, you don’t have to write the loop boilerplate any more.
Instead, you provide a lambda expression for updating the variable, and the update is done for you.
The accumulateAndGet method takes a binary operator that is used to combine the atomic value and the supplied argument.
There are also methods getAndUpdate and getAndAccumulate that return the old value.
When you have a very large number of threads accessing the same atomic values, performance suffers because the optimistic updates require too many retries.
Java 8 provides classes LongAdder and LongAccumulator to solve this problem.
A LongAdder is composed of multiple variables whose collective sum is the current value.
Multiple threads can update different summands, and new summands are automatically provided when the number of threads increases.
This is efﬁcient in the common situation where the value of the sum is not needed until after all work has been done.
If you anticipate high contention, you should simply use a LongAdder instead of an AtomicLong.
Call increment to increment a counter or add to add a quantity, and sum to retrieve the total.
NOTE: Of course, the increment method does not return the old value.
Doing that would undo the efﬁciency gain of splitting the sum into multiple summands.
The LongAccumulator generalizes this idea to an arbitrary accumulation operation.
In the constructor, you provide the operation, as well as its neutral element.
Each variable is initialized with the neutral element (0 in our example)
When accumulate is called with value v, then one of them is atomically updated as ai = ai op v, where op is the accumulation operation written in inﬁx form.
In our example, a call to accumulate computes ai = ai + v for some i.
If you choose a different operation, you can compute maximum or minimum (see Exercise 4)
That means that the ﬁnal result must be independent of the order in which the intermediate values were combined.
There are also DoubleAdder and DoubleAccumulator that work in the same way, except with double values.
NOTE: Another addition to Java 8 is the StampedLock class that can be used to implement optimistic reads.
I don’t recommend that application programmers use locks, but here is how it is done.You ﬁrst call tryOptimisticRead, upon which you get a “stamp.” Read your values and check whether the stamp is still valid (i.e., no other thread has obtained a write lock)
If not, get a read lock (which blocks any writers)
A classic programmer’s saying is, “If you can only have one data structure, make it a hash table.” Since Java 5, the ConcurrentHashMap has been a workhorse of concurrent programming.
Moreover, it is quite efﬁcient, allowing multiple threads to update different parts of the table concurrently without blocking each other.
NOTE: Some applications use humongous concurrent hash maps, so large that the size method is insufﬁcient because it returns an int.
What is one to do with a map that has over two billion entries? Java 8 introduces a mappingCount method that returns the size as a long.
NOTE: A hash map keeps all entries with the same hash code in the same “bucket.” Some applications use poor hash functions, and as a result all entries end up in a small number of buckets, severely degrading performance.
Even generally reasonable hash functions, such as that of the String class, can be problematic.
For example, an attacker can slow down a program by crafting a large number of strings that hash to the same value.
As of Java 8, the concurrent hash map organizes the buckets as trees, not lists, when the key type implements Comparable, guaranteeing O(log(n)) performance.
The original version of ConcurrentHashMap only had a few methods for atomic updates, which made for somewhat awkward programming.
Suppose we want to count how often certain features are observed.
As a simple example, suppose multiple threads encounter words, and we want to count their frequencies.
Another thread might be updating the exact same count at the same time.
NOTE: Some programmers are surprised that a supposedly threadsafe data structure permits operations that are not threadsafe.
If multiple threads modify a plain HashMap, they can destroy the internal structure (an array of linked lists)
Some of the links may go missing, or even go in circles, rendering the data structure unusable.
In the example above, the code for get and put will never corrupt the data structure.
But, since the sequence of operations is not atomic, the result is not predictable.
One remedy is to use the replace operation, replacing a known old value with a new one, just as you have seen in the preceding section:
The ﬁrst statement ensures that there is a LongAdder present that we can increment atomically.
Since putIfAbsent returns the mapped value (either the existing one or the newly put one), you can combine the two statements:
Java 8 provides methods that make atomic updates more convenient.
The compute method is called with a key and a function to compute the new value.
That function receives the key and the associated value, or null if there is none, and it computes the new value.
For example, here is how we can update a map of integer counters:
There are many methods that use a null value as an indication that a given key is not present in the map.
There are also variants computeIfPresent and computeIfAbsent that only compute a new value when there is already an old one, or when there isn’t yet one.
That is almost like the call to putIfAbsent that you saw before, but the LongAdder constructor is only called when a new counter is actually needed.
You often need to do something special when a key is added for the ﬁrst time.
It has a parameter for the initial value that is used when the key is not yet present.
Otherwise, the function that you supplied is called, combining the existing value and the initial value.
See Exercise 5 for another compelling application of the merge method.
NOTE: If the function that is passed to compute or merge returns null, the existing entry is removed from the map.
CAUTION: When you use compute or merge, keep in mind that the function that you supply should not do a lot of work.
While that function runs, some other updates to the map may be blocked.
Of course, that function should also not update other parts of the map.
Java 8 provides bulk operations on concurrent hash maps that can safely execute even while other threads operate on the map.
The bulk operations traverse the map and operate on the elements they ﬁnd as they go along.
No effort is made to freeze a snapshot of the map in time.
Unless you happen to know that the map is not being modiﬁed while a bulk operation runs, you should treat its result as an approximation of the map’s state.
Then the search terminates and the function’s result is returned.
With each of the operations, you need to specify a parallelism threshold.
If the map contains more elements than the threshold, the bulk operation is parallelized.
If you want the bulk operation to run in a single thread, use a threshold of Long.MAX_VALUE.
For example, suppose we want to ﬁnd the ﬁrst word that occurs more than 1,000 times.
Then result is set to the ﬁrst match, or to null if the search function returns null for all inputs.
The ﬁrst one simply applies a consumer function for each map entry, for example.
The second variant takes an additional transformer function, which is applied ﬁrst, and its result is passed to the consumer:
Whenever the transformer returns null, the value is silently skipped.
For example, here we only print the entries with large values:
The reduce operations combine their inputs with an accumulation function.
For example, here is how you can compute the sum of all values.
As with forEach, you can also supply a transformer function.
The transformer can act as a ﬁlter, by returning null to exclude unwanted inputs.
NOTE: If the map is empty, or all entries have been ﬁltered out, the reduce operation returns null.
If there is only one element, its transformation is returned, and the accumulator is not applied.
There are specializations for int, long, and double outputs with sufﬁx ToInt, ToLong, and ToDouble.
You need to transform the input to a primitive value and specify a default value and an accumulator function.
The default value is returned when the map is empty.
CAUTION: These specializations act differently from the object versions where there is only one element to be considered.
Suppose you want a large, threadsafe set instead of a map.
There is no ConcurrentHashSet class, and you know better than trying to create your own.
Of course, you can use a ConcurrentHashMap with bogus values, but then you get a map, not a set, and you can’t apply operations of the Set interface.
All map values are Boolean.TRUE, but you don’t actually care since you just use it as a set.
Of course, if you have an existing map, the keySet method yields the set of keys.
If you remove the set’s elements, the keys (and their values) are removed from the map.
But it doesn’t make sense to add elements to the key set, because there would be no corresponding values to add.
Java 8 adds a second keySet method to ConcurrentHashMap, with a default value, to be used when adding elements to the set:
If "Java" wasn’t already present in words, it now has a value of one.
The Arrays class now has a number of parallelized operations.
With all methods, you can supply the bounds of a range, such as.
NOTE: At ﬁrst glance, it seems a bit odd that these methods have parallel in their name, since the user shouldn’t care how the sorting happens.
However, the API designers wanted to make it clear that the sorting is parallelized.
That way, users are on notice to avoid comparators with side effect.
The parallelSetAll method ﬁlls an array with values that are computed from a function.
The function receives the element index and computes the value at that location.
There are versions for all primitive type arrays and for object arrays.
Clearly, one can make this computation in parallel in separate regions of the array.
In the next step, update the indicated elements by multiplying them with elements that are one or two positions below:
This is a win over the straightforward linear computation if sufﬁcient processors are available.
On special-purpose hardware, this algorithm is commonly used, and users of such hardware are quite ingenious in adapting it to a variety of problems.
In the following sections, you will see how completable futures make it possible to compose asynchronous operations.
The method reads a web page in a separate thread, which is going to take a while.
Now suppose we want to extract all URLs from the page in order to build a web crawler.
How can we apply that method to the future object? Unfortunately, there is only one way.
First, call the get method on the future to get its value when it becomes available.
We are really no better off than with a method public String readPage(URL url) that blocks until the result is available.
Unlike a plain Future, a CompleteableFuture has a method thenApply to which you can pass the post-processing function.
When the ﬁrst future has completed, its result is fed to the getLinks method, and the return value of that method becomes the ﬁnal result.
This composability is the key aspect of the CompletableFuture class.
Composing future actions solves a serious problem in programming asynchronous applications.
The traditional approach for dealing with nonblocking calls is to use event handlers.
The programmer registers a handler for the next action after completion.
Of course, if the next action is also asynchronous, then the next action after that is in a different event handler.
It gets worse when one has to add error handling.
Suppose step 2 is “the user logs in”; then we may need to repeat that step since the user can mistype the credentials.
Trying to implement such a control ﬂow in a set of event handlers, or to understand it once it has been implemented, is challenging.
With completable futures, you just specify what you want to have done, and in which order.
It won’t all happen right away, of course, but what is important is that all the code is in one place.
In Chapter 2, you saw how a stream pipeline starts with stream creation, then goes through one or more transformations, and ﬁnishes with a terminal operation.
Start out by generating a CompletableFuture, usually with the static method supplyAsync.
That method requires a Supplier<T>, that is, a function with no parameters yielding a T.
In our example, we can start out the pipeline with.
This is useful if you simply want to schedule one action after another, without passing data between them.
One of them runs the provided action on the common ForkJoinPool.
Next, you can call thenApply or thenApplyAsync to run another action, either in the same thread or another.
For example, here is a two-stage pipeline for reading and processing the web page:
Eventually, you’ll be done, and you will need to save the results somewhere.
The thenAccept method takes a Consumer—that is, a function with return type void.
The last step in the pipeline simply deposits the result where it belongs.
NOTE: You don’t explicitly start the computation.The static supplyAsync method starts it automatically, and the other methods cause it to be continued.
There is a large number of methods for working with completable futures.
Let us ﬁrst look at those that deal with a single future (see Table 6–1)
For each method shown, there are also two Async variants that I don’t show.
As noted in the preceding section, one of them uses the common ForkJoinPool, and the other has an Executor parameter.
That sounds rather abstract, but it can be quite natural.
Consider the action of reading a web page from a given URL.
Invoke the function on the result and execute the returned future.
Now, suppose we have another method that gets the URL from user input, perhaps from a dialog that won’t reveal the answer until the user has clicked the OK button.
The third method in Table 6–1 focuses on a different aspect that I have ignored so far: failure.
When an exception is thrown in a CompletableFuture, it is captured and wrapped in an unchecked ExecutionException when the get method is called.
In order to handle an exception, use the handle method.
The supplied function is called with the result (or null if none) and the exception (or null if none), and it gets to make sense of the situation.
The remaining methods have void result and are usually used at the end of a processing pipeline.
Now let us turn to methods that combine multiple futures (see Table 6–2)
As soon as one of them ﬁnishes, its result is passed on, and the other result is ignored.
Execute both and combine the results with the given function.
When a result is available from one or the other, pass it to the given function.
Complete with void result after any of the given futures completes.
NOTE: Technically speaking, the methods in this section accept parameters of type CompletionStage, not CompletableFuture.
That is an interface type with almost forty abstract methods, currently implemented only by CompletableFuture.
Most programmers wouldn’t casually implement that interface, so I don’t dwell on the distinction.
Does a LongAdder help with yielding a sequence of increasing IDs? Why or why not?
Use a LongAccumulator to compute the maximum or minimum of the accumulated elements.
Write an application in which multiple threads read all words from a collection of ﬁles.
It is called Rhino because a wellregarded JavaScript book has the image of a rhinoceros on its cover.
Oracle’s engineers realized that they could build a much more efﬁcient JavaScript interpreter using the new JVM instructions designed for dynamic languages.
You get extra karma for pronouncing it nas-horn, not na-shorn.
Nashorn is very fast, and it lets you integrate Java with JavaScript on a highly performant virtual machine.
It is also incredibly compliant with the ECMAScript standard for JavaScript.
Not only do you get the beneﬁts of a reasonably well-designed scripting language (i.e., JavaScript), but you have the full power of the JVM behind it.
Nashorn is the successor to the Rhino JavaScript interpreter, with greater performance and ﬁdelity to the JavaScript standard.
Nashorn is a pleasant environment for experimenting with the Java API.
You can run JavaScript through the jjs interpreter, or from Java via the scripting API.
Use the predeﬁned JavaScript objects for the most common packages, or the Java.type function to access any package.
Beware of intricacies in the conversion of strings and numbers between JavaScript and Java.
JavaScript offers a convenient syntax for working with Java lists and maps, as well as JavaBeans properties.
You can convert JavaScript functions to Java interfaces in a way that is very similar to using lambda expressions.
You can extend Java classes and implement Java interfaces in JavaScript, but there are limitations.
Nashorn has good support for writing shell scripts in JavaScript.
You can write JavaFX programs in JavaScript, but the integration is not as good as it might be.
You get what’s called a “read-eval-print” loop, or REPL, in the world of Lisp, Scala, and so on.
NOTE: As a reminder, in JavaScript, strings can be delimited by '...' or "..."
In this chapter, I will use single quotes for JavaScript strings to give you a visual clue that the code is JavaScript, not Java.
Now, when you type contents, you see the contents of the web page.
I wasn’t quite sure whether I could read the entire contents by setting the delimiter to $, but I tried it out and it worked.
And I didn’t have to write public static void main.
I didn’t have to make a project in my IDE.
The REPL is the easiest way to explore an API.
It is a bit odd that one drives Java from JavaScript, but it is also convenient.
Note how I didn’t have to deﬁne the types for the input and contents variables.
In the preceding section, you saw one use case for Nashorn scripting: to experiment with Java APIs from the jjs REPL.
Another use case is to allow users of your programs to run scripts.
For example, all Microsoft Ofﬁce applications can be scripted with a language called VB Script that is a descendant of the Basic language.
Quite a few people write such scripts, and this capability leads to a form of vendor lock.
It is difﬁcult to adopt an alternate ofﬁce suite that won’t run those scripts.
If you want to lock in the users of your Java desktop or server app, you can provide the same capabilities.
You can use that mechanism to execute scripts in any.
There are also script engines for languages that run outside the JVM, such as PHP or Scheme.
To run a script, you need to get a ScriptEngine object.
If the engine is registered, you can simply get it by name.
To make a Java object available to your scripts, use the put method of the ScriptEngine interface.
For example, you can make a JavaFX stage visible, so that you can populate it using JavaScript code:
Instead of putting variables into the global scope, you can collect them in an object of type Bindings and pass that object to the eval method:
This is useful if a set of bindings should not persist for future calls to the eval method.
In the preceding section, you saw how the script engine can make Java objects accessible to JavaScript.
Nashorn supports a convenient property syntax for getters and setters.
If the expression stage.title occurs to the left of the = operator, it is translated to an invocation of the setTitle method.
You can even use the JavaScript bracket notation to access properties:
Note that the argument of the [] operator is a string.
In this context, that isn’t useful, but you can call stage[str] with a string variable and thereby access arbitrary properties.
NOTE: In JavaScript, semicolons at the end of a line are optional.
Many JavaScript programmers put them in anyway, but in this chapter, I omit them so that you can easily distinguish between Java and JavaScript code snippets.
There can be only one method with a given name, and it can have any number of parameters of any type.
Nashorn attempts to pick the correct Java method, following the number and types of the parameters.
In almost all cases, there is only one Java method that matches the supplied parameters.
If there is not, you can manually pick the correct method with the following rather strange syntax:
Here, we specify the remove(Object) method that removes the Integer object 1 from the list.
When you want to construct objects in JavaScript (as opposed to having them handed to you from the script engine), you need to know how to access Java packages.
There are global objects java, javax, javafx, com, org, and edu that yield package and class objects via the dot notation.
This is a bit faster than java.net.URL, and you get better error checking.
If you make a spelling error such as java.net.Url, Nashorn will think it is a package.
But if you want speed and good error handling, you probably shouldn’t be using a scripting language in the ﬁrst place, so I will stick with the shorter form.
NOTE: The Nashorn documentation suggests that class objects should be deﬁned at the top of a script ﬁle, just like you place imports at the top of a Java ﬁle:
Once you have a class object, you can call static methods:
To construct an object, pass the class object to the JavaScript new operator.
If you aren’t concerned about efﬁciency, you can also call.
CAUTION: If you use Java.type with new, you need an extra set of parentheses:
If you need to specify an inner class, you can do so with the dot notation:
Alternatively, if you use Java.type, use a $, like the JVM does:
In this case, the JavaScript string is converted to a Java string.
In general, a JavaScript string is converted to a Java string whenever it is passed to a Java method.
Also note that any JavaScript object is converted to a string when it is passed to a Java method with a String parameter.
The Paths.get method wants a String, and it gets one, even though it makes no sense in this situation.
It follows the general JavaScript behavior to turn anything into a string when a string is expected.
It is features such as this one that make programming in a dynamically typed language an exciting adventure.
Its Number type is the same as the Java double type.
When a number is passed to Java code that expects an int or long, any fractional part is silently removed.
For efﬁciency, Nashorn keeps computations as integers when possible, but that difference is generally transparent.
The value of price happens to be an integer, and it is assigned to an Object since the format method has an Object...
That causes the format method to fail, since the f format is intended for ﬂoating-point numbers.
To construct a Java array, ﬁrst make a class object:
Then call the new operator and supply the length of the array:
To iterate through all values of the names array, use.
This is the equivalent of the enhanced for loop in Java.
If you need the index values, use the following loop instead:
CAUTION: Even though this loop looks just like the enhanced for loop in Java, it visits the index values.
When you supply a JavaScript array where a Java array is expected, Nashorn will carry out the conversion.
Given a JavaScript array, use the Java.to method to obtain the equivalent Java array:
Conversely, use Java.from to turn a Java array into a JavaScript array:
You can use the bracket operator with any Java List to invoke the get and set methods:
To visit all elements in the map, you can use the JavaScript for each loops:
If you want to process keys and values together, simply iterate over the entry set:
NOTE: The for each loop works for any Java class that implements the Iterable interface.
Syntactically, such an anonymous function is very similar to a Java lambda expression.
Instead of an arrow after the parameter list, you have the keyword function.
You can use an anonymous function as a functional interface argument of a Java method, just like you could use a lambda expression in Java.
Nashorn supports shorthand for functions whose body is a single expression.
For such functions, you can omit the braces and the return keyword:
Again, note the similarity with a Java lambda expression (a, b) -> Integer.
NOTE: That shorthand notation (called an “expression closure”) is not part of the ofﬁcial JavaScript language standard (ECMAScript 5.1), but it is also supported by the Mozilla JavaScript implementation.
To extend a Java class, or to implement a Java interface, use the Java.extend function.
Supply the class object of the superclass or interface and a JavaScript object with the methods that you want to override or implement.
For example, here is an iterator that produces an inﬁnite sequence of random numbers.
For each method, we provide an implementation as an anonymous JavaScript function:
NOTE: When calling Java.extend, you can specify any number of superinterfaces as well as a superclass.
Place all class objects before the object with the implemented methods.
Another Nashorn syntax extension lets you deﬁne anonymous subclasses of interfaces or abstract classes.
When new JavaClassObject is followed by a JavaScript object, an object of the extended class is returned.
If the supertype is abstract and has only one abstract method, you don’t even have to give the method name.
Instead, pass the function as if it was a constructor parameter:
If you want instance variables in your subclass, add them to the JavaScript object.
For example, here is an iterator that produces ten random numbers:
Note that the JavaScript methods next and hasNext refer to the instance variable as this.count.
It is possible to invoke a superclass method when overriding a method, but it is quite ﬁnicky.
The call Java.super(obj) yields an object on which you can invoke the superclass method of the class to which obj belongs, but you must have that object available.
When you call arr.add('Fred'), a message is printed before the value is added to the array list.
Note that the call Java.super(arr) requires the arr variable, which is being set to the value returned by new.
Calling Java.super(this) does not work—that only gets the JavaScript object that deﬁnes the method, not the Java proxy.
The Java.super mechanism is only useful for deﬁning individual objects, not subclasses.
When a Java method throws an exception, you can catch it in JavaScript in the usual way:
Note that there is only one catch clause, unlike in Java where you can catch expressions by type.
That, too, is in the spirit of dynamic languages where all type inquiry happens at runtime.
If you need to automate a repetitive task on your computer, chances are that you have put the commands in a shell script, a script that replays a set of OS-level commands.
I have a directory ~/bin ﬁlled with dozens of shell scripts: to upload ﬁles to my web site, my blog, my photo storage, and to my publisher’s FTP.
For me, these are bash scripts, but in the olden days when I used Windows they were batch ﬁles.
So what is wrong with that? The problem comes once you have a need for branches and loops.
For some reason, most implementors of command shells are terrible at programming language design.
The way variables, branches, loops, and functions are implemented in bash is simply awful, and the batch language in Windows is even worse.
I have a few bash scripts that started out modest but have over time accreted so much cruft that they are unmanageable.
Why not just write these scripts in Java? Java is quite verbose.
If you call external commands via Runtime.exec, you need to manage standard input/output/error streams.
The Nashorn designers want you to consider JavaScript as an alternative.
The syntax is comparatively lightweight, and Nashorn offers some conveniences that are speciﬁcally geared towards shell programmers.
Now you can execute shell commands by including them in backquotes, for example.
By convention, an exit code of zero means success, and non-zero codes describe error conditions.
You can also capture the standard output by assigning the result of the backquoted command to a variable:
If you want to supply standard input for a command, use.
For example, this command passes the output of ls -al to grep -v class:
As with the bash shell, string interpolation does not work inside singly quoted strings.
Strings are also interpolated in “here documents”—inline documents in a script.
These inline documents are useful when a command reads multiple lines from standard input and the script author doesn’t want to put the input in a separate ﬁle.
As an example, here is how you can feed commands to the GlassFish administration tool:
Note that the name and location of the application are interpolated.
String interpolation and here documents are only available in scripting mode.
Since it is possible to include multiple script ﬁles on the jjs command line, you need to separate the script ﬁles and arguments with a --:
If you have only one script ﬁle, you can instead run.
TIP: The ﬁrst line of a script can be a “shebang,” the symbols #! followed by the location of the script interpreter.
Then you can make the script ﬁle executable and simply run it as path/script.js.
When a script starts with a shebang, scripting mode is automatically activated.
In the script ﬁle, you receive the command-line arguments in the arguments array:
With jjs (but not with jrunscript), you can use $ARG instead of arguments.
If you use that variable with string interpolation, you need two dollar signs:
In your script, you can obtain the shell’s environment variables through the ENV object:
In scripting mode, you can prompt the user for input with the readLine function:
Simply put the instructions that you would normally put into the start method of the Application subclass into the script.
You don’t even have to call show on the Stage object—that is done for you.
For example, here is the “Hello” program from Chapter 4 in JavaScript:
NOTE: If you need to override the init or stop lifecycle methods of the Application class in addition to start, include the methods that you need in your script, at the top level.
With the -fx option, you then get a subclass of Application with the script methods.
As you have seen in Chapter 4, most FX events are handled through listeners to FX properties.
In Java, you can call addListener with a lambda expression, and the compiler is able to ﬁgure out from the parameter types which of the two listeners to add.
Suppose we have a slider to control the font size.
We’d like to add a listener that updates the size when the slider value changes:
That’s more heavyweight than the Java equivalent—not something one wants to see in a lightweight scripting language.
Compatibility with scripting languages was perhaps not their major concern, particularly since they had just abandoned another scripting language.
When you design a Java API, remember Atwood’s law: “Any application that can be written in JavaScript will eventually be written in JavaScript.” Design your API so that it can be accessed nicely from JavaScript.
And there is another sad aspect about the JavaFX support in Nashorn.
Recall how in the olden days of JavaFX Script, it was easy to describe the layout of a scene like this:
Doesn’t it almost look like JavaScript? Well, Nashorn/JavaFX developers, tear down that wall and turn it into JavaScript! Then we can write both the UI layout and event handling in JavaScript, and Atwood’s law will be fulﬁlled.
Run some experiments in jjs: construct objects, call methods, and observe the returned values.
Did you ﬁnd it easier than writing test programs in Java?
First read the words, then ﬁlter the long words, and so on.
How does this interactive approach compare to your usual workﬂow?
Construct a nonliteral JavaScript string by extracting a substring from another string, and invoke the getClass method.
Write a JavaScript function that is a factory for such objects, so that one can generate any number of logging array lists.
Write a JavaScript function pipe that takes a sequence of shell commands and pipes the output of one to the input of the next, returning the ﬁnal output.
The solution of the preceding exercise is not quite as good as a Unix pipe because the second command only starts when the ﬁrst one has ﬁnished.
Write a script that prints the values of all environment variables.
Write a script nextYear.js that obtains the age of the user and then prints Next year, you will be ..., adding 1 to the input.
The age can be speciﬁed on the command line or the AGE environment variable.
Write a JavaFX program in JavaScript that reads data from a source of your choice and renders a pie chart.
Was it easier or harder than developing the program in Java? Why?
But there are also numerous smaller changes throughout the library that are quite useful.
In this chapter, you will ﬁnd what is new for strings, numbers, math, collections, ﬁles, annotations, regular expressions, and JDBC.
Joining strings with a delimiter is ﬁnally easy: String.join(", ", a, b, c) instead of a + ", " + b + ", " + c.
Use Math.floorMod(x, n) instead of x % n if x might be negative.
There are new mutators in Collection (removeIf) and List (replaceAll, sort)
Files.list lazily lists the entries of a directory, and Files.walk traverses them recursively.
Annotations can now be repeated and applied to type uses.
Convenient support for null parameter checks can be found in the Objects class.
A common task is to combine several strings, separating them with a delimiter such as ", " or "/"
Think of join as the opposite of the String.split instance method.
Ever since Java 5, each of the seven numeric primitive type wrappers (i.e., not Boolean) had a static SIZE ﬁeld that gives the size of the type in bits.
You will be glad to know that there is now a BYTES ﬁeld that reports the size in bytes, for those who cannot divide by eight.
All eight primitive type wrappers now have static hashCode methods that return the same hash code as the instance method, but without the need for boxing.
The ﬁve types Short, Integer, Long, Float, and Double now have static methods sum, max, and min, which can be useful as reduction functions in stream operations.
The Boolean class has static methods logicalAnd, logicalOr, and logicalXor for the same purpose.
In general, with unsigned numbers, you lose the negative values and get twice the range of positive values.
The Byte and Short classes have methods toUnsignedInt, and Byte, Short, and Integer have methods toUnsignedLong.
The Integer and Long classes have methods compareUnsigned, divideUnsigned, and remainderUnsigned to work with unsigned values.
You don’t need special methods for addition, subtraction, and multiplication.
The + and - operators do the right thing already for unsigned values.
NOTE: In order to work with unsigned numbers, you need to have a clear understanding of base-two arithmetic and the binary representation of negative numbers.
In C and C++, mixing signed and unsigned types is a common cause of subtle errors.
Java has wisely decided to stay away from this area, and has managed to live with only signed numbers for many years.
The primary reason to use unsigned numbers is if you work with ﬁle formats or network protocols that require them.
In the past, you had to call the instance methods isInfinite and isNaN to get the same result.
The Math class provides several methods for “exact” arithmetic that throw an exception when a result overﬂows.
The toIntExact method converts a long to the equivalent int.
You compute the position of the hour hand of a clock.
But what if adjustment is negative? Then you might get a negative number.
NOTE: Unfortunately, floorMod gives negative results for negative divisors, but that situation doesn’t often occur in practice.
The nextDown method, deﬁned for both double and float parameters, gives the next smaller ﬂoating-point number for a given number.
For example, if you promise to produce a number < b, but you happen to have computed exactly b, then you can return Math.nextDown(b)
NOTE: All methods described in this section also exist in the StrictMath class.
You may wonder why the Stream interface has so many methods that accept lambda expressions but just one such method, removeIf, was added to the Collection interface.
If you review the Stream methods, you will ﬁnd that most of them return a single value or a stream of transformed values that are not present in the original stream.
The removeIf method can be thought of as the opposite of filter, removing rather than producing all matches and carrying out the removal in place.
The distinct method would be costly to provide on arbitrary collections.
The List interface has a replaceAll method, which is an in-place equivalent of map, and a sort method that is obviously useful.
The Map interface has a number of methods that are particularly important for maps accessed concurrently.
The Iterator interface has a forEachRemaining method that exhausts the iterator by feeding the remaining iterator elements to a function.
Finally, the BitSet class has a method that yields all members of the set as a stream of int values.
The Comparator interface has a number of useful new methods, taking advantage of the fact that interfaces can now have concrete methods.
The static comparing method takes a “key extractor” function that maps a type T to a comparable type (such as String)
The function is applied to the objects to be compared, and the comparison is then made on the returned keys.
For example, suppose you have an array of Person objects.
You can chain comparators with the thenComparing method for breaking ties.
If two people have the same last name, then the second comparator is used.
You can specify a comparator to be used for the keys that the comparing and thenComparing methods extract.
For example, here we sort people by the length of their names:
Moreover, both the comparing and thenComparing methods have variants that avoid boxing of int, long, or double values.
An easier way of producing the preceding operation would be.
If your key function can return null, you will like the nullsFirst and nullsLast adapters.
These static methods take an existing comparator and modify it so that it doesn’t throw an exception when encountering null values but ranks them as smaller or larger than regular values.
For example, suppose getMiddleName returns a null when a person has no middle name.
The nullsFirst method needs a comparator—in this case, one that compares two strings.
The naturalOrder method makes a comparator for any class implementing Comparable.
Here is the complete call for sorting by potentially null middle names.
The static reverseOrder method gives the reverse of the natural order.
A checkedQueue wrapper, that has apparently been overlooked all these years, has also been added.
As a reminder, the checked wrappers have a Class parameter and throw a ClassCastException when you insert an element of the wrong type.
Suppose you declare a Queue<Path>, and somewhere in your code there is a ClassCastException trying to cast a String to a Path.
This could have happened because you passed the queue to a method void getMoreWork(Queue q) with no type parameter.
Because the generic type was suppressed, the compiler could not detect that.
Much later, you took out that String, thinking it was a Path, and the error manifested itself.
If you temporarily replace the queue with a CheckedQueue(new LinkedList<Path>, Path.class), then every insertion is checked at runtime, and you can locate the faulty insertion code.
Java 8 brings a small number of convenience methods that use streams for reading lines from ﬁles and for visiting directory entries.
Also, there is ﬁnally an ofﬁcial way of performing Base64 encoding and decoding.
To read the lines of a ﬁle lazily, use the Files.lines method.
It yields a stream of strings, one per line of input:
As soon as the ﬁrst line containing password is found, no further lines are read from the underlying ﬁle.
NOTE: Unlike the FileReader class, which was a portability nightmare since it opened ﬁles in the local character encoding, the Files.lines method defaults to UTF-8.You can specify other encodings by supplying a Charset argument.
The streams that you have seen in Chapter 2 didn’t need to close any resources.
But the Files.lines method produces a stream whose close method closes the ﬁle.
The easiest way to make sure the ﬁle is indeed closed is to use a Java 7 try-with-resources block:
When a stream spawns another, the close methods are chained.
When filteredLines is closed, it closes the underlying stream, which closes the underlying ﬁle.
NOTE: If you want to be notiﬁed when the stream is closed, you can attach an onClose handler.
Here is how you can verify that closing filteredLines actually closes the underlying stream:
This subterfuge is necessary because stream operations are not declared to throw any checked exceptions.
With this method, closing the resulting stream does not close the reader.
For that reason, you must place the BufferedReader object, and not the stream object, into the header of the try statement.
NOTE: Almost ten years ago, Java 5 introduced the Scanner class to replace the cumbersome BufferedReader.
It is unfortunate that the Java 8 API designers decided to add the lines method to BufferedReader but not to Scanner.
The static Files.list method returns a Stream<Path> that reads the entries of a directory.
The directory is read lazily, making it possible to efﬁciently process directories with huge numbers of entries.
Since reading a directory involves a system resource that needs to be closed, you should use a try block:
NOTE: Under the hood, the stream uses a DirectoryStream, a construct introduced in Java 7 for efﬁcient traversal of huge directories.
That interface has nothing to do with Java 8 streams; it extends Iterable so that it can be used in an enhanced for loop.
To process all descendants of a directory, use the Files.walk method instead.
NOTE: If you ﬁlter the paths returned by walk and your ﬁlter criterion involves the ﬁle attributes stored with a directory, such as size, creation time, or type (ﬁle, directory, symbolic link), then use the find method instead of walk.
Since the directory is being read anyway, the attributes are readily available.
It is used for binary data in email messages and “basic” HTTP authentication.
That class has methods to encode an array of bytes or a NIO ByteBuffer.
Alternatively, you can “wrap” an output stream, so that all data sent to it is automatically encoded.
Annotations are tags inserted into the source code that some tools can process.
In Java SE, annotations are used for simple purposes, such as marking deprecated features or suppressing warnings.
Annotations have a much more important role in Java EE where they are used to conﬁgure just about any aspect of an application, replacing painful boilerplate code and XML customization that was the bane of older Java EE versions.
Java 8 has two enhancements to annotation processing: repeated annotations and type use annotations.
Moreover, reﬂection has been enhanced to report method parameter names.
This has the potential to simplify annotations on method parameters.
In this context, it made no sense to apply the same annotation twice.
Of course, different annotations on the same element are ﬁne and quite common:
Soon, more and more uses for annotations emerged, leading to situations where one would have liked to repeat the same annotation.
For example, to denote a composite key in a database, you need to specify multiple columns:
Since that wasn’t possible, the annotations were packed into a container annotation, like this:
As an annotation user, that is all you need to know.
If your framework provider has enabled repeated annotations, you can just use them.
For a framework implementor, the story is not quite as simple.
What should that method do if multiple annotations of the same type are present? Return the ﬁrst one only? That could have all sorts of undesirable behavior with legacy code.
To solve this problem, the inventor of a repeatable annotation must.
For example, for a simple unit testing framework, we might deﬁne a repeatable @TestCase annotation, to be used like this:
This is because the element is actually annotated with the container annotation TestCases.
NOTE: What I just described relates to processing runtime annotations with the reﬂection API.
In those APIs, there is no support for “looking through” a container.You will need to process both the individual annotation (if it is supplied once) and the container (if the same annotation is supplied more than once)
Prior to Java 8, an annotation was applied to a declaration.
A declaration is a part of code that introduces a new name.
Here are a couple of examples, with the declared name in bold:
This can be useful in combination with tools that check for common programming errors.
Now suppose you annotated variables that you never want to be null as @NonNull.
Of course, the tool should detect any statement that might cause names to become null:
It sounds tedious to put such annotations everywhere, but in practice, some of the drudgery can be avoided by simple heuristics.
The null checker in the Checker Framework (http://types.cs.washington.edu/checker-framework) assumes that any nonlocal variables are implicitly @NonNull, but that local variables might be null unless the code shows otherwise.
If a method may return a null, it needs to be annotated as @Nullable.
That may not be any worse than documenting the nullness behavior.
In the preceding example, the names variable was declared as @NonNull.
But how can one express that the list elements should be non-null? Logically, that would be.
It is this kind of annotation that was not possible before Java 8 but has now become legal.
There are currently no standard annotations that are meaningful for type use.All examples in this section come from the Checker Framework or from the author’s imagination.
With superclasses and implemented interfaces: class Image implements @Rectangular Shape.
They have no effect on the behavior of a cast or an instanceof check.
There are a few type positions that cannot be annotated:
You can supply a separate annotation, but it would apply to the name declaration.
The practical use of these annotations hinges on the viability of the tools.
In almost all cases, the parameter names are the same as the annotation arguments, or they can be made to be the same.
If the annotation processor could read the parameter names, then one could simply write.
Unfortunately, for the necessary information to appear in the classﬁle, the source must be compiled as javac -parameters SourceFile.java.
Let’s hope annotation writers will enthusiastically embrace this mechanism, so there will be momentum to drop that compiler ﬂag in the future.
We end this chapter with miscellaneous minor changes that you might ﬁnd useful.
This section covers the new features of the Objects, Logger, and Locale classes, as well as changes to regular expressions and JDBC.
The Objects class has static predicate methods isNull and nonNull that can be useful for streams.
The message string is formatted even when the logging level is such that it would never be used.
Now the lambda expression is only evaluated at the FINEST logging level, when the cost of the additional lambda invocation is presumably the least of one’s problems.
The requireNonNull of the Objects class (which is described in Chapter 9) also has a version that computes the message string lazily.
In the common case that directions is not null, this.directions is simply set to directions.
In Java 8, you can use the names in the start, end, and group methods of Matcher:
The Pattern class has a splitAsStream method that splits a CharSequence along a regular expression:
The method asPredicate can be used to ﬁlter strings that match a regular expression:
A locale speciﬁes everything you need to know to present information to a user with local preferences concerning language, date formats, and so on.
It used to be that locales were simple, consisting of location, language, and (for a few oddball cases, such as the Norwegians who have two spelling systems) variants.
Nowadays, a locale is composed of up to ﬁve components.
A language, speciﬁed by two or three lowercase letters, such as en (English) or de (German or, in German, Deutsch)
This is useful because some languages, such as Serbian, are written in Latin or Cyrillic, and some Chinese readers prefer the traditional over the simpliﬁed characters.
A country, speciﬁed by two uppercase letters or three digits, such as US (United States) or CH (Switzerland)
Nynorsk spelling of Norwegian is now expressed with a different language code, nn, instead of a variant NY of the language no.
Extensions describe local preferences for calendars (such as the Japanese calendar), numbers (Thai digits), and so on.
Such extensions start with u- and a two-letter code specifying whether the extension deals with the calendar (ca), numbers (nu), and so on.
For example, the extension u-nu-thai denotes the use of Thai numerals.
Other extensions are entirely arbitrary and start with x-, such as x-java.
Java 8 adds methods for ﬁnding locales that match user needs.
A language range is a string that denotes the locale characteristics that a user desires, with * for wildcards.
For example, a German speaker in Switzerland might prefer anything in German, followed by anything in Switzerland.
Given a list of weighted language ranges and a collection of locales, the filter method produces a list of matching locales, in descending order of match quality:
In this case, the best match is de, which isn’t very interesting.
But if locales contains a more restricted set of locales, such as those in which a document was available, then this mechanism can be useful.
The Date, Time, and Timestamp classes in the java.sql package have methods to convert from and to their java.time analogs LocalDate, LocalTime, and LocalDateTime.
Euclid’s algorithm (which is over two thousand years old) computes the greatest common divisor of two numbers as gcd(a, b) = a if b is zero, and gcd(b, rem(a, b)) otherwise, where rem is the remainder.
Clearly, the gcd should not be negative, even if a or b are (since its negation would then be a greater divisor)
Implement the algorithm with %, floorMod, and a rem function that produces the mathematical (non-negative) remainder.
Which of the three gives you the least hassle with negative values?
The Math.nextDown(x) method returns the next smaller ﬂoating-point number than x, just in case some random process hit x exactly, and we promised a number < x.
Can this really happen? Consider double r = 1 - generator.
But, given that there are 253 such ﬂoating-point numbers, will you ever get a zero? Indeed, you.
Do the same with a lambda expression, but without using streams.
Using only methods of the Comparator class, deﬁne a comparator for Point2D which is a total ordering (that is, the comparator only returns zero for equal objects)
Write a program that demonstrates the beneﬁts of the CheckedQueue class.
Write methods that turn a Scanner into a stream of words, lines, integers, or double values.
Using Files.walk, ﬁnd all Java ﬁles that contain the keywords transient and volatile.
Implement the TestCase annotation and a program that loads a class with such annotations and invokes the annotated methods, checking whether they yield the expected values.
Repeat the preceding exercise, but build a source-level annotation processor emitting a program that, when executed, runs the tests in its main method.
Use a regular expression with named capturing groups to parse a line containing a city, state, and zip code.
In this chapter, I will write about some of the library changes that haven’t been discussed so much and that I have found far more useful in daily work than switching on strings or binary literals.
I cover one language change that is very useful in daily work—the try-with-resources statement.
Use the try-with-resources statement with any object that implements AutoCloseable.
The try-with-resources statement rethrows the primary exception if closing a resource throws another exception.
You can catch unrelated exceptions with a single catch clause.
You can read and write all characters, or all lines, of a text ﬁle with a single command.
The Files class has static methods for copying, moving, and deleting ﬁles, and for creating ﬁles and directories.
When comparing numbers in a comparator, use the static compare method.
Applets and Java Web Start applications continue to be supported in corporate environments, but they may no longer be viable for home users.
Everyone’s favorite trivial change: "+1" can now be converted to an integer without throwing an exception.
Changes in ProcessBuilder make it simple to redirect standard input, output, and error streams.
I start this chapter with the Java 7 features for exception handling, since they have a major impact on writing reliable programs.
I brieﬂy review the try-with-resources statement before moving on to more subtle changes.
Java 7 provides a useful shortcut to the code pattern.
It is a subinterface of AutoCloseable, also with a single close method, but that method is declared to throw an IOException.
In its simplest variant, the try-with-resources statement has the form.
Here is a typical example—reading all words of a ﬁle:
When the block exits normally, or when there is an exception, the in.close() method is called, exactly as if you had used a finally block.
No matter how the block exits, both in and out are closed if they were constructed.
NOTE: A try-with-resources statement can itself have catch clauses and a finally clause.
In practice, it’s probably not a good idea to pile so much onto a single try statement.
Whenever you work with input or output, there is an awkward problem with closing the resource after an exception.
Suppose an IOException occurs and then, when closing the resource, the call to close throws another exception.
Which exception will actually be caught? In Java, an exception thrown in a finally clause discards the previous exception.
After all, the user is likely to be much more interested in the original exception.
When an exception is thrown in a close method of one of the AutoCloseable objects, the original exception gets rethrown, and the exceptions from calling close are caught and attached as “suppressed” exceptions.
This is a very useful mechanism that would be tedious to implement by hand (see Exercise 2)
When you catch the primary exception, you can retrieve those secondary exceptions by calling the getSuppressed method:
If you want to implement such a mechanism yourself in the (hopefully rare) situation when you can’t use the try-with-resources statement, call.
NOTE: The classes Throwable, Exception, RuntimeException, and Error have constructors with an option for disabling suppressed exceptions and for disabling stack traces.
When suppressed exceptions are disabled, calling addSuppressed has no effect, and getSuppressed returns a zero-length array.
When stack traces are disabled, calls to fillInStackTrace have no effect, and getStackTrace returns a zero-length array.
This can be useful for VM errors when memory is low, or for programming languages on the VM that use exceptions to break out of nested method calls.
CAUTION: Detecting secondary exceptions only works when it isn’t actively sabotaged.
In particular, if you use a Scanner, and if input fails, and then closing fails, the Scanner class catches the input exception, closes the resource and catches that exception, and then throws an entirely different exception, without linking the suppressed exceptions.
As of Java SE 7, you can catch multiple exception types in the same catch clause.
For example, suppose that the action for missing ﬁles and unknown hosts is the same.
This feature is only needed when catching exception types that are not subclasses of one another.
Catching multiple exceptions doesn’t just make your code look simpler but is also more efﬁcient.
The generated bytecodes contain a single block for the shared catch clause.
In the past, when you called a reﬂective method, you had to catch multiple unrelated checked exceptions.
For example, suppose you construct a class and invoke its main method:
Of course, you can use the feature described in the preceding section and combine them in a single clause:
Plainly, it is bad design not to provide a common superclass for related exceptions.
The try-with-resources statement is my favorite feature in Java 7, but the ﬁle handling improvements are a close second.
Operations that used to be tedious, such as reading a ﬁle into a string, or copying a ﬁle to another, are now as easy as they should have been all along.
It is never a good idea to include “new” in a product name—what is new today will invariably become old, and the name will look silly.
Before you can learn how to carry out these easy ﬁle operations, you have to learn about the Path interface that replaces the File class.
Next, you will see how to read and write ﬁles.
A Path is a sequence of directory names, optionally followed by a ﬁle name.
The ﬁrst component of a path may be a root component, such as / or C:\
A path that starts with a root component is absolute.
For example, here we construct an absolute and a relative path.
For the absolute path, we assume a computer running a Unix-like ﬁle system.
The static Paths.get method receives one or more strings, which it joins with the path separator of the default ﬁle system (/ for a Unix-like ﬁle system, \ for Windows)
You can also provide a string with separators to the Paths.get method:
NOTE: Just like a File object, a Path object does not have to correspond to a ﬁle that actually exists.
To create a ﬁle, ﬁrst make a path, then call a method to create the corresponding ﬁle.
The call p.resolve(q) returns a path according to these rules:
Otherwise, the result is “p then q,” according to the rules of the ﬁle system.
For example, suppose your application needs to ﬁnd its conﬁguration ﬁle relative to the home directory.
There is a convenience method resolveSibling that resolves against a path’s parent, yielding a sibling path.
The call p.relativize(r) yields the path q which, when resolved with p, yields r.
The toAbsolutePath method yields the absolute path of a given path.
If the path is not already absolute, it is resolved against the “user directory”—that is, the directory from which the JVM was invoked.
The Path interface has many useful methods for taking paths apart and combining them with other paths.
This code sample shows some of the most useful ones:
NOTE: Occasionally, you may need to interoperate with legacy APIs that use the File class instead of the Path interface.
The Path interface has a toFile method, and the File class has a toPath method.
The Files class makes quick work of common ﬁle operations.
For example, you can easily read the entire contents of a ﬁle:
If you want to read the ﬁle as a string, call readAllBytes followed by.
But if you want the ﬁle as a sequence of lines, call.
NOTE: By default, all methods of the Files class that read or write characters use the UTF-8 encoding.
In the (hopefully unlikely) case that you need a different encoding, you can supply a Charset argument.
Contrast with the String constructor and getBytes method which use the platform default.
When you work with text ﬁles of moderate length, it is usually simplest to process the contents as a single string or list of strings.
If your ﬁles are large or binary, you can still use the familiar streams or readers/writers:
These convenience methods save you from having to deal with FileInputStream, FileOutputStream, BufferedReader, or BufferedWriter.
Occasionally, you may have an InputStream (for example, from a URL) and you want to save its contents to a ﬁle.
All but the last component in the path must already exist.
The call throws an exception if the ﬁle already exists.
If the ﬁle doesn’t exist, it is created before anyone else has a chance to do the same.
The call path.exists() method checks whether the given ﬁle or directory exists, but of course it might cease to exist by the time the method has returned.
There are convenience methods for creating a temporary ﬁle or directory in a given or system-speciﬁc location.
Here, dir is a Path, and prefix/suffix are strings which may be null.
To copy a ﬁle from one location to another, simply call.
To move a ﬁle (that is, copy and delete the original), call.
You can also use this command to move an empty directory.
The copy or move will fail if the target exists.
If you want to overwrite an existing target, use the REPLACE_EXISTING option.
If you want to copy all ﬁle attributes, use the COPY_ATTRIBUTES option.
Then you are assured that either the move completed successfully, or the source continues to be present.
This method throws an exception if the ﬁle doesn’t exist, so instead you may want to use.
The deletion methods can also be used to remove an empty directory.
NOTE: There is no convenient method for removing or copying a nonempty directory.
See the API documentation of the FileVisitor interface for code outlines that achieve these tasks.
Java 7 introduces several methods that make it more convenient to deal with null values in the ubiquitous equals and hashCode, and with numeric comparisons in compareTo.
Suppose you have to implement the equals method for this class:
First, there is the drudgery of casting the parameter to a Person:
Instead of worrying that first or last might be null, just call.
The Objects.hashCode method returns a code of 0 for a null argument, so you can implement the body of your hashCode method like this:
The varargs method Objects.hash, introduced in Java 7, lets you specify any sequence of values, and their hash codes get combined:
But it isn’t a varargs method, making it less convenient.
When you compare integers in a comparator, it is tempting to return the difference between them since you are allowed to return any negative or positive number—only the sign matters.
If x is large and other.x is negative, the difference can overﬂow.
The static compare method has also been added to Long, Short, Byte, and Boolean.
If you need to compare two char values, you can safely subtract them because the result will not overﬂow.
The same is true for short or byte, of course.
NOTE: The static compare method existed for Double and Float since Java 1.2
The designers of Java knew perfectly well that executing remote code is a security risk, so they designed a “sandbox” model that stopped any damaging instructions in their tracks.
Soon thereafter, academic researchers found some implementation ﬂaws that were promptly ﬁxed, and other academic researchers groused in general over the fact that the Java security model was rather complex and there was little assurance that its darker corners are safe from assault.
At the time, I didn’t take that very seriously because the vast majority of Java applet consumers used Microsoft Windows, which was far less secure and far more complex.
Applets were limited to visual effects and network connections to the originating host, which many application writers found limiting.
They wanted local device access for storage, printing, and so on.
Unfortunately, Java Web Start was poorly understood, not integrated with applets, and not maintained with any vigor.
Instead, many application developers simply signed their web-delivered programs, which gave them full permission to do anything on the user’s machine.
Signing certiﬁcates from commercial entities are within reach of anyone willing to endure some cost and pain.
It was also possible to apply a meaningless selfsigned certiﬁcate, or have users agree to run an applet without a certiﬁcate.
Warnings were toned down from one release to the next until they became background noise.
Meanwhile, Microsoft, with an enormous engineering effort, got better at closing Windows loopholes, and it became worthwhile for hackers to look at obscure Java vulnerabilities instead.
When Oracle purchased Sun in 2010, they inherited a very limited infrastructure for dealing with such attacks and no reliable means of updating client virtual machines.
In this regard, the early researchers who warned of a large attack surface in the Java security model were entirely justiﬁed.
It took Oracle until 2013 to credibly respond to attacks.
Management of client VMs is still a work in progress.
As of today, Oracle signals that it is no longer focused on securing home users’ Java applets and Web Start applications (collectively called rich internet applications, or RIAs)
Oracle continues to close Java vulnerabilities, and develops tools that are suitable for corporate deployment, so that legacy RIAs can be deployed safely.
Home users are expected to migrate away from PCs to tablets and smartphones.
These devices don’t support a Java VM in the browser.
And business users are a plausible revenue target for maintaining legacy applications.
With successive Java 7 releases, Oracle has tightened the security rules.
As of January 2014, RIAs running outside the sandbox need to be signed by a commercial certiﬁcate authority.
Another requirement is designed to thwart “repurposing attacks.” Currently, it is possible to grab a legitimately signed JAR ﬁle from a third party and serve it from a hacker site, exploiting some vulnerability in that third-party app.
As of January 2014, all JARs must have a manifest entry.
Since the manifest entry is inside the JAR ﬁle, it is signed and cannot be modiﬁed afterwards.
The Java client will not permit sandbox execution of an all-permission client, which prevents “drive-by” attacks where an applet runs without any user consent.
Of course, it is still possible to attack users who are habituated to agree to any security dialogs.
To make that harder, another, as yet optional, manifest entry has been added:
NOTE: It has always been possible to call applets from JavaScript—another dubious decision from the point of view of the security minded.
Java held great promise as a universal execution platform for remote code.
If Java had offered a more compelling sandbox, if nonsandbox code had been more aggressively controlled, if there had.
But there is no use dwelling on what might have been.
At this point, Java is no longer a viable platform for widespread distribution of client applications over the Internet.
If you maintain an applet or Java Web Start application for home users, the message is clear: Move away from it.
If your application serves a specialized audience (for example, software development, image editing, or document processing), make your users install Java or bundle a JVM with your installer.
NOTE: If you decide to make your users install Java, you face another hurdle.
Or you could bundle a JVM, which you are then obligated to update since no effective update mechanism is supplied by Oracle.
In a corporate environment, you can effectively secure Java RIAs, provided you have control over the applications and the client machines.
You will need to tightly manage the application packaging and be ready to update client VMs when security updates become available.
NOTE: To more tightly manage corporate RIAs, you can provide deployment rulesets on end-user machines.
As in the preceding chapter, this section describes a number of smaller features that you may ﬁnd interesting or useful.
Prior to JDK 1.7, what was the result of the following code segment?
This has now been ﬁxed for all the various methods that construct int, long, short, byte, and BigInteger values from strings.
Unfortunately, that instance variable has to be initialized somewhere, and if other logging happens in the static initialization code, it was possible to cause deadlocks.
The Objects class has methods requireNonNull for convenient null checks of parameters.
When you see a call to requireNonNull as the culprit, you know right away what you did wrong.
You can also supply a message string for the exception:
Prior to Java 5, the Runtime.exec method was the only way to execute an external command from within a Java application.
Java 5 added the ProcessBuilder class that gives more control over the generated operating system process.
In particular, with the ProcessBuilder, you can change the working directory.
Java 7 adds convenience methods to hook the standard input, output, and error streams of the process to ﬁles.
NOTE: Since Java 8, the Process class has a waitFor method with timeout:
Also new in Java 7 is the inheritIO method of ProcessBuilder.
It sets the standard input, output, and error streams of the process to those of the Java program.
Suppose you want to write a Java program that automates execution of JUnit tests.
To load the JUnitCore class, you need a class loader that reads the JUnit JAR ﬁles:
Before Java 7, code such as this could lead to resource leaks.
Java 7 simply adds a close method to close the classloader.
URLClassLoader now implements AutoCloseable, so you can use a try-with-resources statement:
CAUTION: Don’t use any classes after the classloader has been closed.
If you do, and those classes need to load other classes to do their work, they will fail.
A BitSet is a set of integers that is implemented as a sequence of bits.
The ith bit is set if the set contains the integer i.
NOTE: As of Java 8, BitSet has a method stream that yields an IntStream.
Be sure to close both objects, provided they have been properly constructed.
Improve on the preceding exercise by adding any exceptions thrown by in.close() or out.close() as suppressed exceptions to the original exception, if there was one.
When you rethrow an exception that you caught in a multi-catch clause, how do you declare its type in the throws declaration of the ambient method? For example, consider.
Write a program that reads all characters of a ﬁle and writes them out in reverse order.
Write a program that reads all lines of a ﬁle and writes them out in reverse order.
Write a program that reads the contents of a web page and saves it to a ﬁle.
Implement a compareTo method for the LabeledPoint class of the preceding exercise.
Using the ProcessBuilder class, write a program that calls grep -r to look for credit card numbers in all ﬁles in any subdirectory of the user’s home directory.
Suppose you want to offer it to users as a security scan.
Package it so that it will run on your JRE.
What did you have to do? What would your users have to do to run it from your web site?
Horstmann introduces Scala concepts and techniques in  blogsized  chunks that you can quickly master and apply.
Here you will gain access to quality and trusted content and.
Access to supplemental content, including bonus chapters, source code, or project files.
Benefits will be listed on your Account page under Registered Products.
InformIT is a brand of Pearson and the online presence for the world’s leading technology publishers.
It’s your source for reliable and qualified content and knowledge, providing access to the top brands, authors, and contributors from the tech community.
LearnIT at InformIT Looking for a book, eBook, or training video on a new technology? Seeking timely and relevant information and tutorials? Looking for expert opinions, advice, and tips?  InformIT has the solution.
Learn about new releases and special promotions by subscribing to a wide variety of newsletters.
See it, believe it Watch hundreds of expert-led instructional videos on today’s hottest topics.
WAIT, THERE’S MORE! Gain a competitive edge Be first to learn about the newest technologies and subjects with Rough Cuts.
Accelerate your project Copy and paste code, create smart searches that let you know when new.
Safari Books Online is a digital library providing searchable, on-demand access to thousands of technology, digital media, and professional development books and videos from leading publishers.
With one monthly or yearly subscription price, you get unlimited access to learning tools and information on topics including mobile app and software development, tips and tricks on using your favorite gadgets, networking, project management, graphic design, and much more.
